{"id1": "19660893", "id2": "1332258", "code1": "    private String load(URL url) {\n        BufferedReader r = null;\n        try {\n            r = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buf = new StringBuffer();\n            while (r.ready()) {\n                buf.append(r.readLine()).append('\\n');\n            }\n            r.close();\n            return buf.toString();\n        } catch (IOException e) {\n            logger.severe(\"Could not load shader program: \" + e);\n            logger.logp(Level.SEVERE, getClass().getName(), \"load(URL)\", \"Exception\", e);\n            return null;\n        }\n    }\n", "code2": "    public void writeTo(OutputStream out) throws IOException {\n        if (!closed) {\n            throw new IOException(\"Stream not closed\");\n        }\n        if (isInMemory()) {\n            memoryOutputStream.writeTo(out);\n        } else {\n            FileInputStream fis = new FileInputStream(outputFile);\n            try {\n                IOUtils.copy(fis, out);\n            } finally {\n                IOUtils.close(fis);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "user", "connection", "rel", "buffer", "io", "src", "l", "http", "lr", "base", "f", "loader", "channel", "ref", "re", "remote", "resource", "server", "address", "config", "name", "ur", "location", "string", "path", "image", "uri", "file", "ssl", "err", "URL", "Url", "str", "sl"], "r": ["reader", "gr", "rar", "rx", "nr", "R", "ro", "br", "http", "b", "lr", "fr", "f", "re", "rg", "rus", "ir", "er", "cur", "ur", "rc", "e", "u", "rs", "parser", "sr", "pr", "rh", "dr", "adr", "hr", "tr", "ri", "cr", "rl", "rw", "c", "rt", "rd", "err", "i", "mr", "rr", "ar", "kr", "res", "rb", "p"], "buf": ["af", "sb", "cb", "tmp", "queue", "bf", "la", "bh", "binary", "buffer", "buff", "br", "Buffer", "pb", "src", "cas", "fp", "b", "aux", "bc", "home", "f", "cv", "data", "ref", "pad", "fun", "Buff", "func", "rc", "bb", "ob", "uf", "bag", "ba", "book", "string", "ab", "db", " buffer", "err", "wb", "fb", "BU", " b", "av", "array", "conv", "bu", "str", "rb"]}}
{"id1": "678400", "id2": "691789", "code1": "    public void go() {\n        DataOutputStream outStream = null;\n        try {\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Length\", new Integer(sendData.length()).toString());\n            connection.setRequestProperty(\"Content-type\", \"text/html\");\n            connection.setRequestProperty(\"User-Agent\", \"Pago HTTP cartridge\");\n            outStream = new DataOutputStream(connection.getOutputStream());\n            outStream.writeBytes(sendData);\n            System.out.println(1);\n            InputStream is = connection.getInputStream();\n            System.out.println(2);\n            inReader = new BufferedReader(new InputStreamReader(is));\n            String result;\n            System.out.println(3);\n            if ((result = inReader.readLine()) != null) {\n                System.out.println(result);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n            System.exit(0);\n        } finally {\n            try {\n                if (outStream != null) outStream.close();\n                if (inReader != null) inReader.close();\n            } catch (IOException ioe) {\n                System.err.println(\"Error closing Streams!\");\n                ioe.printStackTrace();\n            }\n            connection.disconnect();\n        }\n    }\n", "code2": "    public void bubbleSort(int[] arr) {\n        BasicProcessor.getInstance().getStartBlock();\n        BasicProcessor.getInstance().getVarDeclaration();\n        boolean swapped = true;\n        BasicProcessor.getInstance().getVarDeclaration();\n        int j = 0;\n        BasicProcessor.getInstance().getVarDeclaration();\n        int tmp;\n        {\n            BasicProcessor.getInstance().getWhileStatement();\n            while (swapped) {\n                BasicProcessor.getInstance().getStartBlock();\n                swapped = false;\n                j++;\n                {\n                    BasicProcessor.getInstance().getForStatement();\n                    for (int i = 0; i < arr.length - j; i++) {\n                        BasicProcessor.getInstance().getStartBlock();\n                        {\n                            BasicProcessor.getInstance().getIfStatement();\n                            if (arr[i] > arr[i + 1]) {\n                                BasicProcessor.getInstance().getStartBlock();\n                                tmp = arr[i];\n                                arr[i] = arr[i + 1];\n                                arr[i + 1] = tmp;\n                                swapped = true;\n                                BasicProcessor.getInstance().getEndBlock();\n                            }\n                        }\n                        BasicProcessor.getInstance().getEndBlock();\n                    }\n                }\n                BasicProcessor.getInstance().getEndBlock();\n            }\n        }\n        BasicProcessor.getInstance().getEndBlock();\n    }\n", "label": 0, "substitutes": {"outStream": ["outputSteam", "outputStream", "inputSteam", "outFile", "outReader", " outWriter", "outStreamer", "upReader", "upStream", "OutFile", "outForm", "upstream", " outForm", " outFile", "inWriter", "iostream", "ioSteam", "inputStreamer", " outPath", "inSteam", "outputstream", "OutPath", "outputReader", "outstream", "outPath", "outSteam", "OutStreamer", "inStream", " outSteam", "instream", "OutForm", "Outstream", "upSteam", "inputStream", " outstream", "OutStream", " outStreamer", "outWriter", "OutWriter", "inPath", "ioForm", "ioStream", "inputFile", "OutSteam"], "connection": ["translation", "url", "default", "link", "user", "function", "io", "conn", "c", "communication", "con", "client", "object", "union", "connected", "part", "loc", "application", "channel", "directory", "version", "response", "resource", "handler", "server", "call", "condition", "config", "creator", "writer", "ctx", "section", "component", "event", "query", "ci", "log", "ion", "password", "text", "relation", "cli", "session", "document", "image", "connect", "cache", "socket", "uri", "context", "graph", "command", "error", "builder", "character", "current", "database", "service", "which", "position", "proxy", "Connection", "option", "use", "entry"], "is": ["nis", "si", "isa", "ais", "isl", "out", "in", "as", "isp", "was", "iss", "os", "ris", "serv", "ai", "es", "inner", "info", "ir", "js", "has", "isi", "init", "ui", "ci", "IS", "api", "ri", "isc", "lis", "ios", "its", "uri", "i", "im", "isol", "ois", "us", "ses", "bis", "Is", "iso", "ip", "ib", "does", "ie"], "inReader": ["InRead", "inIterator", "inLine", " inRead", "outReader", "dinReader", "outResult", " inStreamer", "outIterator", "inResult", " inStream", "outLine", "inData", " inResult", "InStreamer", "runReader", "inLoader", "insReader", "inRead", "runStream", "dinRead", "dinStream", "runIterator", "inStreamer", " inLine", "insStream", "dinStreamer", "runLoader", "thinReader", "inStream", "insResult", "thinIterator", "outRead", "thinLoader", " inData", "InStream", "InData", "insLine", "thinStream", "outLoader", "outData", "InReader"], "result": ["source", "ner", "value", "continue", "default", "success", "buffer", "Result", "dict", "message", "output", "card", "request", "description", "row", "hello", "data", "future", "re", "response", "r", "resource", "match", "ret", "repl", "raw", "res", "results", "rc", "report", "json", "runner", "text", "comment", "content", "string", "pass", "answer", "error", "err", "character", "current", "valid", "str", "line", "entry"]}}
{"id1": "20004216", "id2": "21413102", "code1": "        public boolean check(Object credentials) {\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5) {\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                } else {\n                    md.update(username.getBytes(StringUtil.__ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StringUtil.__ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StringUtil.__ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                md.reset();\n                md.update(method.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StringUtil.__ISO_8859_1));\n                byte[] ha2 = md.digest();\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StringUtil.__ISO_8859_1));\n                byte[] digest = md.digest();\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n            } catch (Exception e) {\n                log.warn(LogSupport.EXCEPTION, e);\n            }\n            return false;\n        }\n", "code2": "    private static byte[] getHashBytes(String data, String algorithm) {\n        MessageDigest md;\n        byte[] digest = null;\n        try {\n            md = MessageDigest.getInstance(algorithm);\n            md.update(data.getBytes(\"UTF-8\"), 0, data.length());\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n        } catch (UnsupportedEncodingException e) {\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"credentials": ["chedmissions", "chedents", "cronential", "cargentials", "coururation", "Credmissions", "creditsential", "cribents", "chedlins", "courmissions", "chedlaus", "credlaus", "courential", "carpmissions", "criblines", "chedkins", "cribential", "carguration", "condaentials", "Credlins", "creditsences", "Credents", "Chedential", "condalaus", "Credential", "carpuration", "cronentials", "cronmissions", "chedential", "crafential", "Cheduration", "crafkins", "cheduration", "Credlaus", "Credlines", "cribentials", "Chedents", "credmissions", "credential", "cntential", "Chedlaus", "credents", "Chedentials", "condalins", "Creduration", "Chedences", "condaences", "credlines", "carpentials", "cntmissions", "credences", "crafentials", "chedentials", "cargents", "cronlins", "cronences", "creduration", "chedences", "Chedlins", "Credences", "courentials", "cargential", "cntentials", "creditsentials", "condaential", "Credkins", "Credentials", "chedlines", "credlins", "craflines", "cribkins", "carpential", "cntences", "Chedlines", "credkins", "Chedkins", "criburation", "Chedmissions", "creditslaus"], "password": [" Password", "hash", "user", "token", "auth", "sword", "nick", "username", "message", "wd", "security", "cmd", "channel", "phrase", " username", "prefix", "server", "address", "word", "alias", "name", "method", "ssh", "device", "param", "text", "session", " credential", "key", "string", "path", "agent", "uri", "code", "attribute", "secret", "sudo", "Password", "crypt", "account", "staff", "pass"], "md": ["cd", "d", "dd", "ld", "hd", "mm", "doc", "mac", "hm", "meta", "old", "mod", "nt", "ok", "od", "pm", "mr", "nd", "amd", "em", " cmd", "msg", "lf", "mid", "ht", "dev", "pd", "mode", "bd", "mc", "gm", "dm", "de", "MD", "mail", "html", "self", "ad", "mn", "dc", "om", "my", "ind", " MD", "sm", "ma", "cmd", "git", "bm", "n", "mand", "mag", "module", "sha", "sym", "kg", "_", "mt", "ml", "mg", "Cmd", "ds", "metadata", "nm", "s", "pkg", "mb", "cm", "wd", "ms", "mo", "di", "mu", "dn", "body", "mp", "rm", " dd", "m", "db", "ng", "mi"], "ha1": ["vaone", "shaOne", "ha4", "la3", "haX", "ha3", "HA81", "HAOne", "haone", "va0", "haOne", "wa1", "la1", "va2", "wa8", "sha81", "la4", "wa3", "va1", "shaone", "HAX", "ha0", "sha0", "ya1", "wa2", "sha1", "la8", "sha8", "HA2", "HA1", "sha4", "la2", "HAone", "vaX", "shaX", "ha8", "ya81", "sha3", "va4", "sha2", "ha81", "yaOne", "ya2", "la0"], "ha2": ["ha6", "ha4", "na1", "wa1", "la1", "wa0", "va2", "na4", "la4", "va1", "ha0", "na2", "sha0", "wa2", "sha1", "va6", "sha4", "la2", "sha6", "va4", "sha2", "la0", "na6", "wa4"], "digest": ["decert", "decest", "digitested", "digester", "DigEST", "decher", "ngEST", "digitest", "Digher", "Digert", "digEST", "Digester", "Digested", "ngest", "digher", " digester", "digitester", "decEST", "digested", "ngher", "digert", " digested", "Digest", "ngert"]}}
{"id1": "11719103", "id2": "12631774", "code1": "    public static String hash(final String text) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] sha1hash = new byte[40];\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n            return Sha1.convertToHex(sha1hash);\n        } catch (final Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public static String getMd5Hash(String plaintext) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(plaintext.getBytes());\n            byte[] digest = md5.digest();\n            BigInteger bigInt = new BigInteger(1, digest);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            return hashtext;\n        } catch (final NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"text": ["source", "translation", "contract", "url", "input", "TEXT", "txt", "binary", "token", "buffer", " TEXT", "output", "message", "letter", "format", "out", "object", "this", "in", "Text", "data", "hex", "editor", "config", "template", "word", "transfer", "pattern", "password", "content", "string", "path", "image", "obj", "font", "code", "context", "struct", "texture", "test", "str", "ext"], "md": ["hash", "bf", "d", "mb", "dd", "ind", "ld", "hd", "message", " MD", "mm", "ma", "pd", "vd", "wd", "gd", "am", "cmd", "ms", "mode", "data", "mac", "mo", "bd", "ud", "hm", "mand", "editor", "mag", "meta", "mc", "sha", "mp", "rpm", "me", "dm", "mod", "rm", "dh", "MD", "mt", "m", "df", "nm", "od", "pm", "mg", "mad", "metadata", "amd", "sd", "mi", "dig"], "sha1hash": ["SHA2hash", " SHA1hash", "sha91hash", "sha91hex", "sha2Hash", "maonematch", " SHAoneblock", "sha1match", "sha5value", "sha5hash", "sha5Hash", " SHA1Hash", "shaoneHash", "sha9cache", "sha2hash", "SHA2Hash", " SHAonecache", "sha9Hash", "sha2hex", "sha1value", "SHA1hash", " SHAonehash", "ma1hash", " SHA1block", "ma1hex", "shaonematch", "sha1Hash", "sha1cache", "maonehash", "shaonehex", "shaonecache", "sha9hash", "SHA2value", "shaoneblock", " SHA1cache", " SHAoneHash", "sha2value", "sha2block", "maonehex", "sha9block", "sha2cache", "sha2match", "sha1hex", "SHA1Hash", "shaonehash", "sha91match", "SHA1value", "ma1match", "sha1block"]}}
{"id1": "10195648", "id2": "3613198", "code1": "    public static void main(String[] args) {\n        if (args.length != 3) {\n            System.out.println(\"Usage: HexStrToBin enc/dec <infileName> <outfilename>\");\n            System.exit(1);\n        }\n        try {\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            InputStream in = new FileInputStream(args[1]);\n            int len = 0;\n            byte buf[] = new byte[1024];\n            while ((len = in.read(buf)) > 0) os.write(buf, 0, len);\n            in.close();\n            os.close();\n            byte[] data = null;\n            if (args[0].equals(\"dec\")) data = decode(os.toString()); else {\n                String strData = encode(os.toByteArray());\n                data = strData.getBytes();\n            }\n            FileOutputStream fos = new FileOutputStream(args[2]);\n            fos.write(data);\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"os": ["los", "ks", "des", "oid", "ss", "io", "fs", "out", "ros", "OS", "ms", "bos", "oes", "as", "oa", "bs", "outs", "ens", "es", "ot", "dos", "bytes", "sys", "js", "vs", "oss", "oS", "ins", "o", "aos", "ob", "rs", "cs", "mos", "ls", "Os", "fits", "nos", "ose", "ios", "ops", "socket", "ol", "ols", "pos", "us", "is", "cos", "ds", "boot", "obs", "bis", "osi", "iso", "ps", "op", "so"], "in": ["reader", "input", "inc", "din", "arin", "win", "io", "nin", "con", "out", "login", "as", "f", "In", "pin", "stream", "again", "ac", "inner", "init", "ins", "o", "vin", "ini", "ex", "kin", "sin", "cin", "c", "socket", "i", "IN", "err", "inn", "rin", "is", "ilo", "lin", "bin", "s", "fa", "ic", "pass"], "len": ["dl", "size", "split", "en", "num", "url", "ln", "lf", "ll", "iter", "min", "limit", "lim", "l", "pre", "val", "lon", "part", "loc", "base", "Len", "f", "n", "el", "body", "nt", "length", "fl", "lc", "li", "le", "count", "rev", "err", "pos", "lin", "fin", "bin", "str", "line", "sl"], "buf": [" buff", "dec", "cb", "queue", "bf", "la", "bh", "uc", "buffer", "buff", "br", "Buffer", "cas", " bu", " buffers", "b", "bc", "loc", "cv", "bd", "ref", "bytes", "ctx", "box", "raw", "off", "func", "batch", "bb", "seq", "wave", "uf", "bag", "v", "ba", "pool", "border", "ab", " buffer", "vec", "wb", "fb", "array", " b", "block", "ff", "str", "rb", "fab"], "data": ["div", "dec", "str", "id", "split", "value", "input", "plain", "memory", "la", "size", "reader", "buffer", "message", "output", "format", "description", "part", "base", "ata", "bytes", "style", "response", "raw", "info", "pad", "name", "body", "results", "batch", "DATA", "da", "json", "content", "xxx", "done", "slice", "string", "media", "image", "what", "cache", "error", "code", "i", "struct", "array", "aa", "block", "valid", "empty", "alpha", "dat", "p", "entry"], "strData": ["STRData", "StrEl", "StrVal", "rVal", "rdata", " strString", "STRVal", "StrData", "STRArray", "Strdata", "STREl", " strBu", "rArray", "strVal", "StrArray", " strEl", "strArray", "strString", "strEl", "STRString", "STRdata", "StrBu", "strBu", "StrString", "STRBu", "rData", "strdata"], "fos": [" fros", "sfos", " foses", "fose", "forose", "afose", " fo", "forios", "infoss", "sfoses", "foross", "infoses", "foss", "ffoses", "ffos", "fo", "fros", "Fos", "fol", "afos", "infos", "Fo", "fios", "ffo", " fios", " fol", "infros", "sfros", "afoss", "afios", "foses", "ffol", "Fol", "Foses", "foros", "sfoss", " foss", " fose"]}}
{"id1": "1218380", "id2": "6066145", "code1": "    public static void main(String[] args) {\n        try {\n            Object o = Naming.lookup(\"Server\");\n            IServer serverStub = (IServer) o;\n            File srcDir = new File(args[0]);\n            File dstDir = new File(args[1]);\n            File[] srcFiles = srcDir.listFiles();\n            long position = 0;\n            for (File f : srcFiles) {\n                if (f.isDirectory()) continue;\n                try {\n                    FileChannel srcChannel = new FileInputStream(f).getChannel();\n                    String fileName = dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName();\n                    FileChannel dstChannel = new FileOutputStream(fileName).getChannel();\n                    System.out.println(\"Coping \" + fileName);\n                    ByteBuffer buffer = ByteBuffer.allocate(65536);\n                    int nr = 0;\n                    srcChannel.position(nr);\n                    nr = srcChannel.read(buffer);\n                    while (nr > -1) {\n                        buffer.flip();\n                        byte[] bytes = new byte[buffer.limit()];\n                        buffer.get(bytes);\n                        position = serverStub.write(bytes, position);\n                        buffer.clear();\n                        nr = srcChannel.read(buffer);\n                    }\n                    System.out.println(\"Done \");\n                    srcChannel.close();\n                    dstChannel.close();\n                } catch (IOException e) {\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        } catch (NotBoundException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void copy(String source, String target) throws IOException {\n        @Cleanup FileChannel sourceChannel = new FileInputStream(new File(source)).getChannel();\n        @Cleanup FileChannel targetChannel = new FileOutputStream(new File(target)).getChannel();\n        targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n    }\n", "label": 1, "substitutes": {"o": ["d", "oid", "io", "k", "l", "out", "object", "b", "op", "po", "no", "n", "os", "oa", "r", "oo", "oi", "bo", "vo", "er", "e", "ob", "ingo", "uto", "t", "oe", "ko", "m", "OO", "od", "O", "Obj", "obj", "c", "i", "or", "ando", "s", "so", "p"], "serverStub": ["serverStubs", "serverStob", "ServerTubs", "serverFubs", "serverBubs", "serverStrob", "serverstob", "erverStrob", "serverBub", "erverStrub", "serverTob", "ServerStub", "ServerTub", "serverTab", "serverTUB", "serverstub", "serverStrubs", "erverStrubs", "serverFUB", "serverstubs", "serverBUB", "ServerTUB", "serverBab", "serverTub", "ServerTab", "ServerStab", "serverFub", "serverStUB", "erverStUB", "serverStrub", "serverStab", "serverStrUB", "serverstUB", "erverStubs", "erverStob", "serverTubs", "erverStub", "ServerStUB", "serverFab", "erverStrUB", "ServerStubs"], "srcDir": ["sourceDir", "srcFile", " srcDirectory", "rcFile", " srcFolder", "rcFolder", "sourceFolder", "srcDirectory", "srcFolder", "rcDir", " srcFile", "sourceFile", "rcDirectory", "sourceDirectory"], "dstDir": ["destDIR", "drcDirectory", "dostDir", "dstDirectory", "dostDirectory", "drcDir", "dostDIR", "DrcDir", "DrcFile", "destDirectory", "DrcDIR", "dstFile", "dostFile", "dstFolder", "dstsFolder", "dndDir", "dstDIR", "dstsDIR", "DstFile", "DstDirectory", "dstsDir", "drcDIR", "DstDir", "destDir", "DrcFolder", "drcFile", "DstDIR", "DrcDirectory", "dndFile", "dndDirectory", "DstFolder", "destFolder", "dndDIR", "dstsDirectory", "drcFolder"], "srcFiles": ["sourceDir", "sourcefiles", "rcDir", "rcFiles", "sourceNames", "rcfiles", "sourceFile", "srcNames", " srcfiles", "srcfiles", "sourceFiles", " srcNames", " srcFile", "srcFile", "rcFile", "rcNames"], "position": ["next", "adjust", "head", "select", "parent", "size", "operation", "page", "nl", "open", "range", "iter", "pose", "result", "limit", "object", "request", "move", "loc", "number", "resolution", "response", "r", "resource", "address", "sequence", "Position", "random", "transfer", "patch", "length", "capacity", "job", "area", "offset", "release", "index", "string", "count", "point", "insert", "pointer", "sort", "image", "numbered", "i", "seek", "coord", "speed", "pos", "reset", "item", "type", "manager", "block", "osition", "order", "location", "duration", "unit"], "f": ["folder", "h", "rf", "bf", "d", "feed", "lf", "cf", " F", "function", "l", "fs", "fc", "fp", "b", "sf", "fd", "fr", "part", "tf", "fe", "directory", "n", "r", "info", "name", "filename", "dir", "u", "e", "fn", "t", "F", "m", "v", "j", "c", "file", "i", "fb", "files", "fen", " df", "s", "fa", "p", "fx"], "srcChannel": ["sbchannel", "remotechannel", "srcchannel", "srcBuffer", "sslchannel", "srcClient", "rcChan", " srcChan", "sbChannel", "remoteClient", "inputConsole", " srcConsole", " srcConnection", " srcCh", "rcchannel", "srcChan", "rcChannel", "inputChannel", "sbConnection", "rcConsole", "sslBuffer", "rcCh", "inputchannel", "srcCh", "inputChan", "sbCh", " srcBuffer", "syncConnection", "remoteChannel", "syncChannel", "rcClient", "rcConnection", "srcConsole", " srcchannel", " srcClient", "rcBuffer", "sslChannel", "syncchannel", "sslChan", "syncBuffer", "srcConnection"], "fileName": ["FileInfo", " fileUrl", " fileNum", "fName", "FilePath", "fileUrl", "fPath", "Filename", " filePath", "filename", " filename", "fname", "fileInfo", "fileNum", " fileInfo", "filePath", "FileName", "FILEname", "FileNum", "FILENum", "FileUrl", "FILEName", "FILEInfo", "fUrl"], "dstChannel": [" dndChannel", "drcManager", "ddestchannel", " dndSocket", "ddestChannel", " dstClient", "drcChannel", "drdChannel", "dndchannel", "dstsClient", "dsrcManager", "dsrcchannel", "dstsManager", " drcClient", "ddestConnection", "drdchannel", " drcChannel", "drdConnection", "ddestSocket", "dstSocket", "drcchannel", "dstschannel", "dsrcChannel", " dstSocket", " drcManager", "dstClient", "dndSocket", "dndChannel", " dndConnection", "dsrcClient", "dstManager", "drcClient", " dstConnection", "dstchannel", " dstchannel", " drcchannel", "dstConnection", "drdSocket", " dstManager", " dndchannel", "dndConnection", "dstsChannel"], "buffer": ["reader", "size", "processor", "queue", "memory", "binary", "counter", "reference", "buff", "repeat", "iter", "result", "player", "Buffer", "extra", "limit", "audio", "this", "b", "base", "layer", "data", "loader", "number", "channel", "r", "cover", "resource", "handler", "server", "address", "writer", "uffer", "sequence", "er", "transfer", "null", "batch", "flush", "wave", "comment", "FFER", "buf", "bar", "offset", "slice", "border", "seed", "cache", "file", "builder", "array", "header", "block", "rate", "copy", "pause"], "nr": ["next", "size", "ru", "nl", "num", "rf", "gr", "rx", "uni", "len", "counter", "range", "iter", "eno", "arity", "radius", "lr", "loc", "number", "rn", "no", "n", "r", "nor", "sequence", "inter", "usr", "NR", "nt", "length", "sr", "hr", "nu", "adr", "offset", "nos", "index", "pointer", "rl", "mr", "err", "i", "coord", "pos", "rr", "nb", "order", "ng", "sn", "nil", "inv", "nm", "nc", "rb", "ner", "umber"], "bytes": ["resources", "classes", "cells", "size", "strings", "binary", "Bytes", "pieces", "runs", "lines", "packs", "items", "bps", "b", "bc", "data", "fe", "blocks", "zip", "bs", "objects", "outs", "es", "address", "gets", "vs", "body", "pages", "values", "buf", "rules", "units", "rows", "les", "vals", "its", "limits", "features", "files", "pos", "bits", "tes", "seconds", "reads"]}}
{"id1": "22024581", "id2": "5707204", "code1": "    private static Collection<String> crossCheckFromOBOFile(String category) throws Exception {\n        Collection<String> miCol = new ArrayList<String>();\n        String revision = \"1.48\";\n        URL url = new URL(OboUtils.PSI_MI_OBO_LOCATION + \"?revision=\" + revision);\n        log.debug(\"url \" + url);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        int termCounter = 0;\n        int miCounter = 0;\n        int obsoleteCounter = 0;\n        int obsoleteCounterDef = 0;\n        int typedefCounter = 0;\n        int drugTerm = 0;\n        int psiTerm = 0;\n        String mi = null;\n        while ((inputLine = in.readLine()) != null) {\n            String temp;\n            temp = inputLine;\n            if (inputLine.startsWith(\"[Term]\")) {\n                termCounter++;\n            } else if (inputLine.matches(\"id:\\\\s+(MI:.*)\")) {\n                mi = temp.split(\"\\\\s+\")[1];\n                miCounter++;\n            } else if (inputLine.contains(\"is_obsolete: true\")) {\n                obsoleteCounter++;\n            } else if (inputLine.matches(\"def:.*?OBSOLETE.*\")) {\n                obsoleteCounterDef++;\n            } else if (inputLine.startsWith(\"[Typedef]\")) {\n                typedefCounter++;\n            } else if (inputLine.matches(\"subset:\\\\s+PSI-MI\\\\s+slim\")) {\n                psiTerm++;\n                if (category.equalsIgnoreCase(OboCategory.PSI_MI_SLIM)) miCol.add(mi);\n            } else if (inputLine.matches(\"subset:\\\\s+Drugable\")) {\n                drugTerm++;\n                if (category.equalsIgnoreCase(OboCategory.DRUGABLE)) miCol.add(mi);\n            }\n        }\n        Assert.assertEquals(948, termCounter);\n        Assert.assertEquals(948, miCounter);\n        Assert.assertEquals(53, obsoleteCounter);\n        Assert.assertEquals(53, obsoleteCounterDef);\n        Assert.assertEquals(1, typedefCounter);\n        Assert.assertEquals(844, psiTerm);\n        Assert.assertEquals(124, drugTerm);\n        in.close();\n        return miCol;\n    }\n", "code2": "    public void download(final String url, final long deleteRowId) {\n        new Thread(new Runnable() {\n\n            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n        }).start();\n    }\n", "label": 0, "substitutes": {"category": ["consumer", "gap", "folder", "program", "language", "id", "reason", " catalogue", "VERSION", "period", "year", "product", "reference", "division", "ategories", "cat", " genre", "culture", "format", "ategory", "nature", "color", "number", "version", "Category", "directory", "re", "r", "region", "resource", "genre", "cot", "module", "section", "tag", "name", "method", "component", "dir", "currency", "purpose", "scope", "feat", "unit", "comment", "string", "path", "family", "c", "record", "file", "attribute", " regex", "character", " Category", "project", "month", "type"], "miCol": ["mmColumn", "MICor", "MiCor", "diColl", "mmCor", "miniColl", "mmCon", "miColl", "MICol", "umiColl", "diCol", "MiRef", "MiColl", "diRef", "miColumn", "umiCon", "MiCol", "miCor", "diCon", "umiRef", "miCon", "mmColl", "MIRef", "umiCol", "miniCol", "miniColumn", "MIColl", "MIColumn", "miniRef", "miRef", "mmRef", "mmCol"], "revision": ["recvision", "brevision", "preision", "preolution", "revversion", "recjection", "recversion", "breision", "Reision", "rejection", "Rejection", "reward", "reolution", "reversion", "revvision", "reision", "preward", "revjection", "breolution", "recision", "revward", "breward", "Reversion", "revolution", "Revision", "prevision"], "url": ["source", "host", "page", "id", "link", "user", "feed", "connection", "open", "buffer", "build", "ll", "l", "http", "client", "fr", "loc", "f", "base", "channel", "data", "ref", "stream", "href", "resource", "org", "server", "address", "tool", "ur", "gl", "log", "api", "location", "ls", "string", "path", "image", "rl", "file", "uri", "ssl", "rect", "URL", "service", "Url", "www", "blog", "web", "sl"], "in": ["source", "read", "reader", "h", "id", "input", "inc", "din", "connection", "buffer", "io", "l", "con", "out", "b", "this", "login", "f", "data", "In", "fe", "stream", "again", "r", "resource", "inner", "ins", "t", "ini", "m", "ex", "c", "file", "ssl", "i", "IN", "socket", "inn", "is", "bin", "s", "line"], "inputLine": ["requestLink", "infSource", "inputCo", "reviewBlock", " inputL", "InputRow", "jsonline", "loadline", "requestLine", "Inputline", "inputSource", "inputL", "InputBlock", "inputLook", "inputBlock", "sourceline", " inputBody", "outputLink", "InputLine", "InputCo", "InputSource", "pullLin", "pullLine", "outputline", " inputRow", "infRow", "outputFile", "execBlock", "reviewLine", "flowLink", "pullBlock", " inputLink", "infline", "inputPage", "sourceLook", "InputBody", "InputLin", " inputBlock", "inputRow", "loadPage", "sourceLine", " inputSource", "loadLin", "flowLine", "reviewline", "inputBody", "inputLink", "InputLook", "InputL", "pullL", " inputline", " inputPage", "reviewCo", " inputLin", "jsonLin", "loadLine", "infLink", "requestline", "flowline", "requestPage", "inputFile", " inputLook", "execline", "execBody", "requestSource", "infBlock", "jsonLine", "inputline", "execLine", "outputLine", "flowL", " inputFile", "infLine", "InputPage", "requestBlock", " inputCo", "InputFile", "inputLin", "outputL", "sourceSource", "jsonPage"], "termCounter": ["termsStore", "wordBar", "termscounter", "metaBar", "mmNum", "TermNum", "termCode", " termCode", "TermOffset", "termcounter", "metaCounter", "termBar", "tokenClock", "termNum", "TermCategory", "termCategory", " termNum", "termOffset", "wordVector", " termcounter", "termVector", "wordClock", " termOffset", "metaClock", "termClock", "termsCategory", "TermCounter", "tokenVector", "tokenCounter", "mmCode", "tokenBar", "Termcounter", "termStore", "TermCode", " termStore", "metaVector", "mmCounter", "TermStore", "wordCounter", "mmOffset", " termCategory", "termsCounter"], "miCounter": ["amiCount", "iniMaster", "amicounter", "micCount", "mmTimer", "iniTimer", "umiCount", "miniCounter", "umicounter", "amiIndex", "mmMaster", "micCounter", "mmcounter", "miMaster", "miniNumber", "mmCount", "iniNumber", "umiCounter", "amiCounter", "pmIndex", "miniMaster", "pmCounter", "pmCount", "miCount", "miniTimer", "umiIndex", "micNumber", "umiNumber", "mmCounter", "miTimer", "mmNumber", "iniCounter", "miccounter", "micounter", "pmcounter", "miIndex", "miNumber"], "obsoleteCounter": ["obgoneCounter", "observedPercent", "ubviousCounter", "ubsoleteCounter", "obliquePercent", "abliqueCounter", "obsoletecounter", "ubviousNumber", "obliqueConsumer", "obsoletePercent", "obliqueCount", "obviousNumber", "obviousCounter", "absoleteConsumer", "obsoleteConsumer", "abliqueConsumer", "obliquecounter", "observedNumber", "ubviouscounter", "ubsoletecounter", "observedCounter", "ubsoletePercent", "absoleteNumber", "obsoleteCount", "obviouscounter", "ubviousCount", "obgoneConsumer", "observedConsumer", "ubsoleteNumber", "obliqueNumber", "absoleteCounter", "obliqueCounter", "abliqueNumber", "obviousCount", "obgoneNumber", "obviousPercent", "ubviousPercent", "ubsoleteCount", "observedcounter", "obsoleteNumber"], "obsoleteCounterDef": ["obsoleteBERCond", "obsoleteCounterCond", "obsoletePercentCond", "obliquecounterEx", "obliqueCounterDesc", "obviousPercentEx", "obsoletePercentEx", "obsoleteCounterDesc", "obviousPercentCond", "obsoletePercentDef", "obsoletecounterDesc", "obsoleteBEREx", "obviousCounterdef", "obsoleteCounterdef", "obviousPercentDef", "obsoleteCountCond", "obviousCounterEx", "obsoleteCountDef", "obsoleteCountdef", "obsoletePercentDesc", "obsoletecounterEx", "obsoleteBERdef", "obliqueCounterDef", "obsoletePercentdef", "obviousCounterDef", "obviousPercentdef", "obsoleteCountDesc", "obliquecounterDef", "obsoleteCounterEx", "obsoletecounterDef", "obsoleteBERDef", "obsoleteCountEx", "obviousCounterCond", "obliquecounterDesc", "obliqueCounterEx"], "typedefCounter": ["tyedescCounter", "tyedefNumber", "typedescCounter", "tyedescNumber", "typedevcounter", "typedepCounter", "typedesccounter", "tyedesccounter", "typedevCount", "typedepCount", "typedecCounter", "tyledevCounter", "tyedefCount", "typedecCount", "typediffcounter", "typedescCount", "tyedefcounter", "tyedefCounter", "tyledevcounter", "tyledevCount", "typediffCount", "tyedescCount", "typedepcounter", "tyledefCount", "typedefcounter", "typediffCounter", "typedepNumber", "tyledefCounter", "typedefNumber", "typedescNumber", "tyledefcounter", "typedeccounter", "typedecNumber", "typedefCount", "typedevCounter"], "drugTerm": ["DrugTer", "DrugCounter", "asionTerm", " drugCounter", "drugCounter", " drugEntity", " drugterm", "asionterm", " drugTer", "proteinTer", "DrugEntity", "drugterm", "DrugCount", "proteinterm", "drugTer", " drugCount", "drugCount", "asionCount", "proteinTerm", "proteinEntity", "drugEntity", "Drugterm", "asionCounter", "DrugTerm"], "psiTerm": ["psicEntry", "mpiRate", "psicRate", "psaiEntry", "psaiTerm", "rsiTab", "psiaTer", "psiuTerm", "psaiTer", "rsiuEntry", "psiaTerm", "rsiuTab", "mpicOffset", "psicOffset", "psiWord", "psicTab", "psiRate", "rsiTerm", "rsiWord", "psaiRate", "rsiEntry", "mpicTerm", "psicWord", "psaiWord", "psiTer", "mpiOffset", "psaiOffset", "psiOffset", "psiuWord", "psiEntry", "rsiuTerm", "psaiTab", "mpiTer", "psiuEntry", "psicTer", "psicTerm", "mpiTerm", "psiaRate", "psiuTab", "rsiuWord", "psiTab", "mpicTer", "mpicRate", "psiaOffset"], "mi": ["mic", "my", "si", "multi", "ami", "phi", "mm", "lim", "yi", "Mi", "bm", "data", "di", "bi", "ti", "omi", "mag", "meta", "gi", "mc", "Temp", "mia", "ai", "imi", "umi", "ui", "ci", "wi", "tc", "shi", "ini", "mis", "m", "lc", "li", "xi", "cli", "MI", "pm", "ri", "tm", "uri", "i", "vi", "pi", "fi", "mini"], "temp": ["source", "get", "su", "tmp", "py", "input", "num", "test", "txt", "term", "cm", "buffer", "result", "iter", "now", "mm", "flat", "tw", "format", "original", "pre", "fake", "wa", "data", "tem", "match", "prefix", "template", "wrap", "Temp", "name", "pattern", "unit", "json", "tc", "cont", "Str", "text", "atom", "m", "copy", "lc", "key", "pm", "path", "tm", "cache", "c", "emp", "i", "local", "item", "vi", "pi", "form", "empty", "nm", "str", "mini", "p", "type"]}}
{"id1": "13433285", "id2": "473797", "code1": "    public static String md5(final String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[FOUR_BYTES];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"text": ["source", "str", "contract", "input", "TEXT", "txt", "binary", "token", "buffer", "message", "output", "format", "letter", "object", "Text", "number", "data", "hex", "version", "bytes", "prefix", "template", "word", "name", "transfer", "pattern", "password", "length", "content", "key", "string", "path", "image", "obj", "font", "code", "struct", "secret", "test", "value", "ext"], "md": ["h", "um", "hash", "bf", "d", "mb", "cm", "dig", "dd", "ind", "cf", "message", "mm", " MD", "pd", "ma", "am", "wd", "cmd", "ms", "po", "mo", "mac", "arm", "bd", "hm", "mand", "mag", "meta", "mc", "sha", "mp", "de", "mod", "dm", "MD", "m", "df", "temp", "od", "pm", "mg", "metadata", "amd", "nm", "me", "ad", "pkg"], "md5hash": ["mdloghash", "MD5sum", "md4sum", "MD5hash", " md2sum", " md5number", "md5sum", " md2number", "mdlogdash", "md6hash", "md4hash", "MD2hash", "md2sum", "md4dash", "md55hash", "md2hash", "md6sum", " md2hash", "MD2Hash", "md6dash", " md4dash", "md2number", " md5sum", "md2Hash", "MD5Hash", "md4number", " md4hash", " md5dash", "md5number", " md2Hash", "md55number", "md6Hash", "md5dash", "md55Hash", " md5Hash", "mdlogHash", " md4Hash", "md5Hash", "md55sum", "md4Hash", "MD2sum"]}}
{"id1": "9980609", "id2": "5936410", "code1": "    public static void copyResource(Resource source, Resource dest, FilterSetCollection filters, Vector filterChains, boolean overwrite, boolean preserveLastModified, boolean append, String inputEncoding, String outputEncoding, Project project) throws IOException {\n        if (!(overwrite || SelectorUtils.isOutOfDate(source, dest, FileUtils.getFileUtils().getFileTimestampGranularity()))) {\n            return;\n        }\n        final boolean filterSetsAvailable = (filters != null && filters.hasFilters());\n        final boolean filterChainsAvailable = (filterChains != null && filterChains.size() > 0);\n        if (filterSetsAvailable) {\n            BufferedReader in = null;\n            BufferedWriter out = null;\n            try {\n                InputStreamReader isr = null;\n                if (inputEncoding == null) {\n                    isr = new InputStreamReader(source.getInputStream());\n                } else {\n                    isr = new InputStreamReader(source.getInputStream(), inputEncoding);\n                }\n                in = new BufferedReader(isr);\n                OutputStream os = getOutputStream(dest, append, project);\n                OutputStreamWriter osw;\n                if (outputEncoding == null) {\n                    osw = new OutputStreamWriter(os);\n                } else {\n                    osw = new OutputStreamWriter(os, outputEncoding);\n                }\n                out = new BufferedWriter(osw);\n                if (filterChainsAvailable) {\n                    ChainReaderHelper crh = new ChainReaderHelper();\n                    crh.setBufferSize(FileUtils.BUF_SIZE);\n                    crh.setPrimaryReader(in);\n                    crh.setFilterChains(filterChains);\n                    crh.setProject(project);\n                    Reader rdr = crh.getAssembledReader();\n                    in = new BufferedReader(rdr);\n                }\n                LineTokenizer lineTokenizer = new LineTokenizer();\n                lineTokenizer.setIncludeDelims(true);\n                String newline = null;\n                String line = lineTokenizer.getToken(in);\n                while (line != null) {\n                    if (line.length() == 0) {\n                        out.newLine();\n                    } else {\n                        newline = filters.replaceTokens(line);\n                        out.write(newline);\n                    }\n                    line = lineTokenizer.getToken(in);\n                }\n            } finally {\n                FileUtils.close(out);\n                FileUtils.close(in);\n            }\n        } else if (filterChainsAvailable || (inputEncoding != null && !inputEncoding.equals(outputEncoding)) || (inputEncoding == null && outputEncoding != null)) {\n            BufferedReader in = null;\n            BufferedWriter out = null;\n            try {\n                InputStreamReader isr = null;\n                if (inputEncoding == null) {\n                    isr = new InputStreamReader(source.getInputStream());\n                } else {\n                    isr = new InputStreamReader(source.getInputStream(), inputEncoding);\n                }\n                in = new BufferedReader(isr);\n                OutputStream os = getOutputStream(dest, append, project);\n                OutputStreamWriter osw;\n                if (outputEncoding == null) {\n                    osw = new OutputStreamWriter(os);\n                } else {\n                    osw = new OutputStreamWriter(os, outputEncoding);\n                }\n                out = new BufferedWriter(osw);\n                if (filterChainsAvailable) {\n                    ChainReaderHelper crh = new ChainReaderHelper();\n                    crh.setBufferSize(FileUtils.BUF_SIZE);\n                    crh.setPrimaryReader(in);\n                    crh.setFilterChains(filterChains);\n                    crh.setProject(project);\n                    Reader rdr = crh.getAssembledReader();\n                    in = new BufferedReader(rdr);\n                }\n                char[] buffer = new char[FileUtils.BUF_SIZE];\n                while (true) {\n                    int nRead = in.read(buffer, 0, buffer.length);\n                    if (nRead == -1) {\n                        break;\n                    }\n                    out.write(buffer, 0, nRead);\n                }\n            } finally {\n                FileUtils.close(out);\n                FileUtils.close(in);\n            }\n        } else if (source.as(FileProvider.class) != null && dest.as(FileProvider.class) != null) {\n            File sourceFile = ((FileProvider) source.as(FileProvider.class)).getFile();\n            File destFile = ((FileProvider) dest.as(FileProvider.class)).getFile();\n            File parent = destFile.getParentFile();\n            if (parent != null && !parent.isDirectory() && !destFile.getParentFile().mkdirs()) {\n                throw new IOException(\"failed to create the parent directory\" + \" for \" + destFile);\n            }\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            FileChannel srcChannel = null;\n            FileChannel destChannel = null;\n            try {\n                in = new FileInputStream(sourceFile);\n                out = new FileOutputStream(destFile);\n                srcChannel = in.getChannel();\n                destChannel = out.getChannel();\n                long position = 0;\n                long count = srcChannel.size();\n                while (position < count) {\n                    position += srcChannel.transferTo(position, FileUtils.BUF_SIZE, destChannel);\n                }\n            } finally {\n                FileUtils.close(srcChannel);\n                FileUtils.close(destChannel);\n                FileUtils.close(out);\n                FileUtils.close(in);\n            }\n        } else {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = source.getInputStream();\n                out = getOutputStream(dest, append, project);\n                byte[] buffer = new byte[FileUtils.BUF_SIZE];\n                int count = 0;\n                do {\n                    out.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            } finally {\n                FileUtils.close(out);\n                FileUtils.close(in);\n            }\n        }\n        if (preserveLastModified) {\n            Touchable t = (Touchable) dest.as(Touchable.class);\n            if (t != null) {\n                setLastModified(t, source.getLastModified());\n            }\n        }\n    }\n", "code2": "    public void run() {\n        try {\n            String getter = null;\n            String str, targetHost = \"\", httpHeader = \"\";\n            int targetPort = 80;\n            while (true) {\n                str = fromBrowser.readLine();\n                if (str.startsWith(\"GET\") || str.startsWith(\"DESCRIBE\") || str.startsWith(\"POST\") || str.startsWith(\"HEAD\")) {\n                    getter = str;\n                }\n                if (str.startsWith(\"Accept-Encoding: gzip\")) {\n                    str = \"Accept-Encoding: identity\";\n                }\n                httpHeader += str + \"\\r\\n\";\n                if (str.startsWith(\"Host: \")) {\n                    targetHost = str.substring(6);\n                } else if (str.startsWith(\"DESCRIBE\")) {\n                    targetPort = 554;\n                    targetHost = str.substring(str.indexOf(\"//\") + 2);\n                    targetHost = targetHost.substring(0, targetHost.indexOf(\"/\"));\n                }\n                if (str.length() == 0) {\n                    break;\n                }\n            }\n            String target = targetHost;\n            if (targetHost.indexOf(\":\") > -1) {\n                try {\n                    targetPort = Integer.parseInt(targetHost.substring(targetHost.indexOf(\":\") + 1));\n                } catch (NumberFormatException nfe) {\n                }\n                target = targetHost.substring(0, targetHost.indexOf(\":\"));\n            }\n            logger.trace(\"[PROXY] Connect to: \" + target + \" and port: \" + targetPort);\n            socketToWeb = new Socket(InetAddress.getByName(target), targetPort);\n            InputStream sockWebInputStream = socketToWeb.getInputStream();\n            toWeb = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socketToWeb.getOutputStream())), true);\n            toWeb.println(httpHeader);\n            toWeb.flush();\n            StringTokenizer st = new StringTokenizer(getter, \" \");\n            st.nextToken();\n            String askedResource = st.nextToken();\n            askedResource = askedResource.substring(askedResource.indexOf(targetHost) + targetHost.length());\n            logger.trace(\"[PROXY] Asked resource: \" + askedResource);\n            String directoryResource = askedResource.substring(0, askedResource.lastIndexOf(\"/\"));\n            directoryResource = getWritableFileName(directoryResource);\n            String fileResource = askedResource.substring(askedResource.lastIndexOf(\"/\") + 1);\n            fileResource = getWritableFileName(fileResource);\n            fileResource = fileResource + \".cached\";\n            String fileN = \"proxycache/\" + target + \"/\" + directoryResource;\n            File directoryResourceFile = new File(fileN);\n            if (writeCache) {\n                directoryResourceFile.mkdirs();\n            }\n            File cachedResource = new File(directoryResourceFile, fileResource);\n            byte[] buffer = new byte[8192];\n            boolean resourceExists = cachedResource.exists() || this.getClass().getResource(\"/\" + fileN) != null;\n            boolean inMemory = writeCache && !resourceExists;\n            FileOutputStream fOUT = null;\n            if (resourceExists) {\n                logger.trace(\"[PROXY] File is cached: \" + cachedResource.getAbsolutePath());\n                sockWebInputStream.close();\n                if (cachedResource.exists()) {\n                    sockWebInputStream = new FileInputStream(cachedResource);\n                } else {\n                    sockWebInputStream = this.getClass().getResourceAsStream(\"/\" + fileN);\n                }\n            } else if (writeCache) {\n                logger.trace(\"[PROXY] File is not cached / Writing in it: \" + cachedResource.getAbsolutePath());\n                fOUT = new FileOutputStream(cachedResource, false);\n            }\n            OutputStream baos = null;\n            if (inMemory) {\n                baos = new ByteArrayOutputStream();\n            } else {\n                baos = toBrowser;\n            }\n            long total_read = 0;\n            int bytes_read;\n            long CL = 10000000000L;\n            while (total_read < CL && (bytes_read = sockWebInputStream.read(buffer)) != -1) {\n                if (!resourceExists) {\n                    if (10000000000L == CL) {\n                        String s = new String(buffer, 0, bytes_read);\n                        int clPos = s.indexOf(\"Content-Length: \");\n                        if (clPos > -1) {\n                            CL = Integer.parseInt(s.substring(clPos + 16, s.indexOf(\"\\n\", clPos)).trim());\n                            logger.trace(\"Found Content Length: \" + CL);\n                        }\n                    }\n                    if (bytes_read >= 7) {\n                        byte end[] = new byte[7];\n                        System.arraycopy(buffer, bytes_read - 7, end, 0, 7);\n                        if (new String(end).equals(\"\\r\\n0\\r\\n\\r\\n\")) {\n                            System.out.println(\"end of transfer chunked\");\n                            CL = -1;\n                        }\n                    }\n                    if (writeCache) {\n                        fOUT.write(buffer, 0, bytes_read);\n                    }\n                }\n                baos.write(buffer, 0, bytes_read);\n                total_read += bytes_read;\n            }\n            if (inMemory) {\n                baos.close();\n                toBrowser.write(((ByteArrayOutputStream) baos).toByteArray());\n            }\n            if (writeCache && fOUT != null) {\n                fOUT.close();\n            }\n            socketToWeb.close();\n            toBrowser.close();\n        } catch (IOException e) {\n        } finally {\n            try {\n                if (toWeb != null) {\n                    toWeb.close();\n                }\n                if (toBrowser != null) {\n                    toBrowser.close();\n                }\n                socket.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"source": ["resources", "reader", "site", "input", "result", "src", "from", "view", "http", "fp", "Source", "client", "base", "git", "stream", "class", "remote", "style", "resource", "single", "server", "slave", "config", "template", "rc", "s", "target", "scope", "spec", "text", "ource", "sin", "SOURCE", "slice", "string", "path", "seed", "secure", "file", "uri", "i", "service", "current", "scene", "subject", "start", "proxy", "copy", "null", "use"], "dest": ["draw", "folder", "tmp", "later", "dc", "proc", "trans", "d", "rest", "txt", "result", "cat", "output", "src", "cdn", "home", " destination", "gen", "delete", "resource", "thin", "ret", " Dest", "desc", "dir", "target", "de", "cont", "transform", "Dest", "temp", "done", "path", "orig", "them", "comb", "wb", "dist", "self", "destroy", "bin", "dat", "usr"], "filters": ["flators", "batter", " Filcers", "Filers", " filers", "baters", "fillines", "filcers", "lifters", "Filators", "lifchers", "Filppers", "filizers", " filcers", "filterters", "flers", " Filers", "filchers", "lifizers", "Filtering", "filterers", "batters", "fter", "ilters", "filators", "Fillines", "Filcers", "battering", "ilppers", "fters", "ilizers", " Filters", "fllines", "filterlines", "ilchers", "fers", "ftering", "filppers", "Filizers", "lifppers", " Filizers", "filterators", "Filter", "filtering", "Filters", "Filchers", " filizers", "filers", "filter", "flters"], "filterChains": ["filterCHannels", "filterchaining", "filterChain", "filterGines", " filterCHines", " filterchanners", "filterchines", "filterChainers", "FilterChroups", "Filterchain", "filterGaining", "filterchanners", "filterClines", " filterCHains", " filterChines", " filterChanners", "sortchainers", " filterChaining", "filterChannels", "sortChines", " filterCHannels", "filterClain", "filterBanners", "Filterchroups", "filterGains", "filterBaining", "Filterchans", "filterBain", "filterchannels", "filterCHaining", "filterchainers", "sortChain", "sortchain", "sortchines", " filterchain", " filterChain", "filterchroups", " filterChannels", "sortChainers", "filterchains", "sortChains", "filterchain", " filterCHaining", "FilterChans", "filterClains", "filterClans", "filterChans", "filterChroups", "filterGannels", "filterchans", "filterChines", " filterchaining", "filterChanners", "filterClainers", "filterCHains", "filterChaining", " filterchains", "FilterChain", "FilterChains", "filterCHroups", "filterClroups", "filterCHines", "filterBains", "filterCHans", "filterCHain", "sortchains", "Filterchains"], "overwrite": [" Overwrite", "interwritten", "undertext", " Overwritten", " overtext", "underwrite", "overwritten", "interwrite", "underwriting", "underWrite", "interWrite", " overwritten", "overtext", " Overtext", " override", "underwritten", "underride", "override", "overwriting", " Override", " Overwriting", " OverWrite", "overWrite", "interwriting"], "preserveLastModified": ["preserveLastMification", "preserveFirstmodued", "preserveFirstModued", "preserveLastMified", "preserveLastmodifiedued", "preserveLastmodifiedification", "preserveFirstmodification", "preserveLastmodification", "preserveLastModification", "preserveFirstmodDate", "preserveFirstModification", "preserveLastmodued", "preserveFirstmodified", "preserveLastMDate", "preserveLastmodifiedDate", "preserveLastmodifiedified", "preserveLastmodDate", "preserveLastmodified", "preserveFirstModified", "preserveLastModued", "preserveFirstModDate", "preserveLastModDate", "preserveLastMued"], "append": ["absolute", "next", "attach", "pend", "disable", "write", "open", "bind", "output", "join", "format", "app", "end", "include", "prefix", "save", "push", "pad", "update", "send", "init", "batch", "printf", "patch", "password", "flush", "text", "escape", "post", "index", "insert", "string", "vert", "replace", "pp", "mount", "create", "start", "add", "apply", "forward", "ext"], "inputEncoding": [" inputExtearing", "inputEncoded", "inputExploding", "outputEncapping", " inputDecryption", "outputEncryption", "inputExplasing", "inputDecryption", "inputEncasing", " inputEncryption", "inputEngoding", "inputencryption", "inputExplapping", "inputExpapping", "inputDecapping", "inputChapping", " inputExtoded", "inputencapping", "outputDecapping", "inputEncryption", "inputEncaling", "inputDecoding", "inputExpoding", "outputDecoding", " inputExtoding", "inputDecearing", "inputExpasing", "inputDecaling", "inputEngoded", "inputChaling", "inputencaling", " inputEncoded", " inputDecoding", "inputChoding", " inputEncaling", "inputEncearing", "inputencoding", "inputExplryption", " inputEncapping", "inputExpryption", "inputDecasing", " inputDecapping", "inputDecoded", " inputExtasing", "inputExtoding", " inputEncasing", "inputExtoded", "outputDecasing", "inputChryption", " inputDecaling", "inputEngearing", "outputEncasing", "inputExtearing", "inputExtasing", "inputEncapping", " inputEncearing", "inputEngasing", "outputDecryption"], "outputEncoding": ["outputChilling", "outputEncording", " outputChoding", "outputChoder", "outputencilling", "outputEncoder", "inputChaching", "referenceencoding", "outputChocol", "outputClryption", "inputChasing", "outputCoding", "outputCryption", "outputEncryption", " outputChryption", " outputEncryption", "outputEncilling", "outputencinding", "outputChording", "inputEncasing", "referenceencasing", "outputEscaching", "outputencoding", "inputEncaching", "referenceencocol", "referenceEncocol", "outputExpocol", "referenceEncinding", "outputChaching", "outputExpasing", "referenceEncasing", " outputChording", "outputencasing", "referenceencinding", "outputencocol", "outputCoder", "outputEscasing", " outputEncording", "outputEscoding", "inputChoding", "referenceEncoding", "outputencaching", "outputExpoding", "outputCloding", "outputEncocol", "outputEscilling", "inputChilling", " outputChoder", "outputChoding", "outputExpinding", "outputCording", "outputChasing", "outputChryption", "outputCloder", "inputEncilling", "outputEncasing", "outputChinding", "outputEncinding", "outputEncaching", " outputEncoder", "outputClording"], "project": ["folder", "contract", "Project", "proc", "phase", "plugin", "jp", "license", "client", "app", "object", "request", "driver", "root", "prop", "profile", "progress", "region", "directory", "version", "resource", "config", "component", "method", "dir", "scope", "target", "report", "pattern", "job", "path", "document", "pro", "file", "context", "rect", "projects", "struct", "database", "process", "subject", "proxy", "bot", "port"], "filterSetsAvailable": ["filterSetsAvailability", "filterSsetsavailable", "filterSistsAvailable", "filterShsetsAvailability", "filterSumesAvailable", "filterSistsActive", "filterShetsavailable", "filterSsetsAvailability", "filterSSetActive", "filterShetsAvailability", "filterShETSReady", "filterSsetsAvailable", "filterShsetsAvailable", "filterShetsReady", "filterSetsavailable", "filterSETSActive", "filterSistsAvailability", "filterShETSActive", "filterShETSAvailable", "filterSETSReady", "filterShETSAvailability", "filterSSetAvailability", "filterShetsActive", "filterSistsavailable", "filterSetsActive", "filterShetsAvailable", "filterShsetsavailable", "filterSistsReady", "filterSumesavailable", "filterSumesAvailability", "filterSSetReady", "filterSETSAvailable", "filterSETSAvailability", "filterSetsReady", "filterSSetAvailable"], "filterChainsAvailable": ["filterchainingAvailable", "filterchainsAvailable", "filterChansAvailable", "filterChainavailable", "filterChainsActive", "filterChainsavailable", "filterChainingAvailability", "filterchroupsAvailability", "filterChainAvailable", "filterChainAvailability", "filterchainsavailable", "filterChroupsavailable", "filterChinesavailable", "filterchroupsavailable", "filterChroupsActive", "filterChainsAvailability", "filterChansAvailability", "filterChainingAvailable", "filterChainingavailable", "filterChroupsAvailability", "filterChansavailable", "filterChansActive", "filterChinesAvailability", "filterchainsAvailability", "filterchainingavailable", "filterChroupsAvailable", "filterChinesAvailable", "filterchroupsAvailable", "filterchroupsActive", "filterchainsActive", "filterchainingAvailability", "filterChainActive"], "in": ["get", "read", "reader", "h", "id", "url", "input", "inc", "din", "arin", "ic", "win", "connection", "io", "nin", "src", "l", "conn", "b", "this", "request", "login", "f", "data", "In", "pin", "into", "n", "r", "re", "inas", "again", "stream", "resource", "serv", "isin", "inner", "er", "init", "it", "ins", "o", "vin", "gin", "ini", "a", "rec", "cin", "c", "file", "i", "err", "IN", "inside", "inn", "rin", "is", "ar", "lin", "bin", "s", "p"], "out": ["str", "inc", "user", "write", "net", "with", "result", "extra", "io", "output", "doc", "conn", "ew", "outer", "w", "object", "client", "cmd", "ou", "this", "part", "op", "to", "again", "Out", "work", "outs", "prefix", "OUT", "resource", "writer", "editor", "strip", "inner", "exec", "name", "ne", "o", "ax", "comment", "ex", "writ", "copy", "temp", "string", "obj", "socket", "file", "i", "err", "array", "at", "group", "bin", "res", "p", "ext"], "isr": ["isrx", "ISpr", "ash", "Ispr", "osr", " isra", "issh", "Isrx", "issrs", "izrs", "ISr", "ISw", "ISre", "asrs", "Isr", "osnr", "asw", "issw", "izra", "isra", "osh", "issr", " isw", " isrs", "ISra", "osre", "Isre", "ISrs", "ISnr", "isnr", "osrx", "isre", "ispr", "isrs", "izw", "ish", "ospr", "issnr", "osrs", "isw", "izr", "asr", "ISrx"], "os": ["los", "oses", "ss", "io", "ws", "rss", "conn", "fs", "acs", "ns", "ms", "OS", "ou", "bos", "as", "oc", "oa", "bs", "ot", "es", "sys", "oss", "oos", "res", "oS", "o", "s", "aos", "Os", "ose", "ios", "ops", "ori", "i", "ol", "ols", "or", "ois", "pos", "us", "is", "cos", "osi", "iso", "op", "so", "p"], "osw": ["ssww", "OSwe", "coswe", "osww", "oh", "osr", "iosr", "oswu", "oswe", " osnw", "oww", "OSwx", "coswar", " osww", "osh", "cosW", "OSw", "ssh", " oswx", "ioswx", "iosnw", " osr", " osh", " osW", "ssw", " oswar", "OSwar", "ow", "sswe", "sswu", " oswe", "OSr", "OSW", "cosw", "OSnw", "owe", "osW", "oswar", "owu", "osnw", "iosw", "oswx", " oswu"], "crh": ["trbh", "RChd", "RChr", "Crrh", "crhe", "clbh", "ccbh", "crv", "RCv", "Crr", "archhe", "clrh", "crrh", "clr", "ccph", " crph", "ccH", "CRh", " crhd", "arch", "Crv", "CRH", "Crh", "crhs", "crH", "cfhe", " crhs", "arcv", "archhs", " crbh", " crhr", "clh", "CRph", "crph", "cch", "archh", "cfbh", " crH", "trv", "crhr", "RCh", "CRhs", "CRr", "CRbh", "archr", "cfhs", " crv", "crhd", "CrH", "trh", "Crhs", "cfh", "clhs", " crrh", "archd", "crbh", "trH", "Crhe", "archbh", "CRrh", "Crbh", "crr"], "rdr": ["odr", "rdm", "bdr", "rrR", "srr", "odh", "rrb", "odm", "rtr", "rdb", "rrh", "rrr", "rtm", "srb", "rdR", "odR", "bdh", "srh", "rth", "bddr", "rtR", "rddr", "rrdr", "rrm", "bdb", "rdh", "srdr"], "lineTokenizer": ["lineSerializing", "lineCharacteriz", " lineTokenizers", "LineNormalizer", "lineSerializer", "lineInitializing", "lineNormalizers", "lineInitializers", "lineSerializ", " lineTokenize", "LineNormalize", "lineRegularizer", "LineTokenizer", " lineTokeniz", "LineNormalizers", "lineTokenize", "lineRegularize", "LineTokenizing", "lineTokenizing", "LineNormalizing", " lineInitializer", "lineCharacterizer", "lineNormalizer", " lineInitialize", " lineInitializers", " lineCharacterizer", "LineTokenizers", "lineRegularized", " lineCharacteriz", "lineCharacterized", " lineTokenizing", "lineNormalize", "lineSerialize", "LineTokenize", "lineTokeniz", " lineInitializing", "lineNormalizing", "lineRegulariz", "lineSerialized", "lineInitialize", "lineTokenizers", " lineCharacterized", "lineSerializers", "lineInitializer", " lineCharacterize", "lineTokenized", " lineTokenized", "lineCharacterize"], "newline": ["neweline", "newstring", "freshtoken", "plainline", "fresheline", "newLine", "NewLINE", "freshlines", "Newline", "plaineline", " newlines", " neweline", "freshline", "oldline", "plaintoken", "freshLine", "oldLine", "freshstring", "oldLINE", " newtoken", "NewLine", "newlines", "oldstring", "newtoken", "Newstring", "freshLINE", "plainlines", "newLINE"], "line": ["page", "entry", "value", "split", "url", "link", "term", "user", "token", "len", "lf", "range", "lines", "iter", "message", "l", "letter", "end", "object", "LINE", "cell", "Line", "row", "part", "base", "data", "no", "inline", "style", "lo", "word", "name", "body", "log", "text", "comment", "content", "job", "lc", "key", "le", "string", "frame", "rule", "parse", "code", "header", "block", "pos", "item", "character", "lin", "lane", "str", "type"]}}
{"id1": "21462052", "id2": "3167466", "code1": "    public int deleteRecord(String uuid) throws SQLException, CatalogIndexException {\n        Connection con = null;\n        boolean autoCommit = true;\n        PreparedStatement st = null;\n        ResultSet rs = null;\n        int nRows = 0;\n        boolean cancelTask = false;\n        StringSet fids = new StringSet();\n        if (cswRemoteRepository.isActive()) {\n            StringSet uuids = new StringSet();\n            uuids.add(uuid);\n            fids = queryFileIdentifiers(uuids);\n        }\n        try {\n            con = returnConnection().getJdbcConnection();\n            autoCommit = con.getAutoCommit();\n            con.setAutoCommit(false);\n            String sSql = \"SELECT COUNT(*) FROM \" + getResourceTableName() + \" WHERE DOCUUID=? AND PROTOCOL_TYPE IS NOT NULL AND PROTOCOL_TYPE<>''\";\n            logExpression(sSql);\n            st = con.prepareStatement(sSql);\n            st.setString(1, uuid);\n            rs = st.executeQuery();\n            if (rs.next()) {\n                cancelTask = rs.getInt(1) > 0;\n            }\n            closeStatement(st);\n            sSql = \"DELETE FROM \" + getResourceTableName() + \" WHERE DOCUUID=?\";\n            logExpression(sSql);\n            st = con.prepareStatement(sSql);\n            st.setString(1, uuid);\n            nRows = st.executeUpdate();\n            closeStatement(st);\n            sSql = \"DELETE FROM \" + getResourceDataTableName() + \" WHERE DOCUUID=?\";\n            logExpression(sSql);\n            st = con.prepareStatement(sSql);\n            st.setString(1, uuid);\n            st.executeUpdate();\n            CollectionDao colDao = new CollectionDao(this.getRequestContext());\n            if (colDao.getUseCollections()) {\n                closeStatement(st);\n                sSql = \"DELETE FROM \" + colDao.getCollectionMemberTableName() + \" WHERE DOCUUID=?\";\n                logExpression(sSql);\n                st = con.prepareStatement(sSql);\n                st.setString(1, uuid);\n                st.executeUpdate();\n            }\n            con.commit();\n        } catch (SQLException ex) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw ex;\n        } finally {\n            closeResultSet(rs);\n            closeStatement(st);\n            if (con != null) {\n                con.setAutoCommit(autoCommit);\n            }\n        }\n        CatalogIndexAdapter indexAdapter = getCatalogIndexAdapter();\n        if (indexAdapter != null) {\n            indexAdapter.deleteDocument(uuid);\n            if (cswRemoteRepository.isActive()) {\n                if (fids.size() > 0) cswRemoteRepository.onRecordsDeleted(fids);\n            }\n        }\n        if (cancelTask && getRequestContext() != null) {\n            getRequestContext().getApplicationContext().getHarvestingEngine().cancel(getRequestContext(), uuid);\n        }\n        return nRows;\n    }\n", "code2": "    public void alterarCliente(ClienteBean cliente, String cpf) {\n        PreparedStatement pstmt = null;\n        String sql = \"UPDATE cliente SET nome = ?,\" + \"cpf = ?,\" + \"telefone = ?,\" + \"cursoCargo = ?,\" + \"bloqueado = ?,\" + \"ativo = ?,\" + \"tipo = ? WHERE cpf = ?\";\n        try {\n            pstmt = connection.prepareStatement(sql);\n            pstmt.setString(1, cliente.getNome());\n            pstmt.setString(2, cliente.getCPF());\n            pstmt.setString(3, cliente.getTelefone());\n            pstmt.setString(4, cliente.getCursoCargo());\n            pstmt.setString(5, cliente.getBloqueado());\n            pstmt.setString(6, cliente.getAtivo());\n            pstmt.setString(7, cliente.getTipo());\n            pstmt.setString(8, cpf);\n            pstmt.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException ex1) {\n                throw new RuntimeException(\"Erro ao atualizar cliente.\", ex1);\n            }\n            throw new RuntimeException(\"Erro ao atualizar cliente.\", ex);\n        } finally {\n            try {\n                if (pstmt != null) pstmt.close();\n            } catch (SQLException ex) {\n                throw new RuntimeException(\"Ocorreu um erro no banco de dados.\", ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"uuid": ["uuit", "suID", "uuiden", "ruID", "uniqueids", "uciID", "uident", "uuip", "suid", "cuip", "ruu", "ucidate", "uuension", "cuID", "uuident", "uciida", "suida", "uccu", "cuida", "uniqueuid", "tuids", "cuid", "uccid", "ucid", "ufuid", "ufid", "uniqueid", "ruiden", " ruID", "luidate", "uuidate", "uccuid", "luID", "suip", " ruids", "uuida", "uniqueit", "luids", " ruid", "tuid", "uciid", "uciip", "uuu", "ruuid", "uuID", "luident", " ruident", "luiden", "uit", "uuuid", "luid", "tuit", "ufu", "uccension", "ufension", "ruension", "ruidate", "tuuid", "ruid", "uciden", "ucID", "uids", "uid", "uID"], "con": ["pen", "an", "en", "connection", "uc", "core", "min", "co", "conn", "fc", " conn", "client", "bc", "Conn", "fr", "common", "ver", "gen", "ctrl", "ec", "pub", "re", "xc", "ctx", "can", "mc", "el", "cn", "x", "fun", "conf", "pc", "cons", "crit", "cur", "rc", " CON", "per", "CON", "cl", "log", "act", "container", "pr", "ch", "ren", "com", "cr", "connect", "cache", "c", "reg", "db", "ran", "un", "conv", "cc", "cond", "Connection", "ca", "nc", "fa", "ac", "Con"], "st": ["sa", "sb", "en", "ST", "pe", "la", "sth", "ld", "ost", "co", "ws", "sign", "RS", "src", "conn", "td", "l", "sw", "ist", "const", "fr", "part", "ste", "est", "std", "fe", "r", "set", "ctx", "sc", "sh", "ast", "stage", "pc", "sta", "rc", "inst", "da", "s", "nt", "act", "cl", "t", "sr", "pr", "mt", "St", "hr", "post", "se", "pt", "ft", "art", "cr", "sts", "ut", "sp", "c", "rt", "rd", "start", "nd", "ust", "th", "sn", "ct", "stack", "str", "put", "rest", "sl", "bl"], "rs": ["Rs", "ys", "RC", "hs", "ks", "rys", "ows", "ra", "rx", "ges", "runs", "ws", "rss", "RS", "conn", "sw", "ns", "ros", "ars", "fr", "row", "arch", "r", "sc", "ris", "rg", "repl", "qs", "pc", "vs", "xs", "res", "ins", "rc", "results", "cs", "sr", "pr", "dr", "ls", "hr", "sels", "rows", "cr", "rl", "rt", "rd", "mr", "vers", "rr", "ras", "ds", "ts", "ps", "s", "sl"], "nRows": ["nWows", "nRsues", "nRrows", "nLows", "nGrues", " nLows", "nGrrows", "nLodes", "nGrows", " nLues", "nRsOWS", " nROWS", " nLrows", "nWables", "nRsows", "nRodes", " nRables", "nRsrows", " nRodes", " nLodes", " nRues", "nRues", "nRsables", "nWrows", "nROWS", "nGrodes", "nRsodes", "nWOWS", " nRrows", "nLrows", "nLues", "nRables"], "fids": ["cids", "cfids", " fires", "Fida", "cIDs", "cfires", "cidents", " fIDs", "uidents", "Fires", "fid", "cid", "FIDs", "Fids", " fida", "uIDs", " fid", "fIDs", "cfida", " fidents", "fires", "cfIDs", "fida", "fidents", "uids", "uid"], "uuids": ["uuities", " uities", "euities", "euIDs", " uIDs", "uclIDs", "uips", "uida", "guips", "uuIDs", "guIDs", "euids", "uuida", "uclida", "guids", "uIDs", "uclids", " uids", "uities", "uuips", "uclid", "euid", " uid", "euips", "guid", "uids", "uid"], "autoCommit": ["autoCompmit", "AutoCommmit", "autoCompit", "autoQuits", "autoMit", " autoMits", "autoCommite", "autoQuit", "AutoComits", "AutoCommit", "autoMits", "autoComIT", "autoCompits", "autoCompitting", "autoQuite", "AutoComit", "autoComits", "autoQuitting", " autoMitting", "autoMite", "autoMIT", "autoComit", "autoCommIT", "autoCompite", " autoCommitting", "AutoCommits", " autoMit", "autoCompIT", "AutoComIT", "autoMmit", " autoCommits", "autoCommitting", " autoMite", "autoCommmit", "AutoCommIT", " autoCommite", "autoMitting", "autoCommits"], "sSql": ["sSlresource", "sEsl", "sServicesql", " sSq", " sSsl", "sideSSresource", "sEssql", "sUQL", "sSq", "oEsql", "sDqu", "pDql", "sgSq", "sFsSQL", "sPsell", "sgFilesql", "sEsql", "sPsQL", "sScheQL", "sEsell", " sDql", "sScheym", " sGql", " sDq", " sPsql", "sServicesQL", " sPsell", "sC\n", "pSsql", "sSS\n", "sGym", "sDQL", "ssl", " sSell", " sDQL", " sSizzle", "sSl", " sSym", "sGl", "sSizzle", " sEsQL", "sEsii", "sDquad", " sGsql", "sScheql", "sgSquad", "sAsQL", "ssql", " sPsq", "sGsl", "sSii", "sGQL", "sDforce", "sUii", "sSSQL", "sFilesql", " sPsizzle", "sSl\n", "sFsql", "sServicesizzle", "sDq", "sSresource", "sSquad", " sSlic", "sEnsql", "sSchesql", "sPsql", "pSql", "pSqu", "sEslic", "sS\n", " sGQL", "sDsql", " sAsql", "sDSQL", "sFilesquad", "sgSql", "sEnql", "pDforce", "sSqu", "ssue", "sUql", "sEsizzle", "sGsql", "sFilesSQL", "sideSS\n", "sDql", "ssQL", "sAsql", "sPsizzle", "sSforce", "sSingell", "oEsQL", " sEssl", "sSusql", "sFsq", "oEsii", " sEsql", " sDsql", " sEslic", "sSingql", "oEsue", "sGql", "pDsql", "sslic", "sSue", "sServicessql", "sEsue", " sSsql", "sDym", "sgFilesquad", "sEssl", "sSlic", " sPsQL", "pSforce", "sUue", "oSii", "sAsell", " sGell", "sSingsql", "sSQL", "sAssql", " sPssql", "oSQL", "sEnqu", "sideSresource", " sEssql", " sDym", "sSingQL", "sSuQL", "sAssl", " sSQL", "sCresource", "sFsquad", "oSql", " sSl", "sSsql", "ssii", "sFilesq", " sAsQL", "sSell", "sPssql", " sAssql", "sGell", "sSsl", "sGlic", "sideS\n", "sgSSQL", " sAsq", "sSuql", " sEsl", "sEnforce", "sgFilesq", "sSym", "sSSresource", "oSue", "pDqu", "sSuell", "sgFilesSQL", "sEsQL"], "cancelTask": ["ccelerTask", "crawlTask", "coralJob", " cascadeJob", "cascadeJob", "Canceltask", "ccelerAttempt", "cascadeTask", "cancelJob", "coralTask", " cascadeThread", "cancelAttempt", " cascadeAttempt", "coralLink", " cancelAttempt", "crawlLink", "ccelerJob", " cancelThread", "CancelJob", " cascadeTask", "cascadeAttempt", "crawltask", "canceltask", " cancelJob", "coraltask", "CancelTask", "cancelThread", "cascadeThread", "CancelLink", "cancelLink", "ccelerThread", "crawlJob"], "colDao": ["colDSfa", " colDpo", "colSfa", "colDoaos", "colDDao", "colDDoo", "colSai", " colSai", " colGao", "colSaos", " colDai", "colDoongo", "colDofa", "colDSongo", "ColDongo", "ColSfa", "ColSoo", "colDai", "ColDpo", " colSoo", "ColSongo", "colDoao", "ColDoo", " colRoo", " colGpo", "ColDfa", "colDfa", "ColSao", "colSpo", "colDoo", "ColDaos", "colDDaos", " colGai", "colSao", "colDaos", "colDpo", " colDoo", " colRai", "colDongo", " colSpo", "colDDpo", "colSoo", " colSao", " colRao", " colRpo", " colGoo", "ColDao", "ColSpo", "ColSaos", "colSongo", "colDSao", "colDSaos"]}}
{"id1": "10195648", "id2": "15416858", "code1": "    public static void main(String[] args) {\n        if (args.length != 3) {\n            System.out.println(\"Usage: HexStrToBin enc/dec <infileName> <outfilename>\");\n            System.exit(1);\n        }\n        try {\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            InputStream in = new FileInputStream(args[1]);\n            int len = 0;\n            byte buf[] = new byte[1024];\n            while ((len = in.read(buf)) > 0) os.write(buf, 0, len);\n            in.close();\n            os.close();\n            byte[] data = null;\n            if (args[0].equals(\"dec\")) data = decode(os.toString()); else {\n                String strData = encode(os.toByteArray());\n                data = strData.getBytes();\n            }\n            FileOutputStream fos = new FileOutputStream(args[2]);\n            fos.write(data);\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void download(File archive, File timestamp, URL url, IProgressMonitor monitor) throws IOException {\n        monitor.subTask(\"download \" + url.toString());\n        InputStream in = null;\n        FileOutputStream out = null;\n        URLConnection conn = null;\n        try {\n            conn = url.openConnection();\n            Writer writer = null;\n            try {\n                Date date = new Date(conn.getLastModified());\n                writer = new FileWriter(timestamp);\n                writer.write(this.FORMAT.format(date));\n            } catch (IOException e) {\n                timestamp.delete();\n            } finally {\n                IOUtils.closeQuietly(writer);\n            }\n            in = conn.getInputStream();\n            out = new FileOutputStream(archive);\n            IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 1, "substitutes": {"os": ["los", "ks", "des", "oid", "ss", "io", "fs", "out", "ros", "OS", "ms", "bos", "oes", "as", "oa", "bs", "outs", "ens", "es", "ot", "dos", "bytes", "sys", "js", "vs", "oss", "oS", "ins", "o", "aos", "ob", "rs", "cs", "mos", "ls", "Os", "fits", "nos", "ose", "ios", "ops", "socket", "ol", "ols", "pos", "us", "is", "cos", "ds", "boot", "obs", "bis", "osi", "iso", "ps", "op", "so"], "in": ["reader", "input", "inc", "din", "arin", "win", "io", "nin", "con", "out", "login", "as", "f", "In", "pin", "stream", "again", "ac", "inner", "init", "ins", "o", "vin", "ini", "ex", "kin", "sin", "cin", "c", "socket", "i", "IN", "err", "inn", "rin", "is", "ilo", "lin", "bin", "s", "fa", "ic", "pass"], "len": ["dl", "size", "split", "en", "num", "url", "ln", "lf", "ll", "iter", "min", "limit", "lim", "l", "pre", "val", "lon", "part", "loc", "base", "Len", "f", "n", "el", "body", "nt", "length", "fl", "lc", "li", "le", "count", "rev", "err", "pos", "lin", "fin", "bin", "str", "line", "sl"], "buf": [" buff", "dec", "cb", "queue", "bf", "la", "bh", "uc", "buffer", "buff", "br", "Buffer", "cas", " bu", " buffers", "b", "bc", "loc", "cv", "bd", "ref", "bytes", "ctx", "box", "raw", "off", "func", "batch", "bb", "seq", "wave", "uf", "bag", "v", "ba", "pool", "border", "ab", " buffer", "vec", "wb", "fb", "array", " b", "block", "ff", "str", "rb", "fab"], "data": ["div", "dec", "str", "id", "split", "value", "input", "plain", "memory", "la", "size", "reader", "buffer", "message", "output", "format", "description", "part", "base", "ata", "bytes", "style", "response", "raw", "info", "pad", "name", "body", "results", "batch", "DATA", "da", "json", "content", "xxx", "done", "slice", "string", "media", "image", "what", "cache", "error", "code", "i", "struct", "array", "aa", "block", "valid", "empty", "alpha", "dat", "p", "entry"], "strData": ["STRData", "StrEl", "StrVal", "rVal", "rdata", " strString", "STRVal", "StrData", "STRArray", "Strdata", "STREl", " strBu", "rArray", "strVal", "StrArray", " strEl", "strArray", "strString", "strEl", "STRString", "STRdata", "StrBu", "strBu", "StrString", "STRBu", "rData", "strdata"], "fos": [" fros", "sfos", " foses", "fose", "forose", "afose", " fo", "forios", "infoss", "sfoses", "foross", "infoses", "foss", "ffoses", "ffos", "fo", "fros", "Fos", "fol", "afos", "infos", "Fo", "fios", "ffo", " fios", " fol", "infros", "sfros", "afoss", "afios", "foses", "ffol", "Fol", "Foses", "foros", "sfoss", " foss", " fose"]}}
{"id1": "18157910", "id2": "1766801", "code1": "    private static ArrayList<String> YahooSearch(String query) {\n        ArrayList<String> yahooSearchResults = new ArrayList<String>();\n        try {\n            String request = \"http://boss.yahooapis.com/ysearch/web/v1/\" + URLEncoder.encode(\"Java example for \" + query, \"UTF-8\") + \"?appid=zfau5aPV34ETbq9mWU0ui5e04y0rIewg1zwvzHb1tGoBFK2nSCU1SKS2D4zphh2rd3Wf\" + \"&format=xml&count=30&type=-msoffice,-pdf\";\n            URL url = new URL(request);\n            System.out.println(\"Host : \" + url.getHost());\n            url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            String finalContents = \"\";\n            while ((inputLine = reader.readLine()) != null) {\n                finalContents += \"\\n\" + inputLine;\n            }\n            Document doc = Jsoup.parse(finalContents);\n            Elements eles = doc.getElementsByTag(\"url\");\n            for (Element ele : eles) {\n                yahooSearchResults.add(ele.text());\n                System.out.println(\"YahooResult: \" + ele.text());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return yahooSearchResults;\n    }\n", "code2": "    public void update() {\n        Authenticator.setDefault(new MyAuthenticator());\n        URL url = null;\n        try {\n            url = new URL(\"http://trade.gigabass.de/update/update.php\");\n        } catch (MalformedURLException e) {\n            handleException(e);\n            return;\n        }\n        URLConnection conn;\n        try {\n            conn = url.openConnection();\n        } catch (IOException e) {\n            handleException(e);\n            return;\n        }\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = null;\n        try {\n            wr = new OutputStreamWriter(conn.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            wr.write(\"sql=\" + URLEncoder.encode(sql, \"UTF-8\") + \"\\n\");\n            wr.flush();\n        } catch (IOException e) {\n            handleException(e);\n        }\n        BufferedReader rd = null;\n        try {\n            rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = rd.readLine()) != null) {\n            }\n        } catch (IOException e) {\n            handleException(e);\n        }\n        try {\n            wr.close();\n        } catch (IOException e) {\n            handleException(e);\n        }\n        try {\n            rd.close();\n        } catch (IOException e) {\n            handleException(e);\n        }\n    }\n", "label": 0, "substitutes": {"query": ["source", "page", "id", "term", "xml", "result", "params", "resource", "feature", "qq", "qs", "word", "tag", "name", "results", "qu", "report", "json", "text", "content", "words", "index", "string", "answer", "uri", "html", "expression", "Query", "search", "q", "gallery", "question", "filter", "quer", "type"], "yahooSearchResults": ["yahooResultResults", "ahooSearchRESULTS", "yahooQueryresults", "ahooSearchRes", "yahooFindResults", "yahooSearchResult", "yahooSearchRESULTS", "yahooFindResult", "yahooQueryResult", "googleSearchResult", "yahoosearchresults", "googlesearchReturns", "yahooSquareResult", "yahooResultResult", "ahoosearchItems", "yahooResultresults", "yahooListItems", "yahoosearchRes", "yahoosearchResults", "yahooListResult", "yahooListResults", "ahooSearchItems", "yahooSearchRes", "yahooQueryResults", "yahoosearchItems", "yahooAnswerResult", "yahooSearchresults", "ahoosearchResults", "yahooAnswerReturns", "yahooSquareItems", "ahooSearchResult", "yahooSquareResults", "yahoosearchReturns", "ahooQueryResults", "yahoosearchResult", "yahooResultReturns", "googlesearchresults", "googlesearchResult", "ahooQueryResult", "yahooAnswerResults", "ahooQueryresults", "ahoosearchResult", "ahooSearchresults", "yahooAnswerresults", "ahoosearchRESULTS", "yahooSearchReturns", "yahoosearchRESULTS", "yahooQueryRes", "ahooSearchResults", "ahooQueryRes", "yahooFindRes", "yahooListRESULTS", "googlesearchResults", "googleSearchResults", "yahooSearchItems", "googleSearchReturns", "yahooFindresults", "yahooSquareRESULTS", "googleSearchresults"], "request": ["input", "queue", "req", "open", "xml", "reference", "complete", "result", "message", "http", "params", "object", "data", "response", "resource", "server", "call", "address", "Request", "name", "method", "transfer", "report", "post", "string", "path", "frame", "uri", "parse", "search", "q", "create", "question", "register", "QUEST"], "url": ["source", "host", "page", "user", "link", "browser", "connection", "feed", "buffer", "pull", "open", "build", "download", "result", "conn", "l", "view", "http", "article", "out", "b", "client", "home", "album", "bug", "f", "loader", "base", "layer", "ver", "ref", "stream", "r", "resource", "org", "server", "email", "address", "info", "tool", "force", "bb", "ob", "api", "bel", "location", "mail", "key", "book", "string", "image", "impl", "socket", "file", "uri", "ssl", "html", "search", "URL", "item", "hub", "Url", "www", "blog", "proxy", "web", "coll", "sl", "entry"], "reader": ["read", "upper", "input", "rar", "Reader", "feed", "buffer", "result", "iter", "keeper", "io", "out", "in", "ler", "driver", "row", "f", "loader", "data", "oder", "worker", "stream", "r", "resource", "handler", "server", "writer", "inner", "er", "rer", "reading", "per", "bird", "parser", "ri", "file", "i", "or", "rr", "ner", "entry"], "inputLine": [" inputLINE", "InputLine", " inputBlock", "inputRow", "readableL", " inputRow", "inputline", "readableLine", " inputL", "rawLine", "InputRow", "InputL", "requestBlock", " inputline", "requestLine", "Inputline", "rawBlock", "readableline", "rawL", "inputL", "requestline", "readableLINE", "InputBlock", "inputLINE", "inputBlock", "InputLINE", "requestRow"], "finalContents": [" finalResults", "finishedContent", " finalReader", "completeString", "finalLine", "FinalParts", "FinalContents", "FinalContent", " finalLine", " finalContent", " finalParts", "finishedReader", "completeReader", "completeContents", "FinalResults", "completeContent", "completeResults", "finalContent", "completeParts", "finalReader", "FinalLine", "finalResults", "finalString", "finishedContents", " finalString", "finalParts", "finishedString", "completeLine"], "doc": ["div", "dec", "dc", "id", "d", "Document", "xml", "result", "http", "out", "app", "home", "f", "git", "data", "oc", "di", "pub", "org", "tx", "mc", "desc", "body", "de", "exp", "Doc", "parser", "oup", "df", "docs", "document", "node", "sp", "html", "parse", "db", "c", "cam", "md", "dom", "DOC"], "eles": ["elends", " leends", "ELes", "Elists", "Eles", "Elis", " elends", "Elises", "eltis", " leES", "elists", "ELe", "eltes", "ELis", " elES", "ELends", "elis", "elES", " lee", " lees", "eltises", "ELES", "ELists", "eltists", "ELises", "elises"], "ele": ["sel", "entry", "Ele", " ELE", "ea", "lem", "tle", "ette", "eor", "elle", "ellen", "ee", "mel", " ce", "sole", "ler", "ole", "tile", "ere", "nel", "eur", "elt", "el", " element", "element", "oodle", "ite", "ge", "ne", "e", "de", "enne", "ef", "yle", "oe", "LE", "sl", "kel", "eed", "ple", "ect", "le", "ell", "sle", "eb", "eller", "efe", "eu", "een", "elope", "bat", "line", "ie"]}}
{"id1": "8446069", "id2": "22728537", "code1": "    public static String test(String server, String baseDir, String user, String password) throws Exception {\n        FTPClient ftpClient = new FTPClient();\n        try {\n            String file = baseDir;\n            ftpClient.connect(server);\n            ftpClient.login(user, password);\n            int reply = ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftpClient.disconnect();\n                System.err.println(\"FTP server refused connection.\");\n                return null;\n            }\n            ftpClient.setFileType(FTP.IMAGE_FILE_TYPE);\n            ftpClient.enterLocalPassiveMode();\n            boolean isDir = isDir(ftpClient, file);\n            if (isDir) {\n                FTPFile[] files = ftpClient.listFiles(file);\n                for (int i = 0; i < files.length; i++) {\n                }\n            } else {\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                if (ftpClient.retrieveFile(file, bos)) {\n                } else {\n                    throw new IOException(\"Unable to retrieve file:\" + file);\n                }\n            }\n            return \"\";\n        } finally {\n            closeConnection(ftpClient);\n        }\n    }\n", "code2": "                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(\"data/icons/view_sidetreeOK.png\"));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n", "label": 0, "substitutes": {"server": ["host", "folder", "page", "site", "url", "Server", "connection", "open", "username", "ser", "peer", "message", "conn", "lib", "control", "client", "request", "base", "ver", "directory", "system", "response", "email", "serv", "address", "send", "transfer", "api", "erver", "localhost", "socket", "uri", "ssl", "error", "command", "fail", "problem", "service", "manager", "database", "domain", "proxy", "test", "port"], "baseDir": [" baseUrl", "BaseUrl", " basePath", "homeDir", "basePath", "BaseDirectory", "workingDir", "basedir", "BasePath", "baseDirectory", " basedir", "baseFile", " baseFile", "Basedir", "homeDirectory", "BaseDir", "homeFile", "workingDirectory", "baseUrl", " baseDirectory", "homedir", "workingPath", "BaseFile", "workingUrl"], "user": ["host", "site", "id", "line", "auth", "username", "from", "wd", "client", "home", "owner", "object", "login", "base", "email", "address", "info", "name", "users", "uid", "null", "query", "USER", "log", "session", "key", "User", "up", "string", "path", "db", "person", "secret", "field", "account", "author", "usr", "use", "pass"], "password": ["host", "token", "auth", "sword", "priv", "username", "wd", "client", "PASS", "mode", "login", "data", "phrase", "prefix", "email", "address", "ass", "word", "name", "filename", "words", "key", "string", "path", "attribute", "secret", "sudo", "Password", "staff", "account", "wallet", "port", "pass"], "ftpClient": ["ftPclient", "ftpCloud", "ftpBase", "ftbConnection", "ctpGuest", "ftcpControl", "fttpBase", "afttclient", "ftcpConnection", "ftspContext", "ftpControl", "ctpConnect", "affHost", "afttControl", "ftpoServer", " ftpclient", "fcpClient", " ftpServer", "ftcpConnect", "ctcpContext", "ftpSystem", "ftPConnection", "ftcpClient", "ftcpclient", "ftfpCase", "ftcContext", "ftPHost", "ctpCase", "ftpcCloud", "ftpHelper", "ctcpSync", "ftapCase", "ftcpCloud", "fttCase", "fpControl", "ftapGuest", "ftfpStore", "ftbaseConnection", "ftcServer", "ctbGuest", "ftcpBase", "fpclient", "fttClient", "ftcpCase", "ftpclient", "ftcpServer", "afttCase", "ctcpServer", "ftbaseclient", "ftcControl", "fttpContext", "ctbConnection", "ftdpController", "ftbaseHelper", "ftbaseConnect", "ftapclient", "ftpConnect", "fttControl", "ftdpClient", "ftPServer", "ftcClient", "ftapServer", "affClient", "ftspContainer", "ctbCloud", "ftcpSystem", "ftPStore", " ftpContext", "ftfclient", "ftbaseServer", "ftpcServer", "afpclient", " ftcpBase", "ftcpController", "ftfpControl", "ftpController", "ctpSync", "ftcpContainer", "ftpoHost", "ftfpClient", "ftspSystem", "ftpSync", "ctpHelper", "ftfpGuest", "aftpclient", "fpClient", " ftfpServer", "ftfpclient", "fttpContainer", "ftlpConnection", "ctcpClient", "ftlpClient", "ftcSystem", "ctpCloud", "ctbClient", "ftbServer", "ftcclient", "ctpServer", "ftpContainer", "ftcpContext", "fttpClient", " ftcpClient", "ctpclient", "ftpHost", "ftspclient", "afpClient", "ctcpConnect", "ftpStore", "ftbaseClient", "ftpoClient", "ftapStore", "ctbclient", "ftpCase", "ctbServer", "ftpConnection", "ctpController", "ftPHelper", "affServer", "ftapClient", "ctpConnection", "ftcCase", "ftspControl", "ftbClient", "ftbclient", "ctcpclient", "ctpClient", "ftpGuest", "ctcpCase", " ftfpClient", " ftcpContainer", "ftpServer", "ctcpHelper", "ftlpController", "aftpControl", "ftpcConnection", "ftbGuest", "afpHost", " ftpStore", "afpServer", "ftpcClient", "fttContext", " ftpContainer", "ftfHost", "fcpclient", "ftbaseSync", "ftapControl", "ftpoclient", "ftfServer", "ftcSync", "ftfpServer", "ctcpController", "ctpContext", "aftpClient", " ftfpclient", "ftpContext", "fpSystem", " ftpBase", " ftfpStore", " ftcpContext", "affclient", "afttClient", "ftfClient", "ftbCloud", "ftcConnect", "ftdpConnection", "ftPClient", "aftpCase", "fcpControl", "ftcpHelper", "ftcpSync", "fcpSystem", "fttclient", "ftspBase", "ctcpConnection", "ftspClient"], "file": ["source", "play", "folder", "entry", "route", "id", "url", "queue", "ile", "link", "connection", "feed", "function", "File", "message", "lib", "l", "http", "fp", "part", "model", "base", "f", "data", "directory", "zip", "resource", "handler", "work", "address", "name", "filename", "dir", "log", "up", "string", "path", "image", "pool", "rule", "db", "uri", "FILE", "line", "location", "type"], "reply": ["respond", "py", "queue", "link", "write", " replies", "feed", "len", "fee", "result", "message", "http", "article", "ply", "ise", "base", "response", "prefix", "call", "address", "ret", "info", "repl", "send", "Reply", "sync", "query", "report", "comment", "post", "status", "ping", "dy", "count", "answer", "error", "code", "resp", "proxy", "bot", "reason"], "isDir": [" isFolder", "isFolder", "setDirectory", "getFolder", "setDir", "asList", "issDir", "IsDirectory", " isFile", " isDirectory", "asFile", "isDirectory", "isFile", "IsDir", "asFolder", "IsFile", "IsFolder", "setdir", " isdir", "getDirectory", "issList", "isdir", "getDir", "issFile", "asDirectory", " isList", "isList", "asDir", "issDirectory", "getdir", "setFolder"], "files": ["ums", "Files", "balls", "opens", "cells", "links", "events", "pes", "lines", "keys", "mails", "fs", "items", "pins", "books", "bugs", "sheets", "facts", "scenes", "bytes", "bs", "objects", "flows", "models", "qs", "groups", "boxes", "users", "ins", "results", "phones", "images", "pages", "ls", "rows", "thumbnails", "ips", "iles", "apps", "ids", "parts", "dates", "ps", "uploads"], "i": ["id", "si", "d", "multi", "iu", "hi", "io", "k", "phi", "y", "b", "f", "di", "bi", "mu", "I", "ti", "ni", "ai", "info", "oi", "gi", "x", "name", "ui", "ci", "o", "u", "li", "v", "key", "xi", "index", "ri", "slice", "j", "uri", "ii", "pi", "field", "fi", "chi", "mi", "ip", "p", "type"], "bos": ["opens", "los", "bh", "abi", "io", "rss", "fs", "pins", "bps", "ros", "bc", "was", "osa", "os", "bs", "outs", "obb", "bo", "zip", "lo", "oss", "zo", "aos", "ob", "ko", "abs", "buf", "fits", "ba", "ios", "ops", " os", "bis", "obs", "bn", "bin", "so"]}}
{"id1": "7199548", "id2": "14113380", "code1": "    protected GVTFontFamily getFontFamily(BridgeContext ctx, ParsedURL purl) {\n        String purlStr = purl.toString();\n        Element e = getBaseElement(ctx);\n        SVGDocument svgDoc = (SVGDocument) e.getOwnerDocument();\n        String docURL = svgDoc.getURL();\n        ParsedURL pDocURL = null;\n        if (docURL != null) pDocURL = new ParsedURL(docURL);\n        String baseURI = XMLBaseSupport.getCascadedXMLBase(e);\n        purl = new ParsedURL(baseURI, purlStr);\n        UserAgent userAgent = ctx.getUserAgent();\n        try {\n            userAgent.checkLoadExternalResource(purl, pDocURL);\n        } catch (SecurityException ex) {\n            userAgent.displayError(ex);\n            return null;\n        }\n        if (purl.getRef() != null) {\n            Element ref = ctx.getReferencedElement(e, purlStr);\n            if (!ref.getNamespaceURI().equals(SVG_NAMESPACE_URI) || !ref.getLocalName().equals(SVG_FONT_TAG)) {\n                return null;\n            }\n            SVGDocument doc = (SVGDocument) e.getOwnerDocument();\n            SVGDocument rdoc = (SVGDocument) ref.getOwnerDocument();\n            Element fontElt = ref;\n            if (doc != rdoc) {\n                fontElt = (Element) doc.importNode(ref, true);\n                String base = XMLBaseSupport.getCascadedXMLBase(ref);\n                Element g = doc.createElementNS(SVG_NAMESPACE_URI, SVG_G_TAG);\n                g.appendChild(fontElt);\n                g.setAttributeNS(XMLBaseSupport.XML_NAMESPACE_URI, \"xml:base\", base);\n                CSSUtilities.computeStyleAndURIs(ref, fontElt, purlStr);\n            }\n            Element fontFaceElt = null;\n            for (Node n = fontElt.getFirstChild(); n != null; n = n.getNextSibling()) {\n                if ((n.getNodeType() == Node.ELEMENT_NODE) && n.getNamespaceURI().equals(SVG_NAMESPACE_URI) && n.getLocalName().equals(SVG_FONT_FACE_TAG)) {\n                    fontFaceElt = (Element) n;\n                    break;\n                }\n            }\n            SVGFontFaceElementBridge fontFaceBridge;\n            fontFaceBridge = (SVGFontFaceElementBridge) ctx.getBridge(SVG_NAMESPACE_URI, SVG_FONT_FACE_TAG);\n            GVTFontFace gff = fontFaceBridge.createFontFace(ctx, fontFaceElt);\n            return new SVGFontFamily(gff, fontElt, ctx);\n        }\n        try {\n            Font font = Font.createFont(Font.TRUETYPE_FONT, purl.openStream());\n            return new AWTFontFamily(this, font);\n        } catch (Exception ex) {\n        }\n        return null;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void execute() throws MojoExecutionException {\n        List<Dependency> dependencies = project.getDependencies();\n        File file = new File(this.localRepository.getBasedir());\n        File dojoArtifact = null;\n        for (Dependency dependency : dependencies) {\n            if (!dependency.getGroupId().equals(\"org.dojotoolkit\") && !dependency.getArtifactId().equals(\"dojo\")) continue;\n            File file2 = new File(file, dependency.getGroupId().replace('.', File.separatorChar));\n            file2 = new File(file2, dependency.getArtifactId());\n            file2 = new File(file2, dependency.getVersion());\n            file2 = new File(file2, dependency.getArtifactId() + '-' + dependency.getVersion() + '.' + dependency.getType());\n            if (!file2.exists()) throw new MojoExecutionException(\"No artifact found in base repository \" + file2);\n            dojoArtifact = file2;\n        }\n        if (dojoArtifact == null) throw new MojoExecutionException(\"No dojo dependencies found\");\n        Plugin plugin = (Plugin) project.getBuild().getPluginsAsMap().get(\"org.apache.maven.plugins:maven-war-plugin\");\n        if (plugin == null) return;\n        String webappDirectory = null;\n        Xpp3Dom dom = (Xpp3Dom) plugin.getConfiguration();\n        if (dom != null) webappDirectory = dom.getChild(\"webappDirectory\").getValue();\n        if (webappDirectory == null) webappDirectory = project.getBuild().getDirectory() + File.separatorChar + project.getArtifactId() + '-' + project.getVersion();\n        try {\n            File webAppDojoDir = new File(webappDirectory, this.dojoDir);\n            if (!webAppDojoDir.exists()) webAppDojoDir.mkdirs();\n            ZipInputStream inputStream = new ZipInputStream(new FileInputStream(dojoArtifact));\n            ZipEntry zipentry = inputStream.getNextEntry();\n            byte[] buf = new byte[1024];\n            while (zipentry != null) {\n                File entry = new File(webAppDojoDir, zipentry.getName());\n                if (zipentry.isDirectory()) {\n                    entry.mkdirs();\n                } else {\n                    int n;\n                    FileOutputStream fileoutputstream;\n                    if (entry.getParent() != null) {\n                        entry.getParentFile().mkdirs();\n                    }\n                    fileoutputstream = new FileOutputStream(entry);\n                    while ((n = inputStream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                    fileoutputstream.close();\n                    inputStream.closeEntry();\n                }\n                zipentry = inputStream.getNextEntry();\n            }\n            inputStream.close();\n        } catch (Exception e) {\n            throw new MojoExecutionException(\"Error to extract the dojo artifact \", e);\n        }\n    }\n", "label": 0, "substitutes": {"ctx": ["cb", "hw", "connection", "cm", "cu", "cf", "cmp", "conn", "cas", "client", "cmd", "bc", "ca", "cpp", "cv", "ctrl", "loc", "kb", "fw", "cp", "sc", "config", "tx", "mc", "cn", "conf", "component", "ci", "rc", "wcs", "tc", "cs", "cli", "lc", "cca", "media", "cr", "cfg", "c", "context", "support", "Context", "cam", "conv", "cc", "cal", "cms", "ck", "ct", "concept", "coll", "pkg"], "purl": ["lpurl", " pUrl", "gref", "cpurl", "Pentry", "pimage", "npUrl", "apUrl", "furi", "npuri", "cpURL", " pimage", "npref", "preURL", "npurl", "lpURL", "apuri", "gUrl", "gurl", " pURL", " puri", "guri", " pref", " pentry", "lpUrl", "Pimage", "preurl", "cpuri", "Puri", "Purl", "lpref", "puri", "lpuri", "Pref", "PURL", "cpimage", "preUrl", "apurl", "lpentry", "fURL", "apURL", "furl", "pentry", "PUrl", "pUrl", "preuri", "fUrl", "pref", "pURL"], "purlStr": ["purlString", "polStr", "puriString", "pfileString", "pnlstr", "puriMsg", "pUrlMsg", "pslSTR", "pUrlString", "pslStr", "PslSpec", "PurlSt", "polSTR", "pUrlSpec", "Pslstr", "Purlstr", "PURLstr", "purlSTR", "purlstr", "pURLStr", "PurlString", "pURLString", "PurlStr", "pfileSTR", "PURLStr", "PurlBr", "PUrlUrl", "PUrlStr", "PurlMsg", "PurlSTR", "pUrlSt", "pslstr", "polSpec", "pnlUrl", "puriUrl", "pfileSt", "pfileStr", "PUrlSt", "pURLSTR", "pURLstr", "PurlSpec", "pUrlstr", "purlUrl", "purlSt", "pUrlSTR", "pslSpec", "PUrlString", "pUrlStr", "pUrlUrl", "pnlStr", "puriStr", "PURLString", "purlBr", "pnlString", "PslStr", "PurlUrl", "pURLSt", "PURLBr", "PUrlSTR", "pUrlBr", "pnlMsg", "PUrlMsg", "purlSpec", "pURLBr", "PslSTR", "purlMsg", "polstr", "pnlBr"], "e": ["ea", "ei", "en", "pe", "d", "edge", "ee", "l", "ev", "object", "this", "diff", "ep", "f", "E", "fe", "ec", "eg", "data", "elt", "esi", "el", "element", "er", "body", "it", "event", "u", "o", "de", "exp", "ae", "ne", "ef", "t", "eval", "oe", "enter", "m", "eb", "node", "entity", "c", "html", "i", "or", "ce", "eu", "me", "ed", "p", "ie"], "svgDoc": ["svgeDocument", "svGConfig", "svgnDoc", " svGFile", "svvgDoc", "svgndoc", "svgeDoc", "svcDoc", "svcFile", " svgFile", " svgConfig", "svgnConfig", "svvgDocument", "svgedoc", "svGDoc", " svGDocument", "svGdoc", " svGdoc", "svgConfig", "svgeFile", "svvgdoc", "svvgConfig", "svgnDocument", " svgdoc", "svgFile", " svgDocument", "svcDocument", " svGDoc", " svGConfig", "svcdoc", "svgdoc", "svGDocument", "svgDocument", "svGFile"], "docURL": ["documentCL", "baseURL", "documentSSL", "documentURI", "baseSSL", "resourceSSL", "resourceCL", "resourceURI", "htmlURL", " docCL", "documentUrl", "docUrl", "docURI", "documentURL", "htmlUrl", "resourceUrl", "docSSL", "htmlUR", "resourceUR", "documentUR", "docCL", "baseUrl", " docURI", "htmlURI", "resourceURL", " docUrl", "docUR"], "pDocURL": [" pDirUrl", " pDocUrl", "PDocStr", "PFileUrl", "PFileURL", "PDocUrl", "pContentUrl", "PFileStr", "pUrlURI", " pDirRL", "PDocURI", "pdocLocation", "pBaseUrl", " pDocCL", "pFileURL", "pDocStr", " pDocURI", "pDirUrl", "pDocRL", "pBaseStr", "pUrlCL", "pContentURL", "pdocUrl", "pdocURL", "pContentURI", " pDocRL", "PFileURI", " pUrlCL", "pDirURI", "pDocUrl", "pDocLocation", "pUrlRL", "pdocCL", "pDirURL", " pDocLocation", "pFileLocation", "pFileCL", "pBaseURI", " pDirURI", "pUrlStr", "pUrlUrl", " pUrlURL", "pBaseURL", " pDirURL", "pDocURI", " pUrlLocation", "pFileUrl", "pDirRL", " pUrlUrl", "pContentRL", "pFileStr", "pUrlURL", "pFileURI", "pUrlLocation", "pDocCL", "PDocURL"], "baseURI": ["sourceUrl", " baseUrl", " baseURL", "BaseUrl", "baseURL", "basURL", " baseuri", "baseuri", "basURI", "BaseURL", "basUrl", "Baseuri", "sourceURI", "baseUrl", "BaseURI", "sourceURL", "basuri"], "userAgent": ["useInfo", "UserAg", "useagent", "Useragent", "memberAg", "memberAgent", "memberagent", "userAg", " useragent", "userInfo", "UserAgent", "UserInfo", "useAg", "useragent", "useAgent", " userInfo"], "ref": ["af", " reference", "default", "rel", "l", "val", "r", "resource", "tx", "info", "alias", "name", "aff", "rc", "bb", "image", "obj", "id", "bf", "reference", "lf", "pre", "b", "diff", "part", "Reference", "remote", "ob", "cache", "html", "c", "local", "Ref", "get", "parent", "url", "link", "pb", "http", "inf", "f", "loc", "href", "def", "el", "element", "full", "ef", "comment", "node", "ab", "error", "i", "q", "p", "h", "req", "br", "root", "fr", "fe", "re", "config", "conf", "ne", "large", "bel", "REF", "m", "db"], "doc": ["div", "parent", "head", "gov", "dc", "h", "msg", "d", "util", "xml", "co", "dev", "ma", "og", "mm", "http", "cdn", "home", "bc", "gen", "f", "loc", "po", "git", "oc", "di", "pub", "style", "org", "ac", "mc", "pc", "desc", "dir", "exp", "ax", "Doc", "api", "m", "post", "docs", "media", "document", "norm", "sp", "html", "c", "db", "vm", "local", "valid", "cam", "md", "project", "op", "qa", "coll", "DOC"], "rdoc": ["RDuc", "rbuc", "rdec", "RDOC", "rhuc", "ldOC", "RDow", "rdOC", "rbOC", "rhec", "ldow", "RDoc", "RDec", "rhOC", "ridocol", "rhoc", "rduc", "ldocol", "ridoc", "ldoc", "RDocol", "rdow", "rboc", "rbec", "ridow", "ridOC", "rdocol"], "fontElt": ["fontEld", "fonterl", " fontEilt", " fontFlf", "letterUlem", " fontElelt", "fontGelt", "fontElelt", "fontUler", "fontElementgt", "backgrounderl", "fontEllt", "fontEler", "fontCheld", "letterEler", " fontFld", "fontLlt", "fontEnt", "backgroundELT", "fontFgt", "fontEelt", "fontElem", "backgroundeilt", "backgroundelt", " fontElf", "letterElt", "fontElnt", " fontOilt", "fontOld", "fontEgt", "fontEilt", "fontIlt", "fontELT", "fontIilt", " fontFgt", "backgroundErl", "fontEls", " fontEld", "fontelt", "fontCheelt", " fontEllem", "letterUlt", "fontOler", "fontElementld", "letterElem", "backgroundEilt", "fontOnt", "fontElementlf", "fontLelt", "fontOlem", "fontFlf", "fontIrl", " fontElem", "fontOls", " fontEgt", " fontEnt", " fontEelt", "fontCheilt", "fontOilt", "fontFlt", "fontGerl", "fontOlt", " fontOelt", " fontOld", "fontElelem", "backgroundeLT", "fontGeLT", "fontElementlt", "fontGeler", "letterEls", "fontEllem", "fontErl", "fontLilt", "backgroundElt", "fontLld", "letterUls", "fontGelem", "fonteilt", "fontUlem", "fontFld", " fontEllt", "fontChelt", "letterUler", "fontEleelt", "fontUlt", "fontOelt", "fontILT", " fontOlt", "fontUls", "fontGeilt", "fontGels", " fontFlt", "fontElf", "fontElent", " fontElnt", "fonteLT"], "base": ["bas", "id", "site", "url", "bf", "buffer", "space", "scale", "format", "http", "based", "root", "model", "bi", "face", "style", "resource", "prefix", "set", "kit", "server", "info", "name", "ge", "ui", "unit", "api", "bar", "area", "key", "frame", "path", "cache", "file", "uri", "db", "is", "Base", "bn", "binding", "ase", "type"], "g": ["h", "vg", "msg", "d", "G", "sg", "gd", "l", "og", "w", "pg", "gs", "b", "gen", "f", "r", "gi", "gc", "ge", "u", "gm", "o", "gp", "gn", "t", "m", " mg", "v", "gb", "gu", "j", "c", "reg", "i", "gg", "q", "img", "ig", "ng", "s", "p"], "fontFaceElt": ["fontFaceGEld", "fontFontEls", "fontFontGElt", "fontFaceGElt", "fontFontGElem", "fontFaceEld", "fontFaceUlt", "fontFaceUld", "fontFaceEls", "fontFontElem", "fontFaceUlem", "fontFaceGels", "fontFaceElem", "fontFaceGelem", "fontFontGEld", "fontFontElt", "fontFaceGEls", "fontFaceGElem", "fontFaceGelt", "fontFaceGeld", "fontFontEld", "fontFontGEls", "fontFaceUls"], "n": ["next", "Node", "an", "nl", "none", "ln", "d", "nn", "network", "not", "nw", "nr", "k", "conn", "l", "y", "b", "ns", "f", "rn", "r", "ni", "child", "dn", "adj", "cn", "x", "name", "ne", "na", "u", "o", "s", "nt", "gn", "fn", "t", "syn", "m", "nu", "v", "N", "node", "j", "c", "i", "nc", "nat", "pn", " c", "nb", "nd", "sn", " ng", "p"]}}
{"id1": "21164147", "id2": "11959071", "code1": "    public String requestPOST(String baseUrl, Map<String, String> params) throws Exception {\n        String result = \"\";\n        HttpPost request = new HttpPost(baseUrl);\n        HttpEntity entity = null;\n        if (params != null && !params.isEmpty()) {\n            List<NameValuePair> postParams = new ArrayList<NameValuePair>();\n            List<String> keys = new ArrayList<String>(params.keySet());\n            for (String key : keys) {\n                postParams.add(new BasicNameValuePair(key, params.get(key)));\n            }\n            entity = new UrlEncodedFormEntity(postParams, \"utf-8\");\n            request.setEntity(entity);\n        }\n        HttpResponse res = client.execute(request);\n        if (res.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n            entity = res.getEntity();\n            BufferedReader in = new BufferedReader(new InputStreamReader(entity.getContent()));\n            StringBuffer content = new StringBuffer();\n            String read = \"\";\n            while ((read = in.readLine()) != null) {\n                content.append(read);\n            }\n            in.close();\n            JSONObject rObj = new JSONObject(content.toString());\n            result = rObj.getString(\"msg\");\n        } else result = \"\u8bf7\u6c42\u5931\u8d25\u4e86\";\n        entity.consumeContent();\n        client.getConnectionManager().shutdown();\n        request = null;\n        return result;\n    }\n", "code2": "        private String download(MacroManagerProgress progress, String fileName, String url) throws Exception {\n            URLConnection conn = new URL(url).openConnection();\n            progress.setMaximum(Math.max(0, conn.getContentLength()));\n            String path = MiscUtilities.constructPath(installDirectory, fileName);\n            if (!copy(progress, conn.getInputStream(), new FileOutputStream(path), true, true)) return null;\n            if (archive_zip) {\n                Enumeration entries;\n                ZipFile zipFile;\n                try {\n                    File tempFile = new File(path);\n                    zipFile = new ZipFile(tempFile);\n                    entries = zipFile.entries();\n                    while (entries.hasMoreElements()) {\n                        ZipEntry entry = (ZipEntry) entries.nextElement();\n                        if (entry.isDirectory()) {\n                            String dpath = MiscUtilities.constructPath(installDirectory, entry.getName());\n                            (new File(dpath)).mkdir();\n                            continue;\n                        }\n                        progress.setMaximum((int) entry.getSize());\n                        String ePath = MiscUtilities.constructPath(installDirectory, entry.getName());\n                        copy(progress, zipFile.getInputStream(entry), new BufferedOutputStream(new FileOutputStream(ePath)), true, true);\n                    }\n                    zipFile.close();\n                    tempFile.delete();\n                } catch (IOException ioe) {\n                    ioe.printStackTrace();\n                }\n            } else if (archive_gzip) {\n                File srce = new File(path);\n                GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(srce));\n                File temp = File.createTempFile(\"macro\", \"mgr\");\n                progress.setMaximum((int) srce.length());\n                copy(progress, gzis, new BufferedOutputStream(new FileOutputStream(temp)), true, true);\n                TarArchive tarc = new TarArchive(new FileInputStream(temp));\n                tarc.extractContents(new File(installDirectory));\n                tarc.closeArchive();\n                (new File(path)).delete();\n            }\n            return path;\n        }\n", "label": 0, "substitutes": {"baseUrl": ["apiPath", " baseURL", "BaseUrl", " basePath", "baseURL", " baseurl", "basePath", "baseUr", "BasePath", "BaseUr", "Baseurl", "starturl", "startUrl", "startPath", " baseUr", "BaseURL", "baseurl", "apiUr", "apiURL", "apiUrl", "startURL"], "params": ["options", "resources", "attr", "relations", "url", "settings", "properties", "pins", "license", "http", "ms", "as", "data", "photos", "phrase", "blocks", "ctx", "server", "par", "config", "posts", "models", "body", "query", "plugins", "results", "param", "json", "members", "names", "post", "rules", "all", "media", "list", "parse", "Parameters", "apps", "details", "array", "manager", "files", "ras", "parts", "database", "services", "ams", "ps", "s", "collection", "p", "terms"], "request": ["get", "operation", "url", "input", "user", "queue", "req", "pe", "task", "connection", "submit", "xml", "pull", "buffer", "build", "complete", "message", "view", "join", "http", "client", "object", "model", "base", "application", "hello", "worker", "re", "response", "resource", "r", "server", "call", "condition", "Request", "child", "method", "claim", "query", "transfer", "project", "event", "report", "instance", "post", "issue", "session", "media", "document", "record", "command", "q", "create", "order", "question", "form", "rate", "collection", "rest", "QUEST"], "entity": ["translation", "url", "pe", "connection", "ent", "xml", "ee", "message", "output", "conn", "security", "article", "object", "client", "this", "model", "environment", "base", "application", "remote", "response", "enc", "resource", "server", "address", "el", "element", "name", "component", "body", "event", "ge", "query", "e", "Entity", "action", "json", "container", "api", "instance", "oe", "comment", "issue", "session", "status", "string", "document", "image", "node", "cache", "file", "error", "obj", "person", "service", "item", "em", "project", "coll", "entry"], "postParams": ["postVariars", " postPans", "postParamam", " postParans", "postVariam", " postParam", " postPas", "postParars", " postPach", " postParas", "postPerparams", "postVarias", "postParas", "postParparams", "postPas", " postPars", "postPerams", "postPerach", "postPam", "postparam", "postRas", "postParans", "postPparams", " postParach", "postPeram", "postRam", "postParam", "postPach", " postParars", "postPams", "postparach", "postParamams", "postParamas", "postPars", "postVariams", "postPans", "postRars", "postParach", "postparparams", "postparams", "postParamans", "postPerans", " postPams", "postPeras", " postPparams", " postPam", " postParparams", "postRams"], "keys": ["states", "relations", "ks", "strings", "chains", "links", "Keys", "pes", "items", "properties", "ns", "types", "codes", "qs", "ics", "vs", "ports", "groups", "xs", "ins", "values", "locks", "names", "fields", "words", "rows", "cats", "vals", "ips", "apps", "vers", "files", "kes", "ids", "parts", "obs", "ps"], "key": ["host", "hop", "str", "id", "link", "pe", "range", "k", "letter", "object", "val", "part", "row", "base", "f", "data", "Key", "r", "pair", "ie", "prefix", "KEY", "section", "x", "name", "query", "exp", "param", "a", "ex", "col", "index", "string", "rule", "change", "list", "up", "lock", "ask", "code", "label", "item", "block", "field", "value", "ip", "entry"], "res": ["rem", "resources", "respond", "gr", "Res", "des", "req", "rup", "Result", "rep", "reply", "rss", "RES", "http", "ries", "ver", "onse", "resolution", "re", "r", "response", "resource", "remote", "ret", "ris", "rus", "sys", "results", "rc", "json", "rs", "ress", "sr", "hr", "rh", "status", "rec", "Response", "rows", "obj", "rev", "err", "resp", "Resp", "ras", "rest", "pres"], "in": ["reader", "input", "inc", "din", "win", "buffer", "min", "io", "nin", "con", "out", "login", "as", "In", "pin", "stream", "n", "r", "again", "resource", "re", "serv", "isin", "inner", "init", "it", "ins", "gin", "ini", "ex", "kin", "rec", "c", "socket", "i", "IN", "err", "inn", "rin", "is", "lin", "bin", "on", "ic"], "content": ["size", "value", "url", "memory", "line", "write", "feed", "buffer", "xml", "Content", "message", "output", "format", "out", "object", "data", "response", "clean", "resource", "enc", "raw", "address", "ontent", "activity", "section", "body", "cont", "json", "length", "container", "text", "wave", "escape", "temp", "status", "variable", "string", "media", "load", "c", "readable", "code", "array", "character", "current", "copy", "null"], "read": [" text", "get", "source", " write", "reader", "play", "input", "write", "feed", "Read", "build", "bind", "READ", "ride", "end", "data", "enc", "work", "resource", "raw", " Read", "exec", "sync", " load", "it", "length", "text", "dr", "se", "run", " raw", " feed", "cr", "orig", "pass", "load", "c", "parse", " sleep", "i", "check", "readable", "and", "wait", "lex", " continue", "valid", "accept", "add", "str", "line", "ip", "reads"], "rObj": ["srObj", "Robj", "rObject", "rBody", "arrayOb", "srObject", " robj", "srobj", " rOb", "RObj", "srBody", "RBody", "rOb", "rExt", "ROb", " rExt", "arrayObj", "RObject", " rObject", "robj", " rBody", "RExt", "arrayObject", "arrayExt"], "result": ["page", "successful", "str", "value", "compl", "continue", "msg", "warning", "default", "notice", "success", "dict", "Result", "ception", "reply", "function", "message", "output", "flash", "ult", "val", "description", "data", "future", "response", "r", "resource", "ret", "results", "rc", "report", "json", "comment", "found", "status", "string", "html", "answer", "error", "replace", "err", "date", "current", "valid", "reason", "test"]}}
{"id1": "2972950", "id2": "3108499", "code1": "    private void proxyMediaServlet(String url, HttpServletRequest req, HttpServletResponse resp) {\n        try {\n            URL u = new URL(\"http://mediaserver:8080/sagex\" + url);\n            log.debug(\"Proxy Media: \" + u.toString());\n            URLConnection c = u.openConnection();\n            c.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.1) Gecko/2008072820 Firefox/3.0.1\");\n            OutputStream os = resp.getOutputStream();\n            IOUtils.copy(c.getInputStream(), os);\n            os.flush();\n            resp.flushBuffer();\n        } catch (Throwable t) {\n            log.error(\"Failed to get url: \" + url, t);\n            try {\n                resp.sendError(500, t.getMessage());\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"url": ["source", "host", "page", "route", "id", "connection", "rel", "ll", "src", "l", "http", "request", "fr", "loc", "base", "f", "href", "ref", "remote", "zip", "resource", "org", "server", "address", "el", "name", "ur", "gl", "location", "ls", "string", "media", "path", "image", "rl", "rule", "html", "uri", "ssl", "file", "URL", "service", "Url", "proxy", "web", "sl"], "req": ["cb", "proc", "rx", "ro", "cgi", "conn", "src", "w", "request", "b", "fr", "ref", "re", "r", "ctx", "Request", "conf", "query", "requ", "Requ", "rec", "quest", "obj", "err", "rr", "q", "res", "rb"], "resp": ["page", "respond", "rel", "rep", "reply", "result", "conn", "http", "out", "request", "client", "ref", "re", "response", "r", "ctx", "zip", "server", "ret", "serv", "esi", "body", "e", "report", "cl", "api", "df", "esp", "rec", "Response", "v", "respons", "pool", "sp", "obj", "rev", "cache", "html", "err", "wb", "Resp", "prev", "pp", "rr", "inv", "res", "cmp", "p"], "u": ["su", "ru", "uc", "util", "cu", "iu", "l", "ul", "uu", "http", "this", "fp", "b", "ue", "ou", "client", "f", "n", "mu", "tu", "U", "yu", "hu", "ur", "ui", "o", "t", "m", "nu", "up", "chu", "lu", "ut", "uri", "uv", "i", "us", "eu", "bu", "p"], "c": ["h", "dc", "d", "uc", "cm", "cu", "cy", "cf", "co", "conn", "l", "ct", "fc", "con", "w", "client", "b", "bc", "f", "p", "ec", "cp", "enc", "xc", "mc", "pc", "exec", "cn", "ci", "e", "o", "cl", "t", "cs", "ch", "cli", "lc", "v", "cr", "i", "cc", "z", "cmp", "ac", "C"], "os": ["los", "ys", "ks", "des", "ies", "ss", "io", "conn", "fs", "http", "out", "OS", "bos", "as", "oc", "oa", "bs", "outs", "ens", "es", "dos", "ors", "vs", "oss", "oos", "o", "e", "aos", "s", "cs", "rs", "ls", "Os", "nos", "ios", "ops", "i", "us", "ds", "cos", "is", "osi", "ps", "res"]}}
{"id1": "12764800", "id2": "11513043", "code1": "    public static void extractZipFile(String filename) {\n        try {\n            byte[] buf = new byte[1024];\n            ZipInputStream zipinputstream = null;\n            ZipEntry zipentry;\n            zipinputstream = new ZipInputStream(new FileInputStream(filename));\n            zipentry = zipinputstream.getNextEntry();\n            while (zipentry != null) {\n                String entryName = zipentry.getName();\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(entryName);\n                String directory = newFile.getParent();\n                if (directory == null) {\n                    if (newFile.isDirectory()) break;\n                }\n                fileoutputstream = new FileOutputStream(entryName);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n                zipentry = zipinputstream.getNextEntry();\n            }\n            zipinputstream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String hash(String password) {\n        MessageDigest sha1Digest;\n        try {\n            sha1Digest = MessageDigest.getInstance(\"SHA-1\");\n        } catch (NoSuchAlgorithmException e) {\n            throw NestedException.wrap(e);\n        }\n        sha1Digest.update(password.getBytes());\n        StringBuilder retval = new StringBuilder(\"sha1:\");\n        retval.append(new String(Base64.encodeBase64(sha1Digest.digest())));\n        return retval.toString();\n    }\n", "label": 0, "substitutes": {"filename": ["source", "utf", "folder", "journal", "url", "queue", "binary", "txt", "SourceFile", "connection", "jet", "dll", "username", "File", "l", "fp", "sf", "fd", "f", "loader", "data", "zip", "Filename", "archive", "prefix", "kl", "name", "json", "fn", "length", "string", "path", "document", "lock", "file", "uri", "that", "files", "database", "FILE", "which", "sheet", "nil", "s", "location", "fil"], "buf": ["cb", "bf", "la", "bh", "binary", "uc", "buffer", "buff", "br", "Buffer", "lim", "src", "que", "fp", "b", "aux", "alloc", "fd", "bc", "cmd", "loc", "cv", "data", "bd", "blocks", "bytes", "ctx", "Buff", "func", "batch", "rc", "seq", "uf", "bag", "gb", "uv", "vec", "wb", "fb", "bus", "conv", "img", "lb", "rb", "bp"], "zipinputstream": ["archiveInputport", "zipfeedstream", "fileinputStream", "zipinputsample", "fileinputsystem", "archiveinputStream", "zipInputsession", "zipinputStream", "zipInputsample", "archiveinputsample", "zinputsc", "archiveinputstream", "zipbitthread", "fileinputsession", "zipinputport", "zinputStream", "fileoutputsample", "archiveInputstream", "fileoutputchannel", "zInputstream", "zipbitstream", "fileinputsample", "archiveInputStream", "zinputstream", "zipuploadstream", "zipoutputsample", "zipfeedchannel", "zInputsc", "zipinputchannel", "fileinputchannel", "fileInputstream", "zipoutputchannel", "archiveinputport", "zipcontextstream", "zipInputsystem", "zipcontextsystem", "archiveInputsample", "zipoutputsc", "zipinputsystem", "zipimportsc", "zipuploadsession", "fileInputsystem", "fileinputstream", "zipoutputport", "zipinputthread", "fileInputStream", "zipexecsample", "zipinputsc", "zipbitStream", "zipInputsc", "zInputthread", "zipexecStream", "zipimportport", "zipimportsample", "zipuploadStream", "fileoutputStream", "zipoutputsession", "zipoutputstream", "zipInputthread", "zipfeedsample", "zipInputstream", "zipoutputStream", "fileoutputsession", "zipinputsession", "zipInputport", "zipimportchannel", "zipfeedStream", "zipimportStream", "zipcontextStream", "zinputthread", "zInputStream", "zipimportstream", "zipInputStream", "zipoutputsystem", "zipexecstream", "zipoutputthread"], "zipentry": ["zipletter", "lockelement", "zipEntry", "feedreader", "zelement", "zobj", "zipsource", "feedEntry", "gzception", " zipelement", "lexEntry", "zipreader", "feedelement", "lexentry", "gzreader", "fileletter", " zipsource", "fileobj", "ceenter", " zipenter", "zipindex", "zentry", " zipception", "lexreader", "zipobj", "zipception", "zletter", "cereader", "zoneelement", " zipletter", "zoneenter", "lockreader", " zipEntry", "gzindex", "gzenter", "zEntry", "zonesource", " zipreader", "locksource", "gzentry", "zreader", "zipelement", "lockception", "lexelement", "ceentry", "fileEntry", "zoneentry", " zipindex", "feedentry", "fileentry", "zipenter", " zipobj", "lockenter", "ceindex", "lockentry"], "entryName": ["folderName", "entryType", "folderNAME", "entryNAME", "patchName", " entryNumber", "archiveName", "elementPart", "archivePart", "elementname", "archivename", "baseNumber", "patchType", "baseName", "folderType", "entrySize", "entryPart", " entryNAME", " entryType", "elementAlias", "folderTitle", "entryAlias", " entryTitle", " entryPart", "elementName", "enterSize", "baseSize", "patchNAME", "entryNumber", " entrySize", "enterNumber", "entryTitle", "enterName", " entryname", " entryAlias", "patchTitle", "archiveAlias", "entryname"], "n": ["size", "none", "en", "num", "d", "nn", "len", "nr", "k", "l", "y", "w", "out", "b", "ns", "f", "number", "no", "r", "dn", "nor", "cn", "x", "name", "ne", "u", "e", "o", "nt", "t", "m", "nu", "v", "index", "N", "node", "j", "c", "i", "g", "pos", "un", "nc", "nb", "ng", "sn", "z", "s", "p"], "fileoutputstream": ["fileoperationstream", "fileoutStream", " fileoutputStream", "zipoutputstack", " fileoutputsw", "fileOutputstream", "fileoutstream", "fileproductioncontrol", "fileinputStream", "fileproductionstream", "zipoutputstream", " fileoperationStream", "fileinputcontrol", "filetargetstream", "fileoutstage", "fileoperationsw", "zipoutputStream", "zipoutputview", "fileoutputsw", "fileoperationstage", " fileoperationstage", "fileoutputview", "fileinputpath", "zipOutputstack", "fileproductionStream", "fileinputstack", "Fileoutputpath", "FileinputStream", "zipinputStream", "fileoperationStream", "fileOutputstage", "fileoutputstack", " fileoutputstage", "fileOutputstack", "fileOutputsw", "zipOutputstream", "fileoutputpath", "fileoutview", "zipinputview", "fileOutputpath", "fileOutputcontrol", "FileoutputStream", " fileoperationsw", "fileinputview", "Fileoutputcontrol", " fileoperationstream", "Fileinputstream", "Fileoutputstream", "fileoutputcontrol", "fileinputstream", "fileoutputstage", "fileoutsw", "filetargetStream", "fileproductionpath", "Fileinputpath", "filetargetstack", "Fileinputcontrol", "fileOutputStream", "fileOutputview", "fileoutputStream", "zipOutputStream"], "newFile": ["missingFolder", " newDir", "missingfile", "NewDir", "newfile", "oldFolder", "oldDirectory", " newDirectory", "missingFiles", "missingFile", "oldDir", "NewFile", "newFiles", "NEWDir", "newDir", "NEWFolder", "NewFolder", "NEWfile", "newFolder", "NewDirectory", " newFiles", "oldFile", " newfile", "Newfile", "NewFiles", "NEWFile", "newDirectory", " newFolder"], "directory": ["language", "folder", "parent", "url", "d", "connection", "director", "division", "Directory", "python", "class", "archive", "creator", "module", "section", "machine", "volume", "component", "dir", "direction", "container", "category", "whatever", "variable", "path", "document", "manager", "service", "database", "which", "position", "project", "copy", "collection", "entry", "location", "either"]}}
{"id1": "8561726", "id2": "17526811", "code1": "    public boolean actualizarDivisionActual(division div) {\n        int intResult = 0;\n        String sql = \"UPDATE divisionxTorneo \" + \" SET tipoTorneo_idTipoTorneo = \" + div.getidTipoTorneo() + \" , nombreDivision = '\" + div.getnombreDivision() + \"', \" + \" descripcion = '\" + div.getDescripcion() + \"', tipoDesempate = \" + div.getDesempate() + \", \" + \" numFechas = \" + div.getnumFechas() + \" , ptosxbye = \" + div.getPtosxBye() + \" WHERE idDivisionxTorneo = \" + div.getidDivision();\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    private String getDocumentAsString(URL url) throws IOException {\n        StringBuffer result = new StringBuffer();\n        InputStream in = url.openStream();\n        int c;\n        while ((c = in.read()) != -1) result.append((char) c);\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"div": ["draw", "dec", "plus", "cand", "dc", "folder", "DIV", "d", "nov", "dict", "rup", "director", "division", "player", "down", "ord", "dev", "Div", "td", "definition", "this", "diff", "part", "rou", "def", "data", "prov", "box", "config", "der", "element", "du", "section", "sup", "component", "desc", "dir", "dan", "de", "dm", "flow", "dim", "area", "done", "obj", "code", "comb", "valid", "block", "eng", "img", "group", "form", "dom", "sea", "project", "defined", "dem", "coll", "p"], "intResult": ["interResult", "floatResult", "floatReturn", "ntresult", "IntResponse", "ntScore", "floatRes", "IntResult", "intresult", "valRes", "uintReturn", "intRes", " intResults", "ntResult", "uintRes", "intScore", "valResult", " intresult", "ntBreak", "ntResponse", " intResponse", "IntReturn", " intRes", "uintResponse", "interResults", "valresult", " intScore", "ntResults", "ntRes", "uintResult", "intBreak", "interBreak", " intBreak", "valResponse", "intResponse", "IntRes", "intResults", "floatResponse", "intReturn", "interScore"], "sql": ["select", "dl", "cop", "sb", "general", "url", "xml", "function", "conn", "http", "params", "fp", "cmd", "sf", "loc", "table", "zip", "ql", "section", "shell", "eps", "plan", "query", "body", "printf", "json", "QL", "log", "fn", "comment", "pr", "SQL", "job", "string", "seed", "install", "socket", "ssl", "db", "sol", "details", "sq", "q", " SQL", "str", "sl"], "connection": ["function", "engine", "statement", "conn", "communication", "con", "client", "pg", "union", "bc", "driver", "connected", "environment", "loc", "application", "channel", "table", "po", "cp", "ctx", "handler", "server", "condition", "config", "section", "machine", "query", "event", "ci", "collection", "log", "ion", "relation", "jc", "session", "close", "index", "graph", "pool", "connect", "document", "socket", "c", "db", "context", "lock", "manager", "database", "position", "cond", "Connection", "proxy", "port", "p", "unit"], "ps": ["hs", "cop", "ks", "pe", "ss", "jp", "pd", "gs", "pg", "ns", "ms", "ups", "cp", "os", "bs", "par", "posts", "qs", "pc", "eps", "ppa", "pa", "ins", "mp", "pps", "cs", "PS", "pr", "syn", "ls", "Ps", "pse", "sp", "ips", "details", "person", "pp", "pos", "ds", "pers", "ts", "proxy", "p"]}}
{"id1": "15385608", "id2": "115129", "code1": "    public boolean setFavBoard(List<BoardObject> list) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        HttpPost post = new HttpPost(HttpConfig.bbsURL() + HttpConfig.BBS_FAV_SETTING);\n        List<NameValuePair> nvps = new ArrayList<NameValuePair>();\n        for (BoardObject board : list) nvps.add(new BasicNameValuePair(board.getId(), \"on\"));\n        try {\n            post.setEntity(new UrlEncodedFormEntity(nvps, BBSBodyParseHelper.BBS_CHARSET));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isHttp200(response) && HTTPUtil.isXmlContentType(response)) {\n                HTTPUtil.consume(response.getEntity());\n                return true;\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    public static void bubbleSort(String[] a) {\n        Collator myCollator = Collator.getInstance();\n        boolean switched = true;\n        for (int pass = 0; pass < a.length - 1 && switched; pass++) {\n            switched = false;\n            for (int i = 0; i < a.length - pass - 1; i++) {\n                if (myCollator.compare(a[i], a[i + 1]) > 0) {\n                    switched = true;\n                    String temp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"list": ["dl", "lp", "parent", "land", "queue", "LIST", "range", "chain", "result", "view", "l", "pre", "que", "object", "part", "base", "table", "set", "config", "can", "sequence", "stack", "name", "batch", "cl", "lists", "listed", "all", "pool", "load", "live", "array", "gallery", "many", "test", "collection", "entry", "coll"], "client": ["host", "head", "url", "pe", "connection", "io", "pb", "conn", "http", "request", "app", "object", "end", "to", "resource", "handler", "server", "config", "force", "method", "per", "patch", "bird", "api", "Client", "cli", "session", "media", "pool", "connect", "cache", "c", "ssl", "i", "cloud", "service", "ip", "self", "et", "project", "copy", "p"], "post": ["next", "get", "head", "POST", "proc", "upload", "feed", "pod", "submit", "the", "open", "ost", "build", "one", "http", "pre", "request", "object", "f", "to", "put", "set", "zip", "server", "push", "posts", "wp", "send", "body", "project", "patch", "od", "Post", "pass", "load", "install", "posted", "valid", "create", "form", "add", "copy", "rest", "p"], "nvps": ["NVp", "nvPS", "vPS", "nvips", "nvp", "NVPS", "nvpps", "vps", "NVips", "nvsp", "nwps", "nncs", "NVps", "svp", "svpps", "NVpps", "svps", "nlPS", "nlps", "vp", "nwpps", "nlcs", "nwPS", "nnsp", "nnps", "svips", "svsp", "nvcs", "nlsp", "nnPS", "svcs", "vips", "svPS", "nwp"], "board": [" row", "land", " lobby", " corporation", "upload", "feed", "division", " dashboard", "game", " builder", " video", " obstacle", "card", "deck", "view", "object", "model", "row", " chunk", " poll", " card", "server", " image", "boards", " bar", "Board", "flow", " deck", " block", " box", " game", " opponent", "hole", " logo", " clip", "pool", "node", " cross", " controller", " player", " billboard", "boarding", "database", "builder", "video", "bot", "league", " tile"], "response": ["page", "successful", "respond", "site", "connection", "success", "feed", "reply", "ception", "result", "message", "output", "view", "http", "request", "object", "model", "channel", "application", "onse", "data", "f", "stream", "resource", "handler", "server", "body", "full", "o", "report", "json", "api", "former", "wave", "session", "status", "Response", "index", "document", "image", "error", "resp", "code", "received", "res", "collection"], "entity": ["page", "translation", "pe", "ent", "connection", "xml", "feed", "ception", "result", "ee", "output", "message", "article", "ity", "object", "model", "environment", "onse", "data", "tree", "resource", "server", "el", "activity", "component", "body", "e", "Entity", "content", "node", "image", "document", "uri", "error", "resp", "person", "service", "ce", "collection", "entry"], "msg": ["str", "id", "mid", "sg", "message", "doc", "ma", "gs", "cmd", "ms", "op", "gen", "loc", "exc", "agg", "data", "comm", "desc", "body", "ge", "e", "gm", "log", "text", "comment", "ko", "m", "content", "dr", "status", "string", "Msg", "html", "reg", "error", "err", "map", "g", "mess", "md", "reason", "s", "ug", "pkg", "type"]}}
{"id1": "19999376", "id2": "1551466", "code1": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "code2": "    public static void test2() throws Exception {\n        int keySize = 1024;\n        int dBlockSize = keySize / 8;\n        int eBlockSize = dBlockSize - 8 - 3;\n        CertAndKeyGen certAndKeyGen = new CertAndKeyGen(\"RSA\", \"MD5WithRSA\");\n        certAndKeyGen.generate(keySize);\n        PublicKey publicKey = certAndKeyGen.getPublicKey();\n        PrivateKey privateKey = certAndKeyGen.getPrivateKey();\n        Cipher cipher1 = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher1.init(Cipher.ENCRYPT_MODE, publicKey);\n        String fileA = \"C:/temp/a.txt\";\n        String fileB = \"C:/temp/b.txt\";\n        String fileC = \"C:/temp/c.txt\";\n        FileInputStream fis = new FileInputStream(fileA);\n        FileOutputStream fos = new FileOutputStream(fileB, false);\n        CipherOutputStream eos = new CipherOutputStream(fos, cipher1, eBlockSize);\n        byte[] b = new byte[128];\n        int i = fis.read(b);\n        while (i != -1) {\n            eos.write(b, 0, i);\n            i = fis.read(b);\n        }\n        eos.flush();\n        eos.close();\n        fos.close();\n        Cipher cipher2 = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher2.init(Cipher.DECRYPT_MODE, privateKey);\n        fis = new FileInputStream(fileB);\n        CipherInputStream cis = new CipherInputStream(fis, cipher2, dBlockSize);\n        FileOutputStream decodedFile = new FileOutputStream(fileC, false);\n        int read = -1;\n        while ((read = cis.read()) > -1) {\n            decodedFile.write(read);\n        }\n        decodedFile.close();\n        fis.close();\n    }\n", "label": 1, "substitutes": {"zipfile": ["zipFile", "zFile", "Zipdir", "zfile", "clipfile", "zentry", "zipfiles", "clipfiles", "zipdir", "gzdir", "Zipfiles", " zipfiles", "zipentry", "Zipfile", "clipFile", "Zipstream", "clipstream", "gzFile", "Zipentry", "gzentry", " zipstream", " zipFile", "zdir", "ZipFile", "gzfile", "zipstream"], "entry": ["next", "source", "folder", "route", "reader", "draft", "id", "export", "input", "link", "queue", "si", "line", "connection", "feed", "xml", "plugin", "ry", "audio", "lock", "in", "object", "cell", "ries", "base", "data", "directory", "zip", "system", "her", "archive", "server", "address", "info", "inner", "element", "module", "name", "dir", "it", "e", "country", "nt", "container", "log", "cel", "parser", "api", "enter", "comment", "se", "session", "path", "image", "cache", "install", "file", "record", "uri", "error", "or", "parse", "Entry", "service", "sea", "add", "ie"], "outputDir": ["inputFolder", " outputDIR", "outFile", " outputdir", "writeDIR", "inputdir", "inputDIR", "writeFolder", "outDir", "outDirectory", "exitDIR", "outputFolder", "exitDir", "outDIR", "outputDirectory", "outputDIR", "writeDir", "writeDirectory", "outFolder", "targetFolder", "exitdir", " outputDirectory", "targetFile", "inputDirectory", "targetDirectory", "outputdir", "targetDir", "inputDir", "exitDirectory", "inputFile"], "outputFile": [" outputfile", "inputfile", "inputFolder", "outFile", "inputPath", " outputPath", "outLine", "inputLine", "OutputPath", "outDir", "outDirectory", "outputLine", "outputFolder", "inputJar", "outputDirectory", " outputFolder", "responseFile", "OutputDir", "outputJar", " outputLine", " outputDirectory", "OutputFile", "responsefile", "inputDirectory", "outStream", "responseFolder", "responseDir", " outputJar", "inputDir", "outputPath", "OutputJar", "inputFile", "outputfile"], "inputStream": [" inputReader", "outputSteam", " inputChannel", "inputSteam", "InputStream", " inputView", " inputSteam", " inputFile", "inputReader", "InputView", "inputView", "outputReader", "outputChannel", "inputChannel", "InputFile", "InputChannel", "outputView", "InputSteam", "InputReader", "inputFile"], "outputStream": ["outputSteam", "inputSteam", "OutputSteam", "execStream", " outputChannel", "OutputStream", "execFile", "inputStreamer", "outputChannel", "inputChannel", " outputSteam", "OutputFile", "OutputStreamer", "execStreamer", "OutputChannel", "inputFile", "outputStreamer", "execSteam"]}}
{"id1": "3838437", "id2": "18609247", "code1": "    public static boolean copyFile(final File inFile, final File outFile) {\n        try {\n            FileChannel ic = new FileInputStream(inFile).getChannel();\n            FileChannel oc = new FileOutputStream(outFile).getChannel();\n            ic.transferTo(0, ic.size(), oc);\n            ic.close();\n            oc.close();\n            return true;\n        } catch (IOException e) {\n            SystemUtils.LOG.log(Level.INFO, \"SystemUtils.copyFile() Exception while copy file \" + inFile.getAbsolutePath() + \" to \" + outFile.getAbsolutePath(), e);\n            return false;\n        }\n    }\n", "code2": "        private void compileJarFile() {\n            String javaFileName = jarFileName + \".java\";\n            try {\n                File pluginWorkDirectory = new File(CastadivaModel.PLUGIN_WORKFOLDER);\n                pluginWorkDirectory.mkdirs();\n                File pluginsDir = new File(pluginWorkDirectory.getPath() + \"/castadiva/Plugins\");\n                pluginsDir.mkdirs();\n                BufferedWriter bout = new BufferedWriter(new FileWriter(pluginWorkDirectory.getPath() + \"/castadiva/Plugins/\" + javaFileName));\n                bout.write(\"package castadiva.Plugins;\\n\");\n                bout.write(\"import java.io.*;\\n\");\n                bout.write(\"import java.util.zip.ZipEntry;\\n\");\n                bout.write(\"import java.util.jar.JarFile;\\n\");\n                bout.write(\"import lib.IPluginCastadiva;\\n\");\n                bout.write(\"public class \" + jarFileName + \" implements IPluginCastadiva {\\n\");\n                bout.write(\"    public String getBin() {\\n\");\n                bout.write(\"        return \\\"\" + binaryFilePath + \"\\\"; \\n    }\\n\");\n                bout.write(\"    public String getFlags() {\\n\");\n                bout.write(\"        return \\\"\" + protocolFlags + \"\\\"; \\n    }\\n\");\n                bout.write(\"    public String getPathConf() {\\n\");\n                bout.write(\"        return \\\"\" + configurationFilePath + \"\\\"; \\n    }\\n\");\n                bout.write(\"    public String getConfContent(){\\n\");\n                bout.write(\"        BufferedReader confFileReader;\\n\");\n                bout.write(\"        try {\\n\");\n                bout.write(\"            JarFile jar = new JarFile(\\\"\" + CastadivaModel.PLUGIN_JAR_FOLDER + \"/\" + jarFileName + \".jar\\\");\\n\");\n                bout.write(\"            ZipEntry entry = jar.getEntry(\\\"\" + configurationFilename[configurationFilename.length - 1] + \"\\\");\\n\");\n                bout.write(\"            confFileReader = new BufferedReader(new InputStreamReader(jar.getInputStream(entry)));\\n\");\n                bout.write(\"            String confFile = \\\"\\\";\\n\");\n                bout.write(\"            String confFileLine;\\n\");\n                bout.write(\"            while((confFileLine = confFileReader.readLine()) != null){\\n\");\n                bout.write(\"                 confFile+=\\\"\\\\n\\\"+confFileLine;\\n\");\n                bout.write(\"            }\\n\");\n                bout.write(\"            return(confFile);\\n\");\n                bout.write(\"        } catch (Exception ex) {\\n\");\n                bout.write(\"            System.out.println(ex);\\n\");\n                bout.write(\"        }\\n\");\n                bout.write(\"        return(null);\\n\");\n                bout.write(\"    }\\n\");\n                bout.write(\"    public String getConf(){\\n\");\n                bout.write(\"        return(\\\"\" + configurationFilename[configurationFilename.length - 1] + \"\\\");\\n\");\n                bout.write(\"    }\\n\");\n                bout.write(\"    public String getKillInstruction() {\\n\");\n                bout.write(\"        return  \\\"killall \" + binFileName[binFileName.length - 1] + \" 2>/dev/null\\\"\" + \";\\n    }\\n}\");\n                bout.close();\n                BufferedWriter confFileWriter = new BufferedWriter(new FileWriter(CastadivaModel.PLUGIN_WORKFOLDER + \"/\" + configurationFilename[configurationFilename.length - 1]));\n                confFileWriter.write(protocolConfiguration);\n                confFileWriter.close();\n            } catch (IOException ex) {\n                Logger.getLogger(ProtocolsGUI.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n", "label": 1, "substitutes": {"inFile": ["inputPath", "inDirectory", "inputfile", " inStream", "inputFiles", " inSourceFile", "baseDirectory", " inPath", "outfile", "baseFile", " inDirectory", "inputSourceFile", "basefile", "incSourceFile", "inSourceFile", "inStream", "infile", "InFile", "incfile", "outStream", "InDirectory", "outFiles", "InStream", "inPath", "incFile", "inFiles", " inFiles", "incPath", "baseStream", " infile", "inputFile", "inputStream", "Infile"], "outFile": ["upFile", " outPlace", "tempFilename", "execfile", " outDirectory", "tempFile", "tempPath", " outString", "OutFile", " outfile", "execStream", "outDirectory", "outputFile", "execFile", "upfile", "outFilename", "outputDirectory", "outputString", "upFilename", " outPath", "outfile", "tempfile", "upPath", "outPlace", "targetfile", "OutPlace", "Outfile", "outPath", " outFilename", "targetFile", "outStream", "targetDirectory", "OutStream", "execPlace", "targetString", "outString", " outStream", "outputfile"], "ic": ["mic", "ik", "anc", "inc", "ican", "uc", "cu", "unic", "voc", "icc", "vc", "ico", "io", "fc", "IC", "bc", "loc", "aic", "ec", "nic", "enc", "xc", "irc", "ai", "lic", "mc", "aci", "pc", "ics", "exec", "x", "ix", "ci", "rc", "pic", "cli", "icer", "lc", "iac", "c", "i", "cci", "cc", "cit", "ici", "ct", "ip", "ac"], "oc": ["mic", "dc", "anc", "uc", "cf", "voc", "co", "vc", "ico", "io", "aco", "fc", "acs", "OC", "bc", "alloc", "toc", "loc", "wic", "ec", "nic", "enc", "org", "sc", "xc", "irc", "oca", "ai", "ocr", "mc", "pc", "exec", "iv", "ci", "o", "rc", "ace", "arc", "cs", "pic", "roc", "abc", "isc", "c", "oci", "cc", "soc", "ct", "nc", "ac"]}}
{"id1": "12844597", "id2": "7131421", "code1": "        private String findTitle(URL url) {\n            HTMLEditorKit.ParserCallback callback;\n            try {\n                URLConnection conn = url.openConnection();\n                Reader rd = new InputStreamReader(conn.getInputStream());\n                ParserDelegator parser = new ParserDelegator();\n                callback = new Callback();\n                parser.parse(rd, callback, true);\n            } catch (Exception exp) {\n                System.err.println(exp);\n            }\n            return title;\n        }\n", "code2": "    private void getEventHeapsFromWeb() {\n        try {\n            URL url = getServersURL();\n            InputStream in = url.openStream();\n            Document doc = factory.newDocumentBuilder().parse(in);\n            readFromDocument(doc);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "feed", "open", "connection", "download", "l", "http", "object", "client", "bug", "f", "loader", "base", "remote", "r", "resource", "server", "config", "address", "name", "string", "path", "image", "rl", "html", "uri", "file", "ssl", "or", "URL", "service", "Url", "www", "blog", "proxy", "str", "sl"], "callback": ["consumer", "reader", "cb", "processor", "proc", "wrapper", "connection", "buffer", "director", "plugin", "function", "client", "bc", "cell", "loop", "loader", "worker", "data", "class", "handler", "call", "config", "pc", "func", "ack", "rc", "CB", "bb", "bird", "backs", "back", "book", "rule", "node", "library", "load", "c", "cache", "Callback", "process", "cc", "ck", "proxy", "cmp", "forward"], "conn": ["cb", "dc", "connection", "open", "io", "ct", "http", "con", "fp", "pg", "client", "cmd", "connected", "ca", "cp", "n", "enc", "ctx", "pc", "cn", "conf", "exec", "ci", "rc", "nt", "ch", "apt", "cr", "connect", "c", "rt", "db", "conv", "cc", "Connection", "Conn", "nc", "coll", "p"], "rd": ["reader", "dc", "ra", "rx", "d", "dd", "director", "ld", "xd", "ord", "vd", "rss", "pd", "fd", "red", "bd", "rn", "rg", "rc", "erd", "rm", "rs", "rod", "rh", "dr", "hr", "rl", "rw", "rt", "rr", "ds", "nd", "dra", "rb", "RD"], "parser": ["parent", "reader", "cb", " reporter", "proc", "wrapper", "plugin", "player", "pd", "http", "arser", "driver", "b", " plugin", "loader", "jack", "worker", "oder", "class", "r", "handler", "server", "config", "writer", "pc", "er", "angler", "monkey", "func", "dog", "patch", " parent", "instance", "bird", "library", "parse", "gg", "g", "manager", " parse", " parsing", "copy", "Parser", "p"]}}
{"id1": "14518760", "id2": "8943482", "code1": "    public void connect(final URLConnectAdapter urlAdapter) {\n        if (this.connectSettings == null) {\n            throw new IllegalStateException(\"Invalid Connect Settings (is null)\");\n        }\n        final HttpURLConnection httpConnection = (HttpURLConnection) urlAdapter.openConnection();\n        BufferedReader in;\n        try {\n            in = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n            final StringBuilder buf = new StringBuilder(200);\n            String str;\n            while ((str = in.readLine()) != null) {\n                buf.append(str);\n                buf.append('\\n');\n            }\n            final ConnectResult result = new ConnectResult(httpConnection.getResponseCode(), buf.toString());\n            final Map<String, List<String>> headerFields = httpConnection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : headerFields.entrySet()) {\n                final String key = entry.getKey();\n                final List<String> val = entry.getValue();\n                if ((val != null) && (val.size() > 1)) {\n                    System.out.println(\"WARN: Invalid header value : \" + key + \" url=\" + this.connectSettings.getUrl());\n                }\n                if (key != null) {\n                    result.addHeader(key, val.get(0), val);\n                } else {\n                    result.addHeader(\"Status\", val.get(0), val);\n                }\n            }\n            this.lastResult = result;\n        } catch (IOException e) {\n            throw new ConnectException(e);\n        }\n    }\n", "code2": "    public InputStream getImageAsStream(Photo photo, int size) throws IOException, FlickrException {\n        String urlStr = \"\";\n        if (size == Size.SQUARE) {\n            urlStr = photo.getSmallSquareUrl();\n        } else if (size == Size.THUMB) {\n            urlStr = photo.getThumbnailUrl();\n        } else if (size == Size.SMALL) {\n            urlStr = photo.getSmallUrl();\n        } else if (size == Size.MEDIUM) {\n            urlStr = photo.getMediumUrl();\n        } else if (size == Size.LARGE) {\n            urlStr = photo.getLargeUrl();\n        } else if (size == Size.ORIGINAL) {\n            urlStr = photo.getOriginalUrl();\n        } else {\n            throw new FlickrException(\"0\", \"Unknown Photo-size\");\n        }\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        if (transport instanceof REST) {\n            if (((REST) transport).isProxyAuth()) {\n                conn.setRequestProperty(\"Proxy-Authorization\", \"Basic \" + ((REST) transport).getProxyCredentials());\n            }\n        }\n        conn.connect();\n        return conn.getInputStream();\n    }\n", "label": 0, "substitutes": {"urlAdapter": ["webapter", "httpConnector", "webConnector", "httpConfig", "httpapter", "urlConfig", "webConfig", " urlConnection", "webConnection", "urlapter", "urlConnector", "urlConnection", "webAdapter", " urlConfig", " urlapter", " urlConnector", "httpAdapter"], "httpConnection": ["webClient", " httpClient", "httpsConnector", "httpConnector", "httpConnect", "HTTPConn", " httpConnect", "urlConnect", "httpsConnection", " httpconnection", "httpsConnect", " httpInterface", "httpsconnection", "httpInterface", "httpClient", " httpConn", "urlconnection", "webConnection", "HTTPConnect", "httpconnection", " httpconn", "httpconn", "urlConnector", "urlClient", "HTTPconn", "urlConnection", "urlConn", "httpsConn", "urlconn", "httpConn", " httpConnector", "webConnect", "httpsInterface", "webconnection", "urlInterface", "HTTPConnection"], "in": ["source", "read", "reader", "h", "url", "input", "inc", "din", "id", "win", "connection", "buffer", "min", "doc", "nin", "conn", "l", "con", "out", "b", "login", "f", "as", "gen", "In", "pin", "again", "re", "r", "fac", "isin", "inner", "ins", "ini", "a", "m", "ex", "kin", "rec", "cin", "c", "socket", "i", "IN", "err", "builder", "inn", "is", "bin", "s", "fa", "ac"], "buf": ["cb", "tmp", "url", "queue", "binary", "txt", "la", "uc", "buffer", "buff", "cf", "br", "Buffer", "cat", "pb", "cas", "fp", "b", "aux", "bc", "fd", "base", "cv", "data", "bytes", "ctx", "box", "config", "cur", "func", "grab", "bb", "ob", "runner", "text", "seq", "uf", "abs", "temp", "bag", "auc", "string", "ab", "wb", "map", "builder", "array", "header", "fb", "conv", "nb", "bu", "rb", "coll", "pkg"], "str": ["dec", "wr", "STR", "read", "url", "reader", "arr", "br", "iter", "l", "char", "b", "st", "fr", "f", "data", "r", "enc", "er", "cur", "e", "s", "exp", "spec", "cl", "Str", "text", "sr", "pr", "hr", "dr", "lc", "tr", "string", "cr", "list", "obj", "sp", "rev", "i", "err", "rr", "stri", "line", "coll", "sl"], "result": ["next", "source", "value", "continue", "default", "user", "our", "success", "Result", "complete", "function", "extra", "message", "output", "view", "this", "object", "root", "part", "pack", "ver", "row", "data", "summary", "future", "response", "r", "resource", "master", "ret", "repl", "server", "info", "event", "results", "report", "json", "runner", "job", "status", "up", "done", "session", "pass", "obj", "error", "db", "err", "builder", "manager", "current", "valid", "res", "coll"], "headerFields": ["headerForms", "HeaderFields", "HeaderColumngs", "headerColumnsets", "headerPrefes", "headerColgs", "headerFieldsets", "headerSignments", "headerSignerences", "headerFieldments", " headerColumnments", " headerFieldes", "headerColumnes", "headerColsets", "headerColumnments", "HeaderColumnes", " headerColumnes", "headerColumngs", "headerFielderences", "headerPrefsets", "headerSignes", "headerColes", " headerColumns", "headerPrefs", " headerFielderences", "headerFieldgs", " headerColumnerences", "headerFormes", "HeaderColumns", "HeaderColumnsets", "HeaderFieldsets", "headerFormments", "headerCols", "HeaderFieldes", "headerSigns", " headerFieldments", "headerFormerences", "HeaderFieldgs", "headerColumnerences", "headerFieldes", "headerColumns", "headerPrefgs"], "entry": ["mission", "reader", "ner", "inc", "term", "pe", "la", "si", "ent", "ger", "ry", "letter", "ence", "cell", "part", "row", "ries", "r", "set", "pair", "second", "inner", "section", "element", "er", "inter", "ge", "member", "e", "enter", "lc", "se", "index", "string", "entity", "record", "or", "Entry", "value", "line", "ie"], "key": ["nice", "sel", "parent", "id", "link", "pe", "cy", "ee", "co", "k", "letter", "op", "part", "ver", "by", "Key", "style", "set", "match", "ie", "box", "KEY", "section", "element", "word", "x", "name", "ace", "step", "length", "text", "col", "ke", "string", "path", "index", "change", "lock", "error", "code", "check", "i", "title", "label", "service", "header", "type", "ce", "order", "field", "oy", "option", "reason", "value", "ip"], "val": ["sel", "split", "url", "default", "msg", "la", "alt", "len", "arr", "Val", "ee", "l", "ul", "lv", "part", "base", "loc", "p", "data", "elt", "serv", "al", "el", "element", "VAL", "section", "iv", "x", "va", "it", "eval", "unit", "values", "text", "sl", "pr", "fl", "ls", "li", "v", "col", "il", "string", "list", "aval", "vals", "obj", "error", "sol", "ol", "err", "vol", "Value", "arg", "vi", "valid", "item", "detail", "value", "line", "pl", "bl"], "lastResult": ["nextReturn", " lastStatus", " lastResponse", "nextResponse", "prevResult", "lastReturn", "nextResult", " lastReturn", "lastResponse", "prevResponse", "lastStatus", "nextStatus", "prevReturn", "prevStatus"]}}
{"id1": "9353182", "id2": "13339653", "code1": "    String test() throws ServerException, RtmApiException, IOException {\n        HttpClient httpclient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(this.request.getUrl());\n            HttpPost httppost = new HttpPost(uri);\n            HttpResponse response = httpclient.execute(httppost);\n            InputStream is = response.getEntity().getContent();\n            StringBuilder sb = new StringBuilder();\n            BufferedReader r = new BufferedReader(new InputStreamReader(new DoneHandlerInputStream(is)));\n            for (String line = r.readLine(); line != null; line = r.readLine()) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (URISyntaxException e) {\n            throw new RtmApiException(e.getMessage());\n        } catch (ClientProtocolException e) {\n            throw new RtmApiException(e.getMessage());\n        }\n    }\n", "code2": "    public void write(String resource, String destinationPath) throws IOException, CoreException {\n        OutputStream output = null;\n        InputStream contentStream = null;\n        try {\n            contentStream = new BufferedInputStream(new FileInputStream(resource));\n            output = new BufferedOutputStream(new FileOutputStream(destinationPath));\n            int available = contentStream.available();\n            available = available <= 0 ? DEFAULT_BUFFER_SIZE : available;\n            int chunkSize = Math.min(DEFAULT_BUFFER_SIZE, available);\n            byte[] readBuffer = new byte[chunkSize];\n            int n = contentStream.read(readBuffer);\n            while (n > 0) {\n                output.write(readBuffer, 0, n);\n                n = contentStream.read(readBuffer);\n            }\n        } finally {\n            if (contentStream != null) {\n                try {\n                    contentStream.close();\n                } catch (IOException e) {\n                    IDEWorkbenchPlugin.log(\"Error closing input stream for file: \" + resource, e);\n                }\n            }\n            if (output != null) {\n                output.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"httpclient": ["webClient", "webapi", "serverClient", " httpClient", "httpsmethod", " httpapi", "serverproxy", "Httpclient", "serverclient", "phpmethod", "serverapi", "phpClient", "httpsconnection", "httpClient", " httpproxy", "httpconnection", "httpproxy", "Httpconnection", "httpapi", "webclient", "httpmethod", "phpclient", "httpsclient", "Httpmethod", "phpconnection", "httpsClient", "HttpClient", "webproxy"], "uri": ["source", "absolute", "route", "url", "si", "qi", "connection", "reference", "plugin", "range", "result", "io", "http", "request", " URI", "base", "directory", "remote", "resource", "prefix", "server", "handler", "address", "adi", "query", "ui", "api", "cli", "xi", "iri", "ri", "string", "path", "i", "service", "database", "pi", "hub", "URI", "mi", "uni", "location"], "httppost": ["httpost", " httpposter", "httpppost", "httppoint", "httploint", " httpppost", "httposter", " httpsoint", "httpspost", "nitphpost", " httppoint", "nitphonse", "httplonse", "nitpposter", "httponse", "httpponse", "httpsoster", " httpsoster", "httphpost", "httpoint", "httplpost", "nitppost", "nitphost", "httphost", "nitpppost", "httploster", "nitpponse", "httphoster", "httpsoint", "httphonse", " httpsost", "httplost", " httpspost", "httpsost", "nitphoster", "httpposter"], "response": ["page", "successful", "respond", "connection", "success", "reply", "result", "message", "output", "http", "request", "object", "this", "client", "application", "onse", "data", "stream", "resource", "server", "body", "e", "json", "api", "status", "Response", "document", "error", "err", "resp", "Resp", "received", "res"], "is": ["url", "si", "rss", "src", "conn", "ais", "http", "in", "b", "as", "data", "iss", "stream", "os", "handler", "ris", "esi", "ai", "serv", "server", "address", "ir", "x", "res", "ui", "it", "IS", "api", "rs", "sr", "ri", "lis", "i", "err", "ar", "Is", "iso", "s", "ip", "p"], "sb": ["su", "cb", "sa", "bf", "si", "bh", "mb", "abi", "buffer", "sth", "sg", "bg", "BB", "pb", "src", "sbm", "bps", "b", "sf", "bc", "lr", "bm", "kb", "bd", "abb", "bs", "obb", "erb", "sup", "bj", "bb", "SB", "ob", " SB", "zb", "sv", "gb", "xb", "eb", "ib", "bsp", "ssl", "db", "wb", "fb", "builder", "lab", "nb", "soc", "lb", "sn", "rb", "bp"], "r": ["reader", "rar", "rx", "iter", "R", "br", "l", "b", "lr", "fr", "re", "ir", "er", "ur", "res", "rc", "e", "rs", "sr", "pr", "rh", "hr", "dr", "adr", "ri", "vr", "cr", "rl", "rw", "rt", "i", "err", "mr", "orer", "rd", "rr", "ar", "s", "rb", "ner", "p"], "line": ["source", "page", "entry", "reader", "none", "nl", "link", "pe", "lf", "lines", "message", "l", "letter", "one", "out", "b", "char", "LINE", "cell", "end", "Line", "row", "f", "base", "layer", "data", "model", "on", "inline", "style", "el", "element", "sync", "name", "part", "liner", "e", "o", "unit", "non", "cl", "text", "comment", "lc", "job", "le", "string", "frame", "point", "file", "error", "code", "err", "label", "character", "block", "lin", "sheet", "str", "ip", "sl"]}}
{"id1": "3177725", "id2": "322658", "code1": "    public DBAccess(String pathToDb) {\n        if (instance != null) {\n            throw new IllegalStateException();\n        }\n        System.setProperty(\"derby.system.home\", pathToDb);\n        try {\n            boolean exists = new File(pathToDb).exists();\n            new EmbeddedDriver();\n            Properties props = new Properties();\n            if (exists) {\n                connection = DriverManager.getConnection(protocol + \"rmpDB;\", props);\n                connection.setAutoCommit(true);\n                Statement statement = connection.createStatement();\n                try {\n                } finally {\n                    statement.close();\n                }\n            } else {\n                connection = DriverManager.getConnection(protocol + \"rmpDB;create=true\", props);\n                connection.setAutoCommit(true);\n                URL url = Platform.getBundle(\"ru.spbu.dorms.geo.rmp\").getResource(\"sql/createdb.sql\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                StringBuilder query = new StringBuilder();\n                for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                    if (query.length() > 0) {\n                        query.append('\\n');\n                    }\n                    query.append(s);\n                }\n                reader.close();\n                Statement statement = connection.createStatement();\n                try {\n                    String[] statements = query.toString().split(\";(\\\\s)*\");\n                    for (String s : statements) {\n                        statement.execute(s);\n                    }\n                } finally {\n                    statement.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        instance = this;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 0, "substitutes": {"pathToDb": ["PathOfDir", "PathToDB", "PathOfWeb", "pathOfFile", "pathToDir", "PathOfDB", "pathTODB", "pathtoDb", "pathFromDb", "path2DB", "pathFromWeb", "pathForDir", "PathToDir", "pathFordb", "pathtoDir", "pathToDB", "pathOfDir", "pathOfDatabase", "pathForDb", "pathOfWeb", "pathTODatabase", "pathFromDatabase", "pathFromFile", "PathOfFile", "pathTodb", "PathToDatabase", "pathtodb", "pathForDB", "pathToFile", "pathToWeb", "pathFromDB", "pathToDatabase", "path2Db", "path2File", "PathToWeb", "pathTODb", "pathtoDB", "PathTodb", "pathOfDb", "pathOfDB", "PathOfdb", "PathToFile", "pathTOWeb", "path2Database", "PathOfDb", "PathOfDatabase", "PathToDb", "pathOfdb"], "exists": ["enset", "Existing", "EXisting", " existence", "sexists", "exits", "Exits", "ensistance", "exist", "Exists", "clists", "existence", "ensists", "sexist", "EXits", "EXist", "EXists", " existing", "Exist", "existet", "existists", " exits", "clisting", "sexits", "Existance", "sexisting", "Existence", "exististance", "Exet", "existance", "clistence", "existist", "exet", "ensist", "clits", "existing"], "props": ["Properties", "proops", "roperties", "perps", "procs", "percs", "rops", "roops", "Procs", "Proops", "perops", "properties", "protps", "protperties", "protcs", "rocs", "Props", " procs", " proops", "perperties", "protops", " properties"], "connection": ["sql", "director", "function", "conn", "communication", "con", "client", "union", "connected", "environment", "loc", "channel", "application", "table", "version", "directory", "resource", "handler", "server", "child", "config", "writer", "creator", "condition", "section", "machine", "component", "volume", "log", "ion", "password", "relation", "session", "index", "port", "graph", "image", "connect", "pool", "lock", "document", "context", "socket", "library", "builder", "manager", "database", "position", "Connection", "proxy", "collection", "unit"], "statement": ["execute", "study", "general", "memory", "sql", "operator", "si", "office", "result", "function", "message", "conn", "out", "this", "b", "object", "state", "application", "table", "storage", "response", "style", "resource", "handler", "server", "slave", "gi", "condition", "writer", "usage", "section", "volume", "event", "batch", "report", "ion", "parser", "stat", "instance", "comment", "runner", "relation", "session", "string", "media", "document", "db", "expression", "Statement", "i", "command", "builder", "manager", "database", "binding", "journal", "unit"], "url": ["source", "link", "user", "browser", "feed", "buffer", "l", "http", "driver", "client", "base", "loader", "layer", "channel", "stream", "r", "resource", "org", "server", "address", " URL", "ur", "bel", "abs", "location", "string", "path", "rl", "uri", "file", "ssl", "context", "builder", "URL", "service", "Url", "blog", "gl", "str", "sl"], "reader": ["read", "input", "rar", "rx", "Reader", "feed", "buffer", "iter", "keeper", "io", "iterator", "http", "driver", "in", "ler", "part", "row", "f", "loader", "layer", "oder", "stream", "r", "resource", "handler", "editor", "server", "writer", "inner", "er", "rer", "rc", "e", "ink", "reading", "per", "bird", "parser", "key", "ri", "file", "uri", "i", "or", "builder", "ner"], "query": ["select", "source", "str", "sql", "user", "build", "range", "result", "function", "view", "join", "params", "request", "in", "row", "data", "table", "r", "response", "resource", "server", "info", "ql", "script", "body", "qu", "report", "json", "password", "text", "comment", "scan", "timeout", "key", "string", "path", "media", "rule", "seed", "cache", "uri", "error", "expression", "command", "Query", "search", "parse", "sq", "q", "database", "block", "question", "form", "value", "line"], "s": ["su", "an", "sql", "d", "lines", "l", "ns", "sf", "r", "es", "sync", "name", "u", "ls", "rows", "side", "ssl", "your", "line", "comments", "sb", "id", "strings", "sections", "object", "b", "os", "sets", "results", "t", "instance", "values", "sv", "a", "c", "search", "ses", "str", "si", "ss", "ements", "items", "request", "f", "n", "second", "sym", "e", "o", "v", "words", "string", "i", "ans", "g", "q", "ds", "S", "null", "p", "h", "ings", "ws", "sw", "data", "spec", "m", "session", "its", "sq", "parts", "sl", "type"], "statements": ["Statings", "stements", "strings", "Statements", "Statations", "regents", "Statments", "Statuments", "stances", "statments", "Statances", "statementents", "statementuments", "statementments", "statents", "strements", "strances", "statances", "regments", "strations", "statations", "statementements", "stings", "statings", "Statents", "statuments", "stations", "regements", "reguments"]}}
{"id1": "7003929", "id2": "4265804", "code1": "    public URLConnection openConnection(String string) throws ParserException {\n        final String prefix = \"file://localhost\";\n        String resource;\n        URL url;\n        StringBuffer buffer;\n        URLConnection ret;\n        try {\n            url = new URL(fixSpaces(string));\n            ret = openConnection(url);\n        } catch (MalformedURLException murle) {\n            try {\n                File file = new File(string);\n                resource = file.getCanonicalPath();\n                buffer = new StringBuffer(prefix.length() + resource.length());\n                buffer.append(prefix);\n                if (!resource.startsWith(\"/\")) buffer.append(\"/\");\n                buffer.append(resource);\n                url = new URL(fixSpaces(buffer.toString()));\n                ret = openConnection(url);\n            } catch (MalformedURLException murle2) {\n                String msg = \"Error in opening a connection to \" + string;\n                ParserException ex = new ParserException(msg, murle2);\n                throw ex;\n            } catch (IOException ioe) {\n                String msg = \"Error in opening a connection to \" + string;\n                ParserException ex = new ParserException(msg, ioe);\n                throw ex;\n            }\n        }\n        return (ret);\n    }\n", "code2": "    private static ArrayList<String> YahooSearch(String query) {\n        ArrayList<String> yahooSearchResults = new ArrayList<String>();\n        try {\n            String request = \"http://boss.yahooapis.com/ysearch/web/v1/\" + URLEncoder.encode(\"Java example for \" + query, \"UTF-8\") + \"?appid=zfau5aPV34ETbq9mWU0ui5e04y0rIewg1zwvzHb1tGoBFK2nSCU1SKS2D4zphh2rd3Wf\" + \"&format=xml&count=30&type=-msoffice,-pdf\";\n            URL url = new URL(request);\n            System.out.println(\"Host : \" + url.getHost());\n            url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            String finalContents = \"\";\n            while ((inputLine = reader.readLine()) != null) {\n                finalContents += \"\\n\" + inputLine;\n            }\n            Document doc = Jsoup.parse(finalContents);\n            Elements eles = doc.getElementsByTag(\"url\");\n            for (Element ele : eles) {\n                yahooSearchResults.add(ele.text());\n                System.out.println(\"YahooResult: \" + ele.text());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return yahooSearchResults;\n    }\n", "label": 0, "substitutes": {"string": ["source", "host", "via", "language", "value", "strings", "operation", "input", "binary", "connection", "reference", "function", "message", "format", "letter", "object", "number", "data", "version", "stream", "single", "server", "setting", "address", "ident", "section", "word", "name", "filename", "ring", "s", "text", "relation", "slice", "path", "document", "socket", "uri", "expression", "struct", "array", "service", "database", "field", "str", "duration", "type"], "prefix": ["source", "folder", "route", "network", "reference", "plugin", "username", "format", "http", "pre", "fp", "fix", "request", "part", "base", "phrase", "ref", "directory", "remote", "address", "filename", "name", "ring", "ix", "null", "scope", "pattern", "password", "text", "area", "offset", "path", "pointer", "cache", "uri", "context", "service", "header", "reset", "fixed", "padding", "p"], "resource": ["source", "resources", "folder", "route", "queue", "reference", "range", "Resource", "result", "format", "request", "base", "channel", "data", "directory", "ruby", "region", "remote", "response", "server", "feature", "address", "filename", "name", "relative", "target", "content", "area", "media", "path", "rule", "image", "document", "pointer", "uri", "attribute", "record", "context", "property", "database", "project", "res", "type"], "url": ["source", "host", "page", "user", "feed", "rel", "connection", "ll", "iter", "output", "l", "ul", "http", "object", "b", "lr", "base", "f", "loc", "channel", "layer", "ref", "stream", "server", "address", "el", "name", "null", "ur", "event", "bb", "ob", "log", "bel", "fl", "job", "path", "image", "il", "rl", "socket", "uri", "ssl", "fb", "URL", "service", "Url", "self", "www", "proxy", "web", "str", "jar", "sl"], "buffer": ["source", "reader", "queue", "memory", "binary", "append", "feed", "reference", "buff", "repeat", "iter", "Buffer", "message", "limit", "http", "b", "base", "layer", "data", "ref", "server", "writer", "reverse", "uffer", "transfer", "batch", "bb", "length", "flush", "wave", "comment", "bar", "buf", "timeout", "offset", "document", "border", "cache", "uri", "fb", "builder", "array", "header", "block", "bin"], "ret": ["sb", "bf", "alt", "connection", "rel", "rets", "arr", "reply", "pet", "result", "iter", "real", "conn", "mem", "val", "bc", "def", "f", "data", "hard", "ref", "re", "response", "r", "det", "repl", "info", "al", "el", "fun", "cur", "inter", "ur", "bb", "gt", "nt", "job", "ft", "ut", "cache", "obj", "rl", "db", "rt", "rev", "resp", "att", "reg", "conv", "fi", "Ret", "proxy", "web", "res", "RET", "ext"], "file": ["source", "folder", "page", "reader", "plain", "binary", "pe", "feed", "File", "io", "l", "http", "out", "fp", "b", "object", "f", "base", "data", "fe", "directory", "class", "zip", "filename", "name", "dir", "full", "e", "per", "path", "document", "il", "cache", "uri", "db", "FILE", "use"], "msg": ["en", "req", "cm", "sg", "Message", "message", "bg", "doc", "og", "ger", "format", "rag", "cmd", "ms", "bug", "console", "gen", "base", "mode", "phrase", "mu", "mag", "comm", "module", "name", "method", "e", "log", "comment", "m", "missing", "cfg", "Msg", "debug", "html", "uri", "error", "title", "err", "mg", "g", "mess", "md", "ag", "domain", "reason", "nm", "str", "ug", "pkg", "type"], "ex": ["rem", "expl", "su", "nex", "rx", "ception", "rex", " exc", " exp", "Ex", "wx", "out", "Exc", "aux", "used", "exc", "pex", "data", "class", "es", "tx", "external", "sex", "x", "crit", "six", "it", "e", "exp", "act", "log", "ax", " Ex", "ait", "temp", "status", "ect", "sec", "se", "EX", "obj", "lex", "expr", "reason", "str", "exit", "except", "ext"]}}
{"id1": "11548511", "id2": "19752873", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void reqservmodif(HttpServletRequest req, HttpServletResponse resp, SessionCommand command) {\n        setHeader(resp);\n        try {\n            logger.debug(\"SeMo: Requesting server modification for session \" + command.getSession());\n            File tempFile = new File(getSyncWorkDirectory(req), command.getSession() + \".smodif\");\n            OutputStream fos = new FileOutputStream(tempFile);\n            syncServer.getServerModifications(command.getSession(), fos);\n            InputStream fis = new FileInputStream(tempFile);\n            resp.setContentLength(fis.available());\n            while (fis.available() > 0) {\n                resp.getOutputStream().write(fis.read());\n            }\n            resp.getOutputStream().flush();\n            resp.flushBuffer();\n        } catch (IOException ioe) {\n            logger.error(ioe.getMessage());\n        } catch (ImogSerializationException ex) {\n            logger.error(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfile", "infilename", " inFile", "infiles", "inFile", "inbase", "inputfiles", "inputfilename", " instream", "outfiles", " infilename", "Instream", "infp", " infp", "inputfp", "Inbase", "outfilename", " infiles", "InFile", "instream", "minbase", " inbase", "minstream", "outfp", "minfile", "Infile", "minFile"], "outfile": ["inputfile", "outFile", "infilename", " outdatabase", "outputpath", "inFile", "outputfilename", "outdatabase", "outputFile", " outFile", "outpath", "outfilename", "outputdatabase", " outfolder", "inputdatabase", "outfolder", "outputfolder", "infolder", "inputpath", "inputFile", " outpath", " outfilename", "outputfile"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "min", "nin", "conn", "con", "b", "login", "as", "data", "In", "pin", "into", "re", "r", "inas", "thin", "again", "ac", "isin", "inner", "init", "ins", "gin", "ini", "a", "m", "sin", "cin", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "lin", "bin", "s", "ic", "pass"], "out": ["parent", "inc", "write", "net", "co", "io", "output", "outer", "conn", "one", "lib", "client", "home", "ou", "base", "channel", "to", "no", "In", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "log", "ex", "post", "job", "session", "up", "timeout", "point", "image", "cache", "socket", "file", "obj", "error", "err", "or", "bin", "copy", "exit", "line", "pass"], "buffer": ["source", "size", "reader", "split", "url", "queue", "input", "write", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "base", "channel", "layer", "data", "bytes", "server", "raw", "address", "uffer", "transfer", "null", "padding", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "count", "border", "seed", "cache", "bin", "value", "type"], "read": ["play", "select", "next", " write", "size", "reader", "ad", "get", "inc", "write", "id", "feed", "len", "Read", "ind", "iter", " skip", "fill", "READ", "ride", "io", "limit", "end", "tell", "f", "sleep", "find", "n", "r", "work", "raw", "exec", "x", "sync", "send", "reading", "_", "length", "allow", "run", "se", "slice", "count", "pass", "load", "parse", "connect", "i", "seek", "check", "wait", "lex", "current", " copy", "start", " count", "ip", "add", "copy", " Read", "use", "reads"], "success": ["successful", "continue", "roll", "default", "warning", "first", "better", "successfully", "open", " succeed", "complete", "growth", "result", "right", "message", "Success", "true", "positive", "flash", "winner", " succ", "model", " successful", "cess", "data", "fast", "again", "response", "primary", "xx", "rolled", " Success", "method", "func", "results", "failed", "initial", "comment", "danger", "content", "status", "done", "path", "error", "fail", "valid", "construct", "ccess", "rolling", "follow", "ceed", "good", "value", "null", "pass"]}}
{"id1": "16389677", "id2": "16301512", "code1": "    public void extract(CabFolder cabfolder, File outputFolder) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        File file;\n        byte[] buffer = new byte[2048];\n        int read, remain, maxread = buffer.length;\n        in = new CabFileInputStream(cabfolder);\n        CabEntry[] cabentries = this.getEntries();\n        for (int i = 0; i < cabentries.length; i++) {\n            if (cabentries[i].getCabFolder() == cabfolder) {\n                file = new File(outputFolder, cabentries[i].getName().replace('\\\\', '/'));\n                FileUtils.createParents(file);\n                out = new FileOutputStream(file);\n                remain = cabentries[i].getInflatedSize();\n                while (remain != 0 && (read = in.read(buffer, 0, maxread)) != -1) {\n                    out.write(buffer, 0, read);\n                    remain -= read;\n                    if (buffer.length > remain) maxread = remain; else maxread = buffer.length;\n                }\n                in.close();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copy(File src, File dst) throws IOException {\n        FileChannel inChannel;\n        FileChannel outChannel;\n        inChannel = new FileInputStream(src).getChannel();\n        outChannel = new FileOutputStream(dst).getChannel();\n        outChannel.transferFrom(inChannel, 0, inChannel.size());\n        inChannel.close();\n        outChannel.close();\n    }\n", "label": 1, "substitutes": {"cabfolder": ["cacmode", "cafFolder", " caftheme", " cafdivision", " cafdirectory", "Cubdir", "CacFolder", "cabetheme", "CabFolder", "cabsfolder", "cubdir", "cabdir", "cabedivision", "cabedirectory", "Cacmode", "cabsdirectory", "cabstheme", " cabdivision", "Cabfolder", "cabmode", "cacfolder", "cubfolder", " caffolder", "cabsfile", "Cabdir", "cafdirectory", "Cubfolder", "cubFolder", "cafmode", "capFolder", "capfolder", "caftheme", " cabtheme", "cabdirectory", "cabFolder", "cabsmode", "cabfile", "CubFolder", " cabdirectory", "cabsdivision", "Cabmode", "cacFolder", "cacdir", "capdir", "Cubfile", "caffolder", "cafdivision", "cabsFolder", "cubfile", "Cacdir", "cabtheme", "capfile", "Cacfolder", "Cabfile", "cabdivision", "cabefolder", "cabsdir", "cafdir"], "outputFolder": ["targetfolder", "outDir", "outDirectory", "Outputfolder", " outputDir", "outputDirectory", "OutputDirectory", "OutputDir", "outFolder", "targetFolder", "outfolder", "OutputFolder", "outputDir", " outputDirectory", "outputfolder", "targetDirectory", " outputfolder"], "in": ["source", "reader", "id", "url", "input", "inc", "din", "win", "io", "nin", "conn", "con", "this", "b", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "into", "ai", "inner", "exec", "init", "ins", "e", "ini", "a", "m", "rec", "up", "cin", "image", "c", "socket", "IN", "inside", "err", "inn", "rin", "is", "lin", "bin", "fa", "ic"], "out": ["source", "page", "parent", "inc", "net", "connection", "co", "output", "io", "outer", "conn", "w", "client", "object", "this", "b", "base", "f", "on", "to", "no", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "exp", "log", "post", "ex", "up", "key", "image", "pass", "cache", "socket", "obj", "err", "bin", "copy", "exit", "line", "ext"], "file": ["source", "folder", "parent", "id", "ile", "binary", "pe", "feed", "lf", "File", "l", "lib", "letter", "http", "fp", "b", "object", "root", "part", "model", "f", "base", "data", "directory", "fe", "zip", "resource", "work", "child", "el", "name", "filename", "dir", "full", "it", "e", "per", "log", "run", "book", "up", "le", "path", "il", "key", "cache", "socket", "or", "files", "FILE", "copy", "line", "use", "unit"], "buffer": ["source", "reader", "size", "url", "memory", "queue", "binary", "input", "feed", "reference", "buff", "iter", "player", "result", "Buffer", "message", "limit", "request", "b", "row", "layer", "base", "data", "phrase", "bytes", "available", "resource", "server", "address", "info", "uffer", "shape", "transfer", "null", "padding", "batch", "length", "flush", "wave", "comment", "buf", "timeout", "offset", "slice", "string", "image", "document", "border", "cache", "seed", "header", "texture", "position", "stack", "value", "pause", "entry"], "read": ["select", "get", "play", "size", "id", "en", "num", "input", "write", "reader", "line", "feed", "len", "open", "Read", "ind", "build", "fill", "READ", "io", "ride", "view", "end", "sleep", "data", "rate", "find", "n", "r", "work", "raw", "ime", "x", "cur", "send", "sync", "e", "ize", "length", "text", "max", "run", "close", "index", "se", "count", "show", "connect", "load", "c", "parse", "readable", "check", "seek", "search", "pass", "wait", "block", "current", "create", "level", "start", "add", "copy", "put", "ed", "ip", "use", "reads"], "remain": ["retaining", "REMaining", "renainer", "renain", "retain", "remained", "romains", "renaining", " remained", "Remaine", "resains", " remaine", "REMains", "resaine", "Remains", "Remaining", "REMained", "resained", "REMain", "resain", "retains", "remaine", "romain", "Remain", "romaining", "Remained", " remains", "retained", "remainer", "resaining", " remaining", "renains", "remains", "romained", "Remainer", "remaining", "resainer"], "maxread": ["axRead", "lastlength", "Maxwrite", "lastwrite", "maximumRead", "minlength", "axwrite", " maxsend", "maximumsend", "maximumread", "maxwrite", "minread", "maxload", "axlength", "axload", "maximumwrite", "maxRead", "Maxlength", "minload", " maxRead", "lastread", " maxwrite", "lastload", "maxsend", "Maxload", "Maxread", "axsend", "minwrite", "maxlength", " maxlength", " maxload", "axread"], "cabentries": ["cbEntures", "cabEntry", "cabentrys", "cabsEntry", "cabientrys", "cablentions", "cabEntants", "cabentryiries", "cabsentryries", "cabentryants", "cabsentlections", "cabEntions", "cabentryrys", "cablentrys", "cabinfries", "cabientries", "cabEntlections", "cbentures", "cabientures", "cabentions", "cabientry", "cabenures", "cabinfiries", "cabsentry", "cabentrylections", "cabsentryrys", "cabserverries", "cabserverry", "cbEntrys", "cabserverlections", "cabbentries", "cabsEntries", "cabbinfrys", "cabextions", "cablEntrys", "cabsentiries", "cbentrys", "cabEntries", "cabsEntrys", "cablEntries", "cabentryries", "cabextrys", "cablentries", "cabEntriers", "cbEntry", "cabinfants", "cabsentryiries", "cabEntrys", "cabbinfries", "cabserverrys", "cabentryry", "cabentriers", "cabsentries", "cabenries", "cablEntriers", "cabentures", "cabbentrys", "cabenry", "cbentry", "cabextries", "cabEntures", "cabserverriers", "cabserverions", "cabinfrys", "cbentries", "cbEntries", "cabbentants", "cabenrys", "cabextriers", "cabbinfants", "cabsentrys", "cabentlections", "cabentiries", "cabsEntlections", "cabEntiries", "cabentry", "cablentriers", "cablEntions", "cabentants"], "i": ["id", "h", "si", "d", "multi", "qi", "ic", "iu", "phi", "k", "io", "yi", "y", "b", "part", "f", "di", "bi", "I", "ti", "ni", "ai", "info", "oi", "gi", "x", "iv", "ix", "init", "ui", "ci", "u", "e", "o", "it", "ini", "m", "li", "v", "key", "xi", "ri", "index", "slice", "j", "c", "uri", "ii", "pi", "fi", "mi", "ip", "p", "ie"]}}
{"id1": "4938184", "id2": "4494367", "code1": "    public void testParts() throws Exception {\n        URL url = getClass().getClassLoader().getResource(\"de/schlund/pfixxml/parts.xml\");\n        InputSource source = new InputSource(url.openStream());\n        source.setSystemId(url.toString());\n        IncludePartsInfo info = IncludePartsInfoParser.parse(source);\n        Map<String, IncludePartInfo> parts = info.getParts();\n        assertEquals(3, parts.size());\n        assertTrue(parts.containsKey(\"aaa\"));\n        assertTrue(parts.containsKey(\"bbb\"));\n        assertFalse(parts.containsKey(\"ccc\"));\n        assertTrue(parts.containsKey(\"ddd\"));\n    }\n", "code2": "    @Override\n    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String id = request.getParameter(\"Id\");\n        String libid = request.getParameter(\"LibId\");\n        System.out.println(\"********************************printing starts here***************************\");\n        Enumeration enumx = request.getAttributeNames();\n        while (enumx.hasMoreElements()) {\n            String namex = enumx.nextElement().toString();\n            System.out.println(\"REQ ATTR\" + namex + \"------\" + request.getAttribute(namex));\n        }\n        enumx = request.getSession().getAttributeNames();\n        while (enumx.hasMoreElements()) {\n            String namex = enumx.nextElement().toString();\n            System.out.println(\"SESS ATTR\" + namex + \"------\" + request.getSession().getAttribute(namex));\n        }\n        enumx = request.getParameterNames();\n        while (enumx.hasMoreElements()) {\n            String namex = enumx.nextElement().toString();\n            System.out.println(\"REQ PARAM\" + namex + \"------\" + request.getParameter(namex));\n        }\n        System.out.println(\"********************************printing ends here***************************\");\n        String limitsSet = \"\";\n        try {\n            if (request.getSession().getAttribute(\"searchLimits\") != null) {\n                System.out.println(\"searchLimits set\");\n                limitsSet = \"SET\";\n                java.util.Hashtable htLimits = new java.util.Hashtable();\n                htLimits = (java.util.Hashtable) request.getSession().getAttribute(\"searchLimits\");\n            } else {\n                limitsSet = \"UNSET\";\n                System.out.println(\"searchLimits not set\");\n            }\n            java.util.Properties prop = System.getProperties();\n            prop.load(new FileInputStream(ejb.bprocess.util.NewGenLibRoot.getRoot() + java.io.File.separator + \"SystemFiles\" + java.io.File.separator + \"ENV_VAR.txt\"));\n            System.out.println(\"SEARCH MODE IS \" + searchmode + \" FILE PATH \" + ejb.bprocess.util.NewGenLibRoot.getRoot() + java.io.File.separator + \"SystemFiles\" + java.io.File.separator + \"ENV_VAR.txt\");\n        } catch (Exception e) {\n        }\n        javax.servlet.http.HttpSession session = request.getSession();\n        session.setAttribute(\"totalPages\", \"1\");\n        session.setAttribute(\"formOfRec\", \"\");\n        String forward = \"singleRecordView\";\n        int link = 0, singleLink = 0;\n        java.util.Vector vecThisPage = new java.util.Vector();\n        aportal.form.cataloguing.SingleRecordForm svF = (aportal.form.cataloguing.SingleRecordForm) form;\n        opacHm = (ejb.bprocess.opac.xcql.OPACUtilitiesHome) ejb.bprocess.util.HomeFactory.getInstance().getRemoteHome(\"OPACUtilities\");\n        ejb.bprocess.opac.xcql.OPACUtilities opacUt = opacHm.create();\n        System.out.println(\"CLASS NO \" + request.getParameter(\"ClassNo\") + \" ClassNoForwarded \" + session.getAttribute(\"ClassNoForwarded\"));\n        if (svF.getExportRec() == null || !(svF.getExportRec().equals(\"export\"))) {\n            System.out.println(\"*************************************************************************** 1\");\n            if (id != null && libid != null && request.getParameter(\"relation\") != null && !(session.getAttribute(\"HostItemDisplay\") != null && session.getAttribute(\"HostItemDisplay\").toString().equals(\"false\"))) {\n                System.out.println(\"*************************************************************************** 2\");\n                home = (ejb.bprocess.opac.xcql.SearchSRUWCatalogueHome) ejb.bprocess.util.HomeFactory.getInstance().getRemoteHome(\"SearchSRUWCatalogue\");\n                ejb.bprocess.opac.xcql.SearchSRUWCatalogue searchCat = home.create();\n                String catId1 = id;\n                String ownId1 = libid;\n                System.out.println(\"*********************CatId1: \" + catId1);\n                svF.setCatalogueRecordId(catId1);\n                svF.setOwnerLibraryId(ownId1);\n                String rel = request.getParameter(\"relation\");\n                java.util.Vector vecL = searchCat.getRelatedCatalogueRecords(null, catId1, ownId1, rel);\n                request.setAttribute(\"LuceneVector\", vecL);\n                session.setAttribute(\"searchVec\", vecL);\n                singleLink = 1;\n                session.setAttribute(\"HostItemDisplay\", \"false\");\n                link = 1;\n                forward = \"searchRes\";\n                vecThisPage.addElement(catId1);\n                vecThisPage.addElement(ownId1);\n            } else if (link == 0 || singleLink == 1) {\n                System.out.println(\"*************************************************************************** 3\");\n                System.out.println(\"LINK AND SINGLE LINK \" + link + \" single \" + singleLink);\n                if ((request.getParameter(\"ClassNo\") != null) && session.getAttribute(\"ClassNoForwarded\") == null) {\n                    System.out.println(\"*************************************************************************** 4\");\n                    System.out.println(\"action called for class no.\");\n                    String classificNo = request.getParameter(\"ClassNo\");\n                    System.out.println(\"TITLE WORDS \");\n                    home = (ejb.bprocess.opac.xcql.SearchSRUWCatalogueHome) ejb.bprocess.util.HomeFactory.getInstance().getRemoteHome(\"SearchSRUWCatalogue\");\n                    ejb.bprocess.opac.xcql.SearchSRUWCatalogue searchCat = home.create();\n                    String rawSearchText = (new beans.miscellaneous.RequestStringProcessor()).processString(\"*\" + classificNo + \"*\");\n                    System.out.println(\"raw search Text\" + rawSearchText);\n                    String searchText = \"classificationNumber=\" + rawSearchText;\n                    System.out.println(\"search text is \" + searchText);\n                    String xmlRes = (new org.z3950.zing.cql.CQLParser()).parse(searchText).toXCQL(0);\n                    java.util.Hashtable hs = new java.util.Hashtable();\n                    java.util.Vector v1 = new java.util.Vector();\n                    if (session.getAttribute(\"searchLimits\") != null) {\n                        System.out.println(\"*************************************************************************** 5\");\n                        hs = (java.util.Hashtable) session.getAttribute(\"searchLimits\");\n                    }\n                    Vector vec = new Vector();\n                    String solrQuery = Utility.getInstance().simplifiedSolrQuery(classificNo, \"classificationNumber\");\n                    if (limitsSet.equalsIgnoreCase(\"SET\")) {\n                        System.out.println(\"*************************************************************************** 6\");\n                        String limitsQuery = limitsSolrQuery(hs);\n                        solrQuery += limitsQuery;\n                    }\n                    solrQuery += \" & \";\n                    Vector newRetvec = searchCat.processSolrQuery(1, 25, solrQuery, \"245_Tag\", \"asc\");\n                    Hashtable ht = (Hashtable) newRetvec.get(0);\n                    String totrec = (String) ht.get(\"HITS\");\n                    session.setAttribute(\"TOTALREC\", Integer.parseInt(totrec));\n                    v1 = (Vector) ht.get(\"RESULTS\");\n                    hs.put(\"Query\", solrQuery);\n                    if (v1.size() > 0) {\n                        System.out.println(\"*************************************************************************** 7\");\n                        hs.put(\"searchText\", rawSearchText);\n                        hs.put(\"noOfRecords\", 25);\n                        hs.put(\"browseType\", \"Classification Number\");\n                        session.setAttribute(\"searchEntry\", hs);\n                        session.setAttribute(\"searchVec\", v1);\n                        forward = \"searchRes\";\n                    } else {\n                        System.out.println(\"*************************************************************************** 8\");\n                        forward = \"home\";\n                    }\n                } else {\n                    System.out.println(\"*************************************************************************** 9\");\n                    System.out.println(\"ELSE CALLED \");\n                    String record = request.getParameter(\"record\");\n                    String recNo = request.getParameter(\"recNo\");\n                    int catId = 0, ownerId = 0;\n                    String title = \"\";\n                    if (id != null && libid != null) {\n                        System.out.println(\"*************************************************************************** 10\");\n                        catId = new Integer(id).intValue();\n                        ownerId = new Integer(libid).intValue();\n                        title = \"title\";\n                        svF.setCatalogueRecordId(id);\n                        svF.setOwnerLibraryId(libid);\n                    }\n                    session.setAttribute(\"SingleViewExport\", vecThisPage);\n                    if (session.getAttribute(\"OnlySingleRec\") != null && session.getAttribute(\"OnlySingleRec\").toString().equals(\"true\")) {\n                        System.out.println(\"*************************************************************************** 11\");\n                        java.util.Vector v1 = new java.util.Vector();\n                        System.out.println(\"SEARCH MODE \" + searchmode);\n                        if (searchmode.equalsIgnoreCase(\"a\")) {\n                            System.out.println(\"*************************************************************************** 12\");\n                            System.out.println(\"SEARCHMODE IN SEARCH VIEW ACTION (IF) \" + searchmode);\n                            v1 = (java.util.Vector) request.getAttribute(\"LuceneVector\");\n                            System.out.println(\"VECTOR V1 \" + v1);\n                        } else {\n                            System.out.println(\"*************************************************************************** 13\");\n                            System.out.println(\"SEARCHMODE IN SEARCH VIEW ACTION (ELSE)\" + searchmode);\n                            v1 = (java.util.Vector) session.getAttribute(\"searchVec\");\n                        }\n                        Object[] obj = (Object[]) v1.elementAt(0);\n                        String str[] = (String[]) obj[0];\n                        java.util.Hashtable h = new java.util.Hashtable();\n                        String tit = \"\";\n                        h = (java.util.Hashtable) obj[1];\n                        System.out.println(\"HASH TABLE in view action \" + h);\n                        catId = new Integer(str[0]).intValue();\n                        ownerId = new Integer(str[1]).intValue();\n                        title = h.get(\"TITLE\").toString();\n                        svF.setAttachmentsAndUrl(\"\");\n                        if ((h.get(\"URL\").toString() != null && h.get(\"URL\").toString().equals(\"AVAILABLE\")) || (h.get(\"ATTACHMENTS\") != null && h.get(\"ATTACHMENTS\").equals(\"AVAILABLE\"))) {\n                            System.out.println(\"*************************************************************************** 14\");\n                            svF.setAttachmentsAndUrl(\"available\");\n                        }\n                        record = \"full\";\n                        recNo = \"1\";\n                        session.removeAttribute(\"OnlySingleRec\");\n                    }\n                    if (session.getAttribute(\"HostItemDisplay\") != null && session.getAttribute(\"HostItemDisplay\").equals(\"false\")) {\n                        System.out.println(\"*************************************************************************** 15\");\n                        session.removeAttribute(\"HostItemDisplay\");\n                    }\n                    session.setAttribute(\"Title\", title);\n                    System.out.println(\"Title...........................................\" + title);\n                    java.util.Hashtable hash1 = opacUt.getDetailsForSingleCatalogueRecord(catId, ownerId);\n                    System.out.println(\"hash1 ................................\" + hash1);\n                    vecThisPage.addElement(String.valueOf(catId));\n                    vecThisPage.addElement(String.valueOf(ownerId));\n                    svF.setAttachmentsAndUrl(\"\");\n                    if (hash1.get(\"URL\") != null && hash1.get(\"ATTACHMENTS\") != null && (hash1.get(\"URL\").toString().equals(\"AVAILABLE\") || hash1.get(\"ATTACHMENTS\").toString().equals(\"AVAILABLE\"))) {\n                        System.out.println(\"*************************************************************************** 16\");\n                        svF.setAttachmentsAndUrl(\"available\");\n                    }\n                    svF.setRecordNo(recNo);\n                    session.setAttribute(\"record\", record);\n                    java.util.Vector vecCO = (java.util.Vector) session.getAttribute(\"CatAndOwner\");\n                    svF.setCatCur(catId);\n                    svF.setOwnerCur(ownerId);\n                    svF.setPrevExists(\"no\");\n                    svF.setNextExists(\"no\");\n                    if (vecCO != null) {\n                        System.out.println(\"*************************************************************************** 17\");\n                        for (int j = 0; j < vecCO.size(); j = j + 4) {\n                            int c = new Integer(vecCO.elementAt(j).toString()).intValue();\n                            int o = new Integer(vecCO.elementAt(j + 1).toString()).intValue();\n                            if (c == catId && o == ownerId) {\n                                System.out.println(\"*************************************************************************** 18\");\n                                if (j != 0) {\n                                    System.out.println(\"*************************************************************************** 19\");\n                                    int catPrev = new Integer(vecCO.elementAt(j - 4).toString()).intValue();\n                                    int ownerPrev = new Integer(vecCO.elementAt(j - 3).toString()).intValue();\n                                    svF.setCatPrev(catPrev);\n                                    svF.setOwnerPrev(ownerPrev);\n                                    svF.setTitlePrev(vecCO.elementAt(j - 2).toString());\n                                    svF.setRecPrev(vecCO.elementAt(j - 1).toString());\n                                    svF.setPrevExists(\"yes\");\n                                }\n                                if (j < vecCO.size() - 4) {\n                                    System.out.println(\"*************************************************************************** 20\");\n                                    int catNext = new Integer(vecCO.elementAt(j + 4).toString()).intValue();\n                                    int ownerNext = new Integer(vecCO.elementAt(j + 5).toString()).intValue();\n                                    svF.setCatNext(catNext);\n                                    svF.setOwnerNext(ownerNext);\n                                    svF.setTitleNext(vecCO.elementAt(j + 6).toString());\n                                    svF.setRecNext(vecCO.elementAt(j + 7).toString());\n                                    svF.setNextExists(\"yes\");\n                                }\n                            }\n                        }\n                    }\n                    String str[] = (String[]) hash1.get(\"Biblo_Mat\");\n                    int bib_id = new Integer(str[0]).intValue();\n                    int mat_id = new Integer(str[1]).intValue();\n                    aportal.view.RecordView rv = new aportal.view.DesignFactory().getCorView(bib_id, mat_id, \"full\");\n                    String type = \"\";\n                    if (bib_id == 3 && mat_id == 1) {\n                        type = \"Book\";\n                    } else if (bib_id == 4 && mat_id == 1) {\n                        type = \"Serial\";\n                    } else if (bib_id == 1 && mat_id == 1) {\n                        type = \"Book Chapter\";\n                    } else if (bib_id == 2 && mat_id == 1) {\n                        type = \"Serial Article\";\n                    } else {\n                        type = ejb.bprocess.util.TypeDefinition.getInstance().getTypeDefinition(String.valueOf(bib_id), String.valueOf(mat_id));\n                    }\n                    java.util.Hashtable hMono = (java.util.Hashtable) hash1.get(\"MonoGraphRecords\");\n                    java.util.Hashtable h4 = rv.getView(hash1);\n                    h4.put(\"Type\", type);\n                    try {\n                        String sessionid = request.getSession().getId();\n                        ejb.bprocess.holdings.HoldingsStatement holdingsStatement = ((ejb.bprocess.holdings.HoldingsStatementHome) ejb.bprocess.util.HomeFactory.getInstance().getRemoteHome(\"HoldingsStatement\")).create();\n                        java.util.Vector vecLib = new java.util.Vector();\n                        vecLib.addElement(\"1\");\n                        if (session.getAttribute(\"Libraries\") != null) {\n                            System.out.println(\"*************************************************************************** 21\");\n                            vecLib = (java.util.Vector) session.getAttribute(\"Libraries\");\n                        }\n                        String libIds = libid;\n                        request.setAttribute(\"catRecId\", String.valueOf(catId));\n                        request.setAttribute(\"ownLibId\", String.valueOf(ownerId));\n                        request.setAttribute(\"libIds\", String.valueOf(libIds));\n                        svF.setHashSing(h4);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        } else if (svF.getExportRec() != null && svF.getExportRec().equals(\"export\")) {\n            System.out.println(\"*************************************************************************** 22\");\n            svF.setExportRec(null);\n            vecThisPage = (java.util.Vector) session.getAttribute(\"SingleViewExport\");\n            String format = svF.getSf();\n            if (format.equals(\"marc\")) {\n                String marc = opacUt.getDetailsForMultiRecordViewMARC(vecThisPage);\n                svF.setDisplayFormat(marc);\n                session.setAttribute(\"RecordDisplay\", marc);\n                forward = \"RecordFormat\";\n            } else if (format.equals(\"marcXml\")) {\n                String marcXML = opacUt.getDetailsForMultiRecordViewMARCXML(vecThisPage);\n                svF.setDisplayFormat(marcXML);\n                response.setContentType(\"text/xml\");\n                session.setAttribute(\"RecordDisplay\", marcXML);\n                forward = \"RecordFormat\";\n            } else if (format.equals(\"mods\")) {\n                String mods = opacUt.getDetailsForMultiRecordViewMODS(vecThisPage);\n                svF.setDisplayFormat(mods);\n                session.setAttribute(\"RecordDisplay\", mods);\n                forward = \"RecordFormat\";\n            } else if (format.equals(\"dc\")) {\n                String dc = opacUt.getDetailsForMultiRecordViewDublinCore(vecThisPage);\n                svF.setDisplayFormat(dc);\n                session.setAttribute(\"RecordDisplay\", dc);\n                forward = \"RecordFormat\";\n            } else if (format.equals(\"agris\")) {\n                String agr = opacUt.getDetailsForMultiRecordViewAgris(vecThisPage);\n                svF.setDisplayFormat(agr);\n                session.setAttribute(\"RecordDisplay\", agr);\n                forward = \"RecordFormat\";\n            } else if (format.equals(\"text\")) {\n                java.util.Vector vecTextDis = new java.util.Vector();\n                for (int i2 = 0; i2 < vecThisPage.size(); i2 = i2 + 2) {\n                    java.util.Hashtable hash1 = opacUt.getDetailsForSingleCatalogueRecord(new Integer(vecThisPage.elementAt(i2).toString()).intValue(), new Integer(vecThisPage.elementAt(i2 + 1).toString()).intValue());\n                    aportal.view.ISBDView fullView = new aportal.view.ISBDView();\n                    java.util.Hashtable hashCit = fullView.getView(hash1);\n                    vecTextDis.addElement(hashCit);\n                    forward = \"RecordFormatText\";\n                }\n                session.setAttribute(\"RecordTextDisplay\", vecTextDis);\n                if (svF.getPs() != null && svF.getPs().equals(\"email\")) {\n                    boolean flag = false;\n                    if (svF.getEmail() != null && !(svF.getEmail().equals(\"\"))) {\n                        String emailId = svF.getEmail();\n                        try {\n                            String sessionid = request.getSession().getId();\n                            java.net.URL url = new java.net.URL(\"http://localhost:\" + request.getServerPort() + \"/newgenlibctxt/jsp/aportal/cataloguing/RecordDisplayText.jsp;jsessionid=\" + sessionid);\n                            java.net.URLConnection urlCon = url.openConnection();\n                            java.io.InputStream is = urlCon.getInputStream();\n                            String htmlContent = \"\";\n                            java.io.BufferedReader br = new java.io.BufferedReader(new java.io.InputStreamReader(is));\n                            String line = \"\";\n                            while ((line = br.readLine()) != null) {\n                                htmlContent = htmlContent + line;\n                            }\n                            flag = ((ejb.bprocess.util.DispatchEmailHome) ejb.bprocess.util.HomeFactory.getInstance().getRemoteHome(\"DispatchEmail\")).create().dispatchEmail(null, emailId, \"OPAC results\", htmlContent);\n                        } catch (Exception exp) {\n                            exp.printStackTrace();\n                        }\n                    }\n                    String mailMessage = \"The selected records have been successfully mailed to \" + svF.getEmail();\n                    if (flag == false) {\n                        mailMessage = \"<h4><p>The selected records could not be mailed to \" + svF.getEmail() + \"&nbsp; These might be the possible reasons.</p></h4>\" + \"<h5><ol> <li>The email id entered is not a valid one</font></li>\" + \"<li>The email id domain might not be in the list of allowed  recipient&nbsp; hosts</li>\" + \"<li>There might a error in connectivity to the mail server</li></ol></h5>\" + \"<h4><p>Please contact the  Network Administrator </p></h4>\";\n                    }\n                    session.setAttribute(\"MailStatus\", mailMessage);\n                    forward = \"SendEmail\";\n                }\n            }\n        }\n        String version = ejb.bprocess.util.StaticValues.getInstance().getVersion();\n        if (version != null && !version.equals(\"\")) {\n            svF.setVersion(version);\n        }\n        if (session.getAttribute(\"ClassNoForwarded\") != null) {\n            session.removeAttribute(\"ClassNoForwarded\");\n        }\n        System.out.println(\"final forward is ......................... \" + forward);\n        return mapping.findForward(forward);\n    }\n", "label": 0, "substitutes": {"url": ["host", "id", "site", "link", "connection", "feed", "io", "src", "l", "http", "b", "f", "loader", "base", "data", "channel", "ref", "stream", "class", "zip", "resource", "server", "config", "address", "name", "e", "bb", "api", "ource", "a", "string", "path", "image", "load", "html", "file", "uri", "i", "ssl", "URL", "service", "hub", "Url", "www", "web", "sl"], "source": ["parent", "reader", "size", "input", "connection", "result", "iter", "ser", "io", "src", "from", "object", "inf", "Source", "part", "f", "loader", "base", "data", "stream", "class", "storage", "resource", "config", "inner", "parser", "text", "instance", "ource", "api", "status", "sin", "SOURCE", "slice", "string", "session", "seed", "file", "parse", "uri", "i", "service", "proxy", "use", "unit"], "info": ["py", "id", "txt", "Info", "result", "io", "fo", "properties", "http", "inf", "part", "f", "base", "data", "to", "afi", "auto", "zip", "handler", "inner", "information", "init", "ui", "parser", "api", "slice", "INFO", "list", "obj", "parse", "file", "i", "ii", "uri", "is", "bis", "start", "iso", "type"], "parts": ["resources", "works", "relations", "states", "tests", "ks", "points", "reports", "things", "pieces", "sections", "lines", "keys", "items", "pins", "params", "http", "types", "part", "ions", "data", "objects", "changes", "stats", "es", "posts", "shared", "inner", "hours", "groups", "component", "plugins", "ins", "results", "patch", "pages", "members", "parser", "api", "versions", "words", "headers", "ops", "features", "ants", "its", "apps", "details", "files", "pi", "ds", "services", "shows", "bis", "workers", "dates", "bits", "rots", "ps", "Parts", "series", "arts"]}}
{"id1": "12264242", "id2": "16324555", "code1": "    public static String generateSHA1(final String data) {\n        final StringBuilder hash = new StringBuilder(40);\n        try {\n            final MessageDigest sha1 = MessageDigest.getInstance(\"sha1\");\n            sha1.update(data.getBytes());\n            final byte[] digest = sha1.digest();\n            for (byte aDigest : digest) {\n                String hex = Integer.toHexString(aDigest);\n                if (hex.length() == 1) {\n                    hex = \"0\" + hex;\n                }\n                hex = hex.substring(hex.length() - 2);\n                hash.append(hex);\n            }\n        } catch (NoSuchAlgorithmException e) {\n        }\n        return hash.toString();\n    }\n", "code2": "    public static String gerarDigest(String mensagem) {\n        String mensagemCriptografada = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            System.out.println(\"Mensagem original: \" + mensagem);\n            md.update(mensagem.getBytes());\n            byte[] digest = md.digest();\n            mensagemCriptografada = converterBytesEmHexa(digest);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return mensagemCriptografada;\n    }\n", "label": 1, "substitutes": {"data": ["source", "reader", "input", "binary", "connection", "buffer", "result", "message", "output", "format", "this", "base", "bytes", "response", "raw", "address", "info", "sha", "body", "DATA", "results", "batch", "json", "text", "a", "picture", "content", "key", "string", "image", "cache", "array", "database", "video", "str", "dat"], "hash": ["host", "ash", "h", "cb", "url", "memory", "how", "ha", "buffer", "build", "message", "dump", "object", "this", "over", "base", "version", "print", "response", "sum", "sh", "her", "address", "sha", "body", "json", "log", "height", "copy", "temp", "key", "book", "history", "string", "html", "db", "check", "code", "builder", "array", "header", "block", "Hash", "str", "square"], "sha1": ["SHAone", "mdone", "sa256", "sha256", "haone", "alphaone", "shaache", "alpha1", "ha1", "mc1", "SHA3", " SHAone", "sha81", "SHA81", "SHA4", "shaone", "mcone", "sa4", "sa1", "hash2", "SHA2", " SHA1", "md1", "ha256", "alpha4", "alpha3", "mc3", "md256", "sha4", "ha2", " SHAache", "SHAache", "hashone", "SHA256", "alpha81", "SHA1", " SHA2", "hash1", "hashache", "sha3", "md2", "sha2", "alpha256", "mc81"], "digest": ["signests", "digester", "digests", "signester", "generit", "digum", " digests", " digit", "dimest", "digit", "signested", "sumester", "sumum", "generest", " digum", "Digester", "dimester", "Digested", "sumest", "generester", " digester", "dimests", "dimested", "signest", "generum", "digested", " digested", "Digests", "Digest", "sumit"], "aDigest": ["bdigest", "adigests", "bDigestation", "bDigests", "aDigests", "bdigests", "aRobester", "aDigestation", "aDigEST", "bdigested", "adigesting", "aDigester", "aDigesting", "aDest", "bDigesting", "bDigest", "aDested", "bdigestation", "adigestation", "bDigester", "bdigesting", "adigest", "adigEST", "aRobestation", "bdigEST", "bDigested", "aDigested", "aRobest", "bdigester", "adigester", "aRobEST", "adigested", "aDesting", "bDigEST", "aDests"], "hex": ["loop", "pack", " Hex", "zip", "he", "tx", "ph", "temp", "oct", "coord", "alpha", "dig", "ip", "pixel", "build", "rex", "iter", "digit", "object", "pex", "shape", "it", "batch", "pattern", "exp", "act", "length", "ex", "key", "zero", "ctr", "str", "hack", "ext", "parent", "none", "lit", "buff", "hook", "http", "wh", "serial", "raw", "sex", "x", "sha", "cross", "cookie", "text", "bit", "height", "string", "xxxxxxxx", "null", "xf", "utf", "head", "host", "shift", "h", "letter", "format", "view", "char", "nexus", "comp", "json", "transform", "rh", "com", "check", "built", "code", "character", "form", "bin"]}}
{"id1": "22197335", "id2": "12759328", "code1": "    private void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    final void importSelectedEntity() {\n        TreePath path = projectsTree.getSelectionPath();\n        DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) path.getLastPathComponent();\n        Object userObject = selectedNode.getUserObject();\n        if (userObject instanceof ProjectSet) {\n            JFileChooser fileChooser = new JFileChooser();\n            fileChooser.setMultiSelectionEnabled(false);\n            fileChooser.setFileFilter(new FileNameExtensionFilter(\"JFPSM Projects\", \"jfpsm.zip\"));\n            int result = fileChooser.showOpenDialog(mainWindow.getApplicativeFrame());\n            if (result == JFileChooser.APPROVE_OPTION) {\n                String fullname = fileChooser.getSelectedFile().getName();\n                String projectName = fullname.substring(0, fullname.length() - Project.getFileExtension().length());\n                ProjectSet workspace = (ProjectSet) userObject;\n                boolean confirmLoad = true;\n                if (Arrays.asList(workspace.getProjectNames()).contains(projectName)) {\n                    confirmLoad = JOptionPane.showConfirmDialog(mainWindow.getApplicativeFrame(), \"Overwrite project \\\"\" + projectName + \"\\\"\" + \"?\", \"Overwrite project\", JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION;\n                    if (confirmLoad) {\n                        final int count = selectedNode.getChildCount();\n                        DefaultMutableTreeNode projectNode = null;\n                        for (int i = 0; i < count; i++) if (((Project) ((DefaultMutableTreeNode) selectedNode.getChildAt(i)).getUserObject()).getName().equals(projectName)) {\n                            projectNode = (DefaultMutableTreeNode) selectedNode.getChildAt(i);\n                            break;\n                        }\n                        Project project = (Project) projectNode.getUserObject();\n                        for (FloorSet floorSet : project.getLevelSet().getFloorSetsList()) for (Floor floor : floorSet.getFloorsList()) mainWindow.getEntityViewer().closeEntityView(floor);\n                        for (Tile tile : project.getTileSet().getTilesList()) mainWindow.getEntityViewer().closeEntityView(tile);\n                        workspace.removeProject(project);\n                        ((DefaultTreeModel) projectsTree.getModel()).removeNodeFromParent(projectNode);\n                    }\n                }\n                if (confirmLoad) {\n                    File projectFile = new File(workspace.createProjectPath(projectName));\n                    boolean success = true;\n                    try {\n                        success = projectFile.createNewFile();\n                        if (success) {\n                            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileChooser.getSelectedFile()));\n                            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(projectFile));\n                            byte[] buf = new byte[1024];\n                            int len;\n                            while ((len = bis.read(buf)) > 0) bos.write(buf, 0, len);\n                            bis.close();\n                            bos.close();\n                        }\n                    } catch (Throwable throwable) {\n                        displayErrorMessage(throwable, false);\n                        success = false;\n                    }\n                    if (success) addProject(projectName);\n                }\n            }\n        } else if (userObject instanceof Map) {\n            Map map = (Map) userObject;\n            Floor floor = (Floor) ((DefaultMutableTreeNode) selectedNode.getParent()).getUserObject();\n            importImageForSelectedMap(floor, map);\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "sb", "url", "input", "txt", "upload", "download", "sit", "inf", "b", "loc", "stab", "stream", "sc", "config", "dest", "sup", "filename", "ins", "rc", "inst", "ls", "sin", "slice", "path", "rl", "obj", "file", "uri", "files", "sq", "dist", "img", "sn", "proxy", "s", "rb"], "dst": ["sdst", " dsts", "dsts", "dST", "dsrc", "nsts", "adct", "rdft", "nst", "Ddest", "adst", "sdsrc", "ndest", "rdsrc", "rdct", "adft", "DST", "rdst", "Dsts", " ddest", " dST", "dft", "dct", "adsrc", "Dst", "nST", "ddest", "sdft", "sdct"], "in": ["source", "reader", "id", "url", "input", "inc", "din", "ln", "trans", "win", "pull", "nin", "conn", "con", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "stream", "inner", "init", "ins", "gin", "ini", "kin", "sin", "up", "cin", "socket", "file", "i", "IN", "inside", "inn", "rin", "is", "lin", "bin"], "out": ["parent", "trans", "inc", "net", "io", "output", "outer", "conn", "lib", "w", "client", "part", "data", "n", "Out", "OUT", "outs", "again", "server", "raw", "call", "writer", "off", "exec", "sync", "o", "other", "exp", "log", "ex", "post", "up", "pool", "obj", "cache", "file", "i", "err", "cos", "at", "img", "self", "bin", "copy", "ext"], "buf": ["cb", "tmp", "queue", "bf", "bh", "uc", "buffer", "buff", "br", "lim", "b", "cmd", "bc", "fd", "loc", "cv", "base", "data", "bd", "ref", "bytes", "ctx", "box", "raw", "pad", "off", "func", "batch", "rc", "bb", "length", "seq", "uf", "cap", "bag", "orig", "c", "vec", "fb", "ff", "bn", "bin", "rb", "bp"], "len": ["size", "split", "en", "id", "num", "ln", "lf", "ind", "iter", "min", "limit", "lim", "l", "end", "val", "fd", "part", "f", "base", "Len", "data", "no", "n", "enc", "off", "el", "body", "nt", "length", "cap", "lc", "li", "fl", "le", "all", "dy", "count", "c", "rev", "err", "pos", "fin", "line"]}}
{"id1": "698010", "id2": "5795551", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        System.setProperty(\"debug\", \"debug\");\n        OAuthConsumer consumer = new DefaultOAuthConsumer(\"YmRF4HDvikvwDxYafsaK\", \"r)q7L!4X$j$nTS0lXAjC=al9Xf*cLOdyFJsy%2OE\");\n        consumer.setTokenWithSecret(\"5722da60fee79ef9efc2d383f871d550\", \"39142f31ad8a7e6ff7b87f36cc9e8f10\");\n        URL url = new URL(\"http://api.t.sohu.com/statuses/update.json\");\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        HttpParameters para = new HttpParameters();\n        para.put(\"status\", URLEncoder.encode(\"\u4e2d \u6587\", \"utf-8\").replaceAll(\"\\\\+\", \"%20\"));\n        consumer.setAdditionalParameters(para);\n        consumer.sign(request);\n        OutputStream ot = request.getOutputStream();\n        ot.write((\"status=\" + URLEncoder.encode(\"1\u4e2d \u6587\", \"utf-8\")).replaceAll(\"\\\\+\", \"%20\").getBytes());\n        ot.flush();\n        ot.close();\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 1, "substitutes": {"view": ["page", "head", "sel", "reader", "input", "display", "link", "user", "layout", "buffer", "review", "widget", "http", "object", "out", "client", "request", "cell", "this", "model", "row", "base", "f", "ou", "by", "style", "View", "box", "server", "config", "template", "can", "el", "section", "update", "body", "event", "ui", "full", "e", "query", "VIEW", "see", "container", "edit", "screen", "show", "up", "session", "window", "index", "v", "image", "change", "gu", "cache", "vis", "html", "lock", "check", "im", "list", "vol", "manager", "block", "self", "group", "views", "form", "port", "use"], "url": ["source", "host", "page", "id", "link", "web", "browser", "connection", "open", "buffer", "download", "l", "http", "ul", "client", "b", "base", "f", "loader", "channel", "data", "stream", "zip", "resource", "email", "server", "address", "config", "name", "ob", "log", "length", "location", "job", "string", "path", "image", "socket", "file", "uri", "ssl", "fb", "builder", "URL", "hub", "Url", "www", "position", "blog", "gl", "jar", "sl"], "in": ["source", "reader", "input", "inc", "din", "arin", "win", "buffer", "doc", "nin", "con", "out", "b", "login", "as", "on", "data", "In", "pin", "stream", "again", "resource", "isin", "inner", "init", "ins", "ini", "sin", "cin", "socket", "file", "IN", "inn", "rin", "is", "bis", "lin", "s", "ac"], "bin": ["source", "reader", "an", "ban", "input", "binary", "din", "browser", "win", "abi", "connection", "buffer", "lib", "con", "out", "b", "login", "loader", "pin", "ruby", "bi", "inner", "oin", "body", "init", "bb", "spin", "gin", "ini", "kin", "run", "sin", "cin", "lock", "socket", "record", "file", "cache", "IN", "inside", "inn", "is", "nb", "lin", "bn", "bot", "fin"], "line": ["page", "entry", "id", "nl", "link", "user", "pe", "column", "lf", "range", "lines", "l", "letter", "definition", "out", "b", "val", "LINE", "cell", "end", "Line", "row", "base", "part", "data", "ine", "pin", "inline", "el", "section", "word", "name", "ge", "e", "unit", "log", "cl", "text", "comment", "lc", "job", "status", "le", "key", "up", "string", "file", "parse", "code", "service", "block", "lin", "look", "str", "ip", "type"], "version": ["vision", "id", "VERSION", "product", "download", "pull", "plugin", "username", "dev", "python", "format", "license", "driver", "Version", "description", "bug", "model", "ver", "cover", "feature", "server", "info", "section", "update", "filename", "name", "null", "patch", "versions", "beta", "v", "release", "string", "image", "vert", "install", "code", "date", "secret", "type", "video", "position", "option", "project", "value", "unit"], "build": ["how", "rel", "pull", "uild", "home", "bug", "row", "ver", "base", "Build", "style", "print", "clean", "work", "push", "info", "where", "hold", "update", "tag", "name", "patch", "log", "length", "comment", "job", "building", "show", "run", "release", "image", "help", "install", "lock", "make", "load", "built", "builder", "label", "block", "valid", "boot", "follow", "add", "test", "use", "unit"]}}
{"id1": "15766371", "id2": "5221377", "code1": "    public static String encodeMD5(String s) throws NoSuchAlgorithmException {\n        MessageDigest m = null;\n        String result = null;\n        m = MessageDigest.getInstance(\"MD5\");\n        m.update(s.getBytes(), 0, s.length());\n        result = new BigInteger(1, m.digest()).toString(16);\n        if (result.length() == 31) {\n            result = \"0\" + result;\n        }\n        return result;\n    }\n", "code2": "    public File unpackResource(String resourceName) throws IOException {\n        File file = null;\n        URL url = getURL(\"/\" + resourceName);\n        URLConnection urlConn = url.openConnection();\n        if (urlConn instanceof JarURLConnection) {\n            file = handleJarFile((JarURLConnection) urlConn, resourceName);\n        } else if (urlConn instanceof BundleURLConnection) {\n            file = handleBundleFile((BundleURLConnection) urlConn);\n        } else {\n            file = handleClassicFile(resourceName);\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"s": ["source", "tests", "strings", "ings", "h", "sb", "d", "si", "lines", "ss", "l", "params", "gs", "b", "ns", "f", "data", "bytes", "os", "n", "storage", "es", "js", "sync", "sets", "results", "e", "o", "spec", "t", "sv", "a", "ls", "words", "v", "string", "ssl", "i", "g", "ses", "is", "ds", "services", "parts", "S", "ps", "p"], "m": ["h", "um", "d", "cm", "mut", "message", "sm", "mm", "man", "l", "am", "ms", "ym", "f", "bm", "mo", "mac", "arm", "r", "hm", "mu", "wm", "mand", "mi", "mc", "module", "machine", "u", "e", "dm", "gm", "rm", "o", "t", "mt", "M", "v", "pm", "tm", "mr", "vm", "im", "i", "g", "manager", "fm", "md", "em", "nm", "me", "p"], "result": ["source", "div", "parent", "value", "str", "url", "default", "continue", "term", "success", "product", "Result", "br", "message", "output", "card", "format", "alpha", "request", "score", "diff", "root", "description", "data", "style", "response", "r", "match", "master", "ret", "sum", "feature", "info", "gi", "work", "section", "word", "results", "report", "json", "length", "text", "comment", "status", "up", "string", "cache", "answer", "error", "err", "search", "date", "mer", "valid", "array", "goal", "current", "account", "reason", "test", "res", "null", "pass"]}}
{"id1": "20026764", "id2": "20254498", "code1": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum lang) throws IOException {\n        File tempFile = File.createTempFile(\"oss\", \".pptx\");\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(tempFile);\n            IOUtils.copy(streamLimiter.getNewInputStream(), fos);\n            fos.close();\n        } catch (IOException e) {\n            if (fos != null) IOUtils.closeQuietly(fos);\n            throw e;\n        }\n        try {\n            XSLFSlideShow pptSlideShow = new XSLFSlideShow(tempFile.getAbsolutePath());\n            XSLFPowerPointExtractor poiExtractor = new XSLFPowerPointExtractor(pptSlideShow);\n            CoreProperties info = poiExtractor.getCoreProperties();\n            if (info != null) {\n                addField(ParserFieldEnum.title, info.getTitle());\n                addField(ParserFieldEnum.creator, info.getCreator());\n                addField(ParserFieldEnum.subject, info.getSubject());\n                addField(ParserFieldEnum.description, info.getDescription());\n                addField(ParserFieldEnum.keywords, info.getKeywords());\n            }\n            String content = poiExtractor.getText(true, true);\n            addField(ParserFieldEnum.content, StringUtils.replaceConsecutiveSpaces(content, \" \"));\n            langDetection(10000, ParserFieldEnum.content);\n        } catch (OpenXML4JException e) {\n            throw new IOException(e);\n        } catch (XmlException e) {\n            throw new IOException(e);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PrintStream filesTxt = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"temp/index/files.txt\")));\n        String[] files = new File(Constants.INDEX_PATH).list();\n        for (int i = 0; i < files.length; i++) {\n            String f = files[i];\n            if (f.equals(\"deletable\") || f.startsWith(\".\")) continue;\n            FileInputStream in = new FileInputStream(new File(Constants.INDEX_PATH, f));\n            FileOutputStream out = new FileOutputStream(new File(targetDir, f + \".t\"));\n            byte[] buf = new byte[16384];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n            in.close();\n            out.close();\n            filesTxt.println(f);\n        }\n        filesTxt.close();\n    }\n", "label": 1, "substitutes": {"streamLimiter": ["streamLimitter", "formLimititter", " streamLimite", "streamlimiter", "streamLockiter", "streamLimititter", "streamLimitise", "streamLimitite", "formLimititer", "streamLockise", "streamlimitter", " streamLimiting", "streamLockitter", "formLimise", "streamLockite", "streamLimiting", "formLimitter", "streamLimititer", "formLimite", "streamlimiting", "streamLimite", " streamLimitter", "formLimitite", "formLimiter", "formLimitise", "streamlimite", "streamLimititing", "streamLimise"], "lang": ["language", "lp", "en", "nl", "default", "ln", "ang", "la", "util", "xml", "l", "lib", "format", "Language", "lr", "gen", "base", "loader", "loc", "class", "enc", "config", "name", "parser", "lc", "ml", "local", "lin", "type"], "tempFile": ["fakePath", "localfile", "tempPath", " temporaryFile", " tempfile", "loadFILE", " temporaryPath", " tempPath", "TempFile", "TempF", "TempDie", "tempDie", "TempPath", "poraryPath", " temporaryfile", " temporaryDie", "loadfile", "tempStream", "fakeFile", "tempF", "tempfile", "fakeF", "poraryfile", "loadFile", "TempFILE", "localFILE", "fakefile", "Tempfile", "TempStream", "loadStream", "poraryFile", " tempDie", "poraryF", "tempFILE", "localStream", "localFile"], "fos": [" fros", "Foes", "Foos", "afo", "infOS", "Fops", " fs", "eos", " foes", "cfoS", "tos", "afaos", " flos", " foos", "flos", " fOS", "fros", "fs", "Fos", " fops", "tlos", "fo", "Fols", "fols", "fops", "afos", "Fros", "tOS", "infos", "Fo", "cfs", " fis", "FoS", " faos", "Faos", "foS", "infros", "infoos", " foS", "Fis", "FOS", "cfos", "tis", "taos", "Fs", "infis", "fOS", "faos", " fols", "foos", "cfops", "fis", "eoes", "tols", "infaos", "afros", "eros", "inflos", "eaos", "foes"], "pptSlideShow": ["pptSliderInfo", "pptSliseShow", "pptSlideHide", "pptSLideShow", "pptPlideShow", "pptSLidingOpen", "pptSlidingView", "pptSlideView", "pptSladeShow", "pptSlideInfo", "pptPliseInfo", "pptSLideInfo", "pptPlideInfo", "pptSladeView", "pptSlideOpen", "pptSLidingShow", "pptSlidesOpen", "pptPliseHide", "pptSlidesInfo", "pptSLidingView", "pptSliseHide", "pptSliderShow", "pptSLidingInfo", "pptSliteShow", "pptPliseShow", "pptSlidesShow", "pptSlidesView", "pptSlidingShow", "pptSLideView", "pptSliteInfo", "pptSladeInfo", "pptSladeOpen", "pptSliteHide", "pptSliderHide", "pptSlidingInfo", "pptSLideOpen", "pptSlidingOpen", "pptSliseInfo", "pptPlideHide"], "poiExtractor": ["poIextractor", "poIextrator", "poiExtraction", "poiextractor", "poiExtrator", "poiextraction", "poixtrator", "popiExtraction", "poiExtract", "popixtract", "popiExtractor", "poIExtract", "popixtractor", "poIExtrator", "popixtraction", "poiIntractor", "poiIntor", "poiExractor", "poiExract", "poiExrator", "poixtract", "poIExtor", "poiExraction", "poixtor", "poIExtraction", "poixtractor", "poiextrator", "popixtor", "poiIntract", "popiExtor", "poIextraction", "poiExtor", "poiIntrator", "poIextract", "poiextor", "poiExor", "poixtraction", "poIExtractor", "poiextract", "poIextor", "popiExtract"], "info": ["options", "plus", "py", "id", "about", "success", "admin", "Info", "buff", "result", "extra", "now", "hi", "fo", "properties", "http", "jo", "inf", "b", "diff", "home", "bug", "part", "maybe", "f", "base", "def", "data", "by", "state", "afi", "fw", "zip", "available", "thin", "auto", "handler", "config", "inner", "off", "conf", "update", "aff", "information", "init", "ui", "full", "project", "json", "api", "fields", "index", "string", "INFO", "internal", "help", "obj", "error", "i", "end", "details", "is", "metadata", "good", "iso", "type"], "content": ["language", "source", "page", "translation", "read", "str", "url", "txt", "xml", "Content", "message", "output", "conn", "format", "description", "data", "version", "resource", "work", "config", "address", "section", "activity", "word", "script", "children", "desc", "body", "name", "currency", "component", "report", "cont", "password", "text", "comment", "string", "path", "media", "image", "help", "load", "html", "file", "document", "code", "title", "label", "header", "current", "value", "type"]}}
{"id1": "19434892", "id2": "18778239", "code1": "            public void handle() {\n                if (requestCounter == 0) {\n                    requestCounter++;\n                    return;\n                }\n                requestCounter++;\n                Iterator it = loggerTimeouts.keySet().iterator();\n                while (it.hasNext()) {\n                    String host = (String) it.next();\n                    String timeout = (String) loggerTimeouts.get(host);\n                    int timeoutVal = Integer.parseInt(timeout);\n                    if (timeoutVal > 0) {\n                        timeoutVal /= 10;\n                    }\n                    int timeoutMod = (requestCounter % timeoutVal);\n                    if (timeoutMod == 0) {\n                        Object loggerFile = loggerFiles.get(host);\n                        Object loggerFilenameObject = loggerFilenames.get(host);\n                        Object loggerDestObject = loggerDests.get(host);\n                        Object loggerCompressObject = loggerCompresses.get(host);\n                        Object loggerDayObject = loggerDays.get(host);\n                        Object loggerArchiveObject = loggerArchives.get(host);\n                        Object loggerDeleteObject = loggerDeletes.get(host);\n                        boolean rotateCompress = false;\n                        boolean rotateDelete = false;\n                        String rotateDest = null;\n                        String logFile = null;\n                        String rotateArchive = null;\n                        int rotateDays = 0;\n                        if (loggerCompressObject != null && ((String) loggerCompressObject).equalsIgnoreCase(\"true\")) {\n                            rotateCompress = true;\n                        }\n                        if (loggerDeleteObject != null && ((String) loggerDeleteObject).equalsIgnoreCase(\"true\")) {\n                            rotateDelete = true;\n                        }\n                        if (loggerDestObject != null) {\n                            rotateDest = (String) loggerDestObject;\n                        }\n                        if (loggerFilenameObject != null) {\n                            logFile = (String) loggerFilenameObject;\n                        }\n                        if (loggerArchiveObject != null) {\n                            rotateArchive = (String) loggerArchiveObject;\n                        }\n                        if (loggerDayObject != null) {\n                            rotateDays = Integer.parseInt((String) loggerDayObject);\n                        }\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                                buf = null;\n                                out = null;\n                                in = null;\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"' to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                destChannel = null;\n                                srcChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data from file '\" + logFile + \"' to '\" + destOutFile + \"' for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete) {\n                            try {\n                                ((PrintStream) loggerFile).close();\n                            } catch (Exception e) {\n                            }\n                            (new File(logFile)).delete();\n                            loggerFiles.remove(host);\n                            addLogger(host, logFile);\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            fileList = null;\n                            format1 = null;\n                            archive = null;\n                        }\n                    }\n                }\n                it = null;\n            }\n", "code2": "    public void init() {\n        File[] configsDirectories = { XPontusConstantsIF.XPONTUS_PLUGINS_DATA_DIR, XPontusConstantsIF.XPONTUS_PREFERENCES_DIR, XPontusConstantsIF.XPONTUS_DATABASE_CONFIG_DIR, XPontusConstantsIF.XPONTUS_PLUGINS_DIR, XPontusConstantsIF.XPONTUS_CACHE_DIR };\n        for (int i = 0; i < configsDirectories.length; i++) {\n            if (!configsDirectories[i].exists()) {\n                configsDirectories[i].mkdirs();\n            }\n        }\n        String[] locations = { \"/net/sf/xpontus/configuration/editorPanel.properties\", \"/net/sf/xpontus/configuration/general.properties\", \"/net/sf/xpontus/configuration/mimetypes.properties\" };\n        try {\n            for (String loc : locations) {\n                String outName = FilenameUtils.getName(loc);\n                File output = new File(XPontusConstantsIF.XPONTUS_PREFERENCES_DIR, outName);\n                if (!output.exists()) {\n                    if (loc.equals(locations[0])) {\n                        Properties hackProps = new Properties();\n                        InputStream is = getClass().getResourceAsStream(loc);\n                        hackProps.load(is);\n                        Font hackFont = UIManager.getFont(\"EditorPane.font\");\n                        StrBuilder strFont = new StrBuilder();\n                        strFont.append(hackFont.getFamily() + \",\" + hackFont.getStyle() + \",\" + hackFont.getSize());\n                        hackProps.put(\"EditorPane.Font\", strFont.toString());\n                        OutputStream out = new FileOutputStream(output);\n                        hackProps.store(out, null);\n                        out.close();\n                        is.close();\n                    } else {\n                        InputStream is = getClass().getResourceAsStream(loc);\n                        OutputStream out = new FileOutputStream(output);\n                        IOUtils.copy(is, out);\n                        out.close();\n                        is.close();\n                    }\n                }\n                if (!outName.equals(\"mimetypes.properties\")) {\n                    Properties m_properties = PropertiesConfigurationLoader.load(output);\n                    Iterator it = m_properties.keySet().iterator();\n                    while (it.hasNext()) {\n                        Object m_key = it.next();\n                        Object m_value = m_properties.get(m_key);\n                        XPontusConfig.put(m_key, m_value);\n                    }\n                }\n            }\n        } catch (Exception err) {\n            err.printStackTrace();\n        }\n        Properties m_props = PropertiesConfigurationLoader.load(XPontusConfigurationConstantsIF.EDITOR_PREFERENCES_FILE);\n        String[] f = m_props.get(\"EditorPane.Font\").toString().split(\",\");\n        String family = f[0].trim();\n        String style1 = f[1].trim();\n        int style = Integer.parseInt(style1);\n        int size = Integer.parseInt(f[2].trim());\n        Font m_font = new Font(family, style, size);\n        XPontusConfig.put(\"EditorPane.Font\", m_font);\n        Map map = new HashMap();\n        map.put(ROLE, this);\n        PropertiesHolder.registerProperty(XPontusSettings.KEY, map);\n        DockableContainerFactory.setFactory(new XPontusDockableContainerFactory());\n        FileHistoryList.init();\n        initDefaultSettings();\n    }\n", "label": 1, "substitutes": {"requestCounter": ["responseNum", "RequestNumber", "RequestCounter", "requestcounter", "responseClock", " requestNum", " requestClock", "resourceCount", "reqcounter", "responsecounter", "reqNum", "responseCount", "reqNumber", "requestClock", "reqCounter", "requestNumber", "RequestCount", "RequestClock", "requestNum", " requestcounter", "requestCount", " requestNumber", "reqCount", "resourceCounter", "resourceClock", " requestCount", "resourceNumber", "responseNumber", "responseCounter"], "it": ["split", "id", "si", "ic", "lit", "the", "ind", "itted", "sit", "iter", "ati", "itter", "mit", "end", "iz", "you", "st", "jit", " It", "p", "pit", "set", "I", "master", "ti", "IT", "he", "It", "iv", "ite", "init", "edit", "ci", "iti", "nt", "they", "ort", "t", "ait", "index", "quit", "slice", "ut", "its", "itting", "ble", "or", "start", "which", "et", "ITS", "op", "rit", "entry"], "host": ["source", "head", "hop", "h", "url", "default", "user", "hour", "Host", "connection", "feed", "conn", "format", "http", "request", "cmd", "client", "state", "object", "driver", "owner", "home", "bug", "hello", "loop", "mac", "part", "loc", "remote", "response", "prefix", "handler", "server", "config", "address", "condition", "box", "chrom", "xx", "name", "method", "component", "query", "project", "large", "target", "device", "container", "cont", "pattern", "dr", "content", "localhost", "post", "key", "path", "node", "docker", "connect", "socket", "uri", "service", "header", "database", "hub", "addr", "subject", "domain", "proxy", "ctor", "port", "coll", "location", "type"], "timeout": ["Timeout", "size", "url", "period", "connection", "network", "io", "limit", "conn", "format", "security", "sleep", "response", "resource", "prefix", "ticket", "config", "second", "address", "sync", "until", "name", "slot", "target", "cookie", "length", "capacity", "frequency", "time", "key", "offset", "socket", "delay", "ssl", "service", "wait", "timer", "value", "port", "duration", "unit"], "timeoutVal": ["TimeoutNum", "timeoutEl", "delayVal", " timeoutEl", "delayEl", "timeLen", "TimeoutValue", "delayLen", "timeNum", "delayUnit", "timeoutValue", "timeEl", "timeoutUnit", " timeoutLen", " timeoutUnit", "timeoutNum", " timeoutValue", "delayNum", "TimeoutVal", "TimeoutUnit", "timeoutLen", "TimeoutLen", "delayValue", " timeoutNum", "timeVal"], "timeoutMod": ["TimeoutNum", "delayVal", "timeoutMin", "delayMod", "timeoutModule", " timeoutModule", "timeoutNum", "delayNum", "delayMin", "timeoutMult", "TimeoutVal", "TimeoutMin", " timeoutNum", "delayModule", " timeoutMult", "TimeoutMult", "TimeoutMod", " timeoutMin", "TimeoutModule", "delayMult"], "loggerFile": ["loglerSourceFile", "loglerFILE", "LoggerFILE", "logerSourceFile", "loggerSourceFile", "logerFile", "LoggerSourceFile", "LogerFile", "loggerFiles", "LogerFiles", "loggersSourceFile", "loggerFILE", "loglerFile", "loggersFile", "LoggerFiles", "LogerFILE", "loggersFILE", "loggersFiles", "logerFiles", "LogerSourceFile", "logerFILE", "loglerFiles", "LoggerFile"], "loggerFilenameObject": ["loggerDirectoryobject", "loggerFileObj", "loglerFilenameObj", "loggerDownloadObj", "loggerDownloadString", "loglerFilenameObject", "loggingFilenameObj", "logerFilenameObj", "loggerFilenameobject", "loggingDirectoryObject", "loggerSourceFileString", "loggerDirectoryPart", "loggerDirectoryObject", "loggerSourceFileobject", "loggingDirectoryArray", "logerFilenamePart", "loglerDownloadObj", "loggerSourceFileArray", "loglerDownloadString", "loggerDownloadobject", "loglerFilenameobject", "logerFileObject", "loggerFileobject", "loggingDirectoryobject", "loggerFileString", "loggingFilenameObject", "loggerDirectoryArray", "loggingFilenameArray", "loggerFilenameArray", "loggerFilenamePart", "loggerFileObject", "loglerFilenameString", "loggerFileArray", "loggingDirectoryObj", "logerFileObj", "logerFileArray", "logerFilenameArray", "logerFilePart", "loggerDirectoryObj", "loggerSourceFilePart", "loggerSourceFileObj", "logerFilenameObject", "loggerFilePart", "loglerDownloadobject", "loggerFilenameString", "loggingFilenameobject", "loglerDownloadObject", "loggerSourceFileObject", "loggerDownloadObject", "loggerFilenameObj"], "loggerDestObject": ["loggerDeleteString", "loggerDirectoryPool", "loggerSourceObject", "logerSourceobject", "loggerSyncObj", "loggerDistObject", "loggerDelObject", "loggerDeleteObj", "loggerTargetObj", "loggerSyncObject", "loggerSourceObj", "loggerDirectoryObject", "logerDirectoryObject", "loggerDestPool", "loggerDelObj", "logerDestString", "loggerDestString", "logerDestPool", "loggerDirObj", "loggerDelString", "logerDirectoryString", "loggerSourceString", "loggerTargetPool", "loggerTargetString", "loggerDistObj", "logerDirectoryObj", "logerDeleteObject", "loggerDistobject", "loggerSourceobject", "loggerDestobject", "loggerTargetObject", "loggerDirPool", "logerDestObj", "loggerDelobject", "loggerDirectoryObj", "loggerDirObject", "logerDestobject", "logerSourceString", "loggerDeleteobject", "loggerDirString", "loggerSyncobject", "loggerDirectoryString", "logerDestObject", "logerDirectoryPool", "logerDeleteobject", "logerDeleteObj", "loggerDestObj", "logerSourceObject", "logerSourceObj"], "loggerCompressObject": ["loggercompressObj", "loggercompressorClass", "loggerCompressorObject", "loggerCompressingObject", "loggerCompressingItem", "loggercompressorNumber", "loggercompressNumber", "loggerCompressUnit", "loggerCompressionNumber", "loggercompressorObject", "loggerCompressFile", "loggerCompressionObj", "loggerCompressesFile", "loggerCompressItem", "loggerCompressClass", "loggerPropressionObj", "loggerCompressesObject", "loggerCompressesUnit", "loggerPropressObj", "loggerCompressesNumber", "loggerCompressesObj", "loggerCompressionObject", "loggerPropressNumber", "loggerPropressionItem", "loggerCompressingNumber", "loggerCompressingObj", "loggerPropressionNumber", "loggerCompressorObj", "loggerPropressionObject", "loggerCompressionItem", "loggerCompressorNumber", "loggerPropressObject", "loggerCompressesClass", "loggerCompressionUnit", "loggerCompressorUnit", "loggercompressObject", "loggercompressesUnit", "loggerCompressionClass", "loggerCompressionFile", "loggercompressClass", "loggerCompressesItem", "loggercompressFile", "loggerCompressorFile", "loggerCompressObj", "loggerCompressNumber", "loggercompressesFile", "loggercompressorObj", "loggerCompressorClass", "loggercompressUnit", "loggercompressesObject", "loggercompressesObj", "loggerPropressItem"], "loggerDayObject": ["loggerDeleteInt", "loggerDaysObject", "loggingDateobject", "loggingDayObj", "loggerdayObject", "logerDateObj", "loggerDeleteObj", "loggingDayobject", "loggerDaysNumber", "loggingDateObject", "loggingDayInt", "logerDayFile", "loggerDateObj", "loggerDateObject", "logerDateFile", "loggerdayObj", "logerDayObject", "loggerDayobject", "loggerDailyNumber", "loggerdayNumber", "loggerDaysobject", "loggerDailyFile", "loggingDateObj", "logerDayNumber", "loggerdayobject", "logerDateNumber", "loggerDayInt", "logerDateobject", "loggerDayFile", "loggerDaysInt", "loggingDayObject", "loggerDeleteobject", "loggerDaysObj", "loggerDailyObject", "loggerDateInt", "loggerDateFile", "logerDateObject", "logerDayobject", "loggerDayObj", "logerDayObj", "loggerDaysFile", "loggerDayNumber", "loggerDateobject", "loggingDateInt", "loggerDateNumber", "loggerDailyObj"], "loggerArchiveObject": ["loggerArchueObject", "loggerPhiveFile", "loggerPhivesArray", "loggerPhiveArray", "loggerEngeObject", "loggerEniveObj", "loggerArchIVEOb", "loggerArchueFile", "loggerArchoreLong", "loggerArchIVELong", "loggerEngeNumber", "loggerEngeOb", "loggerPhiveObj", "loggerArchgeObject", "loggerArchoreElement", "loggerArchivesOb", "loggerArchueArray", "loggerEngeObj", "loggerArchivesArray", "loggerDerIVEObject", "loggerDeriveObj", "loggerArchivesObject", "loggerArchIVEObject", "loggerDeriveLong", "loggerArchivesNumber", "loggerPhivesObject", "loggerArchiveObj", "loggerArchIVENumber", "loggerArchivesLong", "loggerArchiveElement", "loggerDerIVELong", "loggerPhiveObject", "loggerArchIVEFile", "loggerPhivesObj", "loggerArchgeObj", "loggerEniveNumber", "loggerArchgeNumber", "loggerDeriveObject", "loggerPhivesFile", "loggerArchiveLong", "loggerDeriveElement", "loggerArchIVEArray", "loggerArchIVEElement", "loggerEniveObject", "loggerArchiveNumber", "loggerDerIVEElement", "loggerArchivesObj", "loggerArchiveFile", "loggerArchueObj", "loggerArchivesElement", "loggerDerIVEObj", "loggerArchgeOb", "loggerEniveOb", "loggerArchiveOb", "loggerArchIVEObj", "loggerArchoreObject", "loggerArchivesFile", "loggerArchiveArray", "loggerArchoreObj"], "loggerDeleteObject": ["logerDelString", "loggerDeleteString", "loggerCopyobject", "loggeeDeleteElement", "loggerDelObject", "loggerDeleteObj", "loggerCopyString", "loggerDelArray", "loggeeDeleteObj", "loggeeDelElement", "loggerDeleteArray", "logerDeleteFunction", "loggerDelObj", "loggerCopyFunction", "loggerCopyArray", "loggerCleanObj", "loggerCleanObject", "loggerDeleteElement", "loggerCleanElement", "loggerDelString", "logerDelObject", "logerDelobject", "loggerDropObject", "logerDeleteObject", "loggerDeleteFunction", "logerDelFunction", "loggerCopyObj", "loggeeDelArray", "loggerDelElement", "loggeeDeleteObject", "loggerDelobject", "loggerCopyElement", "loggeeDelObj", "loggeeDeleteArray", "loggerUpdateObject", "loggerDelFunction", "loggerDropFunction", "loggerDeleteobject", "loggerDropString", "loggerUpdateobject", "logerDeleteString", "loggerCopyObject", "logerDeleteobject", "loggerCleanArray", "loggerUpdateString", "loggeeDelObject"], "rotateDest": ["polgateDir", "polgateDest", "rotationDirect", " rotizeDest", "rotinateZip", "rotgateRoute", "rotgateDir", "rotateZip", "rotateRoute", "polateDes", "rotizeDir", "rotinateDirect", "rotizeDest", "polateDest", " rotizeZip", "rotizeZip", " rotateDirect", " rotizeDirect", "rotgateDes", "polateDir", "rotationDes", "rotateDir", "rotationZip", "rotationDir", "rotinateDest", "rotinateDir", " rotizeDir", "rotgateDest", " rotateZip", "polgateDes", "rotateDes", "polateRoute", "rotationRoute", "rotationDest", "rotizeDirect", " rotateDir", "rotateDirect", "polgateRoute"], "logFile": ["bugStream", "Logfile", " logFilename", "logfile", "copyFile", "copyFiles", "logClass", " logfile", "bugSourceFile", "logFiles", "logSource", "tagfile", "bugfile", "logFilename", "LogFile", "copyRoute", "tagStream", " logSourceFile", "LogFiles", "configSourceFile", "LogSource", " logStream", "catStream", "configFile", "configStream", "logRoute", "bugClass", "LogSourceFile", "catFile", "copyFilename", "bugFile", "logSourceFile", "tagSource", "catSource", " logClass", "configClass", "LogFilename", "LogRoute", "catfile", "tagFile", "logStream", "bugSource", " logFiles", " logRoute", " logSource"], "rotateArchive": ["rotateExived", "rotgeARCHives", "rotgeArchIVE", "rotateExIVE", "rotgeArchive", "rotateExore", "rotgeArchived", "rotateArchIVE", "rotuneArchIVE", "rotateSlives", "rotgeARCHived", "rotateArchived", "rotateInterived", "rotateARCHive", "rotuneArchived", "rotateOctIVE", "rotateSlIVE", "rotateCompore", "rotateSlived", "rotateOctore", "rotateSlive", "rotateARCHIVE", "rotuneCompived", "rotateOctive", "rotuneCompore", "rotateExive", "rotateInterive", "rotgeARCHive", "rotuneCompive", "rotuneCompIVE", "rotateARCHives", "rotgeArchives", "rotuneArchive", "rotateCompIVE", "rotateArchives", "rotgeARCHIVE", "rotateArchore", "rotateInterIVE", "rotateCompived", "rotateInterives", "rotateARCHived", "rotateOctived", "rotuneArchore", "rotateCompive"], "rotateDays": ["rotateFiles", "rotuteDay", "rotateDay", " rotationWords", "RotationHours", "rotrateHours", "RotateHours", "RotationDays", " rotationFiles", "rotationDay", "rotatedFiles", "RotateDay", "rotuteFiles", " rotationDays", "rotationHours", "rotrateDays", " rotateFiles", "RotationFiles", " rotateDay", "RotateDays", "rotateHours", "rotrateFiles", "RotateFiles", "rotationDays", "rotatedWords", "rotatedDays", " rotationDay", "rotrateDay", "rotationWords", " rotateWords", "rotuteHours", "RotationDay", "rotateWords", "rotatedDay", "rotationFiles", "rotuteDays"], "srcChannel": ["srcFile", "srcStream", "rcFile", "insFile", "insStream", "rcStream", "rcChannel", " srcFile", "rcWriter", " srcStream", "srcWriter", "insChannel", " srcWriter", "insWriter"], "destChannel": [" destChan", "destSocket", "targetChan", "srcSocket", "srcCh", "targetCh", "targetSocket", " destCh", "srcChan", " destSocket", "destChan", "destCh", "targetChannel"], "destOutFile": ["srcoutFILE", "srcoutPath", "destoutPath", "destDiffDir", "destoutFILE", "destDestPath", "srcOutPath", "destDestFile", "destOutPath", "destOutDir", "destDiffFILE", "srcoutFile", "destDestFILE", "srcOutDir", "destDiffPath", "destOutFILE", "destDestDir", "srcOutFile", "destoutFile", "srcOutFILE", "srcoutDir", "destDiffFile", "destoutDir"], "destOutFileCompressed": ["destOutFileRepression", "destOutTimeComposed", "destOutFileExposed", "destOutFilecompression", "destOutFileCompression", "destOutTimeRepress", "destOutFilecompress", "destOutTimeCompression", "destOutFileReposed", "destOutFileExpress", "destOutTimeReposed", "destOutFileComposed", "destOutTimeCompress", "destOutTimeRepressed", "destOutFilecompressed", "destOutFileExpression", "destOutTimeCompressed", "destOutFileRepressed", "destOutFileExpressed", "destOutFilecomposed", "destOutTimeRepression", "destOutFileRepress", "destOutFileCompress"], "rotateCompress": ["rotizeExpressed", "rotureCombush", "rotateCompressed", "rotizeCompresses", "rotizeExpress", "rotatePropress", "rotureCompress", "rotateCombress", "rotateExpress", "rotizeCompression", "rotateCombressed", "rotizeCompress", "rotureCombress", "rotureCombressed", "rotatePropressed", "rotizeExpression", "rotateCompush", "rotizeCompressed", "rotateMacresses", "rotateExpressed", "rotateCompressor", "rotureCompressed", "rotateMacressed", "rotatePropush", "rotateCombressor", "rotizeExpresses", "rotateExpresses", "rotateCombush", "rotateExpression", "rotureCompressor", "rotureCombressor", "rotureCompush", "rotateMacress", "rotateCompression", "rotatePropressor", "rotateMacression", "rotateCompresses"], "rotateDelete": ["copateDel", "rotureDel", "rotateUpdate", "RotateDel", "coporeDel", "rotoreLog", "rotoreCreate", "RotateCopy", "rotateLog", "RotuteDelete", "RotateCreate", "rotureUpdate", "rotureLog", "copateDelete", "copateLog", "rotateCopy", "RotuteCopy", "rotoreCopy", "rotuteCopy", "rotateDel", "coporeUpdate", "rotureDelete", "rotuteCreate", "rotateCreate", "coporeLog", "RotateDelete", "rotuteDelete", "copateUpdate", "coporeDelete", "rotoreDel", "RotuteDel", "rotoreDelete", "rotuteDel", "rotoreUpdate", "RotuteCreate"]}}
{"id1": "18288470", "id2": "8481623", "code1": "    public static void unzip(String zipfile, String outputDirectory) {\n        try {\n            byte[] buf = new byte[1024];\n            ZipInputStream zipinputstream = null;\n            ZipEntry zipentry;\n            zipinputstream = new ZipInputStream(new FileInputStream(zipfile));\n            zipentry = zipinputstream.getNextEntry();\n            while (zipentry != null) {\n                String entryName = zipentry.getName();\n                System.out.println(\"entryname \" + entryName);\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(entryName);\n                String directory = newFile.getParent();\n                if (directory == null) {\n                    if (newFile.isDirectory()) break;\n                }\n                fileoutputstream = new FileOutputStream(outputDirectory + entryName);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n                zipentry = zipinputstream.getNextEntry();\n            }\n            zipinputstream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        from_file = checkFile(from_file);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"zipfile": ["zipFile", "zFile", "zfilename", "archivefiles", "zfile", "zentry", "lockfiles", "zipfiles", "archivefilename", "lockfilename", " zipfiles", "archiveFile", "zipfilename", "lockFile", "archivefile", " zipFile", "lockfile", "archiveentry", "lockentry"], "outputDirectory": ["outputdirectory", "inputFolder", " outputdirectory", "imageFile", "targetCollection", "outputFile", "outputFolder", " outputDir", " outputFolder", "imageFolder", "outputCollection", "imageDirectory", "inputCollection", "OutputDirectory", "OutputDir", "targetFolder", "OutputFolder", "outputDir", "targetFile", "inputDirectory", "targetdirectory", "Outputdirectory", "targetDirectory", "imageCollection", "targetDir", "inputFile"], "buf": ["cb", "queue", "bf", "binary", "bh", "pkg", "uc", "la", "buffer", "buff", "br", "Buffer", "lim", "src", "cas", "que", "fp", "b", "cmd", "bc", "aux", "base", "cv", "data", "bd", "bytes", "pad", "Buff", "func", "batch", "rc", "bb", "seq", "uf", "bag", "gb", "ab", "uv", "vec", "wb", "fb", "conv", "img", "lb", "rb", "padding", "fab", "bp"], "zipinputstream": ["zipfileStream", " zipmainsteam", "zipinnersystem", "zipsourcethread", "fileinputStream", "zinputsystem", "zInputput", "zipcontrolstream", "archiveinputStream", "zipfilestream", "zipinputsem", "zipinputStream", "archiveinputstream", "zinputchannel", " zipinputStream", "zipInputsteam", "zipInputsem", "zipinputsteam", "zinputStream", "archiveInputstream", " zipmainStream", "zipInputloop", "zInputstream", "zipsourceStream", "zipcontrolStream", "zipbitstream", "zipmainStream", "zipbitchannel", "archiveInputStream", "fileoutputsem", "zinputstream", "zipinputchannel", "zipoutputloop", "zipfilesystem", "zinputput", "zipinputput", "zipoutputsem", "zipInputsystem", "zipinputsystem", "zipInputput", "zipfilethread", "zoutputStream", "fileinputstream", "zipinputthread", " zipmainstream", "zipcontrolput", "zipbitStream", "zipincludeStream", "zInputthread", "zInputsystem", "zipincludesem", "zipmainsteam", "zipInputchannel", "zipincludestream", "archiveInputloop", "fileoutputStream", "zipinnerthread", "zipimportloop", "zipoutputstream", "zipInputthread", "zipInputstream", "zoutputstream", "zipinnerStream", "zipoutputStream", "zipbitput", "zipsourcestream", "zoutputthread", "zipoutputsteam", "zipimportStream", "zipinnerstream", "fileinputsem", "zinputthread", "zipmainstream", "zoutputsystem", " zipinputsteam", "zInputStream", "zipimportstream", "zipInputStream", "zipinputloop", "zipoutputsystem", "archiveinputloop", "zipoutputthread", "zInputchannel", "zipcontrolchannel"], "zipentry": ["copEntry", "zipdata", "ziparchive", "zipletter", "zipEntry", "zelement", "zenter", "expEntry", "seaelement", "installarchive", " zipserver", "seaentry", "zipreader", "seaEntry", "copenter", "lexentry", "zeletter", " zipdata", "lexenter", "zentry", " zipenter", "downloadarchive", "zonedata", "expentry", "lexarchive", "downloadentry", "installentry", "lexdata", " zipletter", "zoneelement", "seaenter", "zoneenter", " ziparchive", " zipEntry", "zearchive", "zeserver", "installserver", "downloadelement", "zeentry", "zEntry", "copentry", "zipserver", " zipreader", "expenter", "zreader", "zipelement", "expelement", "downloadenter", "lexelement", "zonearchive", "zoneentry", "installletter", "zipenter", "copreader"], "entryName": ["entryType", "entryNAME", "zipname", "entityNames", "EntryYear", "zipName", "elementname", " entryYear", "entityType", "internalName", "stringname", "zipInfo", "entityname", " entryNames", "elementInfo", "entryYear", " entryInfo", "stringName", "elementNAME", "entryInfo", "Entryname", " entryNAME", "entryname", " entryType", "entityName", "entryNames", "stringYear", "elementType", "elementNames", "EntryType", "internalNAME", "internalname", " entryname", "EntryName", "stringType", "elementName", "zipType"], "n": ["none", "en", "num", "d", "nn", "len", "ind", "nr", "k", "l", "w", "out", "b", "ns", "f", "number", "no", "r", "x", "name", "ne", "na", "u", "e", "o", "nt", "t", "m", "nu", "v", "index", "N", "j", "c", "i", "g", "un", "pos", "nb", "nd", "ng", "sn", "z", "nc", "p"], "fileoutputstream": ["fileoutpath", "fileoutStream", " fileoutputStream", "fileinputsw", "fileimagestream", "fileinputmessage", "fileOutputstream", "fileresourceStream", "fileoutstream", "fileinputStream", "resourceinputStream", "fileOutputmessage", "zipoutputstream", "resourceinputsw", "resourceoutputsystem", "fileinputsystem", "fileoutputthread", "fileunitstream", "fileOutputthread", " fileunitthread", "resourceoutputsw", "fileresourcestream", "resourceinputpath", "zipoutputStream", "fileOutputsystem", "fileunitthread", "fileoutputsw", "fileinputpath", "fileoutputmessage", " fileunitStream", "fileinputthread", "resourceOutputstream", "fileoutputsystem", "fileOutputsw", "zipOutputstream", "resourceOutputstring", "fileresourcesystem", "fileoutputstring", "resourceoutputpath", "fileoutputpath", " fileoutputthread", "fileOutputpath", "zipoutputmessage", "fileinputstring", "resourceoutputstring", "fileOutputstring", "fileimagemessage", "fileimageStream", "fileinputstream", "resourceOutputsystem", "resourceoutputStream", "resourceinputstream", "fileoutsw", "fileunitStream", "resourceoutputstream", "fileOutputStream", "zipOutputmessage", "fileoutputStream", "fileresourcestring", "zipOutputStream", "resourceOutputStream", " fileunitstream"], "newFile": [" newDir", "NewPlace", "NewDir", "newfile", "newPlace", "addFile", "addDir", "fromFolder", "fromFile", "addFolder", " newPlace", "NewFile", "NEWDir", "newDir", "NEWFolder", "fromfile", "NewFolder", "addfile", "newFolder", " newfile", "Newfile", "NEWFile", "NEWPlace", " newFolder", "fromDir"], "directory": ["source", "folder", "parent", "url", "d", "office", "connection", "director", "division", "Directory", "python", "home", "description", "root", "class", "system", "tree", "prefix", "archive", "creator", "machine", "filename", "volume", "dir", "direction", "direct", "container", "length", "category", "path", "document", "uri", "manager", "database", "which", "project", "collection", "location"]}}
{"id1": "228212", "id2": "19746605", "code1": "    public void CopyFile(File source, File destination) throws Exception {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(source);\n            fos = new FileOutputStream(destination);\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                fos.write(buffer, 0, read);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private synchronized Frame insertFrame(int index, File source, INSERT_TYPE type) throws IOException {\n        if (source == null) throw new NullPointerException(\"Parameter 'source' is null\");\n        if (!source.exists()) throw new IOException(\"File does not exist: \" + source.getAbsolutePath());\n        if (source.length() <= 0) throw new IOException(\"File is empty: \" + source.getAbsolutePath());\n        if (index < 0) throw new IndexOutOfBoundsException(\"index < 0\");\n        if (index >= frames_.size()) throw new IndexOutOfBoundsException(\"index >= frames_.size()\");\n        File tmp = new File(Settings.getPropertyString(ConstantKeys.project_dir), \"tmp.jpg\");\n        switch(type) {\n            case MOVE:\n                if (source.getParentFile().compareTo(new File(Settings.getPropertyString(ConstantKeys.project_dir))) == 0 && source.getName().matches(\"img_[0-9]{5}\\\\.jpg\")) {\n                    for (int i = 0; i < frames_.size(); i++) {\n                        Frame f = frames_.get(i);\n                        if (f.getFile().compareTo(source) == 0) {\n                            frames_.remove(i);\n                            break;\n                        }\n                    }\n                }\n                source.renameTo(tmp);\n                break;\n            case COPY:\n                FileChannel inChannel = new FileInputStream(source).getChannel();\n                FileChannel outChannel = new FileOutputStream(tmp).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n                break;\n        }\n        for (int i = frames_.size() - 1; i >= index; i--) {\n            Frame newFrame = new Frame(new File(Settings.getPropertyString(ConstantKeys.project_dir), formatFileName(i)));\n            frames_.get(i).moveTo(newFrame);\n            frames_.set(i, newFrame);\n        }\n        File newLocation = new File(Settings.getPropertyString(ConstantKeys.project_dir), formatFileName(index));\n        tmp.renameTo(newLocation);\n        Frame f = new Frame(newLocation);\n        f.createThumbNail();\n        frames_.set(index, f);\n        return f;\n    }\n", "label": 1, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "io", "src", "from", "in", "this", "Source", "base", "table", "directory", "stream", "remote", "resource", "ie", "server", "address", "info", "ources", "filename", "name", "e", "target", "ource", "sin", "SOURCE", "slice", "string", "image", "file", "uri", "i", "service", "scene", "proxy", "use", "unit"], "destination": ["deadinated", "deadination", "Desturation", "destiner", "combinated", "deaduration", "Destinated", "desturation", "Destiner", "destinated", "dinations", "combination", "diination", "diinations", "Destinator", "deadiner", "diinated", "dinated", "destinations", "dinator", "Destinations", "dination", "combiner", "diinator", "comburation", "destinator", "Destination"], "fis": ["los", "fris", "infris", "fois", "Fos", "Fiss", "las", "fiss", "bos", "infos", "lois", "fios", "Fas", " fois", "biss", " fios", "bris", "Fris", "hos", "Fis", "his", "hiss", " fas", "infis", " fris", "hris", "Fois", "lis", "infios", "Fios", "lris", "bis", " fiss", "fas"], "fos": ["Foes", "los", " fros", " foses", "fose", "fus", " foes", " fou", "ufou", "ufos", "baos", "ufros", "pose", "bros", "fros", "Fos", "bos", "infos", "fios", "infus", " fios", " faos", " fus", "Faos", "poes", "lios", "bou", "Fis", "infis", "Fose", "loses", "faos", "lis", "ufis", "infios", "foses", "bus", "Fios", "bios", "pos", "Foses", "poses", "bis", "fou", "foes", " fose"], "buffer": ["reader", "url", "queue", "memory", "binary", "input", "write", "feed", "reference", "buff", "repeat", "iter", "result", "Buffer", "limit", "request", "b", "channel", "number", "layer", "data", "available", "resource", "address", "uffer", "shape", "transfer", "null", "batch", "flush", "length", "wave", "buf", "slice", "count", "document", "border", "seed", "cache", "header", "block", "total", "position", "bin"], "read": ["play", "get", "next", "reader", "en", "size", "id", "write", "d", "input", "feed", "len", "Read", "ind", "open", "iter", "READ", "io", "in", "b", "end", "f", "data", "rate", "find", "n", "work", "raw", "exec", "x", "send", "e", "reading", "_", "length", "allow", "text", "max", "se", "key", "run", "index", "close", "count", "pass", "load", "connect", "parse", "readable", "i", "check", "seek", "current", "type", "wait", "start", " count", "add", "ed", " Read", "use", " ride", "reads"]}}
{"id1": "10460548", "id2": "15903468", "code1": "    public void parse() {\n        InputSource urlInputStream = null;\n        SAXParserFactory spf = null;\n        SAXParser sp = null;\n        HttpURLConnection conn = null;\n        try {\n            URL url = new URL(this.urlString);\n            _setProxy();\n            conn = (HttpURLConnection) url.openConnection();\n            urlInputStream = new InputSource(StreamUtils.inputStreamToReader(conn.getInputStream()));\n            spf = SAXParserFactory.newInstance();\n            if (spf != null) {\n                sp = spf.newSAXParser();\n                sp.parse(urlInputStream, this);\n            }\n        } catch (Exception e) {\n            if (conn != null) {\n                if (conn.getHeaderField(\"X-RateLimit-Limit\") != null) {\n                    String rateLimit = conn.getHeaderField(\"X-RateLimit-Limit\");\n                    String rateRemaining = conn.getHeaderField(\"X-RateLimit-Remaining\");\n                    long rateReset = Long.valueOf(conn.getHeaderField(\"X-RateLimit-Reset\")) * 1000;\n                    LOG.warn(\"Possible rate limits?  LIMIT:\" + rateLimit + \"  REMAINING:\" + rateRemaining + \"  RESET:\" + new Date(rateReset));\n                }\n            }\n            e.printStackTrace();\n            LOG.warn(\"error parsing rss feed\", e);\n        } finally {\n        }\n    }\n", "code2": "    private String[] getHersheyFontNames() {\n        String[] fontNames = null;\n        URL url = HersheyFont.class.getResource(\"futural.jhf\");\n        String protocol = url.getProtocol();\n        if (protocol.equals(\"file\")) {\n            File f = new File(url.getFile());\n            f = f.getParentFile();\n            FilenameFilter filter = new FilenameFilter() {\n\n                public boolean accept(File dir, String name) {\n                    return name.endsWith(\".jhf\");\n                }\n            };\n            String[] children = f.list(filter);\n            if (children == null) {\n                return null;\n            }\n            fontNames = new String[children.length];\n            for (int i = 0; i < children.length; i++) {\n                fontNames[i] = children[i].substring(0, children[i].length() - 4);\n            }\n        } else if (protocol.equals(\"jar\")) {\n            try {\n                JarURLConnection jarURL = (JarURLConnection) url.openConnection();\n                ZipFile zf = new ZipFile(jarURL.getJarFile().getName());\n                Enumeration e = zf.entries();\n                Vector namesVector = new Vector();\n                while (e.hasMoreElements()) {\n                    ZipEntry ze = (ZipEntry) e.nextElement();\n                    String name = ze.getName();\n                    if (name.startsWith(\"visad/util/\") && name.endsWith(\".jhf\")) {\n                        namesVector.add(name.substring(11));\n                    }\n                }\n                zf.close();\n                if (namesVector.size() == 0) {\n                    return null;\n                }\n                fontNames = new String[namesVector.size()];\n                for (int i = 0; i < fontNames.length; i++) {\n                    String name = (String) namesVector.elementAt(i);\n                    fontNames[i] = name.substring(0, name.length() - 4);\n                }\n            } catch (Exception e) {\n                System.out.println(e);\n            }\n        } else {\n            System.out.println(\"Cannot locate the HersheyFonts.\");\n        }\n        return fontNames;\n    }\n", "label": 0, "substitutes": {"urlInputStream": ["urlInstream", "httpInputStream", "urlInSteam", "urlInStream", "urlSourceString", "urlInputSteam", "URLInstream", "urlImportSource", "urlOutputSteam", " urlInputReader", "urlImportString", "urlImportReader", "urlInputReader", "URLInputInterface", "httpOutputReader", "URLInputStream", " urlUpstream", "urlImportStream", "urlReadSource", "urlOutputstream", "urlContentSource", "httpInputReader", "urlReadReader", "urlOutputInterface", "urlUpstream", "urlOutputReader", "URLInputstream", "urlOutputStream", "urlSubInterface", "urlInputString", "urlOutputSource", " urlUpStream", "urlSubStream", " urlUpReader", "urlSourceReader", "urlOutputString", "urlUpReader", "URLInInterface", "urlSourceSource", "urlSourceStream", "URLInStream", "URLInputSteam", "urlReadstream", "urlUpStream", "urlReadStream", "urlInputInterface", "urlInputstream", " urlUpSource", "urlInInterface", "httpOutputStream", " urlInputSource", "httpOutputSource", "httpInputString", "urlContentstream", "httpOutputString", "urlSubSteam", "urlUpSource", "urlContentReader", "urlContentStream", "URLInSteam", " urlInputstream", "httpInputSource", "urlInputSource", "urlSubstream"], "spf": ["Spfx", "psF", "pF", "psf", " spfi", "pf", "psfx", "srfi", "spF", "ypfi", "srf", "spff", "prF", "SPfx", "ypfs", "prfs", "spfx", "ypf", "srfs", "ypfac", " spff", "spfs", "SpF", " spfx", "pfs", " spF", "psfs", "SPfs", "spfi", "Spfs", "prff", "SPF", "Spf", "prf", "SPf", "pff", " spfac", " spfs", "spfac", "srfac"], "sp": ["lp", "py", "pe", "si", "space", "spl", "jp", "sw", "pg", "sf", "f", "isp", "p", "sc", "sh", "serv", "par", "wp", "pc", "sch", "Sp", "sup", "tp", "hp", "mp", "gp", "spec", "ph", "parser", "sl", "pr", "span", "esp", "se", "pt", "pm", "sk", "SP", "parse", "ssl", "pp", "asp", "ps", "pl", "so", "bp"], "conn": ["host", "dc", "cb", "connection", "cm", "auth", "open", "uc", "cf", "core", "co", "ct", "con", "client", "Conn", "loc", "po", "ec", "cp", "rn", "n", "oa", "enc", "ctx", "org", "server", "pub", "ai", "dn", "mc", "adj", "pc", "cn", "conf", "exec", "sync", "oss", "ci", "rc", "nt", "act", "log", "gn", "api", "stat", "ch", "cli", "lc", "ann", "session", "sec", "col", "cr", "connect", "cert", "c", "ssl", "socket", "db", "err", "resp", "fail", "error", "reg", "conv", "cc", "Connection", "ca", "nc", "coll"], "url": ["host", "page", "feed", "connection", "uc", "ll", "l", "http", "b", "lr", "fr", "base", "loc", "zip", "resource", "org", "server", "ur", "gl", "bb", "ob", "log", "cl", "fl", "ls", "path", "rl", "impl", "ssl", "uri", "fb", "URL", "Url", "www", "blog", "proxy", "web", "sl"], "rateLimit": ["RateLimited", "ratingLim", "RateLim", "ratingLock", "RateLock", " ratePool", "rateLim", "ratePool", " rateLim", "rateLock", "ratingLimited", "RateLimit", " rateLock", "RatePool", "rateLimited", "ratingLimit", " rateLimited", "ratingPool"], "rateRemaining": [" rateRemining", " rateResained", " rateRemained", " rateResining", "rateReminding", "ratereminding", " rateResaining", " rateReminding", "rateremaining", "rateResining", "rateMining", "rateMain", "rateResaining", "rateMaining", "rateMained", "rateremain", "rateRemained", " rateResain", "rateResinding", "rateremained", " rateResinding", "rateResain", "rateRemain", "rateResained", " rateRemain", "rateremining", "rateRemining"], "rateReset": ["rateRepume", "ratePresume", "rateRewait", "rateExerved", " rateExait", "rateRewet", "rateExet", "ratePresend", "rateResize", "rateResend", "ratePresize", " rateResume", "ratePreset", " rateExerved", "rateExait", "rateRemet", "rateRemend", "rateResume", " rateExend", " rateReserved", "rateReperved", " rateResend", "rateRepait", "rateExize", "rateRewerved", " rateResait", "rateExume", " rateExize", "rateReserved", "rateResait", "rateExend", "rateRepet", " rateExet", "rateRemize", " rateResize", "rateRemume", "rateRewume", " rateExume"]}}
{"id1": "7317602", "id2": "7309170", "code1": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private void zip(File input, File output) {\n        OutputStream os = null;\n        InputStream is = null;\n        try {\n            os = new GZIPOutputStream(new FileOutputStream(output));\n            is = new FileInputStream(input);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"text": ["source", "translation", "contract", "value", "url", "input", "test", "TEXT", "txt", "token", "connection", " TEXT", "message", "output", "format", "letter", "object", "in", "this", "Text", "number", "data", "hex", "version", "class", "editor", "config", "template", "word", "name", "pattern", "password", "EXT", "content", "key", "string", "path", "image", "obj", "font", "code", "struct", "secret", " Text", "str", "ext"], "md": ["ad", "hash", "cd", "bf", "d", "mb", "dig", "dd", "ind", "ld", "hd", "message", " MD", "mm", "ma", "pd", "sm", "wd", "gd", "vd", "am", "cmd", "ms", "mode", "data", "mac", "mo", "di", "bd", "mand", "editor", "mag", "meta", "mc", "sha", "body", "mp", "dm", "mod", "rm", "MD", "mt", "m", "df", "od", "pm", "mg", "code", "map", "mad", "valid", "Cmd", "metadata", "amd", "nm", "me", "mn"], "sha1hash": ["SHA2hash", "sha5copy", "wa1sum", "wa1hash", "sha5hex", "sha1copy", "sha4hash", "wa1copy", "sha2Hash", "sha5hash", "sha64sum", "sha4sha", "SHA1sum", "wa1hex", "sha4h", "SHA2sum", "SHA2h", "sha4copy", "sha4hex", "sha5sum", "sha2hash", "SHA2Hash", "wa5copy", "sha256Hash", "sha2sha", "sha4sum", "SHA1hash", "sha2sum", "sha256sum", "sha1sum", "SHA1sha", "sha64copy", "wa5hash", "sha1Hash", "sha4Hash", "wa5sum", "sha64hash", "sha1h", "sha11hash", "sha256hash", "sha11sum", "SHA2sha", "sha64hex", "sha11sha", "sha1sha", "sha1hex", "wa5hex", "sha256h", "SHA1Hash", "sha2h", "SHA1h"]}}
{"id1": "18208567", "id2": "2102737", "code1": "    public void createPdf(final String eventURI) throws IOException, DocumentException {\n        createSections(eventURI);\n        even = false;\n        final Document document = new Document(Dimensions.getDimension(even, Dimension.MEDIABOX));\n        final PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(MyProperties.getOutput()));\n        writer.setViewerPreferences(PdfWriter.PageLayoutTwoColumnRight);\n        writer.setCropBoxSize(Dimensions.getDimension(even, Dimension.CROPBOX));\n        writer.setBoxSize(\"trim\", Dimensions.getDimension(even, Dimension.TRIMBOX));\n        writer.setBoxSize(\"bleed\", Dimensions.getDimension(even, Dimension.BLEEDBOX));\n        final EventBackgroundAndPageNumbers event = new EventBackgroundAndPageNumbers();\n        writer.setPageEvent(event);\n        document.open();\n        final PdfContentByte content = writer.getDirectContent();\n        event.setTabs(Index.INFO.getTab());\n        importPages(document, content, new PdfReader(Index.INFO.getOutput()), Index.INFO.getTitle());\n        importPages(document, content, MyProperties.getBefore(), event);\n        addAdPage(document, content);\n        PdfReader reader = new PdfReader(Presentations.INFO.getOutput());\n        String[] titles = { \"\", \"\" };\n        for (int i = 1; i <= reader.getNumberOfPages(); i++) {\n            titles = index.getSubtitle(titles, i);\n            event.setTabs(titles[0].toLowerCase());\n            addTitleLeft(content, Dimensions.getTitleArea(even), titles[0], MyFonts.TITLE);\n            addTitleRight(content, Dimensions.getTitleArea(even), titles[1], MyFonts.DATE);\n            content.addTemplate(writer.getImportedPage(reader, i), Dimensions.getOffsetX(even), Dimensions.getOffsetY(even));\n            document.newPage();\n            even = !even;\n        }\n        addAdPage(document, content);\n        importPages(document, content, MyProperties.getAfter(), event);\n        int total = writer.getPageNumber() - 1;\n        event.setNoMorePageNumbers();\n        event.setTabs(Schedules.INFO.getTab());\n        reader = new PdfReader(Schedules.INFO.getOutput());\n        for (int i = 1; i <= reader.getNumberOfPages(); i++) {\n            addTitleLeft(content, Dimensions.getTitleArea(even), Schedules.INFO.getTitle(), MyFonts.TITLE);\n            content.addTemplate(writer.getImportedPage(reader, i), Dimensions.getOffsetX(even), Dimensions.getOffsetY(even));\n            document.newPage();\n            even = !even;\n        }\n        document.close();\n        final File file = new File(MyProperties.getOutput());\n        final byte[] original = new byte[(int) file.length()];\n        final FileInputStream f = new FileInputStream(file);\n        f.read(original);\n        reader = new PdfReader(original);\n        final List<Integer> ranges = new ArrayList<Integer>();\n        for (int i = 1; i <= total; i++) {\n            ranges.add(i);\n            if (i == total / 2) {\n                for (int j = total + 1; j <= reader.getNumberOfPages(); j++) {\n                    ranges.add(j);\n                }\n            }\n        }\n        reader.selectPages(ranges);\n        final PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(MyProperties.getOutput()));\n        stamper.close();\n    }\n", "code2": "    private String getContents(Server server, String uri) throws TechnicalException {\n        try {\n            URL url = new URL(\"http://localhost:\" + PORT + uri);\n            return StreamUtils.getStreamContent(url.openStream());\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new TechnicalException(e);\n        }\n    }\n", "label": 0, "substitutes": {"eventURI": ["objectPI", "objecturi", "eventuri", "eventPath", "documentURI", "documentPath", "EventURL", "EventPath", " eventURL", "contentURI", "documentURL", "objectURI", "Eventuri", "eventPI", "documenturi", "EventURI", "objectURL", "contentPI", "contenturi", " eventPath", " eventuri", "eventURL", "contentURL", "EventPI"], "document": ["language", "paragraph", "page", "parent", "program", "url", "write", "office", "connection", "Document", "xml", "director", "layout", "function", "material", "output", "doc", "message", "object", "request", "console", "layer", "application", "data", "directory", "system", "feature", "server", "element", "word", "null", "image", "container", "instance", "initial", "session", "index", "media", "window", "node", "graph", "central", "html", "context", "expression", "ocument", "command", "addin", "header", "database", "valid", "video", "design", "sheet", "collection", "author"], "even": ["later", "month", "fall", "down", "now", "seven", "number", "multiple", "other", "company", "central", "numbered", "width", "only", "odd", "position", "one", "owner", "diff", "part", "below", "straight", "breaking", "pair", "update", "until", "mult", "four", "each", "floor", "zero", "self", "figure", "www", "existing", "except", "plus", "left", "none", "complete", "material", "ven", "common", "well", "section", "yet", "instead", "own", "record", "also", "front", "individual", "Even", "two", "correct", "output", "again", "single", "zen", "wrong", "production", "large", "initial", "enter", "character", "current", "west", "author", "high", "standard"], "writer": ["draw", "source", "page", "write", "layout", "office", "connection", "xml", "director", "buffer", "wire", "player", "function", "engine", "ws", "output", "widget", "format", "w", "driver", "client", "object", "layer", "data", "fe", "writers", "worker", "style", "work", "riter", "handler", "editor", "server", "creator", "resource", "element", "er", "script", "word", "e", "report", "parser", "instance", "Writer", "temp", "book", "window", "index", "context", "builder", "manager", "service", "design", "wan", "writing", "author", "wr", "journal", "entry"], "event": ["source", "page", "input", "user", "inc", "events", "layout", "connection", "xml", "player", "function", "ee", "message", "doc", "view", "format", "actual", "vent", "object", "driver", "request", "this", "age", "data", "stream", "class", "style", "resource", "handler", "archive", "config", "external", "inner", "info", "element", "update", "component", "e", "other", "instance", "comment", "index", "Event", "change", "image", "list", "node", "entity", "context", "attribute", "callback", "press", "type", "ce", "self", "form", "author", "entry"], "content": ["source", "page", "write", "layout", "connection", "cm", "xml", "Content", "player", "message", "output", "conn", "example", "view", "format", "client", "object", "css", "description", "driver", "request", "model", "console", "javascript", "loader", "layer", "data", "remote", "response", "resource", "ctx", "child", "handler", "condition", "server", "config", "activity", "section", "script", "component", "null", "body", "report", "pages", "cont", "container", "text", "comment", "lc", "temp", "session", "index", "media", "path", "image", "load", "context", "code", "current", "header", "cms", "value", "author", "entry"], "reader": ["source", "parent", "read", " read", "url", "input", "rar", " Reader", "Reader", "buffer", "director", " reading", "io", " library", " instance", "ler", "client", "driver", "row", "loader", "data", "r", "resource", "handler", "editor", "server", "info", "inner", "x", "er", "rer", " r", "rc", "report", "reading", "container", "parser", "df", "book", "index", "image", "uri", "context", "builder", " readers", "collection", "author", "entry"], "i": ["page", "id", "input", "url", "si", "d", "multi", "qi", "uli", "iu", "phi", "hi", "io", "k", "yi", "l", "di", "bi", "zi", "n", "I", "mu", "ti", "oi", "ai", "info", "gi", "ji", "x", "r", "name", "init", "it", "ui", "ci", "u", "t", "ini", "a", "m", "li", "v", "xi", "ri", "index", "count", "slice", "image", "pointer", "c", "uri", "ii", "pi", "is", "fi", "chi", "z", "mini", "ip", "p", "type"], "titles": ["tystrings", "tyributes", "ttsections", " tstrings", "intps", "tps", "tycriptions", "inttitle", " tumbers", "ttails", "Tasks", " ttitle", "intls", " tsections", "Tls", "Titles", "tsections", "Tstrings", " tales", "ttels", "ttitles", "pales", "ttrees", "pasks", "tappings", " tps", "tyitles", "ttributes", "ttappings", "ytels", "tls", "ytacters", "intstrings", "tales", " trees", "Ttitle", "intumbers", "sels", "tacters", "tumbers", "sappings", "ytappings", "pls", "ytails", " tls", "intitles", "sails", "Tales", "ytps", " tasks", " tributes", " tcriptions", "trees", " tacters", "tstrings", "Trees", "tasks", "tcriptions", "ttstrings", "pitles", "intacters", "ttitle", "sitles", "tails", "ytitles", "ytumbers", "ttcriptions", "tributes", "tels", "Tsections", "ttls"]}}
{"id1": "8670774", "id2": "4608665", "code1": "    public String getHtmlPage(URL url) {\n        String html = null;\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openConnection().getInputStream()));\n            StringBuffer sb = new StringBuffer();\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n            br.close();\n            html = sb.toString().replaceAll(HTML_FILTER_RE, \" \");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return html;\n    }\n", "code2": "    private static void loadUnits(URL url) throws Exception {\n        try {\n            SYSTEM = new UnitSystem();\n            XMLReader reader = SAXParserFactory.newInstance().newSAXParser().getXMLReader();\n            reader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n            reader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n            reader.setContentHandler(SYSTEM);\n            reader.parse(new InputSource(url.openStream()));\n        } catch (Throwable ex) {\n            throw new Exception(url.toString() + \": \" + ex.getMessage(), ex);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "user", "link", "browser", "connection", "feed", "buffer", "plug", "l", "http", "b", "fr", "base", "https", "loc", "f", "resource", "org", "server", "address", "config", "ur", "bel", "string", "image", "rl", "file", "uri", "ssl", "URL", "service", "Url", "web", "str", "sl"], "html": ["next", "source", "page", "HTML", "plain", "link", "xml", "result", "output", "message", "view", "format", "http", "fp", "css", "part", "f", "base", "data", "response", "email", "template", "js", "body", "ui", "e", "bb", "report", "json", "api", "text", "content", "temp", "all", "more", "sp", "db", "title", "details", "header", "tml", "img", "dom", "web", "str"], "br": ["ber", "HR", "brush", "reader", "cb", "gr", "bf", "bh", "browser", "cm", "arr", "be", "result", "io", "src", "http", "Br", "b", "bc", "fr", "bm", "BR", "stream", "r", "bs", "body", "bb", "ob", "bridge", "sr", "ch", "hr", "buf", "bar", "tr", "dr", "abs", "cr", "ab", "db", "mr", "yr", "err", "fb", "cro", "bro", "img", "str", "rb", "wr", "bl"], "sb": ["lp", "cb", "sa", "bf", "si", "bh", "mb", "buff", "sg", "ws", "BB", "pb", "src", "b", "sf", "bc", "bm", "kb", "bd", "abb", "bs", "obb", "erb", " eb", "SB", "bb", " SB", "sv", "gb", "xb", "eb", "B", "ib", "orb", "bsp", "ab", "db", "bt", "vm", "wb", "fb", "Bs", "nb", "lb", "rb", "bp"], "line": ["source", "page", "sel", "id", "split", "link", "pe", "feed", "len", "buffer", "lf", "lines", "l", "letter", "object", "b", "char", "LINE", "cell", "end", "Line", "part", "base", "number", "row", "data", "no", "column", "inline", "style", "word", "name", "e", "log", "cl", "text", "comment", "content", "li", "lc", "key", "le", "job", "string", "pass", "sp", "file", "db", "i", "code", "model", "character", "block", "lin", "str", "ip", "sl", "entry"]}}
{"id1": "2774850", "id2": "3108499", "code1": "    protected Scanner loadSource(String country) {\n        if (httpProxy != null && httpProxy.isEnabled()) {\n            System.setProperty(\"proxySet\", \"true\");\n            System.setProperty(\"http.proxyHost\", httpProxy.getUrl());\n            System.setProperty(\"http.proxyPort\", Integer.toString(httpProxy.getPort()));\n        }\n        try {\n            URL url = new URL(this.url + country);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            return new Scanner(connection.getInputStream());\n        } catch (MalformedURLException e) {\n            return null;\n        } catch (ProtocolException e) {\n            return null;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"country": ["source", "host", "language", "city", "year", "origin", "ry", "Country", "format", "request", "state", "part", "magic", "data", "region", "zip", "resource", "prefix", "server", "address", "cn", "name", "Region", "zone", "query", "currency", "report", "comment", "rule", "count", "family", "company", "file", "uri", "code", "service", "domain", "port", "ip", "location", "type"], "url": ["source", "host", "page", "site", "user", "feed", "conn", "l", "http", "client", "b", "this", "root", "channel", "base", "f", "layer", "number", "stream", "resource", "email", "server", "prefix", "address", "org", "config", "name", "target", "api", "relation", "ls", "location", "key", "string", "path", "point", "rule", "image", "socket", "ssl", "uri", "file", "db", "URL", "service", "Url", "www", "domain", "proxy", "web", "sl"], "connection": ["source", "wrapper", "open", "function", "io", "conn", "l", "communication", "http", "con", "out", "client", "control", "request", "connected", "part", "channel", "application", "directory", "version", " Connection", "response", "resource", "handler", "server", "config", "condition", "creator", "writer", "section", "component", "ion", "relation", "connect", "cache", "c", "uri", "context", "socket", "URL", "current", "database", "character", "position", "Connection", "proxy", "use"]}}
{"id1": "698010", "id2": "11444436", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void run() {\n        try {\n            FTPClient c = new FTPClient();\n            c.configure(ftpConfig);\n            logger.debug(\"Trying to connect\");\n            c.connect(\"127.0.0.1\", 21211);\n            logger.debug(\"Connected\");\n            c.setSoTimeout(5000);\n            if (!FTPReply.isPositiveCompletion(c.getReplyCode())) {\n                logger.debug(\"Houston, we have a problem. D/C\");\n                c.disconnect();\n                throw new Exception();\n            }\n            if (c.login(\"drftpd\", \"drftpd\")) {\n                logger.debug(\"Logged-in, now waiting 5 secs and kill the thread.\");\n                _sc.addSuccess();\n                Thread.sleep(5000);\n                c.disconnect();\n            } else {\n                logger.debug(\"Login failed, D/C!\");\n                throw new Exception();\n            }\n        } catch (Exception e) {\n            logger.debug(e, e);\n            _sc.addFailure();\n        }\n        logger.debug(\"exiting\");\n    }\n", "label": 0, "substitutes": {"view": ["page", "head", "sel", "reader", "input", "display", "link", "user", "layout", "buffer", "review", "widget", "http", "object", "out", "client", "request", "cell", "this", "model", "row", "base", "f", "ou", "by", "style", "View", "box", "server", "config", "template", "can", "el", "section", "update", "body", "event", "ui", "full", "e", "query", "VIEW", "see", "container", "edit", "screen", "show", "up", "session", "window", "index", "v", "image", "change", "gu", "cache", "vis", "html", "lock", "check", "im", "list", "vol", "manager", "block", "self", "group", "views", "form", "port", "use"], "url": ["source", "host", "page", "id", "link", "web", "browser", "connection", "open", "buffer", "download", "l", "http", "ul", "client", "b", "base", "f", "loader", "channel", "data", "stream", "zip", "resource", "email", "server", "address", "config", "name", "ob", "log", "length", "location", "job", "string", "path", "image", "socket", "file", "uri", "ssl", "fb", "builder", "URL", "hub", "Url", "www", "position", "blog", "gl", "jar", "sl"], "in": ["source", "reader", "input", "inc", "din", "arin", "win", "buffer", "doc", "nin", "con", "out", "b", "login", "as", "on", "data", "In", "pin", "stream", "again", "resource", "isin", "inner", "init", "ins", "ini", "sin", "cin", "socket", "file", "IN", "inn", "rin", "is", "bis", "lin", "s", "ac"], "bin": ["source", "reader", "an", "ban", "input", "binary", "din", "browser", "win", "abi", "connection", "buffer", "lib", "con", "out", "b", "login", "loader", "pin", "ruby", "bi", "inner", "oin", "body", "init", "bb", "spin", "gin", "ini", "kin", "run", "sin", "cin", "lock", "socket", "record", "file", "cache", "IN", "inside", "inn", "is", "nb", "lin", "bn", "bot", "fin"], "line": ["page", "entry", "id", "nl", "link", "user", "pe", "column", "lf", "range", "lines", "l", "letter", "definition", "out", "b", "val", "LINE", "cell", "end", "Line", "row", "base", "part", "data", "ine", "pin", "inline", "el", "section", "word", "name", "ge", "e", "unit", "log", "cl", "text", "comment", "lc", "job", "status", "le", "key", "up", "string", "file", "parse", "code", "service", "block", "lin", "look", "str", "ip", "type"], "version": ["vision", "id", "VERSION", "product", "download", "pull", "plugin", "username", "dev", "python", "format", "license", "driver", "Version", "description", "bug", "model", "ver", "cover", "feature", "server", "info", "section", "update", "filename", "name", "null", "patch", "versions", "beta", "v", "release", "string", "image", "vert", "install", "code", "date", "secret", "type", "video", "position", "option", "project", "value", "unit"], "build": ["how", "rel", "pull", "uild", "home", "bug", "row", "ver", "base", "Build", "style", "print", "clean", "work", "push", "info", "where", "hold", "update", "tag", "name", "patch", "log", "length", "comment", "job", "building", "show", "run", "release", "image", "help", "install", "lock", "make", "load", "built", "builder", "label", "block", "valid", "boot", "follow", "add", "test", "use", "unit"]}}
{"id1": "7252230", "id2": "19434890", "code1": "    private String callBambooApi(URL theURL) throws MonitoringException, BambooTicketNeedToBeRenewedError {\n        String returnedValue = null;\n        HttpURLConnection urlConnection = null;\n        BufferedReader urlConnectionReader = null;\n        try {\n            urlConnection = (HttpURLConnection) theURL.openConnection();\n            urlConnection.connect();\n            urlConnectionReader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            String line = null;\n            StringBuffer serverResponse = new StringBuffer();\n            while ((line = urlConnectionReader.readLine()) != null) {\n                serverResponse.append(line);\n            }\n            returnedValue = serverResponse.toString();\n            if (returnedValue.contains(\"<title>Bamboo Setup Wizard - Atlassian Bamboo</title>\")) {\n                throw new MonitoringException(\"Your Bamboo server installation is not finished ! Double click here to complete the Bamboo Setup Wizard !\", getMainPageURI());\n            }\n            InputSource is = new InputSource(new StringReader(serverResponse.toString()));\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            String error = xpath.evaluate(\"/errors/error\", is);\n            if (!\"\".equals(error)) {\n                if (\"User not authenticated yet, or session timed out.\".equals(error)) {\n                    throw new BambooTicketNeedToBeRenewedError();\n                } else {\n                    boolean isErrorOptionsRelated = false;\n                    URI uriForNonOptionsRelatedErrors = getMainPageURI();\n                    if (\"Invalid username or password.\".equals(error)) {\n                        isErrorOptionsRelated = true;\n                    }\n                    if (\"The remote API has been disabled.\".equals(error)) {\n                        error += \" Double click here to enable it.\";\n                        try {\n                            synchronized (this.bambooProperties) {\n                                uriForNonOptionsRelatedErrors = new URI(this.bambooProperties.getServerBaseUrl() + \"/admin/configure!default.action\");\n                            }\n                        } catch (URISyntaxException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                    throw new MonitoringException(\"Error reported by the Bamboo server: \" + error, isErrorOptionsRelated, uriForNonOptionsRelatedErrors);\n                }\n            }\n        } catch (ClassCastException e) {\n            throw new MonitoringException(\"Problem: the base URL defined for the Bamboo server in Options is not an http URL.\", true, null);\n        } catch (UnknownHostException e) {\n            throw new MonitoringException(\"Problem: cannot find host \" + theURL.getHost() + \" on the network.\", true, null);\n        } catch (ConnectException e) {\n            throw new MonitoringException(\"Problem: cannot connect to port \" + theURL.getPort() + \" on host \" + theURL.getHost() + \".\", true, null);\n        } catch (FileNotFoundException e) {\n            throw new MonitoringException(\"Problem: cannot find the Bamboo server REST api using the base URL defined for the Bamboo server in Options. Seems that this URL is not the one to your Bamboo server home page...\", true, null);\n        } catch (SocketException e) {\n            throw new MonitoringException(\"Problem: network error, connection lost.\", null);\n        } catch (XPathExpressionException e) {\n            throw new MonitoringException(\"Problem: the Bamboo Server returned an unexpected content for attribute <error>: \" + returnedValue, null);\n        } catch (MonitoringException e) {\n            throw e;\n        } catch (Throwable t) {\n            throw new MonitoringException(t, null);\n        } finally {\n            if (urlConnectionReader != null) {\n                try {\n                    urlConnectionReader.close();\n                } catch (IOException e) {\n                }\n            }\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n        return returnedValue;\n    }\n", "code2": "    public RequestLogger() {\n        Server.getScheduler().register(\"Request Log Rotator\", new SchedulerInterface() {\n\n            public int getScheduleRate() {\n                return 0;\n            }\n\n            public void handle() {\n                if (requestCounter == 0) {\n                    requestCounter++;\n                    return;\n                }\n                requestCounter++;\n                Iterator it = loggerTimeouts.keySet().iterator();\n                while (it.hasNext()) {\n                    String host = (String) it.next();\n                    String timeout = (String) loggerTimeouts.get(host);\n                    int timeoutVal = Integer.parseInt(timeout);\n                    if (timeoutVal > 0) {\n                        timeoutVal /= 10;\n                    }\n                    int timeoutMod = (requestCounter % timeoutVal);\n                    if (timeoutMod == 0) {\n                        Object loggerFile = loggerFiles.get(host);\n                        Object loggerFilenameObject = loggerFilenames.get(host);\n                        Object loggerDestObject = loggerDests.get(host);\n                        Object loggerCompressObject = loggerCompresses.get(host);\n                        Object loggerDayObject = loggerDays.get(host);\n                        Object loggerArchiveObject = loggerArchives.get(host);\n                        Object loggerDeleteObject = loggerDeletes.get(host);\n                        boolean rotateCompress = false;\n                        boolean rotateDelete = false;\n                        String rotateDest = null;\n                        String logFile = null;\n                        String rotateArchive = null;\n                        int rotateDays = 0;\n                        if (loggerCompressObject != null && ((String) loggerCompressObject).equalsIgnoreCase(\"true\")) {\n                            rotateCompress = true;\n                        }\n                        if (loggerDeleteObject != null && ((String) loggerDeleteObject).equalsIgnoreCase(\"true\")) {\n                            rotateDelete = true;\n                        }\n                        if (loggerDestObject != null) {\n                            rotateDest = (String) loggerDestObject;\n                        }\n                        if (loggerFilenameObject != null) {\n                            logFile = (String) loggerFilenameObject;\n                        }\n                        if (loggerArchiveObject != null) {\n                            rotateArchive = (String) loggerArchiveObject;\n                        }\n                        if (loggerDayObject != null) {\n                            rotateDays = Integer.parseInt((String) loggerDayObject);\n                        }\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                                buf = null;\n                                out = null;\n                                in = null;\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"' to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                destChannel = null;\n                                srcChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data from file '\" + logFile + \"' to '\" + destOutFile + \"' for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete) {\n                            try {\n                                ((PrintStream) loggerFile).close();\n                            } catch (Exception e) {\n                            }\n                            (new File(logFile)).delete();\n                            loggerFiles.remove(host);\n                            addLogger(host, logFile);\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            fileList = null;\n                            format1 = null;\n                            archive = null;\n                        }\n                    }\n                }\n                it = null;\n            }\n\n            public String identString() {\n                return \"Request Log Rotator\";\n            }\n        });\n    }\n", "label": 0, "substitutes": {"theURL": ["theUrl", "theCL", "yourCL", "anotherLL", " theLL", "TheURI", "anotherCL", "yourURI", "theURI", " theCL", "anotherUrl", "yourURL", " theUrl", "TheLL", " theURI", "yourUrl", "anotherURL", "TheUrl", "TheURL", "TheCL", "theLL"], "returnedValue": ["ReturnedString", "returningString", "returninedValue", "ReturnerValue", "accountedString", "returningVALUE", "ReturningValue", "returnpedUnit", "returnpedValue", "ReturningUnit", "Returningvalue", "returninedvalue", "returnpedvalue", "accountpedContent", "returnendedvalue", "returningValue", "returndValue", "returnpedVALUE", "returnpedContent", "accountedValue", "returnedContent", "returnedVal", "ReturnedUnit", "returnendedVal", "returningUnit", "returndvalue", "ReturnedVal", "accountpedString", "returnuatedVALUE", "ReturningString", "returndString", "returninedString", "returnpedString", "returningvalue", "returnendedValue", "ReturnerString", "returnedVALUE", "returnuatedContent", "returnedUnit", "returnerValue", "returningContent", "returnerString", "accountpedValue", "accountedVALUE", "returnedString", "ReturnedValue", "returnendedString", "ReturnerVal", "returnuatedString", "Returnervalue", "accountpedVALUE", "returndUnit", "returnerVal", "returnervalue", "returninedVal", "Returnedvalue", "returnedvalue", "accountedContent", "returnuatedValue"], "urlConnection": ["urlChannel", "webCollection", "serverconnection", "urlCollection", "httpConnection", "urlConnect", " urlChannel", " urlInfo", " urlHandler", "serverChannel", "URLConnector", "resourceInfo", "URLConnection", "serverUnit", "httpChannel", "urlconnection", "webConnection", "httpconnection", "serverHandler", "httpUnit", "sslCollection", "URLInfo", "urlConnector", " urlCollection", "sslConnection", " urlUnit", " urlConn", "urlConn", "resourceConnection", "resourceConnector", "urlUnit", "httpHandler", "URLconnection", "urlInfo", " urlConnect", "resourceconnection", "httpConn", " urlconnection", "webConnect", "sslConnect", "webconnection", "urlHandler", "serverConnection", " urlConnector", "serverConn", "sslconnection"], "urlConnectionReader": ["urlconnectionWriter", "urlResponseRunner", "urlCollectionWriter", "URLResponseWriter", "urlResponseWriter", "URLResponseReader", "httpconnectionLoader", "urlConnectorRaw", "URLResponseBuffer", "urlConnectionLoader", "urlConnectorDriver", "URLResponseRunner", "urlconnectionDriver", "httpConnectionRead", "urlconnectionBuffer", "urlCollectionRunner", "URLConnectionRaw", "urlStreamWriter", "urlConnectionRaw", "urlConnectorReader", "urlConnectionRead", "URLconnectionDriver", "urlCollectionReader", "urlLineLoader", "urlConnectionDriver", "URLConnectionBuffer", "urlconnectionReader", "httpConnectionReader", "urlResponseBuffer", "URLConnectionDriver", "URLconnectionReader", "httpConnectionWriter", "httpconnectionWriter", "urlCollectionBuffer", "URLconnectionRaw", "urlconnectionRunner", "urlResponseReader", "urlConnectorRead", "URLConnectionWriter", "URLConnectionRunner", "urlLineReader", "urlSectionRead", "urlConnectionWriter", "urlConnectionRunner", "URLconnectionRead", "urlSectionReader", "urlSectionDriver", "httpconnectionRead", "urlStreamReader", "urlSectionRaw", "urlconnectionLoader", "urlLineWriter", "httpconnectionReader", "URLConnectionRead", "URLConnectionReader", "httpConnectionLoader", "urlconnectionRead", "urlStreamLoader", "urlLineRead", "urlStreamRead", "urlConnectionBuffer", "urlconnectionRaw"], "line": ["source", "page", "reader", "url", "link", "pe", "connection", "feed", "buffer", "lf", "lines", "result", "message", "output", "limit", "l", "letter", "end", "LINE", "cell", "Line", "part", "row", "number", "data", "inline", "response", "server", "word", "shell", "name", "sync", "body", "ge", "unit", "log", "cl", "text", "comment", "content", "lc", "key", "le", "string", "cr", "pass", "file", "parse", "code", "header", "character", "lin", "str", "sl", "entry"], "serverResponse": [" serverResp", " serverConnection", "erverResponse", "serResult", "serAnswer", " serverResult", "erverLine", "urlResponse", " serverresponse", "jsonLine", "reverseResult", "ServerConnection", "serverStatus", "erverResp", " serverAnswer", "jsonResp", "serverBody", "serverResult", "serverFeed", "serverServer", " serverBody", "erverStatus", "testLine", "serResponse", " serverFeed", " serverStatus", "reverseBody", "serverAnswer", "erverConnection", "testResp", "serverLine", " serverLine", "urlResp", "serverResp", "ServerStatus", "testresponse", "serverresponse", "jsonResponse", "erverresponse", "jsonServer", "urlLine", "reverseResponse", " serverServer", "urlServer", "erverFeed", "serverConnection", "ServerResponse", "ServerFeed", "serBody", "reverseAnswer", "testResponse"], "is": ["source", "get", "sel", "nis", "id", "input", "si", "net", " iss", "sit", "isa", "io", " IS", "ais", "isl", "out", "in", "still", "ise", "as", "was", "iss", "are", "hit", "os", "resource", "es", "ris", "serv", "isin", "info", "ir", "has", "isi", "it", "ui", "ci", "IS", " isn", "mis", "iri", "isc", "ri", "its", "i", "im", "or", "us", "really", "bis", "Is", "et", " cis", "ar", " Is", "s", "ic", "does", "nit"], "xpath": ["rexmap", " XPath", " xPath", " xp", "xmlPath", "xmlp", "xgraph", " Xmap", "XPath", "xath", " xgraph", "xPath", " xath", "Xp", "rexPath", "xmap", "Xath", "rexpath", "rexgraph", "xmlpath", "xp", " xmap", " Xpath", " Xgraph", "Xpath", "xmlath"], "error": ["attr", "route", "warning", "msg", "link", "errors", "si", "success", " exception", "result", "function", "right", "core", "message", "rss", "style", "original", "object", "description", "bug", "op", "row", "ERROR", "magic", "data", "no", "serial", "response", "auto", "resource", "feature", "server", "call", "config", "info", "wrong", "address", "rage", "element", "name", "query", "event", "e", "o", "comment", "danger", "missing", "status", "index", "string", "rule", "html", "code", "err", "problem", "attribute", "or", "command", "block", "rr", "Error", "ror", "order", "throw", "reason", "detail", "value", "location", "type"], "uriForNonOptionsRelatedErrors": ["uriForNonOptionsRelatedMirrors", "uriForNonOptionsRelatedErases", "uriForNonOptionsRelatedHerases", "uriForNonOptionsRelatedMirrs", "uriForNonOptionsRelatedMirases", "uriForNonOptionsRelatedHerrs", "uriForNonOptionsRelatedIterrs", "uriForNonOptionsRelatedHerrors", "uriForNonOptionsRelatedErrorrors", "uriForNonOptionsRelatedErerrors", "uriForNonOptionsRelatedItererrors", "uriForNonOptionsRelatedErrorrs", "uriForNonOptionsRelatedErrorerrors", "uriForNonOptionsRelatedErrorases", "uriForNonOptionsRelatedErrs", "uriForNonOptionsRelatedIterrors", "uriForNonOptionsRelatedErblems", "uriForNonOptionsRelatedErrorblems", "uriForNonOptionsRelatedMirblems", "uriForNonOptionsRelatedIterases", "uriForNonOptionsRelatedHerblems"], "isErrorOptionsRelated": ["isUserOptionRelated", "isErrorErrorRELATED", "isUserOptionsRelated", "isErrorURLrelated", "isUserErrorRelated", "isErrorErrorRelated", "isErrorErrorrelated", "isErrorOptionrelated", "isUserOptionsRELATED", "isErrorOptionsRELATED", "isUserOptionRELATED", "isUserOptionrelated", "isUserOptionsrelated", "isErroroptionsrelated", "isErroroptionsRelated", "isErrorOptionsrelated", "isErrorErrorified", "isUserErrorified", "isErrorOptionsified", "isUserOptionsified", "isErroroptionsified", "isErrorOptionRelated", "isUserErrorrelated", "isErrorURLRELATED", "isErrorOptionRELATED", "isErrorOptionified", "isErrorURLRelated"]}}
{"id1": "3024988", "id2": "411630", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        try {\n            IOUtils.copy((Reader) null, out, \"UTF16\");\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"baout": ["BAOUT", "BAin", "BAerr", " bain", "baerr", "Baout", " baOut", " baerr", " baOUT", "BaOUT", "BAout", "BaOut", "Bain", "Baerr", "bain", "BAOut", "baOUT", "baOut"], "out": ["parent", "user", "write", "result", "output", "io", " in", "conn", "lib", "in", "object", "this", "client", "stable", "base", "data", "ref", "OUT", "Out", "again", "outs", "r", "server", "writer", "exec", "o", "exp", "log", "flush", "ex", "temp", "pool", "image", "obj", "file", "err", "at", "bin", "test", "copy", "line"]}}
{"id1": "2252572", "id2": "15607448", "code1": "    public static void main(String argv[]) {\n        String cp = System.getProperty(\"java.class.path\");\n        String sep = System.getProperty(\"file.separator\");\n        String dirpath = cp.substring(0, cp.lastIndexOf(sep));\n        String jarpath = dirpath + \"/WiiRemoteJ.jar\";\n        if (!new File(jarpath).exists()) {\n            try {\n                System.out.println(\"getting WiiRemoteJ file from remote source...\");\n                URL wiiRemLoc = new URL(\"http://www.world-of-cha0s.hostrocket.com/WiiRemoteJ/WiiRemoteJ%20v1.5.zip.gz\");\n                GZIPInputStream input = new GZIPInputStream(wiiRemLoc.openStream());\n                String temploc = copyInputStreamToTmpFile(input, \".zip\");\n                ZipInputStream zipIn = new ZipInputStream(new FileInputStream(temploc));\n                ZipEntry i = null;\n                while ((i = zipIn.getNextEntry()) != null) {\n                    if (i.getName().endsWith(\"WiiRemoteJ.jar\")) {\n                        File outjar = new File(jarpath);\n                        BufferedOutputStream fs = new BufferedOutputStream(new FileOutputStream(outjar));\n                        int bufferSize = 8192;\n                        byte[] buffer = new byte[bufferSize];\n                        int readSize = 0;\n                        while ((readSize = zipIn.read(buffer, 0, bufferSize)) != -1) {\n                            fs.write(buffer, 0, readSize);\n                        }\n                        fs.close();\n                    }\n                }\n                System.out.println(\"unpacked into classpath.\");\n            } catch (MalformedURLException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        Boogiepants.main(argv);\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"argv": ["Argp", "argsve", "argsf", " argve", "Argf", "Argv", "argV", "argsv", "argve", "paramf", "ArgV", " argf", "argsV", "paramv", " argV", "argsp", "argf", "paramp", "paramV", "Argve", "argp"], "cp": ["cop", "bp", "dc", "cd", "pkg", "cm", "cmp", "cf", "jp", "http", "fp", "pg", "ep", "cpp", "imp", "zip", "ctx", "dp", " CP", "wp", "pc", "ppa", "tp", "SCP", "mp", "hp", "gp", "cap", "lc", "CP", "col", "csv", "path", "cr", "sk", "CF", "sp", "c", "np", "pp", "cc", "ca", "ps", "ip", "p"], "sep": ["lem", "serps", "pesp", "sem", "sepa", "seps", "sept", "persept", "lesp", "pep", "serp", "scheps", " sepse", "sesp", "persep", "schep", "pem", "schepa", "sepse", " seps", "pept", "serpa", "lep", "persesp", "serpse", "schepse", "lept", "persem", " sepa"], "dirpath": ["libPath", "libdir", "directorypattern", "libpattern", "libpath", "folderPath", "dirpattern", " dircase", "libwork", "directorycase", "dircase", "directorydir", " dirpattern", " dirPath", "dirPath", "directoryPath", "folderdir", "directorywork", "libcase", "folderwork", "folderpath", "dirwork", "directorypath", "dirdir"], "jarpath": ["japuth", " japATH", " jarpaths", "Jarpathy", " jarpact", "jARPaths", "JarpATH", "jaspaths", " japath", "jarpaths", "jampath", "jARPATH", " jarppath", "jarith", "jARPath", " jARPuth", " japaths", "Japith", "JapATH", "jarppath", "jarputh", "japith", "jampATH", "jARPuth", "jarpathy", "jrapATH", " jarpATH", "japathy", "Jarpath", "jarath", "jARPact", "jamputh", " jarputh", "jARPpath", "Japath", "jrapath", " jARPath", "japATH", "japath", "japaths", "jrapith", " jARPATH", "jarpATH", "jarATH", "jampact", "jappath", "jaspATH", "jasppath", " jappath", "Japathy", " jARPact", "jaspath", "jrapathy", "jarpith", "jarpact", "japact", "Jarpith", "jarathy"], "wiiRemLoc": ["wiiREMloc", "waiRemLocation", "wiiremLOC", "wairemloc", "wiiREMLoc", "wairemLOC", "waiRemLoc", "wizremloc", "wizRemLoc", "wairemLocation", "wiiremLocation", "wiiREMLocation", "wiiRemoteLocation", "wiiRemoteLoc", "wizremLoc", "wiiRemoteloc", "wiiREMLOC", "wiiremLoc", "wiiRemoteLOC", "wizRemLOC", "wiiRemLocation", "wiiremloc", "wiiRemloc", "wairemLoc", "waiRemloc", "wizRemloc", "waiRemLOC", "wizremLOC", "wiiRemLOC"], "input": ["source", "reader", "tmp", "url", "inc", "upload", "feed", "xml", "pull", "io", "output", "rss", "audio", "http", "out", "in", "inf", "client", "data", "stream", "storage", "single", "zip", "config", "inner", "Input", "init", "amp", "api", "text", "temp", "up", "media", "image", "ssl", "inside", "img", "cms", "accept", "form", "copy", "qa"], "temploc": ["templloc", " templocol", "temppuc", "temlic", "templeric", "tempploc", "temlocol", "temppac", "templateuster", " templuster", "TemPloc", " templic", "temPloc", "templuc", "templocol", " temluster", "temPlac", "templic", "templuster", "Templloc", "templeroc", "templateoc", "TemPlac", "temppoc", "Templac", "temluster", "temPluc", " temloc", " temlic", "templeruster", "templateocol", "TemPluc", "templateic", "Temploc", "templac", " temlocol", "temPlloc", "temloc", "Templuc", "TemPlloc", "templerocol"], "zipIn": ["Zipin", "ZipIn", "archivein", "zipIns", "ZipIns", "zipIN", "folderin", "archiveIns", " zipin", "folderOut", "zin", "zOut", "zIns", " zipOut", "ZipIN", " zipIN", "folderIN", "archiveIn", "zipOut", "zIn", "zipin", "archiveOut", "folderIn", "ZipOut", "archiveIN"], "i": [" ti", "si", "qi", "abi", "iu", "phi", " ii", "io", "l", "out", "in", "b", "f", " e", " fi", "di", "bi", "I", "ie", "esi", "gi", " li", "ai", "ji", "oi", "ir", "ni", "info", "isi", "it", "ui", "ci", "e", "u", "o", "ani", "api", " pi", "ini", "li", "xi", "v", " vi", "ri", "j", "ori", "uri", "c", "ii", "vi", "pi", " bi", "p", "entry"], "outjar": ["outJar", "inJar", " outzip", "outputjar", "OUTJar", "Outjar", "OUTtar", "Outtar", "OUTzip", "outzip", "inzip", "outputzip", " outJar", "Outdir", "OUTjar", "indir", "Outzip", "injar", "OutJar", "outputJar", " outdir", "outtar", "outputtar", "outdir"], "fs": ["ks", "ows", "bf", "feed", "ends", "lf", "ils", "cf", "ss", "ws", "fc", "fp", "sf", "fd", "ms", "f", "fe", "fps", "os", "bs", "es", "posts", "qs", "js", "xs", "cs", "Fs", "rs", "abs", "FS", "df", "fits", "rows", "ls", "ios", "vals", "ips", "uses", "raf", "fb", "files", "fm", "ds", "irs", "obs", "ts", "ps", "res", "ves", "reads"], "bufferSize": ["bufferBody", "byteBody", "bufferSection", "BufferLength", "readsize", "bufferSIZE", "BufferBody", "readLength", "cacheSize", "byteSize", "cacheSection", "byteLength", "cacheSIZE", "BufferSize", " bufferSection", "readSection", "BufferNum", "bytesize", " bufferNum", "buffersize", "byteNum", " bufferBody", " buffersize", " bufferSIZE", "bufferNum", "readSIZE", "bufferLength", " bufferLength"], "buffer": ["page", "read", "size", "reader", "default", "queue", "memory", "binary", "feed", "reference", "buff", "result", "iter", "player", "Buffer", "message", "limit", "row", "layer", "number", "data", "resource", "server", "writer", "pad", "uffer", "padding", "transfer", "null", "batch", "length", "flush", "wave", "comment", "buf", "offset", "variable", "count", "document", "image", "seed", "cache", "border", "width", "header", "block", "position"], "readSize": ["readType", "loadCount", "readsize", "readLen", "readLength", "ReadLen", "ReadName", "writesize", "printQuery", "ReadType", " readQuery", "writeLength", "printSize", "writeName", "printName", "loadsize", "readName", "loadLen", "writeSize", "readQuery", "writeLen", " readName", "writeCount", "loadSize", "readCount", "ReadQuery", " readLen", "ReadCount", " readType", "Readsize", "printType", " readLength", "ReadLength", "ReadSize"]}}
{"id1": "7252230", "id2": "10277959", "code1": "    private String callBambooApi(URL theURL) throws MonitoringException, BambooTicketNeedToBeRenewedError {\n        String returnedValue = null;\n        HttpURLConnection urlConnection = null;\n        BufferedReader urlConnectionReader = null;\n        try {\n            urlConnection = (HttpURLConnection) theURL.openConnection();\n            urlConnection.connect();\n            urlConnectionReader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            String line = null;\n            StringBuffer serverResponse = new StringBuffer();\n            while ((line = urlConnectionReader.readLine()) != null) {\n                serverResponse.append(line);\n            }\n            returnedValue = serverResponse.toString();\n            if (returnedValue.contains(\"<title>Bamboo Setup Wizard - Atlassian Bamboo</title>\")) {\n                throw new MonitoringException(\"Your Bamboo server installation is not finished ! Double click here to complete the Bamboo Setup Wizard !\", getMainPageURI());\n            }\n            InputSource is = new InputSource(new StringReader(serverResponse.toString()));\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            String error = xpath.evaluate(\"/errors/error\", is);\n            if (!\"\".equals(error)) {\n                if (\"User not authenticated yet, or session timed out.\".equals(error)) {\n                    throw new BambooTicketNeedToBeRenewedError();\n                } else {\n                    boolean isErrorOptionsRelated = false;\n                    URI uriForNonOptionsRelatedErrors = getMainPageURI();\n                    if (\"Invalid username or password.\".equals(error)) {\n                        isErrorOptionsRelated = true;\n                    }\n                    if (\"The remote API has been disabled.\".equals(error)) {\n                        error += \" Double click here to enable it.\";\n                        try {\n                            synchronized (this.bambooProperties) {\n                                uriForNonOptionsRelatedErrors = new URI(this.bambooProperties.getServerBaseUrl() + \"/admin/configure!default.action\");\n                            }\n                        } catch (URISyntaxException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                    throw new MonitoringException(\"Error reported by the Bamboo server: \" + error, isErrorOptionsRelated, uriForNonOptionsRelatedErrors);\n                }\n            }\n        } catch (ClassCastException e) {\n            throw new MonitoringException(\"Problem: the base URL defined for the Bamboo server in Options is not an http URL.\", true, null);\n        } catch (UnknownHostException e) {\n            throw new MonitoringException(\"Problem: cannot find host \" + theURL.getHost() + \" on the network.\", true, null);\n        } catch (ConnectException e) {\n            throw new MonitoringException(\"Problem: cannot connect to port \" + theURL.getPort() + \" on host \" + theURL.getHost() + \".\", true, null);\n        } catch (FileNotFoundException e) {\n            throw new MonitoringException(\"Problem: cannot find the Bamboo server REST api using the base URL defined for the Bamboo server in Options. Seems that this URL is not the one to your Bamboo server home page...\", true, null);\n        } catch (SocketException e) {\n            throw new MonitoringException(\"Problem: network error, connection lost.\", null);\n        } catch (XPathExpressionException e) {\n            throw new MonitoringException(\"Problem: the Bamboo Server returned an unexpected content for attribute <error>: \" + returnedValue, null);\n        } catch (MonitoringException e) {\n            throw e;\n        } catch (Throwable t) {\n            throw new MonitoringException(t, null);\n        } finally {\n            if (urlConnectionReader != null) {\n                try {\n                    urlConnectionReader.close();\n                } catch (IOException e) {\n                }\n            }\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n        return returnedValue;\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"theURL": ["theUrl", "theCL", "yourCL", "anotherLL", " theLL", "TheURI", "anotherCL", "yourURI", "theURI", " theCL", "anotherUrl", "yourURL", " theUrl", "TheLL", " theURI", "yourUrl", "anotherURL", "TheUrl", "TheURL", "TheCL", "theLL"], "returnedValue": ["ReturnedString", "returningString", "returninedValue", "ReturnerValue", "accountedString", "returningVALUE", "ReturningValue", "returnpedUnit", "returnpedValue", "ReturningUnit", "Returningvalue", "returninedvalue", "returnpedvalue", "accountpedContent", "returnendedvalue", "returningValue", "returndValue", "returnpedVALUE", "returnpedContent", "accountedValue", "returnedContent", "returnedVal", "ReturnedUnit", "returnendedVal", "returningUnit", "returndvalue", "ReturnedVal", "accountpedString", "returnuatedVALUE", "ReturningString", "returndString", "returninedString", "returnpedString", "returningvalue", "returnendedValue", "ReturnerString", "returnedVALUE", "returnuatedContent", "returnedUnit", "returnerValue", "returningContent", "returnerString", "accountpedValue", "accountedVALUE", "returnedString", "ReturnedValue", "returnendedString", "ReturnerVal", "returnuatedString", "Returnervalue", "accountpedVALUE", "returndUnit", "returnerVal", "returnervalue", "returninedVal", "Returnedvalue", "returnedvalue", "accountedContent", "returnuatedValue"], "urlConnection": ["urlChannel", "webCollection", "serverconnection", "urlCollection", "httpConnection", "urlConnect", " urlChannel", " urlInfo", " urlHandler", "serverChannel", "URLConnector", "resourceInfo", "URLConnection", "serverUnit", "httpChannel", "urlconnection", "webConnection", "httpconnection", "serverHandler", "httpUnit", "sslCollection", "URLInfo", "urlConnector", " urlCollection", "sslConnection", " urlUnit", " urlConn", "urlConn", "resourceConnection", "resourceConnector", "urlUnit", "httpHandler", "URLconnection", "urlInfo", " urlConnect", "resourceconnection", "httpConn", " urlconnection", "webConnect", "sslConnect", "webconnection", "urlHandler", "serverConnection", " urlConnector", "serverConn", "sslconnection"], "urlConnectionReader": ["urlconnectionWriter", "urlResponseRunner", "urlCollectionWriter", "URLResponseWriter", "urlResponseWriter", "URLResponseReader", "httpconnectionLoader", "urlConnectorRaw", "URLResponseBuffer", "urlConnectionLoader", "urlConnectorDriver", "URLResponseRunner", "urlconnectionDriver", "httpConnectionRead", "urlconnectionBuffer", "urlCollectionRunner", "URLConnectionRaw", "urlStreamWriter", "urlConnectionRaw", "urlConnectorReader", "urlConnectionRead", "URLconnectionDriver", "urlCollectionReader", "urlLineLoader", "urlConnectionDriver", "URLConnectionBuffer", "urlconnectionReader", "httpConnectionReader", "urlResponseBuffer", "URLConnectionDriver", "URLconnectionReader", "httpConnectionWriter", "httpconnectionWriter", "urlCollectionBuffer", "URLconnectionRaw", "urlconnectionRunner", "urlResponseReader", "urlConnectorRead", "URLConnectionWriter", "URLConnectionRunner", "urlLineReader", "urlSectionRead", "urlConnectionWriter", "urlConnectionRunner", "URLconnectionRead", "urlSectionReader", "urlSectionDriver", "httpconnectionRead", "urlStreamReader", "urlSectionRaw", "urlconnectionLoader", "urlLineWriter", "httpconnectionReader", "URLConnectionRead", "URLConnectionReader", "httpConnectionLoader", "urlconnectionRead", "urlStreamLoader", "urlLineRead", "urlStreamRead", "urlConnectionBuffer", "urlconnectionRaw"], "line": ["source", "page", "reader", "url", "link", "pe", "connection", "feed", "buffer", "lf", "lines", "result", "message", "output", "limit", "l", "letter", "end", "LINE", "cell", "Line", "part", "row", "number", "data", "inline", "response", "server", "word", "shell", "name", "sync", "body", "ge", "unit", "log", "cl", "text", "comment", "content", "lc", "key", "le", "string", "cr", "pass", "file", "parse", "code", "header", "character", "lin", "str", "sl", "entry"], "serverResponse": [" serverResp", " serverConnection", "erverResponse", "serResult", "serAnswer", " serverResult", "erverLine", "urlResponse", " serverresponse", "jsonLine", "reverseResult", "ServerConnection", "serverStatus", "erverResp", " serverAnswer", "jsonResp", "serverBody", "serverResult", "serverFeed", "serverServer", " serverBody", "erverStatus", "testLine", "serResponse", " serverFeed", " serverStatus", "reverseBody", "serverAnswer", "erverConnection", "testResp", "serverLine", " serverLine", "urlResp", "serverResp", "ServerStatus", "testresponse", "serverresponse", "jsonResponse", "erverresponse", "jsonServer", "urlLine", "reverseResponse", " serverServer", "urlServer", "erverFeed", "serverConnection", "ServerResponse", "ServerFeed", "serBody", "reverseAnswer", "testResponse"], "is": ["source", "get", "sel", "nis", "id", "input", "si", "net", " iss", "sit", "isa", "io", " IS", "ais", "isl", "out", "in", "still", "ise", "as", "was", "iss", "are", "hit", "os", "resource", "es", "ris", "serv", "isin", "info", "ir", "has", "isi", "it", "ui", "ci", "IS", " isn", "mis", "iri", "isc", "ri", "its", "i", "im", "or", "us", "really", "bis", "Is", "et", " cis", "ar", " Is", "s", "ic", "does", "nit"], "xpath": ["rexmap", " XPath", " xPath", " xp", "xmlPath", "xmlp", "xgraph", " Xmap", "XPath", "xath", " xgraph", "xPath", " xath", "Xp", "rexPath", "xmap", "Xath", "rexpath", "rexgraph", "xmlpath", "xp", " xmap", " Xpath", " Xgraph", "Xpath", "xmlath"], "error": ["attr", "route", "warning", "msg", "link", "errors", "si", "success", " exception", "result", "function", "right", "core", "message", "rss", "style", "original", "object", "description", "bug", "op", "row", "ERROR", "magic", "data", "no", "serial", "response", "auto", "resource", "feature", "server", "call", "config", "info", "wrong", "address", "rage", "element", "name", "query", "event", "e", "o", "comment", "danger", "missing", "status", "index", "string", "rule", "html", "code", "err", "problem", "attribute", "or", "command", "block", "rr", "Error", "ror", "order", "throw", "reason", "detail", "value", "location", "type"], "uriForNonOptionsRelatedErrors": ["uriForNonOptionsRelatedMirrors", "uriForNonOptionsRelatedErases", "uriForNonOptionsRelatedHerases", "uriForNonOptionsRelatedMirrs", "uriForNonOptionsRelatedMirases", "uriForNonOptionsRelatedHerrs", "uriForNonOptionsRelatedIterrs", "uriForNonOptionsRelatedHerrors", "uriForNonOptionsRelatedErrorrors", "uriForNonOptionsRelatedErerrors", "uriForNonOptionsRelatedItererrors", "uriForNonOptionsRelatedErrorrs", "uriForNonOptionsRelatedErrorerrors", "uriForNonOptionsRelatedErrorases", "uriForNonOptionsRelatedErrs", "uriForNonOptionsRelatedIterrors", "uriForNonOptionsRelatedErblems", "uriForNonOptionsRelatedErrorblems", "uriForNonOptionsRelatedMirblems", "uriForNonOptionsRelatedIterases", "uriForNonOptionsRelatedHerblems"], "isErrorOptionsRelated": ["isUserOptionRelated", "isErrorErrorRELATED", "isUserOptionsRelated", "isErrorURLrelated", "isUserErrorRelated", "isErrorErrorRelated", "isErrorErrorrelated", "isErrorOptionrelated", "isUserOptionsRELATED", "isErrorOptionsRELATED", "isUserOptionRELATED", "isUserOptionrelated", "isUserOptionsrelated", "isErroroptionsrelated", "isErroroptionsRelated", "isErrorOptionsrelated", "isErrorErrorified", "isUserErrorified", "isErrorOptionsified", "isUserOptionsified", "isErroroptionsified", "isErrorOptionRelated", "isUserErrorrelated", "isErrorURLRELATED", "isErrorOptionRELATED", "isErrorOptionified", "isErrorURLRelated"]}}
{"id1": "10784622", "id2": "14232817", "code1": "    public static InputStream getPropertyFileInputStream(String propertyFileURLStr) {\n        InputStream in = null;\n        String errmsg = \"Fatal error: Unable to open specified properties file: \" + propertyFileURLStr;\n        try {\n            URL url = new URL(propertyFileURLStr);\n            in = url.openStream();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(errmsg);\n        }\n        return (in);\n    }\n", "code2": "    protected void lookupForParsedElementAnnotations(JClassType t) {\n        List<JMethod> methods = getParsableElementMethods(t);\n        if (methods != null) {\n            for (JMethod method : methods) {\n                ParsedElement elementAnnotation = method.getAnnotation(ParsedElement.class);\n                if (elementAnnotation.type() == ParsedElement.Types.SYNC) {\n                    try {\n                        String contents = \"\";\n                        URL url = getClass().getClassLoader().getResource(elementAnnotation.file());\n                        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                        String line = null;\n                        while ((line = reader.readLine()) != null) {\n                            contents += line;\n                        }\n                        reader.close();\n                        ParsedElementDescriptor elementDescriptor = new ParsedElementDescriptor(method.getName(), contents.replaceAll(\"\\\"\", \"'\"), elementAnnotation.type());\n                        this.parsedElementList.add(elementDescriptor);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                } else {\n                    ParsedElementDescriptor elementDescriptor = new ParsedElementDescriptor(method.getName(), elementAnnotation.file(), elementAnnotation.type());\n                    this.parsedElementList.add(elementDescriptor);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"propertyFileURLStr": ["propertyFileURIString", "propertyFileFileSTR", "propertyFileURString", "propertyFileURISTR", "propertyFileStringStr", "propertyFilesURLSt", "propertyFileFileSt", "propertyFileURLSTR", "propertyFileFileStr", "propertyFilesUrlstr", "propertyFileURISt", "propertyFilesUrlSt", "propertyFileFileString", "propertyFilesURLStr", "propertyFilesUrlString", "propertyFilesUrlSTR", "propertyFileURIstr", "propertyFileUrlStr", "propertyFilesURLSTR", "propertyFileURIStr", "propertyFileUrlstr", "propertyFileUrlSTR", "propertyFilesUrlStr", "propertyFileURSt", "propertyFileURLString", "propertyFileUrlString", "propertyFileURSTR", "propertyFileURLstr", "propertyFileStringString", "propertyFileURLSt", "propertyFilesURLString", "propertyFileStringSTR", "propertyFileStringstr", "propertyFileUrlSt", "propertyFilesURLstr", "propertyFileURStr"], "in": ["source", "reader", "id", "input", "inc", "din", "token", "win", "xml", "io", "nin", "conn", "out", "fd", "part", "login", "f", "as", "data", "In", "pin", "stream", "n", "r", "inas", "resource", "serv", "isin", "inner", "it", "ins", "ax", "gin", "ini", "m", "session", "kin", "index", "socket", "file", "ssl", "i", "IN", "err", "inn", "rin", "is", "bin", "str"], "errmsg": ["fynm", "errormessage", "errorMsg", "rrnm", " errMsg", "rrmessage", " errmessage", "rrmsg", "rrMsg", "rrstr", "fymsg", " errnm", "fyMsg", "errmessage", "errstr", "errMsg", "errormsg", "fymessage", " errstr", "errorstr", "errnm"], "url": ["source", "page", "ball", "id", "browser", "feed", "plug", "download", "pull", "open", "rel", "io", "l", "http", "out", "object", "b", "fr", "f", "channel", "data", "stream", "r", "zip", "resource", "server", "el", "ob", "api", "bel", "sl", "ls", "string", "path", "image", "rl", "obj", "file", "uri", "i", "ssl", "URL", "Url", "blog", "web", "str", "ll"]}}
{"id1": "22932987", "id2": "15424571", "code1": "    protected String readContent(URL url, int width) {\n        StringBuffer content = new StringBuffer(\"\");\n        String line = \"\";\n        try {\n            BufferedReader f = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = f.readLine()) != null) content.append(line + \"\\n\");\n            f.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (width >= 0) {\n            String width_old = \"width=\\\"xxx\\\"\";\n            String width_new = \"width=\\\"\" + width + \"\\\"\";\n            int v0 = content.indexOf(width_old);\n            int v1 = v0 + width_old.length();\n            content.replace(v0, v1, width_new);\n        }\n        return content.toString();\n    }\n", "code2": "    private File copyFile(File source, File destiny) {\n        try {\n            FileInputStream fileinputstream = new FileInputStream(source);\n            FileOutputStream fileoutputstream = new FileOutputStream(destiny);\n            byte abyte0[] = new byte[4096];\n            int i;\n            while ((i = fileinputstream.read(abyte0)) != -1) fileoutputstream.write(abyte0, 0, i);\n            fileinputstream.close();\n            fileoutputstream.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            LOGGER.error(e.getMessage());\n        } catch (IOException e) {\n            e.printStackTrace();\n            LOGGER.error(e.getMessage());\n        }\n        return destiny;\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "user", "connection", "feed", "buffer", "io", "l", "http", "this", "b", "lr", "fr", "base", "loc", "stream", "resource", "server", "address", "config", "ur", "log", "bel", "location", "job", "string", "path", "image", "file", "uri", "ssl", "err", "URL", "service", "Url", "blog", "sl"], "width": ["page", "left", "size", "write", "layout", "buffer", "sword", "space", "settings", "fill", "scale", "output", "weight", "widget", "format", "w", "gender", "number", "style", "Width", "writer", "update", "word", "x", "filename", "flow", "length", "text", "height", "align", "index", "string", "port", "platform", "value", "west", "padding", "duration"], "content": ["host", "page", "size", "wrapper", "write", "feed", "cm", "xml", "buffer", "complete", "Content", "result", "core", "message", "output", "weight", "format", "css", "description", "column", "const", "layer", "data", "response", "clean", "resource", "work", "raw", "address", "server", "section", "word", "padding", "body", "full", "large", "report", "cont", "container", "length", "text", "comment", "temp", "lc", "job", "string", "media", "image", "document", "load", "c", "file", "html", "code", "cache", "array", "header", "current", "value"], "f": ["af", "reader", "h", "rf", "bf", "d", "feed", "lf", "cf", "io", "fo", "l", "fs", "w", "fc", "fp", "b", "sf", "fd", "inf", "fr", "tf", "fe", "fast", "stream", "fw", "r", "handler", "fac", "e", "t", "F", "uf", "df", "v", "c", "file", "i", "fb", "raf", "fm", "ff", "fa", "p"], "line": ["source", "page", "entry", "sel", "continue", "nl", "link", "write", "feed", "lf", "lines", "message", "l", "letter", "object", "end", "LINE", "column", "cell", "Line", "part", "base", "row", "data", "no", "margin", "inline", "style", "el", "word", "sync", "name", "cl", "log", "text", "comment", "lc", "li", "le", "key", "job", "string", "rule", "pass", "file", "code", "err", "label", "header", "block", "character", "lin", "unit"], "width_old": ["content_old", "weight_old", "width_0", "content_0", "weight_older", "width_older", "content_older", " width_back", "width_back", "content_new", "width_last", " width_last", "weight_new"], "width_new": ["width_1", "width_New", "weight_old", "weight_1", "width_0", "weight_0", "weight_New", "weight_new"], "v0": ["f02", "f2", "val6", "p1", "j90", "V6", "v00", "f0", "qu1", "sv90", "V00", "val0", " v00", "qu0", "j0", " v6", "j00", "sv6", "p02", "v02", " v2", "sv00", "p0", "qu2", "v6", "val00", "v2", "j6", "qu02", "sv0", "V2", " v90", "V0", "val2", "v90", "p2", "f1"], "v1": ["p11", "p1", "k11", "p3", " v31", "k1", "vari31", "k3", "V1", "vari0", " v3", "vari2", "V31", "v11", " v2", "p0", "v3", "v31", "v2", "V2", "V0", "vari1", " v11", "k0"]}}
{"id1": "22948678", "id2": "20086435", "code1": "    public void load() throws ResourceInstantiationException, InvalidFormatException {\n        if (null == url) {\n            throw new ResourceInstantiationException(\"URL not set (null).\");\n        }\n        try {\n            BufferedReader mapReader = new BomStrippingInputStreamReader((url).openStream(), ENCODING);\n            String line;\n            MappingNode node;\n            while (null != (line = mapReader.readLine())) {\n                if (0 != line.trim().length()) {\n                    node = new MappingNode(line);\n                    this.add(node);\n                }\n            }\n            mapReader.close();\n        } catch (InvalidFormatException ife) {\n            throw new InvalidFormatException(url, \"on load\");\n        } catch (IOException ioe) {\n            throw new ResourceInstantiationException(ioe);\n        }\n    }\n", "code2": "    private InputStream createInputStream(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"classpath://\")) {\n            InputStream is = XMLResource.class.getResourceAsStream(url.substring(12));\n            if (is == null) throw new IOException(\"Couldn't open stream to [\" + url + \"]\");\n            return is;\n        } else {\n            return new URL(url).openStream();\n        }\n    }\n", "label": 0, "substitutes": {"mapReader": ["resourcereader", "resourceReader", "Mapreader", " maper", "addressRead", "linkLine", "mapLine", "addressLine", "mapRead", "linkParser", "MapReader", "mapLoader", "appLoader", "resourceLoader", "linker", " mapHandler", "addressreader", "resourceHandler", " mapLoader", "MapHandler", " mapreader", "appreader", "linkReader", "addresser", "mapHandler", "addressParser", "addressReader", "appReader", "maper", " mapLine", "mapreader", " mapParser", "MapLoader", "mapParser", " mapRead", "addressLoader", "appRead"], "line": ["source", "page", "sel", "value", "id", "url", "nl", "link", "pe", "len", "lf", "lines", "message", "l", "object", "char", "val", "LINE", "cell", "end", "Line", "row", "base", "part", "data", "ine", "no", "inline", "n", "zip", "raw", "el", "word", "name", "ge", "e", "unit", "cl", "text", "comment", "lc", "key", "le", "string", "rule", "pass", "ml", "file", "parse", "code", "pos", "block", "lin", "str", "sl", "entry"], "node": ["odes", "source", "parent", "route", "Node", "id", "nn", "edge", "core", "result", "message", "one", "cdn", "this", "object", "root", "model", "row", "layer", "number", "loader", "data", "n", "tree", "slave", "server", "child", "info", "writer", "element", "bean", "name", "holder", "api", "content", "key", "od", "path", "document", "leaf", "obj", "load", "builder", "array", "scene", "self", "ode", "value", "null", "entry"]}}
{"id1": "3542936", "id2": "17268049", "code1": "    public boolean deleteByQuery(String query, int coreId) {\n        try {\n            URL url = new URL(solrUrl + \"/core\" + coreId + \"/update\");\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-type\", \"text/xml\");\n            conn.setRequestProperty(\"charset\", \"utf-8\");\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            System.out.println(\"******************\" + query);\n            wr.write(\"<delete><query>\" + query + \"</query></delete>\");\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = rd.readLine()) != null) {\n                System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-type\", \"text/xml\");\n            conn.setRequestProperty(\"charset\", \"utf-8\");\n            wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(\"<commit/>\");\n            wr.flush();\n            rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public DProblem loadProblem(String urlString) throws DataStoreException {\n        try {\n            URL url = new URL(urlString);\n            IWPLog.info(this, \"[DProblemManager_HTTP] URL :\" + urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer data = new StringBuffer();\n            String line;\n            int i = 0;\n            while ((line = in.readLine()) != null) {\n                data.append(line + \"\\n\");\n                i++;\n            }\n            DProblem prob = DProblemXMLParser.load(data.toString());\n            if (prob != null) {\n                prob.setUsername(\"Local\");\n                prob.setFilename(urlString);\n                prob.setAccessMode(DProblemManager.HTTP);\n            }\n            return prob;\n        } catch (MalformedURLException e) {\n            throw new DataStoreException(e);\n        } catch (IOException e) {\n            IWPLog.info(this, \"[DProblemManager_HTTP.loadProblem] unable to load: \" + urlString + \": \" + e.getMessage());\n            e.printStackTrace();\n            throw new DataStoreException(e);\n        } catch (XMLParserException e) {\n            throw new DataStoreException(e);\n        }\n    }\n", "label": 1, "substitutes": {"query": ["dq", "sql", "term", "year", "xml", "core", "out", "request", "model", "row", "table", "style", "resource", "feature", "qs", "module", "update", "script", "depth", "name", "qu", "scope", "patch", "json", "password", "text", "comment", "iq", "timeout", "index", "string", "quest", "cache", "lock", "uri", "parse", "error", "command", "Query", "search", "expression", "sq", "q", "database", "question", "str", "filter", "quer", "type"], "coreId": ["ceid", "coreid", "serverPath", "ceId", "corePath", " coreType", "customPath", "coreType", "customById", "serverId", " coreid", "customID", "serverID", "coreById", "ceType", "Coreid", "serverById", "CoreId", "CoreType", "ceID", " coreById", "coreID", " coreID", "customId", " corePath", "CoreID"], "url": ["dl", "host", "sel", "left", "nl", "link", "user", "connection", "pull", "build", "ll", "io", "l", "http", "con", "b", "lr", "fr", "f", "base", "loc", "loader", "layer", "r", "resource", "server", "config", "el", "ur", "bb", "cl", "log", "bel", "fl", "ls", "li", "lc", "key", "il", "path", "rl", "impl", "connect", "file", "ssl", "uri", "lock", "ol", "URL", "Url", "www", "blog", "gl", "sl"], "conn": ["attr", "contract", "net", "win", "auth", "not", "cf", "l", "con", "ctrl", "enc", "ctx", "sync", "oss", "rc", "nt", "gn", "log", "cl", "syn", "cli", "rec", "connect", "ssl", "err", "qt", "Conn", "ll", "cb", "nn", "lang", "ht", "co", "part", "po", "ec", "oa", "ai", "mc", "act", "fn", "apt", "col", "c", "rt", "dc", "en", "client", "loc", "rn", "cp", "n", "org", "server", "cn", "exec", "pr", "ch", "ann", "reg", "conv", "ct", "nc", "iw", "host", "connection", "cm", "nw", "cat", "pg", "serv", "config", "dn", "conf", "init", "ci", "api", "lc", "session", "sec", "lock", "on", "coll"], "wr": ["WR", "wu", "ru", "rar", "rx", "wal", "arr", "nw", "nr", "wk", "wx", "ew", "w", "wd", "sw", "wa", "fr", "rn", "fw", "wh", "r", "Wr", "raft", "wm", "writer", "wer", "wp", "shr", "nor", "wo", "rer", "wl", "sr", "pr", "rh", "dr", "Writer", "hr", "vr", "spr", "rw", "rt", "mr", "wb", "raf", "war", "err", "wy", "rr", "wan", "kr", "RW", "usr", "wt"], "rd": ["respond", "dc", "ru", "rf", "reader", "rar", "rowd", "rx", "cd", "ra", "dig", "dd", "director", "ld", "mid", "xd", "arr", "RS", "wx", "pd", "rss", "wd", "td", "fd", "fr", "bd", "rn", "r", "rob", "rg", "writer", "RR", "rus", "nor", "rer", "func", "rm", "rs", "rod", "pr", "rh", "dr", "sr", "hr", "adr", "vr", "cr", "rl", "rw", "rt", "rid", "mr", "rr", "ds", "nd", "dra", "rb", "RL", "RD"], "line": ["sel", "nl", "lines", "l", "definition", "end", "val", "Line", "model", "number", "style", "sync", "name", "ge", "cl", "log", "sl", "le", "day", "cr", "file", "pass", "id", "feed", "plugin", "iter", "one", "cell", "part", "row", "inline", "job", "key", "col", "lin", "str", "source", "page", "none", "link", "write", "pe", "user", "len", "space", "LINE", "column", "no", "el", "e", "text", "comment", "string", "error", "i", "entry", "next", "reader", "connection", "letter", "out", "char", "data", "ne", "spec", "lc", "li", "code", "character", "block", "shell", "unit"]}}
{"id1": "5467907", "id2": "5600261", "code1": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    private String calculateMD5(String value) {\n        String finalString = new String(\"\");\n        try {\n            MessageDigest md5Alg = MessageDigest.getInstance(\"MD5\");\n            md5Alg.reset();\n            md5Alg.update(value.getBytes());\n            byte messageDigest[] = md5Alg.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            finalString = hexString.toString();\n        } catch (NoSuchAlgorithmException exc) {\n            throw new RuntimeException(\"Hashing error happened:\", exc);\n        }\n        return finalString;\n    }\n", "label": 0, "substitutes": {"src": ["source", "sel", "sb", "url", "input", "upload", "download", "sit", "conn", "http", "in", "b", "this", "st", "root", "loc", "data", "stream", "storage", "resource", "sc", "config", "dest", "iv", "filename", "rc", "inst", "copy", "ls", "sin", "slice", "path", "image", "obj", "file", "uri", "files", "dist", "img", "s", "rb", "sl"], "dst": [" dsts", "dsts", "Ddest", "adst", "Dcr", "tdot", "adcr", "dcr", "dbds", " dcr", "fdst", "dbot", "addest", "fdds", "dds", "dbst", "dot", "adsts", "dbput", "Dsts", "dput", " ddest", "fdot", "tdds", "Dst", "fdput", "ddest", "tdst", "tdput"], "inChannel": ["inConnection", "againCamera", "againChan", "innerStream", "outChan", "binStream", "incStream", "loginChan", " inChan", "binchannel", "againChannel", "INChannel", " inStream", "inMessage", "inChan", " inContext", "incChan", "incCamera", "INchannel", "inputConnection", "inCamera", "outchannel", "binConnection", "innerConnection", "outMessage", "binChan", "INChan", " inConnection", "InChan", "inputChannel", "inputchannel", "inchannel", "inStream", "inputChan", "Inchannel", "INConnection", "loginChannel", "incChannel", "INStream", "outStream", "InContext", "inContext", " inMessage", "innerChannel", "InStream", "binChannel", "loginCamera", "outConnection", "inputMessage", "InChannel", "againStream", "innerChan", "inputStream", " inchannel", "loginStream", "outContext"], "outChannel": ["inConnection", "againChan", "outputStream", "outChan", " outChan", " outQueue", " outWriter", "againChannel", " outchannel", "againQueue", "Outchannel", "inChan", "offContext", "outputchannel", "inWriter", " outGate", "offWriter", "offChannel", "outchannel", "offChan", " outConnection", "outputChan", "OutChan", "outputChannel", "inputChannel", "OutChannel", "inputchannel", "inchannel", "inStream", "inputChan", " outContext", "outQueue", "againConnection", "outStream", "inputStream", "inContext", "OutStream", "outWriter", "outGate", "outConnection", "againStream", "outContext", "inGate", "againchannel", " outStream", "againGate", "inQueue"], "result": ["ure", "successful", "folder", "continue", "default", "compl", "success", "Result", "complete", "math", "function", "true", "card", "diff", "f", "data", "future", "response", "false", "match", "work", "ret", "r", "cash", "func", "event", "results", "length", "comment", "found", "ault", "status", "done", "cache", "error", "err", "or", "array", "current", "valid", "cup", "test", "res", "use", "pass"]}}
{"id1": "7550876", "id2": "1611515", "code1": "    public void test(TestHarness harness) {\n        harness.checkPoint(\"TestOfMD4\");\n        try {\n            Security.addProvider(new JarsyncProvider());\n            algorithm = MessageDigest.getInstance(\"MD4\", \"JARSYNC\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.provider\");\n            throw new Error(x);\n        }\n        try {\n            for (int i = 0; i < 64; i++) algorithm.update((byte) 'a');\n            byte[] md = algorithm.digest();\n            String exp = \"52f5076fabd22680234a3fa9f9dc5732\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testSixtyFourA\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.provider\");\n        }\n        try {\n            harness.verbose(\"NOTE: This test may take a while.\");\n            for (int i = 0; i < 536870913; i++) algorithm.update((byte) 'a');\n            byte[] md = algorithm.digest();\n            String exp = \"47d01fa6657f903280232d30b98da482\";\n            harness.check(exp.equals(Util.toHexString(md)), \"test536870913A\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.provider\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"a\".getBytes());\n            String exp = \"bde52cb31de33e46245e05fbdbd6fb24\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testA\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testA\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"abc\".getBytes());\n            String exp = \"a448017aaf21d8525fc10ae87aa6729d\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testABC\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testABC\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"message digest\".getBytes());\n            String exp = \"d9130a8164549fe818874806e1c7014b\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testMessageDigest\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testMessageDigest\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"abcdefghijklmnopqrstuvwxyz\".getBytes());\n            String exp = \"d79e1c308aa5bbcdeea8ed63df412da9\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testAlphabet\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testAlphabet\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".getBytes());\n            String exp = \"043f8582f241db351ce627e153e7f0e4\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testAsciiSubset\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testAsciiSubset\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\".getBytes());\n            String exp = \"e33b4ddc9c38f2199c3e7b164fcc0536\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testEightyNumerics\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testEightyNumerics\");\n        }\n        try {\n            algorithm.update(\"a\".getBytes(), 0, 1);\n            clone = (MessageDigest) algorithm.clone();\n            byte[] md = algorithm.digest();\n            String exp = \"bde52cb31de33e46245e05fbdbd6fb24\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testCloning #1\");\n            clone.update(\"bc\".getBytes(), 0, 2);\n            md = clone.digest();\n            exp = \"a448017aaf21d8525fc10ae87aa6729d\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testCloning #2\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testCloning\");\n        }\n    }\n", "code2": "    public static Image getPluginImage(Object plugin, String name) {\n        try {\n            try {\n                URL url = getPluginImageURL(plugin, name);\n                if (mURLImageMap.containsKey(url)) {\n                    return mURLImageMap.get(url);\n                }\n                InputStream is = url.openStream();\n                Image image;\n                try {\n                    image = getImage(is);\n                    mURLImageMap.put(url, image);\n                } finally {\n                    is.close();\n                }\n                return image;\n            } catch (Throwable e) {\n                LOG.debug(\"Ignore any exceptions\");\n            }\n        } catch (Throwable e) {\n            LOG.debug(\"Ignore any exceptions\");\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"harness": [" harner", "borresh", " harrity", "arinvey", "houvey", "harler", "arity", "hansession", "harning", "hanment", "Harler", "harner", "harvey", "arinvest", "harservice", "borment", "harly", "arinment", " haress", "warness", "harresh", "warrity", "Harself", "warith", "hasystem", "carness", "earness", "warself", "haress", " harest", "arest", "carner", "carest", " harsystem", " harself", "warly", "houity", "hase", "harnesses", "houness", "garsession", "harity", "ighest", "garnesses", "arith", "borvey", "horvest", "fullness", "harith", "haity", "Harna", "horresh", " harning", "fullresh", " harly", "earse", "warment", "ighment", "garself", "arsession", " harvey", "harment", "hansystem", "garvey", "horness", "garness", "earity", " harment", "harna", "houess", "Harse", "Harning", "Harnesses", "harrity", " harler", "warservice", " harsession", " harna", "garler", "hanness", "hanself", "Harrity", "harself", "arinresh", "Harness", "hanith", "hanesses", "harest", " harity", "garess", "ighner", "garity", "arservice", "arinness", "Harly", "Harsystem", "haness", "warse", "garsystem", " harservice", " harse", "Harservice", "hanity", "harsystem", " harnesses", "carment", "harsession", "warna", "arment", "earning", "Harity", "warsession", "borness", "haservice", "harse", "garservice", "fullvey", "ighness", "horvey", "garment", " harresh", "arness", "harvest", "fullvest", "Harest", "arna"], "algorithm": ["aligorith", " alsystem", "Algo", " aluminum", "Alapter", "updategorithm", "allmbol", "allgo", "opersystem", "allapter", "alphgorithm", "updategorith", "aligngebra", "aruminum", "Algorithm", "alphknowledge", "omalrator", " alapter", " algorith", " alider", "halgorith", "aladdin", "opergebra", "aligment", "aligngment", "alpassword", "alider", "aluminum", "chalpassword", "halgment", "updaterator", "halgorithm", "aligebra", "allgorithm", "logaddin", "elgebra", "alapter", "allsystem", "algebra", " algebra", "Alpassword", "aligngorith", "unalgorithm", "alrator", "aligngorithm", "Alipher", "elider", "Alknowledge", "argorithm", " algo", "aligorithm", "chalipher", "Algebra", "alphpassword", "Alrator", "alknowledge", "logsystem", "unalchant", " aladdin", "alsystem", "alladdin", "almbol", "updatechant", "algorith", "halgebra", "elgorithm", "arrator", "loggorithm", "chalgorithm", " alrator", "omalgorithm", "omalgorith", "argorith", "algment", "alipher", "Algorith", "alchant", "opergorithm", "elsystem", "algo", "allgebra", "alphipher", " almbol", "chalknowledge", "logmbol", "Alchant", "unalrator", "omaluminum", "unalgorith", "operider"], "i": ["h", "id", "si", "d", "qi", "multi", "abi", "uli", "min", "iu", "phi", "k", "io", "yi", "y", "in", "b", "f", "base", "di", "bi", "zi", "n", "I", "ti", "ji", "ai", "info", "gi", "inner", "ni", "adi", "x", "ix", "it", "ui", "ci", "u", "o", "init", "ski", "ini", "m", "li", "v", "xi", "index", "ri", "slice", "gu", "j", "c", "uri", "ii", "pi", "is", "fi", "chi", "mi", "mini", "ip", "p", "ie"], "md": ["id", "dc", "msg", "cd", "mb", "d", "mid", "dd", "ld", "ind", "hd", "sm", "mm", "doc", "lim", "ma", "vd", "gd", "dev", "mem", "cmd", "ms", "diff", "mode", "magic", "mo", "bd", "data", "zip", "mand", "mag", "meta", "mc", "pad", "fun", "sha", "desc", "body", "dm", "MD", "m", "dr", "od", "pm", "oda", "help", "html", "mg", "db", "mad", "med", "metadata", "nd", "amd", "sd", "ng", "nm", "dig", "mn"], "exp": ["host", "div", "expl", "plus", "str", "msg", "inc", "lit", "xml", "rep", "doc", "mem", "lib", "format", "ez", "app", "Exp", "op", "prop", "isp", "imp", "EXP", "magic", "hex", "style", "zip", "enc", "comp", "box", "raw", "push", "fun", "exec", "script", "desc", "ix", "scope", "feat", "printf", "spec", "ef", "act", "api", "express", "ex", "orig", "sp", "reg", "file", "html", "code", "vec", "err", "xp", "np", "field", "expr", "form", "ng", "acc", "ip", "ext"]}}
{"id1": "10717656", "id2": "19687459", "code1": "    public void run() {\n        StringBuffer xml;\n        String tabName;\n        Element guiElement;\n        setBold(monitor.getReading());\n        setBold(monitor.getReadingStatus());\n        monitor.getReadingStatus().setText(\"      Working\");\n        HttpMethod method = null;\n        xml = new StringBuffer();\n        File tempfile = new File(url);\n        if (tempfile.exists()) {\n            try {\n                InputStream in = new FileInputStream(tempfile);\n                int temp;\n                while ((temp = in.read()) != -1) {\n                    xml.append((char) temp);\n                }\n                in.close();\n            } catch (IOException e) {\n                System.out.println(\"Loading Monitor Failed, error while reading XML file from local file\");\n                e.printStackTrace(System.err);\n                return;\n            }\n        } else {\n            try {\n                HttpClient client = new HttpClient();\n                method = new GetMethod(url);\n                int response = client.executeMethod(method);\n                if (response == 200) {\n                    InputStream in = method.getResponseBodyAsStream();\n                    int temp;\n                    while ((temp = in.read()) != -1) {\n                        xml.append((char) temp);\n                    }\n                    in.close();\n                } else {\n                    if (method != null) {\n                        method.releaseConnection();\n                    }\n                    System.out.println(\"Loading Monitor Failed. Incorrect response from HTTP Server \" + response);\n                    return;\n                }\n            } catch (IOException e) {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n                System.out.println(\"Loading Monitor Failed, error while reading XML file from HTTP Server\");\n                e.printStackTrace(System.err);\n                return;\n            }\n        }\n        setPlain(monitor.getReading());\n        setPlain(monitor.getReadingStatus());\n        monitor.getReadingStatus().setText(\"      Done\");\n        setBold(monitor.getValidating());\n        setBold(monitor.getValidatingStatus());\n        monitor.getValidatingStatus().setText(\"      Working\");\n        DocumentBuilderFactoryImpl factory = new DocumentBuilderFactoryImpl();\n        try {\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            Document document = parser.parse(new ByteArrayInputStream(xml.toString().getBytes()));\n            if (method != null) {\n                method.releaseConnection();\n            }\n            Element root = document.getDocumentElement();\n            NodeList temp = root.getElementsByTagName(\"resource\");\n            for (int j = 0; j < temp.getLength(); j++) {\n                Element resource = (Element) temp.item(j);\n                resources.add(new URL(resource.getAttribute(\"url\")));\n            }\n            NodeList connections = root.getElementsByTagName(\"jmxserver\");\n            for (int j = 0; j < connections.getLength(); j++) {\n                Element connection = (Element) connections.item(j);\n                String name = connection.getAttribute(\"name\");\n                String tempUrl = connection.getAttribute(\"url\");\n                if (tempUrl.indexOf(\"${host}\") != -1) {\n                    HostDialog dialog = new HostDialog(Config.getHosts());\n                    String host = dialog.showDialog();\n                    if (host == null) {\n                        System.out.println(\"Host can not be null, unable to create panel.\");\n                        return;\n                    }\n                    tempUrl = tempUrl.replaceAll(\"\\\\$\\\\{host\\\\}\", host);\n                    Config.addHost(host);\n                }\n                JMXServiceURL jmxUrl = new JMXServiceURL(tempUrl);\n                JmxServerGraph server = new JmxServerGraph(name, jmxUrl, new JmxWorker(false));\n                servers.put(name, server);\n                NodeList listeners = connection.getElementsByTagName(\"listener\");\n                for (int i = 0; i < listeners.getLength(); i++) {\n                    Element attribute = (Element) listeners.item(i);\n                    String taskname = attribute.getAttribute(\"taskname\");\n                    MBean mbean = new MBean(attribute.getAttribute(\"mbean\"), null);\n                    String filtertype = attribute.getAttribute(\"filterType\");\n                    TaskNotificationListener listener = new TaskNotificationListener();\n                    NotificationFilterSupport filter = new NotificationFilterSupport();\n                    if (filtertype == null || \"\".equals(filtertype)) {\n                        filter = null;\n                    } else {\n                        filter.enableType(filtertype);\n                    }\n                    Task task = new Task(-1, Task.LISTEN, server);\n                    task.setMbean(mbean);\n                    task.setListener(listener);\n                    task.setFilter(filter);\n                    server.getWorker().addTask(task);\n                    if (tasks.get(taskname) != null) {\n                        System.out.println(\"Task \" + taskname + \" already exists.\");\n                        return;\n                    }\n                    List<Task> hashTempList = new ArrayList<Task>();\n                    hashTempList.add(task);\n                    tasks.put(taskname, hashTempList);\n                }\n                NodeList attributes = connection.getElementsByTagName(\"attribute\");\n                for (int i = 0; i < attributes.getLength(); i++) {\n                    Element attribute = (Element) attributes.item(i);\n                    String taskname = attribute.getAttribute(\"taskname\");\n                    MBean mbean = new MBean(attribute.getAttribute(\"mbean\"), null);\n                    String attributename = attribute.getAttribute(\"attributename\");\n                    String frequency = attribute.getAttribute(\"frequency\");\n                    String onEvent = attribute.getAttribute(\"onEvent\");\n                    if (frequency.equalsIgnoreCase(\"onchange\")) {\n                        TaskNotificationListener listener = new TaskNotificationListener();\n                        AttributeChangeNotificationFilter filter = new AttributeChangeNotificationFilter();\n                        filter.enableAttribute(attributename);\n                        Task task = new Task(-1, Task.LISTEN, server);\n                        MBeanAttribute att = new MBeanAttribute(mbean, attributename);\n                        task.setAttribute(att);\n                        task.setMbean(mbean);\n                        task.setListener(listener);\n                        task.setFilter(filter);\n                        server.getWorker().addTask(task);\n                        if (tasks.get(taskname) != null) {\n                            System.out.println(\"Task \" + taskname + \" already exists.\");\n                            return;\n                        }\n                        Task task2 = new Task(-1, Task.GET_ATTRIBUTE, server);\n                        task2.setAttribute(att);\n                        task2.setMbean(mbean);\n                        server.getWorker().addTask(task2);\n                        List<Task> hashTempList = new ArrayList<Task>();\n                        hashTempList.add(task);\n                        hashTempList.add(task2);\n                        tasks.put(taskname, hashTempList);\n                    } else {\n                        int frequency2 = Integer.parseInt(frequency);\n                        Task task = new Task(frequency2, Task.GET_ATTRIBUTE, server);\n                        MBeanAttribute att = new MBeanAttribute(mbean, attributename);\n                        task.setAttribute(att);\n                        task.setMbean(mbean);\n                        if (tasks.get(taskname) != null) {\n                            System.out.println(\"Task \" + taskname + \" already exists.\");\n                            return;\n                        }\n                        List<Task> hashTempList = new ArrayList<Task>();\n                        hashTempList.add(task);\n                        tasks.put(taskname, hashTempList);\n                        TaskNotificationListener listener = null;\n                        if (onEvent != null && !\"\".equals(onEvent)) {\n                            Task tempTask = tasks.get(onEvent).get(0);\n                            if (tempTask == null) {\n                                System.out.println(onEvent + \" was not found.\");\n                                return;\n                            } else {\n                                listener = (TaskNotificationListener) tempTask.getListener();\n                            }\n                        }\n                        if (listener == null) {\n                            server.getWorker().addTask(task);\n                        } else {\n                            listener.addTask(task);\n                        }\n                    }\n                }\n            }\n            NodeList guiTemp = root.getElementsByTagName(\"gui\");\n            guiElement = (Element) guiTemp.item(0);\n            tabName = guiElement.getAttribute(\"name\");\n            if (MonitorServer.contains(tabName)) {\n                JOptionPane.showMessageDialog(null, \"This panel is already open, stoping creating of panel.\", \"Panel already exists\", JOptionPane.ERROR_MESSAGE);\n                return;\n            }\n            for (int i = 0; i < monitor.getTab().getTabCount(); i++) {\n                if (monitor.getTab().getComponent(i).equals(monitor)) {\n                    monitor.getTab().setTitleAt(i, tabName);\n                    break;\n                }\n            }\n            NodeList tempBindings = root.getElementsByTagName(\"binding\");\n            for (int i = 0; i < tempBindings.getLength(); i++) {\n                Element binding = (Element) tempBindings.item(i);\n                String guiname = binding.getAttribute(\"guiname\");\n                String tmethod = binding.getAttribute(\"method\");\n                String taskname = binding.getAttribute(\"taskname\");\n                String formater = binding.getAttribute(\"formater\");\n                BindingContainer tempBinding;\n                if (formater == null || (formater != null && formater.equals(\"\"))) {\n                    tempBinding = new BindingContainer(guiname, tmethod, taskname);\n                } else {\n                    tempBinding = new BindingContainer(guiname, tmethod, taskname, formater);\n                }\n                bindings.add(tempBinding);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Exception message: \" + e.getMessage());\n            System.out.println(\"Loading Monitor Failed, couldnt parse XML file.\");\n            e.printStackTrace(System.err);\n            return;\n        }\n        setPlain(monitor.getValidating());\n        setPlain(monitor.getValidatingStatus());\n        monitor.getValidatingStatus().setText(\"      Done\");\n        setBold(monitor.getDownload());\n        setBold(monitor.getDownloadStatus());\n        monitor.getDownloadStatus().setText(\"      Working\");\n        List<File> jarFiles = new ArrayList<File>();\n        File cacheDir = new File(Config.getCacheDir());\n        if (!cacheDir.exists()) {\n            cacheDir.mkdir();\n        }\n        for (URL resUrl : resources) {\n            try {\n                HttpClient client = new HttpClient();\n                HttpMethod methodRes = new GetMethod(resUrl.toString());\n                int response = client.executeMethod(methodRes);\n                if (response == 200) {\n                    int index = resUrl.toString().lastIndexOf(\"/\") + 1;\n                    File file = new File(Config.getCacheDir() + resUrl.toString().substring(index));\n                    FileOutputStream out = new FileOutputStream(file);\n                    InputStream in = methodRes.getResponseBodyAsStream();\n                    int readTemp = 0;\n                    while ((readTemp = in.read()) != -1) {\n                        out.write(readTemp);\n                    }\n                    System.out.println(file.getName() + \" downloaded.\");\n                    methodRes.releaseConnection();\n                    if (file.getName().endsWith(\".jar\")) {\n                        jarFiles.add(file);\n                    }\n                } else {\n                    methodRes.releaseConnection();\n                    System.out.println(\"Loading Monitor Failed. Unable to get resource \" + url);\n                    return;\n                }\n            } catch (IOException e) {\n                System.out.println(\"Loading Monitor Failed, error while reading resource file from HTTP Server\");\n                e.printStackTrace(System.err);\n                return;\n            }\n        }\n        URL[] urls = new URL[jarFiles.size()];\n        try {\n            for (int i = 0; i < jarFiles.size(); i++) {\n                File file = jarFiles.get(i);\n                File newFile = new File(Config.getCacheDir() + \"/\" + System.currentTimeMillis() + file.getName());\n                FileInputStream in = new FileInputStream(file);\n                FileOutputStream out = new FileOutputStream(newFile);\n                int n = 0;\n                byte[] buf = new byte[1024];\n                while ((n = in.read(buf, 0, 1024)) > -1) {\n                    out.write(buf, 0, n);\n                }\n                out.close();\n                out.close();\n                in.close();\n                urls[i] = new URL(\"file:\" + newFile.getAbsolutePath());\n            }\n        } catch (Exception e1) {\n            System.out.println(\"Unable to load jar files.\");\n            e1.printStackTrace();\n        }\n        URLClassLoader loader = new URLClassLoader(urls);\n        engine.setClassLoader(loader);\n        setPlain(monitor.getDownload());\n        setPlain(monitor.getDownloadStatus());\n        monitor.getDownloadStatus().setText(\"      Done\");\n        setBold(monitor.getGui());\n        setBold(monitor.getGuiStatus());\n        monitor.getGuiStatus().setText(\"      Working\");\n        Container container;\n        try {\n            String tempXml = xml.toString();\n            int start = tempXml.indexOf(\"<gui\");\n            start = tempXml.indexOf('>', start) + 1;\n            int end = tempXml.indexOf(\"</gui>\");\n            container = engine.render(new StringReader(tempXml.substring(start, end)));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.err.println(\"Exception msg: \" + e.getMessage());\n            System.out.println(\"Loading Monitor Failed, error creating gui.\");\n            return;\n        }\n        for (BindingContainer bcon : bindings) {\n            for (Task task : tasks.get(bcon.getTask())) {\n                if (task != null) {\n                    Object comp = engine.find(bcon.getComponent());\n                    if (comp != null) {\n                        if (task.getTaskType() == Task.LISTEN && task.getFilter() instanceof AttributeChangeNotificationFilter) {\n                            TaskNotificationListener listener = (TaskNotificationListener) task.getListener();\n                            if (bcon.getFormater() == null) {\n                                listener.addResultListener(new Binding(comp, bcon.getMethod()));\n                            } else {\n                                listener.addResultListener(new Binding(comp, bcon.getMethod(), bcon.getFormater(), loader));\n                            }\n                        } else {\n                            if (bcon.getFormater() == null) {\n                                task.addResultListener(new Binding(comp, bcon.getMethod()));\n                            } else {\n                                task.addResultListener(new Binding(comp, bcon.getMethod(), bcon.getFormater(), loader));\n                            }\n                        }\n                    } else {\n                        System.out.println(\"Refering to gui name, \" + bcon.getComponent() + \", that doesnt exist. Unable to create monitor.\");\n                        return;\n                    }\n                } else {\n                    System.out.println(\"Refering to task name, \" + bcon.getTask() + \", that doesnt exist. Unable to create monitor.\");\n                    return;\n                }\n            }\n        }\n        for (int i = 0; i < monitor.getTab().getTabCount(); i++) {\n            if (monitor.getTab().getComponent(i).equals(monitor)) {\n                monitor.getTab().setComponentAt(i, new MonitorContainerPanel(container, this));\n                break;\n            }\n        }\n        System.out.println(\"Connecting to server(s).\");\n        Enumeration<JmxServerGraph> e = servers.elements();\n        List<JmxWorker> list = new ArrayList<JmxWorker>();\n        while (e.hasMoreElements()) {\n            JmxWorker worker = e.nextElement().getWorker();\n            worker.setRunning(true);\n            worker.start();\n            list.add(worker);\n        }\n        MonitorServer.add(tabName, list);\n        Config.addUrl(url);\n    }\n", "code2": "    @SuppressWarnings(\"deprecation\")\n    public void testMemberIterator() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(allfour_gz));\n        Iterator<GZIPMembersInputStream> iter = gzin.memberIterator();\n        assertTrue(iter.hasNext());\n        GZIPMembersInputStream gzMember0 = iter.next();\n        int count0 = IOUtils.copy(gzMember0, new NullOutputStream());\n        assertEquals(\"wrong 1k member count\", 1024, count0);\n        assertEquals(\"wrong member number\", 0, gzin.getMemberNumber());\n        assertEquals(\"wrong member0 start\", 0, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member0 end\", noise1k_gz.length, gzin.getCurrentMemberEnd());\n        assertTrue(iter.hasNext());\n        GZIPMembersInputStream gzMember1 = iter.next();\n        int count1 = IOUtils.copy(gzMember1, new NullOutputStream());\n        assertEquals(\"wrong 32k member count\", (32 * 1024), count1);\n        assertEquals(\"wrong member number\", 1, gzin.getMemberNumber());\n        assertEquals(\"wrong member1 start\", noise1k_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member1 end\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberEnd());\n        assertTrue(iter.hasNext());\n        GZIPMembersInputStream gzMember2 = iter.next();\n        int count2 = IOUtils.copy(gzMember2, new NullOutputStream());\n        assertEquals(\"wrong 1-byte member count\", 1, count2);\n        assertEquals(\"wrong member number\", 2, gzin.getMemberNumber());\n        assertEquals(\"wrong member2 start\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member2 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberEnd());\n        assertTrue(iter.hasNext());\n        GZIPMembersInputStream gzMember3 = iter.next();\n        int count3 = IOUtils.copy(gzMember3, new NullOutputStream());\n        assertEquals(\"wrong 5-byte member count\", 5, count3);\n        assertEquals(\"wrong member number\", 3, gzin.getMemberNumber());\n        assertEquals(\"wrong member3 start\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member3 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length + hello_gz.length, gzin.getCurrentMemberEnd());\n        assertFalse(iter.hasNext());\n    }\n", "label": 1, "substitutes": {"xml": ["xf", "page", "url", "input", "txt", "events", "layout", "feed", "rx", "result", "output", " XML", "message", "rss", "audio", "format", "ul", "http", "mx", "model", "application", "data", "stream", "print", "tree", "zip", "external", "writer", "el", "element", "x", "update", "php", "event", "json", "log", "ML", "wl", "text", "atom", "wave", "content", "status", "string", "path", "image", "html", "ml", "ssl", "son", "cloud", "fm", "www", "web"], "tabName": [" fileName", " fileNames", " sheetName", " tagName", " tagNAME", " sheetname", " tagNames", " sheetNAME", " sheetNames", " fileNAME", " filename", " appname", " appNames", " appName", " appNAME", " tagname"], "guiElement": [" appEntry", " appItem", " closingItem", " openingItem", " childEntry", " childItem", " appManager", " closingEntry", " openingManager", " childManager", " closingManager", " childEntity", " openingEntry", " appEntity", " closingEntity", " openingEntity"], "method": ["Method", "wrapper", "phone", "sign", "model", "METHOD", "r", "zip", "call", "gi", "report", "unit", "cl", "sort", "pm", "ssl", "callback", "header", "received", "project", "verb", "plugin", "build", "settings", "remote", "class", "update", "monitor", "event", "instance", "key", "port", "get", "parent", "url", "user", "term", "util", "function", "http", "request", "this", "version", "stream", "module", "send", "full", "text", "string", "path", "record", "property", "service", "manager", "process", "subject", "use", "num", "pull", "min", "right", "message", "man", "view", "format", "data", "prefix", "config", "php", "member", "api", "rh", "m", "session", "lock", "form", "proxy", "sl", "type"], "tempfile": ["localfile", "inputfile", "Tempf", "blockstore", "tempFile", " temporaryFile", "Temppool", " temporarydir", "tempfiles", "tempf", " tempf", "blockFILE", "TempFile", "blockFile", "tempstore", "inputdir", "templatestore", "templateFile", "inputpool", "localstore", " temporaryfile", "templatefile", "tmpfiles", "Tempdir", " tempFile", "localFILE", "tmpfile", "tmpFile", "Tempfile", "temppool", "templateFILE", " temporarypool", "tempFILE", "tempdir", "Tempfiles", "localFile", " tempfiles", "inputFile", "blockfile", "tmpf"], "in": ["source", "get", "reader", "str", "en", "input", "inc", "din", "url", "token", "win", "min", "nin", "con", "part", "login", "f", "as", "on", "data", "In", "pin", "again", "stream", "r", "re", "serv", "config", "inner", "exec", "init", "ins", "gen", "gin", "ini", "ex", "m", "kin", "rec", "image", "impl", "socket", "ssl", "IN", "err", "inn", "rin", "is", "lin", "bin", "s", "ic"], "temp": ["div", "input", "result", "extra", "flat", "style", "zip", "tc", "timeout", "pt", "count", "err", "type", "level", "read", "porary", "iter", "dev", "diff", "stable", "tem", "clean", "Temp", "cel", "length", "ex", "key", "cache", "cut", "c", "str", "source", "get", "nice", "left", "parent", "size", "tmp", "sem", "multi", "base", "text", "partial", "path", "wait", "valid", "total", "null", "sci", "num", "output", "tw", "fake", "data", "single", "var", "init", "json", "content", "lc", "emp", "current", "empty", "test", "dat", "unit"], "client": ["url", "wrapper", "cm", "plugin", "io", "output", "conn", "http", "con", "request", "cell", "channel", "handler", "child", "config", "call", "per", "api", "Client", "m", "cli", "session", "pool", "connect", "cache", "socket", "ssl", "c", "builder", "service", "manager", "web", "port", "p"], "response": ["page", "successful", "respond", "su", "default", "write", "feed", "success", "reply", "ception", "result", "function", "message", "output", "io", "radius", "example", "http", "object", "request", "model", "number", "data", "version", "stream", "re", "r", "body", "res", "json", "length", "api", "found", "partial", "content", "status", "v", "Response", "image", "respons", "answer", "uri", "error", "resp", "code", "pos", "received", "reason", "value", "entry"], "factory": ["buture", "bault", " fault", "fixture", "fault", "foruture", "foractory", "forixture", "mANCE", "bixture", "future", " fixture", "mFactory", " fFactory", "forault", " fANCE", "Fixture", "bactory", " future", "mactory", "fANCE", "FANCE", "Factory", "fFactory", "mixture", "FFactory"], "parser": ["reader", " constructor", " structure", "buffer", "build", "pb", " library", " markup", " object", "base", " output", " input", "writer", "x", " reader", " manager", " parent", "instance", "html", " template", " html", "manager", " parse", " node", " app", "s", "Parser"], "file": ["source", "page", "folder", "reader", "url", "feed", "buffer", "File", "message", "io", "object", "f", "base", "data", "number", "stream", "class", "handler", "work", "info", "element", "module", "filename", "body", "dir", "report", "log", "text", "content", "book", "string", "path", "image", "cache", "db", "uri", "files", "FILE", "unit"], "out": ["page", "parent", "user", "term", "co", "outer", "io", "output", "conn", "lib", "ger", "dump", "diff", "state", "cmd", "gen", "again", "OUT", "Out", "outs", "re", "sys", "flow", "log", "cli", "v", "up", "key", "pool", "obj", "lock", "cache", "debug", "error", "err", "manager", "group", "copy", "line"], "e": ["ea", "h", "en", "pe", "d", "ception", "ee", "l", "ev", "ue", "ise", "ep", "f", "E", "exc", "fe", "ec", "p", "esi", "he", "es", "el", "element", "x", "er", "event", "ge", "o", "de", "ace", "ae", "ve", "oe", "je", "se", "ke", "ze", "error", "err", "or", "ce", "me", "ed", "ele", "ie"]}}
{"id1": "9769234", "id2": "302513", "code1": "    void downloadImage(String filename, File imageFile) throws Exception {\n        String URL = Constants.IMAGE_URL + \"/\" + filename;\n        SiteResponse response = stratSite.getResponse(URL);\n        InputStream inputStream = response.getInputStream();\n        OutputStream outputStream = new FileOutputStream(imageFile);\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"filename": ["source", "folder", "size", "url", "SourceFile", "download", "fax", "username", "File", "png", "audio", "fp", "sf", "f", "data", "href", "directory", "jpg", "resource", "Filename", "photo", "name", "fn", "string", "path", "image", "media", "document", "file", "uri", "title", "files", "FILE", "Url", "figure", "s", "location", "fil"], "imageFile": [" imagefile", "archiveStream", "photoFile", "imageStream", " imageSource", "imageSource", " imagePlace", "jobPath", "jobfile", "jobPlace", "jobFile", "archiveFile", "photoPlace", "imagePath", " imageStream", "mediaFile", "archivePlace", "mediafile", "mediaPath", "imagefile", "photoStream", "photoSource", " imagePath", "imagePlace", "archiveSource", "mediaPlace"], "URL": ["SSL", "HR", "NAME", "url", "Name", "PORT", "UR", "File", "Buffer", "DIR", "CL", "IP", "PATH", "EL", "IR", "Path", "Image", "base", "Folder", "IE", "IL", "WS", "Location", "HTTP", "SR", "GE", "API", "FP", "SOURCE", "Page", "file", "FR", "TIME", " url", "FILE", "Url", "Base", "URI", "ID", "RET"], "response": ["next", "page", "respond", "site", "url", "connection", "success", "reply", "result", "output", "message", "rss", "http", "out", "request", "object", "client", "application", "onse", "data", "version", "tree", "resource", "server", "body", "results", "report", "api", "status", "Response", "image", "document", "file", "i", "resp", "error", "res", "entry"], "inputStream": [" inputReader", "imageView", "outputSteam", "inputSteam", "imageStream", " inputstream", "inputstream", "InputStream", " inputSteam", "imageSteam", "inputReader", "InputView", "inputView", "outputstream", "outputReader", "Inputstream", "imagestream", "outputView", "InputSteam", "InputReader"], "outputStream": ["outputSteam", "inputSteam", "OutputSteam", "inputstream", "OutputStream", "OutputWriter", " outputView", "Outputstream", "inputView", "outputstream", " outputSteam", " outputWriter", "inputWriter", "outputView", " outputstream", "OutputView", "outputWriter"]}}
{"id1": "2499054", "id2": "6795580", "code1": "    public String encryptToSHA(String info) {\n        byte[] digesta = null;\n        try {\n            MessageDigest alga = MessageDigest.getInstance(\"SHA-1\");\n            alga.update(info.getBytes());\n            digesta = alga.digest();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        String rs = byte2hex(digesta);\n        return rs;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"info": ["source", "id", "url", "about", "txt", "token", "si", "auth", "buffer", "Info", "safe", "ami", "result", "now", "message", "fo", "http", "object", "inf", "b", "part", "f", "base", "data", "auto", "archive", "conf", "name", "information", "api", "text", "key", "string", "INFO", "image", "path", "obj", "error", "i", "secret", "is", "iso", "type"], "digesta": ["digella", "ditza", "digza", " digza", "ditetta", "labest", "Digesta", " digella", "labesta", "digetta", "ditella", " digetta", "Digestation", "digest", " digestation", " digest", "Digetta", "Digella", "ditesta", "labetta", "digestation", "ditestation", "ditest", "labella", "Digza", "Digest"], "alga": ["alphga", "alsba", "alsgas", " algo", "alda", "alphgo", "alg", "alna", "alsqa", "ggas", "ALda", "agpa", "arqa", "alphpa", "palba", "algas", "ALna", " algas", "aggo", "agg", " alpa", "alba", " alna", "palga", "algo", "gda", "palgas", "palqa", "gga", "ALgas", "agga", "ALga", "alphg", "alpa", "gna", "arba", " alda", " alg", "argas", "alqa", "alsga", "arga"], "rs": ["arms", "Rs", "hs", "RC", "ks", "resses", "ss", " codes", "ws", "RS", "params", "ns", " results", "ars", "ros", "ruby", "r", "codes", "rates", "ures", " rows", " params", "xs", " r", "rc", "ins", "results", " chars", "cs", "sr", "ls", " Rs", " details", "rors", "ras", " RS", "parts", "rings", "ig", "ps", "res", "ributes"]}}
{"id1": "1274215", "id2": "19295911", "code1": "    public static void main(String[] args) {\n        try {\n            if (args.length < 2) {\n                System.err.println(\"usage: test [src] [dest]\");\n                return;\n            }\n            FileInputStream in = new FileInputStream(args[0]);\n            FileOutputStream out = new FileOutputStream(args[1]);\n            FileChannel src = in.getChannel();\n            FileChannel channel = out.getChannel();\n            long pos = 0, len = src.size(), ret;\n            while (len > 0) {\n                if ((ret = channel.transferFrom(src, pos, len)) < 0) break;\n                len -= ret;\n                pos += ret;\n            }\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void setTableEmbossage(String te, boolean sys) {\n        fiConf.setProperty(OptNames.pr_emboss_table, te);\n        fiConf.setProperty(OptNames.fi_is_sys_emboss_table, Boolean.toString(sys));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            String fichTable;\n            if (!(te.endsWith(\".ent\"))) {\n                te = te + \".ent\";\n            }\n            if (sys) {\n                fichTable = ConfigNat.getInstallFolder() + \"/xsl/tablesEmbosseuse/\" + te;\n            } else {\n                fichTable = ConfigNat.getUserEmbossTableFolder() + \"/\" + te;\n            }\n            in = new FileInputStream(fichTable).getChannel();\n            out = new FileOutputStream(ConfigNat.getUserEmbossTableFolder() + \"/Embtab.ent\").getChannel();\n            in.transferTo(0, in.size(), out);\n            in.close();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"in": ["source", "reader", "url", "input", "inc", "din", "win", "download", "min", "io", "conn", "lib", "con", "diff", "login", "f", "In", "pin", "stream", "again", "r", "config", "inner", "exec", "init", "ins", "gin", "m", "fit", "up", "image", "cin", "socket", "c", "file", "i", "IN", "ssl", "err", "inside", "is", "bin"], "out": ["source", "parent", "plain", "default", "inc", "net", "connection", "plugin", "io", "output", "outer", "conn", "lib", "client", "ou", "part", "to", "OUT", "Out", "again", "outs", "external", "writer", "config", "dest", "off", "exec", "sync", "name", "target", "log", "up", "image", "cache", "socket", "file", "error", "c", "err", "cos", "at", "img", "option", "copy", "ext"], "src": ["source", "sel", "RC", "reader", "cb", "split", "url", "proc", "input", "req", "upload", "uc", "chain", "vc", "io", "conn", "http", "client", "loc", "ref", "stream", "scenes", "remote", "ctx", "sc", "config", "inner", "ources", "dest", "sub", "cur", "init", "ins", "rc", "inst", "gin", "ch", "buf", "sin", "slice", "rl", "impl", "socket", "c", "ssl", "secure", "file", "dist", "conv", "cos", "start", "img", "sn", "rb"], "channel": ["source", "reader", "en", "queue", "connection", "chain", "chan", "io", "output", "conn", "con", "Channel", "cho", "bc", "client", "stream", "enc", "handler", "server", "sc", "config", "dest", "rc", "target", "container", "ch", "ann", "up", "pool", "socket", "c", "file", "manager", "conv"], "pos": ["next", "source", "size", "id", "en", "num", "lit", "open", "iter", "limit", "l", "pre", "end", "val", "part", "loc", "base", "po", "data", "ref", "n", "os", "off", "pid", "nt", "length", "seq", "offset", "pt", "index", "sp", "i", "Pos", "start", "position", "fin", "res", "line", "p"], "len": ["left", "size", "split", "en", "num", "url", "ln", "la", "lit", "lf", "rel", "iter", "limit", "lim", "l", "pre", "val", "lon", "f", "Len", "lt", "n", "elt", "repl", "fat", "el", "den", "lif", "nt", "non", "length", "sl", "syn", "seq", "fl", "lc", "li", "ls", "le", "count", "lin", "fin", "alt", "line", "ll"], "ret": ["id", "en", "default", "bf", "alt", "rel", "lit", "rets", "reply", "pet", "result", "iter", "conn", "val", "part", "base", "Len", "data", "ref", "lt", "re", "r", "det", "match", "repl", "del", "fun", "cur", "full", "nt", "length", "seq", "bit", "fit", "offset", "orig", "pass", "rev", "rt", "resp", "att", "opt", "fin", "Ret", "res", "RET", "ext"]}}
{"id1": "3908311", "id2": "7273182", "code1": "    public byte[] uniqueID(String name, String topic) {\n        String key;\n        byte[] id;\n        synchronized (cache_) {\n            key = name + \"|\" + topic;\n            id = (byte[]) cache_.get(key);\n            if (id == null) {\n                MessageDigest md;\n                try {\n                    md = MessageDigest.getInstance(\"SHA\");\n                    md.update(name.getBytes());\n                    md.update(topic.getBytes());\n                    id = md.digest();\n                    cache_.put(key, id);\n                    if (debug_) {\n                        System.out.println(\"Cached \" + key + \" [\" + id[0] + \",\" + id[1] + \",...]\");\n                    }\n                } catch (NoSuchAlgorithmException e) {\n                    throw new Error(\"SHA not available!\");\n                }\n            }\n        }\n        return id;\n    }\n", "code2": "    public synchronized String encrypt(String text) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        md.update(text.getBytes());\n        byte raw[] = md.digest();\n        String hash = \"\";\n        for (int i = 0; i < raw.length; i++) {\n            byte temp = raw[i];\n            String s = Integer.toHexString(new Byte(temp));\n            while (s.length() < 2) {\n                s = \"0\" + s;\n            }\n            s = s.substring(s.length() - 2);\n            hash += s;\n        }\n        return hash;\n    }\n", "label": 1, "substitutes": {"name": ["host", "NAME", "parent", "ame", "size", "default", "Name", "term", "first", "office", "space", "message", "one", "client", "object", "root", "part", "normal", "base", "hello", "data", "version", "named", "n", "style", "system", "master", "prefix", "primary", "x", "word", "comment", "names", "time", "up", "family", "path", "image", "company", "file", "title", "search", "self", "domain", "type"], "topic": ["host", "term", "mid", "top", "username", "chan", "message", "format", "thread", "object", "color", "part", "channel", "data", "table", "phrase", "master", "resource", "ticket", "prefix", "address", "template", "config", "meta", "Topic", "event", "pattern", "text", "frequency", "index", "string", "path", "uri", "title", "thing", "priority", "subject", "domain", "project", "test", "type"], "key": ["ame", "value", "hash", "url", "link", "pe", "year", "fee", "ee", "keys", "k", "message", "ry", "sign", "ak", "fix", "app", "bug", "part", "root", "base", "f", "data", "no", "Key", "mac", "phrase", "prefix", "ie", "child", "box", "KEY", "use", "section", "x", "tag", "it", "e", "ace", "patch", "exp", "bird", "text", "copy", "ke", "index", "string", "path", "point", "rule", "seed", "cache", "ask", "error", "code", "ek", "or", "proof", "date", "secret", "lease", "ce", "order", "self", "kid", "reason", "me", "pick", "ip", "ac", "type"], "id": ["get", "head", "parent", "ad", "str", "active", "hash", "url", "did", "link", "d", "oid", "auth", "mid", "result", "doc", "one", "end", "val", "root", "aid", "part", "def", "Id", "gen", "data", "f", "bug", "base", "style", "zip", "address", "info", "shape", "element", "x", "init", "it", "event", "uid", "ix", "pid", "ide", "patch", "comment", "show", "index", "path", "image", "lock", "error", "i", "code", "db", "or", "and", "like", "valid", "ids", "is", "start", "kid", "ID", "sid", "ip", "p", "type"], "md": ["um", "msg", "mb", "d", " Md", "cm", "dig", "mid", "dd", "ind", "hd", "sm", " MD", "mm", "doc", "ma", "pd", "am", "vd", "cmd", "ms", "po", "data", "mo", "bd", "di", "mac", "mu", "sum", "mand", "mag", "meta", "mc", "sha", "rpm", "dm", "rm", "MD", "mt", "m", "df", "nm", "od", "pm", "mg", "map", "mad", "Cmd", "metadata", "nd", "amd", "mi", "me", "mn"]}}
{"id1": "6413929", "id2": "302513", "code1": "    public HogsCustomizer() {\n        m_filename = PathFinder.getCustsFile();\n        m_currenttaunts = new String[10];\n        m_textfields = new JTextField[10];\n        m_color = new Color(255, 255, 255);\n        boolean exists = (new File(m_filename)).exists();\n        m_inverted = false;\n        m_chooser = new JColorChooser();\n        AbstractColorChooserPanel[] panels = m_chooser.getChooserPanels();\n        m_chooser.removeChooserPanel(panels[0]);\n        m_chooser.removeChooserPanel(panels[2]);\n        m_chooser.setPreviewPanel(new JPanel());\n        Reader reader = null;\n        if (exists) {\n            try {\n                reader = new FileReader(m_filename);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        } else {\n            Object[] options = { \"Yes\", \"No, Thanks\" };\n            int n = JOptionPane.showOptionDialog(this, \"You do not have a customization file in your home directory.\\n                 \" + \"Would you like to create one?\", \"Hogs Customization\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n            if (n == 0) {\n                try {\n                    FileChannel srcChannel = new FileInputStream(HogsConstants.CUSTS_TEMPLATE).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(m_filename).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    System.exit(0);\n                }\n            } else {\n                System.exit(0);\n            }\n            try {\n                reader = new FileReader(m_filename);\n            } catch (FileNotFoundException e1) {\n                e1.printStackTrace();\n                System.exit(0);\n            }\n        }\n        try {\n            readFromFile(reader);\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n        Box mainpanel = Box.createVerticalBox();\n        mainpanel.add(buildTauntsPanel());\n        mainpanel.add(buildMouseStylePanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        mainpanel.add(buildColorPanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        mainpanel.add(buildButtonsPanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setContentPane(mainpanel);\n        this.pack();\n        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n        this.setLocation(dim.width / 2 - (this.getWidth() / 2), dim.height / 2 - (this.getHeight() / 2));\n        this.setTitle(\"Hogs Customizer\");\n        this.setVisible(true);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"m_filename": ["m_location", "M_selection", "m__source", "mockpath", "m___directory", "rm_username", " m_source", "m_resource", "m__file", " m_file", "m_file", "rmOCKfilename", "mOCKusername", "rmOCKnom", "mocknom", "m_path", "m2directory", "m2filename", "p_filename", "m___file", " m_directory", "M_url", "p_content", "mOCKfilename", "m2content", "m_content", "rm_nom", " m__directory", "m_url", "mockusername", " m__source", "rm_path", " m__filename", " m__file", "mockfilename", "m_nom", "M_directory", "p_directory", "mOCKpath", "m_username", "m__directory", "M_username", "m__filename", "m___filename", "m_directory", "rmOCKpath", "m2location", "m___source", "M_resource", "m_selection", "mOCKnom", "p_location", "rm_filename", "rmOCKusername", "m_source", "M_filename"], "m_currenttaunts": ["m_currentTitle", "m_currentxtidy", "m_contenttpl", "m_currenttitle", "m_currentfontidy", "m_currenttitles", "m_currentxtpl", "m_contentfontpl", "m_currentTitles", "m_currentfontitle", "m_currentxtitle", "m_contenttitles", "m_currenttpl", "m_currenttidy", "m_contenttidy", "m_contentfontitles", "m_contentfontitle", "m_contentfontidy", "m_contenttitle", "m_currentfontitles", "m_currentfontpl", "m_currentxtitles", "m_currentTidy", "m_currentTpl"], "m_textfields": ["m_inputfields", "m_textboxes", "m_fontfields", "m_buttons", "m_buttonfield", "m_fontboxes", "m_inputfield", "m_texts", "m_fonts", "m_fontfield", "m_buttonboxes", "m_inputboxes", "m_textfield", "m_buttonfields", "m_inputs"], "m_color": ["m__color", "M__background", "M__bg", "M_color", "M_theme", "M__theme", "m__theme", "m__background", "m_background", "M_background", "m_bg", "M_bg", "m__bg", "M__color", "m_theme"], "exists": [" existence", "expist", "existitions", "exits", "Exits", "exist", "Exists", "existence", "EXits", "Exceptions", "expails", "EXist", "existizes", "EXists", "fist", "exizes", "Exizes", "fists", "Exist", "exitions", "existists", "existinates", "EXinates", " exits", "Exinates", "EXistence", "Existence", "EXizes", "exceptions", "fails", "expitions", "exails", "exinates", "existist", "existails", "fitions", "expists", "EXceptions", " exceptions"], "m_chooser": ["m_colosing", "m_close", "m_joose", "m_suppinder", "m_compicker", "m_joerer", "m_choose", "m_boosed", "m_noicker", "m_boer", "m_boinder", "m_joosed", "mockchoinder", "mockboinder", "m_composer", "m_colosite", "m_choer", "m_booser", "m_defosite", "mockchooser", "mockchoerer", "m_composed", "m_noose", "m_noosing", "m_comperer", "m_closing", "mockbooser", "m_choinder", "m_cler", "m_boicker", "m_deferer", "m_boose", "m_choosed", "m_compose", "m_composing", "mockboerer", "m_boerer", "m_supposite", "m_choosing", "m_jooser", "m_composite", "mockboosite", "m_boosing", "m_nooser", "m_definder", "m_choosite", "m_defoser", "mockchoosite", "m_closer", "m_boosite", "m_coloser", "m_supposer", "m_colose", "m_supperer", "m_choicker", "m_choerer"], "panels": ["panagers", "Panels", "Panars", "panes", "panars", "panators", "panices", "polels", "Panors", "cholets", "Panes", "parenices", "spanagers", "choators", "Panlets", "parenels", "polars", "choels", "panlets", "spanels", "panors", "choes", "choagers", "colators", "polices", "Panators", "spanices", " panices", "coles", "polors", "parenors", "choices", "spanes", " panagers", " panes", "Panices", "parenars", "colels", "collets"], "reader": ["source", "read", "h", "draft", "input", "wrapper", "rx", "Reader", "feed", "connection", "buffer", "result", "iter", "player", "io", "ry", "driver", "ler", "client", "lr", "part", "row", "f", "loader", "data", "worker", "stream", "r", "resource", "handler", "server", "author", "writer", "inner", "er", "rc", "e", "reading", "per", "parser", "instance", "dr", "key", "book", "ri", "image", "library", "file", "or", "service", "manager", "rr", "value", "null", "entry"], "options": ["opens", "comments", "value", "Options", "none", "open", "settings", "lines", "io", "optional", "example", "items", "params", "object", "types", "data", "no", "choice", "style", "multiple", "objects", "es", "changes", "info", "groups", "results", "e", "other", "o", "values", "text", "names", "content", "ops", "obj", "html", "details", "times", "files", "zero", "empty", "option", "ts", "ps", "s", "p", "type"], "n": ["en", "num", "nl", "ln", "d", "l", "y", "out", "b", "ns", "f", "number", "r", "ni", "dn", "nor", "adj", "ne", "u", "o", "s", "e", "nt", "fn", "t", "m", "nu", "norm", "count", "N", "don", "j", "c", "i", "g", "un", "pn", "nb", "sn", "z", "nc", "p"], "srcChannel": ["instChannel", "destClient", "srcchannel", "instGate", "inputClient", "inputButton", "srcClient", " srcButton", "rcChan", " srcChan", "destChan", "srcServer", "inputConnection", " srcServer", " srcStream", " srcConnection", "destchannel", "rcchannel", "srcChan", "rcChannel", " srcGate", "instStream", "inputChannel", "instChan", "inputchannel", "distChannel", "destServer", "destConnection", "inputChan", "rcConnection", "destChannel", "distChan", "distGate", "srcGate", "srcStream", "inputServer", " srcchannel", " srcClient", "rcButton", "distStream", "srcConnection", "srcButton"], "dstChannel": ["DndMessage", "ddestChan", "dstsChan", "ddestchannel", "DndButton", "Ddestchannel", "dostChannel", "dirstchannel", "DstButton", "ddestChannel", "drcChannel", "dndchannel", "DstChan", "dndContext", "dstFlow", "dostChan", "dndMessage", "drcMessage", "dirstChan", "dstContext", "DstChannel", "dostchannel", "dsrcchannel", "DdestFlow", "DstMessage", "dstButton", "Dstschannel", "Dndchannel", "dstsFlow", "DstFlow", "dstChan", "DndChannel", "dstMessage", "DstsContext", "dstsContext", "dndChan", "dstschannel", "drcchannel", "dsrcChannel", "drcButton", "dirstFlow", "dostContext", "DstsChan", "ddestFlow", "dsrcMessage", "dndChannel", "dirstChannel", "DstContext", "dsrcButton", "Dstchannel", "DdestChan", "DstsChannel", "DdestChannel", "dstchannel", "dndButton", "dstsChannel"]}}
{"id1": "4204663", "id2": "14120602", "code1": "    @org.junit.Test\n    public void testReadWrite() throws Exception {\n        final byte[] testBytes = \"testString\".getBytes();\n        final InputStream istream = new ByteArrayInputStream(testBytes);\n        final ByteArrayOutputStream destination = new ByteArrayOutputStream();\n        final InputStream teeStream = new TeeInputStreamOutputStream(istream, destination);\n        IOUtils.copy(teeStream, new NullOutputStream());\n        teeStream.close();\n        assertArrayEquals(\"array are equals\", testBytes, destination.toByteArray());\n    }\n", "code2": "    public void startElement(String uri, String tag, String qName, org.xml.sax.Attributes attributes) throws SAXException {\n        wabclient.Attributes prop = new wabclient.Attributes(attributes);\n        try {\n            if (tag.equals(\"app\")) {\n                if (prop == null) {\n                    System.err.println(\"app without properties\");\n                    return;\n                }\n                String appname = prop.getValue(\"name\", \"\");\n                String lookandfeel = prop.getValue(\"lookandfeel\", \"\");\n                global.setAppName(appname);\n                if (lookandfeel.length() > 0) {\n                    if (lookandfeel.equalsIgnoreCase(\"Windows\")) lookandfeel = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\"; else if (lookandfeel.equalsIgnoreCase(\"Motif\")) lookandfeel = \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\"; else if (lookandfeel.equalsIgnoreCase(\"Mac\")) lookandfeel = \"com.sun.java.swing.plaf.mac.MacLookAndFeel\";\n                    UIManager.setLookAndFeel(lookandfeel);\n                }\n            } else if (tag.equals(\"script\")) {\n                WABClient c = (WABClient) global;\n                c.beginScript();\n                String url = prop.getValue(\"src\");\n                if (url.length() > 0) {\n                    try {\n                        BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                        String buffer;\n                        while (true) {\n                            buffer = r.readLine();\n                            if (buffer == null) break;\n                            c.script += buffer + \"\\n\";\n                        }\n                        r.close();\n                        c.endScript();\n                    } catch (IOException ioe) {\n                        System.err.println(\"[IOError] \" + ioe.getMessage());\n                        System.exit(0);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n        }\n    }\n", "label": 0, "substitutes": {"testBytes": ["testingBytes", "testByte", "testingString", "testingByte", " testbytes", "testsParts", "Testbytes", "TestByte", "exampleByte", " testString", " testParts", " testByte", "testsBytes", "TestString", "examplebytes", " testUTF", "testsByte", "testString", "TestBytes", "exampleUTF", "testParts", "testingParts", "testbytes", "testingbytes", "testUTF", "testsString", "TestUTF", "TestParts", "exampleBytes"], "istream": ["istREAM", "ismsREAM", "istsream", "iststream", "ismsensor", "isteed", "ismREAM", "istseed", "ssream", "ismensor", "ssREAM", "ssrum", "ssstream", "ismseed", "ismeed", "istsrum", "eststream", "estream", "istrum", "estREAM", "estrum", "ismsream", "ismream", "istsensor", "istsstream", "istsREAM", "istensor"], "destination": ["distinate", " destinated", " destinator", "destinate", "Destinated", "distinated", "distination", "destinated", "contion", "diension", "Destinate", " destion", " destinate", "Destension", "Destion", "diination", " destension", "Destinator", "diinated", "contribution", "contination", "continator", " destribution", "destion", "destension", "diinator", "destinator", "destribution", "distinator", "Destination", "Destribution"], "teeStream": ["teeeSteam", "teedSteam", "peeSteam", "cheeStream", "teedstream", "teesSteam", "peestream", "teeSt", "teestream", "teesSem", "teepStream", "teedStream", "peeEnc", "cheeeContainer", "teostream", "texeContainer", "texeSt", "texestream", "cheeestream", "teeeStream", "teeeSem", "teepEnc", "eeeStream", "teepstream", "teoContainer", "teeSteam", "teeeSt", "cheeSt", "cheeContainer", "cheeeStream", "teesStream", "teesstream", "teepSteam", "eeeeStream", "eeeeSem", "peesstream", "teoSt", "eeeSteam", "teoStream", "teeEnc", "eeestream", "eeeestream", "eeeeSteam", "peeStream", "peesStream", "teeestream", "teedSem", "peesSteam", "cheeeSt", "cheestream", "teeContainer", "teeSem", "texeStream", "teeeEnc", "eeeSem", "teeeContainer", "teesEnc", "peesEnc"]}}
{"id1": "7561955", "id2": "22026286", "code1": "    public static final String hash(String data) {\n        if (digest == null) {\n            synchronized (StringUtils.class) {\n                if (digest == null) {\n                    try {\n                        digest = MessageDigest.getInstance(\"MD5\");\n                    } catch (NoSuchAlgorithmException nsae) {\n                    }\n                }\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    public static void main(String args[]) {\n        int i, j, l;\n        short NUMNUMBERS = 100;\n        short numbers[] = new short[NUMNUMBERS];\n        printIntro();\n        int time = (int) System.currentTimeMillis();\n        for (i = 0; i < NUMNUMBERS; i++) {\n            numbers[i] = (short) (NUMNUMBERS - 1 - i);\n        }\n        for (i = 0; i < NUMNUMBERS; i++) {\n            for (j = 0; j < NUMNUMBERS - i - 1; j++) {\n                if (numbers[j] > numbers[j + 1]) {\n                    short temp = numbers[j];\n                    numbers[j] = numbers[j + 1];\n                    numbers[j + 1] = temp;\n                }\n            }\n            if (WANT_PROGRESS) {\n                printProgress();\n            }\n        }\n        time = (int) System.currentTimeMillis() - time;\n        System.out.print(time);\n        System.out.print(\"End\\n\");\n    }\n", "label": 0, "substitutes": {"data": ["source", "input", "connection", "buffer", "result", "message", "format", "alpha", "object", "this", "base", "number", "hex", "bytes", "class", "storage", "info", "pad", "sha", "name", "method", "body", "DATA", "password", "length", "text", "a", "picture", "content", "key", "string", "media", "image", "cache", "database", "video", "str", "dat", "p"], "digest": ["Diger", "digger", "mdester", "digester", " digger", "digests", "signester", "DigEST", "logest", "Digger", " digests", "mdest", "diffgest", "diffher", "Digher", "diger", "signested", "signEST", "mdests", "generest", "logher", "digEST", "Digester", "signger", "Digested", " digEST", "generests", "Diggest", " digher", "signher", "generester", "diggest", "digher", " digester", "signer", "signest", "diffest", "loggest", "generEST", "digested", " diger", " digested", "Digests", "logester", "diffester", "Digest", "mdEST"]}}
{"id1": "22991420", "id2": "18036460", "code1": "    public void notifyIterationEnds(final IterationEndsEvent event) {\n        log.info(\"moving files...\");\n        File source = new File(\"deqsim.log\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"deqsim.log\"));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move deqsim.log to its iteration directory.\");\n            }\n        }\n        int parallelCnt = 0;\n        source = new File(\"deqsim.log.\" + parallelCnt);\n        while (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"deqsim.log.\" + parallelCnt));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move deqsim.log.\" + parallelCnt + \" to its iteration directory.\");\n            }\n            parallelCnt++;\n            source = new File(\"deqsim.log.\" + parallelCnt);\n        }\n        source = new File(\"loads_out.txt\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"loads_out.txt\"));\n            try {\n                IOUtils.copyFile(source, destination);\n            } catch (FileNotFoundException e) {\n                log.info(\"WARNING: Could not copy loads_out.txt to its iteration directory.\");\n            } catch (IOException e) {\n                log.info(\"WARNING: Could not copy loads_out.txt to its iteration directory.\");\n            }\n            destination = new File(\"loads_in.txt\");\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move loads_out.txt to loads_in.txt.\");\n            }\n        }\n        source = new File(\"linkprocs.txt\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"linkprocs.txt\"));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move linkprocs.txt to its iteration directory.\");\n            }\n        }\n    }\n", "code2": "    public File getFile() throws IOException {\n        if (file == null) {\n            if (position > 0) {\n                throw new IOException(\"Stream is already being read\");\n            } else {\n                file = tmp.createTemporaryFile();\n                OutputStream out = new FileOutputStream(file);\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    out.close();\n                }\n                FileInputStream newStream = new FileInputStream(file);\n                tmp.addResource(newStream);\n                final InputStream oldStream = in;\n                in = new BufferedInputStream(newStream) {\n\n                    @Override\n                    public void close() throws IOException {\n                        oldStream.close();\n                    }\n                };\n                length = file.length();\n            }\n        }\n        return file;\n    }\n", "label": 1, "substitutes": {"event": ["events", "expected", "result", "ee", "message", "vent", "ev", "this", "f", "exc", "data", "ec", "re", "ctx", "el", "exec", "x", "e", "other", "ex", "Event", "change", "context", "g", "start", "nd", "test", "ext"], "source": ["input", "wrapper", "result", "src", "channel", "storage", "zip", "style", "resource", "archive", "info", "name", "scope", "ource", "missing", "slice", "image", "secure", "file", "position", "option", "project", "folder", "site", "id", "reference", "object", "table", "remote", "slave", "handler", "force", "component", "see", "instance", "sin", "key", "parse", "database", "scene", "start", "figure", "plus", "parent", "left", "size", "url", "core", "function", "grade", "base", "element", "section", "text", "comment", "string", "service", "subject", "sample", "use", "ie", "select", "reader", "connection", "from", "view", "driver", "Source", "root", "layer", "tree", "feature", "inner", "body", "target", "session", "SOURCE", "rule", "document", "seed", "uri", "ce", "form", "proxy", "unit"], "destination": ["variinator", " destinated", " destinator", "variribution", "descinated", "deinator", "defaultination", "targetification", "destinate", "Desturation", "Destinated", "defaulturation", "desturation", "deruction", " destruction", "destinated", "descuration", "homeinate", "deification", "Destinate", "sequination", "sequinated", "suffinated", "destification", "describution", "variination", "Destension", " destension", "extinate", "gesturation", "Destinator", "gestination", "destruction", "descension", "homeuration", "extinated", "continated", "descinator", "contination", "continator", " destribution", "exturation", " desturation", "suffribution", "targetination", "destension", "suffination", "extination", "deination", "defaultinated", "gestinator", "descinate", "sequinate", "targetruction", "targetinator", "continate", "destinator", "defaultribution", "extinator", "destribution", "homeinated", "variuration", " destification", "descination", "gestinated", "sequinator", "suffinator", "variinated", "homeination", "Destination", "Destribution"], "parallelCnt": ["paranoCnn", "parallelcn", "paranoScment", "parasiCnt", "parallelJCnt", "paranoCount", "parallelFct", "parallelScnc", "parallelRrt", "parascalNner", "parallelcnc", "parallelPnd", "parallelDount", "parallelChct", "parallelCount", "parallelCn", "parascalNNT", "parallelLNT", "parallelFn", "parallelNn", "parallelDnt", "parasiFnc", "parallelFth", "parallelRct", "paranoScNT", "parascalCnt", "parallelPNT", "parasiCth", "parascalCner", "parallelcment", "parallelcNT", "parallelCcount", "parallelPpt", "parallelRnt", "parallelcount", "parallelDment", "parasiCct", "parallelCnd", "parallelScnd", "parasiCn", "parallelFrt", "parallelLnn", "parallelFnc", "paranoScpt", "paranoAcnt", "paranoCnd", "parallelCct", "parallelSccount", "parasiRnt", "parallelScount", "paranoCpt", "parallelCth", "parallelScNT", "paranoScnt", "parallelChn", "parallelScn", "parallelScpt", "parascalCNT", "parallelScment", "parallelChrt", "parallelccount", "parallelRn", "parallelScth", "parallelcnt", "parallelCner", "parallelcnd", "paranoAcNT", "parallelChnt", "paranoAcnn", "parallelAcnn", "parascalNn", "paranoScount", "parallelPn", "parasiFn", "parallelAcn", "parallelFnt", "parascalNnt", "parallelLnd", "parallelJCnd", "parallelcth", "parallelAcnt", "parallelcnn", "parallelJCpt", "parallelNnt", "paranoCNT", "parallelAcner", "parasiRrt", "parasiCrt", "parasiFnt", "paranoCment", "paranoScnd", "paranoCcount", "paranoAcnd", "parallelCrt", "parasiFth", "parallelAcNT", "parasiRct", "paranoSccount", "parallelPnt", "paranoCnt", "parasiRn", "parallelCnn", "parallelLnt", "parallelCment", "parallelCNT", "parasiCnc", "parallelAcnd", "parallelCnc", "parallelDcount", "parallelNner", "parallelNNT", "parallelJCNT", "parallelPner", "parascalCn", "parallelCpt", "parallelScnt"]}}
{"id1": "9413061", "id2": "20050668", "code1": "    @Override\n    public void run() {\n        try {\n            FileChannel out = new FileOutputStream(outputfile).getChannel();\n            long pos = 0;\n            status.setText(\"Slu\u010dova\u010d: Proces slu\u010dov\u00e1n\u00ed spu\u0161t\u011bn.. Pros\u00edm \u010dekejte..\");\n            for (int i = 1; i <= noofparts; i++) {\n                FileChannel in = new FileInputStream(originalfilename.getAbsolutePath() + \".\" + String.format(\"%03d\", i)).getChannel();\n                status.setText(\"Slu\u010dova\u010d: Slu\u010duji \u010d\u00e1st \" + i + \"..\");\n                this.splitsize = in.size();\n                out.transferFrom(in, pos, splitsize);\n                pos += splitsize;\n                in.close();\n                if (deleteOnFinish) new File(originalfilename + String.format(\".%03d\", i)).delete();\n                pb.setValue(100 * i / noofparts);\n            }\n            out.close();\n            status.setText(\"Slu\u010dova\u010d: Hotovo..\");\n            JOptionPane.showMessageDialog(null, \"Slou\u010deno!\", \"Slu\u010dova\u010d\", JOptionPane.INFORMATION_MESSAGE);\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static boolean insert(final PedidoSituacao pedidoSituacao) {\n        int result = 0;\n        final Connection c = DBConnection.getConnection();\n        PreparedStatement pst = null;\n        if (c == null) {\n            return false;\n        }\n        try {\n            c.setAutoCommit(false);\n            final String sql = \"insert into pedido_situacao (id_pedido, id_situacao, em, observacao, id_funcionario) \" + \"values (?, ? , now(), ?, ?) \";\n            pst = c.prepareStatement(sql);\n            pst.setInt(1, pedidoSituacao.getPedido().getCodigo());\n            pst.setInt(2, pedidoSituacao.getSituacao().getCodigo());\n            pst.setString(3, pedidoSituacao.getObservacao());\n            pst.setInt(4, pedidoSituacao.getFuncionario().getCodigo());\n            result = pst.executeUpdate();\n            c.commit();\n        } catch (final SQLException e) {\n            try {\n                c.rollback();\n            } catch (final SQLException e1) {\n                e1.printStackTrace();\n            }\n            System.out.println(\"[PedidoSituacaoDAO.insert] Erro ao inserir -> \" + e.getMessage());\n        } finally {\n            DBConnection.closePreparedStatement(pst);\n            DBConnection.closeConnection(c);\n        }\n        if (result > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"out": ["page", "parent", "plus", "size", "input", "inc", "buffer", "extra", "png", "io", "output", "conn", "w", "this", "b", "client", "part", "login", "base", "channel", "to", "In", "OUT", "Out", "again", "outs", "prefix", "writer", "exec", "x", "sync", "init", "o", "password", "ex", "cli", "temp", "v", "status", "up", "cache", "socket", "obj", "ssl", "err", "process", "bin", "copy", "line", "p"], "pos": ["POS", "size", "len", "min", "pose", "iter", "limit", "end", "diff", "part", "loc", "neg", "po", "data", "style", "os", "sum", "off", "conf", "x", "it", "o", "pid", "unit", " position", "length", "found", "temp", "offset", "pt", "index", "point", "pointer", "obj", "cache", "block", "pi", "is", "Pos", "start", "position", "s", "port", "p", "type"], "i": ["id", "split", "si", "qi", "multi", "abi", "d", "iu", "hi", "phi", "l", "part", "f", "number", "directory", "di", "n", "zi", "bi", "I", "ti", "ni", "ai", "gi", "ji", "esi", "adi", "ix", "it", "ui", "ci", "e", "o", "u", "eni", "ski", "ini", "a", "dim", "li", "v", "xi", "ri", "index", "count", "slice", "j", "c", "uri", "ii", "vi", "pi", "is", "parts", "start", "fi", "chi", "position", "z", "mi", "mini", "ip", "p", "ie"], "in": ["source", "reader", "tin", "url", "input", "inc", "din", "binary", "win", "connection", "buffer", "min", "nin", "conn", "l", "con", "client", "this", "diff", "part", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "config", "isin", "inner", "pc", "x", "exec", "init", "ins", "e", "s", "gin", "ini", "ex", "cin", "image", "c", "socket", "ssl", "IN", "err", "inside", "or", "inn", "file", "is", "bin", "on"], "splitsize": ["plitsize", "splitiz", "spliteize", "Splinsiz", "splitessize", "splatssize", "splatsIZE", "plitssize", "plitesization", "splinsize", "Splitssize", "splitization", "splitsze", "splitssize", "splitsIZE", "Splinssize", "plitessize", "splinssize", "splitze", "Splitsize", "SplitsIZE", "splatsiz", "splinsze", "spliteization", "plitsiz", "plitsization", "Splitsiz", "plitize", "plitze", "splitesization", "splitesize", "splitize", "plitiz", "splinsiz", "splinsIZE", "splitsization", "splitsiz", "splitesze", "plitsze", "splatsize", "plitesiz", "splitIZE", "Splinsize", "spliteiz", "plitesize", "SplinsIZE", "splitesiz"]}}
{"id1": "17551461", "id2": "649595", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"inputFile": ["sourceDir", "outputStream", "inputfile", "InputDirectory", "imageFile", "imageStream", " inputfile", " inputDir", "InputStream", " inputDirectory", "sourceFile", "InputDir", "sourceStream", "InputFile", "imageChannel", "inputDirectory", " inputStream", "imagefile", "inputDir", "sourceDirectory", "inputStream", "outputfile"], "outputFile": ["outputStream", " outputfile", "inputPath", "targetStream", "Outputfile", " outputPath", "OutputStream", " outputStream", "outputFiles", "targetPath", "outputDirectory", "OutputFiles", "targetFiles", " outputFiles", "targetfile", " outputDirectory", "OutputFile", "targetFile", "inputDirectory", "targetDirectory", "outputPath", "inputStream", "outputfile"], "inputChannel": ["parentFile", "outputStream", "inputListener", " inputchannel", "httpCh", "InputListener", "inputCh", "InputSocket", "outputSocket", "InputCh", "outputchannel", "InputStream", "parentChan", "httpChannel", "parentStream", "outputCh", "outputChan", "outputListener", "InputFile", "InputChannel", "inputchannel", "inputChan", "parentSocket", " inputStream", "httpSocket", "httpChan", "InputChan", " inputSocket", "parentChannel", "inputSocket", " inputChan", "Inputchannel", "inputStream", " inputListener"], "outputChannel": ["outputStream", "outChan", "outputSocket", "OutputSocket", "OutputStream", " outputConnection", " outputSocket", " outputStream", "inputConnection", "outputChan", "outSocket", "inputChan", "OutputFile", "outputConnection", " outputChan", "outStream", "outChannel", "OutputChan", "OutputChannel", "OutputConnection", "inputStream"]}}
{"id1": "2654261", "id2": "15861394", "code1": "    public char check(String password) {\n        if (captchaRandom.equals(\"null\")) {\n            return 's';\n        }\n        if (captchaRandom.equals(\"used\")) {\n            return 'm';\n        }\n        String encryptionBase = secret + captchaRandom;\n        if (!alphabet.equals(ALPHABET_DEFAULT) || letters != LETTERS_DEFAULT) {\n            encryptionBase += \":\" + alphabet + \":\" + letters;\n        }\n        MessageDigest md5;\n        byte[] digest = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(encryptionBase.getBytes());\n            digest = md5.digest();\n        } catch (NoSuchAlgorithmException e) {\n        }\n        String correctPassword = \"\";\n        int index;\n        for (int i = 0; i < letters; i++) {\n            index = (digest[i] + 256) % 256 % alphabet.length();\n            correctPassword += alphabet.substring(index, index + 1);\n        }\n        if (!password.equals(correctPassword)) {\n            return 'w';\n        } else {\n            captchaRandom = \"used\";\n            return 't';\n        }\n    }\n", "code2": "    public static String md5(String string) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException exception) {\n            LOGGER.warn(exception.getMessage());\n        }\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(string.getBytes(\"iso-8859-1\"), 0, string.length());\n        } catch (UnsupportedEncodingException exception) {\n            LOGGER.warn(exception.getMessage());\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"password": [" Password", "parent", "input", "user", "token", "auth", "fax", "sword", "username", "wd", "description", "root", "channel", "number", "data", "phrase", "enc", "email", "config", "random", "word", "name", " passwords", "pattern", "ion", "text", "words", "key", "string", "path", "seed", "encrypted", "code", "command", "attribute", "secret", "Password", "value", "padding", "pass"], "encryptionBase": ["encryptBase", "enotiationbase", "EncryptedSecret", "encorshipBase", "enryptionArea", "encgorithmBase", "encryptBuffer", "encryptionBuffer", "enryptionbase", "enoverybase", "encgorithmReal", "enotiationArea", "enoveryUnit", "EncryptionSecret", "encgorithmbase", "encoveryBuffer", "encoveryBase", "encryptionUnit", "encotationBase", "EncryptionBase", "encryptbase", "encryptKit", "encgorithmArea", "EncryptedBase", "encryptionKey", "encryptKey", "EncryptedKey", "encryptedSecret", "encryptedBase", "encotationbase", "enoveryBuffer", "EncryptionKit", "encorshipbase", "EncryptedKit", "encipherSecret", "encryptionbase", "enoveryBase", "encotationUnit", "enotiationReal", "encipherBase", "encipherKey", "encryptionSecret", "encotiationArea", "enryptionBase", "encotiationBase", "encotiationbase", "enryptionUnit", "EncryptionKey", "encryptedKit", "encotiationReal", "encryptionKit", "encorshipReal", "encotationBuffer", "encryptSecret", "encryptedKey", "encoverybase", "encoveryUnit", "enotiationBase", "encipherKit", "encryptUnit", "enryptionBuffer", "encorshipArea", "encryptionArea", "enryptionReal", "encryptionReal"], "md5": ["MDpe", "sha5", "dig2", "MD6", " MDpe", " md1", " MD512", " mdpe", "shadown", "mdpe", " MD2", "MD1", "MD5", "MDdown", " MD5", "MD512", "dig512", "digdown", "md1", "sha1", "mddown", "md512", "sha512", "md6", "MD2", "dig6", "dig1", "md2", "sha2", " md2", " md6", " md512", "dig5"], "digest": ["Diger", "mdester", "dedEST", "digester", "digests", "expests", "DigEST", "modest", " digests", "mdest", "modested", "digense", "diger", "dedest", " digace", "moder", "digEST", " digense", "Digester", "Digested", " digEST", "mdense", "dedense", "expest", "digace", "expester", "dedester", " digester", "mdace", "modEST", "digested", " diger", " digested", "Digests", "Digace", "Digest", "expEST", "mdEST"], "index": ["page", "div", "left", "size", "id", "active", "none", "num", "inc", "default", "si", "connection", "ind", "iter", "output", "weight", "digit", "alpha", "object", "end", "val", "diff", "f", "number", "loc", "data", "find", "address", "info", "condition", "second", "element", "x", "update", "ix", "exp", "length", "ini", "key", "offset", "path", "change", "point", "pointer", "j", "slice", "col", "expression", "width", "oct", "Index", "pos", "zero", "tail", "start", "position", "value", "exit"], "i": ["id", "num", "si", "qi", "multi", "iu", "phi", "io", "hi", "l", "f", "di", "n", "bi", "mu", "I", "ti", "ni", "ji", "info", "ai", "gi", "oi", "x", "ix", "ui", "ci", "u", "o", "e", "ini", "li", "v", "key", "xi", "wei", "j", "c", "uri", "ii", "pi", "chi", "z", "uni", "ip", "p", "ie"], "correctPassword": ["completeSecret", "validPass", "wrongPassword", "wrongpassword", "orrectPass", " correctPass", "completeString", "validpassword", "CorrectString", "orrectpassword", "wrongText", "completepassword", " correctPage", "orrectPage", "orrectSecret", "CorrectSecret", "CorrectText", "correctpassword", "Correctpassword", "validPassword", "correctText", "correctPass", "correctSecret", " correctpassword", "wrongString", "completePassword", "CorrectPass", "validPage", "correctPage", "completeText", "CorrectPassword", "completePass", "orrectPassword", "correctString"], "captchaRandom": ["CaptchaToken", "captureToken", "capturerandom", "captchatrandom", "captachaRoot", "captacharandom", "captondaRand", "captureSecret", "captchRand", "Capturerandom", "captchrandom", "CaptureToken", "captachaRandom", "captcharandom", "captachaToken", "CaptchaRandom", "CaptchaRand", "Captcharandom", "captchaRand", "captcherRoot", "captachaRand", "captcaRandom", "captcarandom", "captcherrandom", "CaptachaRandom", "Captacharandom", "CaptachaSecret", "CaptachaRand", "CaptachaRoot", "captcaRand", "captchRoot", "CaptureRandom", "captchaRoot", "captureRand", "captchatRand", "captachaSecret", "captcherRandom", "CaptchaRoot", "captchatRandom", "captchaToken", "CaptchaSecret", "captchRandom", "CaptureRand", "captureRandom", "captchToken", "captondaRandom", "captcherRand", "captchaSecret", "captondaSecret", "captondarandom"]}}
{"id1": "10195648", "id2": "19002156", "code1": "    public static void main(String[] args) {\n        if (args.length != 3) {\n            System.out.println(\"Usage: HexStrToBin enc/dec <infileName> <outfilename>\");\n            System.exit(1);\n        }\n        try {\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            InputStream in = new FileInputStream(args[1]);\n            int len = 0;\n            byte buf[] = new byte[1024];\n            while ((len = in.read(buf)) > 0) os.write(buf, 0, len);\n            in.close();\n            os.close();\n            byte[] data = null;\n            if (args[0].equals(\"dec\")) data = decode(os.toString()); else {\n                String strData = encode(os.toByteArray());\n                data = strData.getBytes();\n            }\n            FileOutputStream fos = new FileOutputStream(args[2]);\n            fos.write(data);\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private String jarDiagnostics(Throwable throwable, File[] files) throws IOException {\n        File home = new File(System.getProperty(\"user.home\"));\n        File jar_file = File.createTempFile(\"nuages-diagnostic.\", \".jar\", home);\n        FileOutputStream fos = new FileOutputStream(jar_file);\n        JarOutputStream jos = new JarOutputStream(fos);\n        ZipEntry ze = new ZipEntry(\"Exception\");\n        jos.putNextEntry(ze);\n        PrintStream ps = new PrintStream(jos);\n        throwable.printStackTrace(ps);\n        for (File file : files) if ((file != null) && file.exists()) {\n            ze = new ZipEntry(file.getName());\n            jos.putNextEntry(ze);\n            byte[] buffer = new byte[65536];\n            FileInputStream fis = new FileInputStream(file);\n            int len;\n            while ((len = fis.read(buffer)) > 0) jos.write(buffer, 0, len);\n            fis.close();\n        }\n        jos.close();\n        return jar_file.getPath();\n    }\n", "label": 1, "substitutes": {"os": ["los", "ks", "des", "oid", "ss", "io", "fs", "out", "ros", "OS", "ms", "bos", "oes", "as", "oa", "bs", "outs", "ens", "es", "ot", "dos", "bytes", "sys", "js", "vs", "oss", "oS", "ins", "o", "aos", "ob", "rs", "cs", "mos", "ls", "Os", "fits", "nos", "ose", "ios", "ops", "socket", "ol", "ols", "pos", "us", "is", "cos", "ds", "boot", "obs", "bis", "osi", "iso", "ps", "op", "so"], "in": ["reader", "input", "inc", "din", "arin", "win", "io", "nin", "con", "out", "login", "as", "f", "In", "pin", "stream", "again", "ac", "inner", "init", "ins", "o", "vin", "ini", "ex", "kin", "sin", "cin", "c", "socket", "i", "IN", "err", "inn", "rin", "is", "ilo", "lin", "bin", "s", "fa", "ic", "pass"], "len": ["dl", "size", "split", "en", "num", "url", "ln", "lf", "ll", "iter", "min", "limit", "lim", "l", "pre", "val", "lon", "part", "loc", "base", "Len", "f", "n", "el", "body", "nt", "length", "fl", "lc", "li", "le", "count", "rev", "err", "pos", "lin", "fin", "bin", "str", "line", "sl"], "buf": [" buff", "dec", "cb", "queue", "bf", "la", "bh", "uc", "buffer", "buff", "br", "Buffer", "cas", " bu", " buffers", "b", "bc", "loc", "cv", "bd", "ref", "bytes", "ctx", "box", "raw", "off", "func", "batch", "bb", "seq", "wave", "uf", "bag", "v", "ba", "pool", "border", "ab", " buffer", "vec", "wb", "fb", "array", " b", "block", "ff", "str", "rb", "fab"], "data": ["div", "dec", "str", "id", "split", "value", "input", "plain", "memory", "la", "size", "reader", "buffer", "message", "output", "format", "description", "part", "base", "ata", "bytes", "style", "response", "raw", "info", "pad", "name", "body", "results", "batch", "DATA", "da", "json", "content", "xxx", "done", "slice", "string", "media", "image", "what", "cache", "error", "code", "i", "struct", "array", "aa", "block", "valid", "empty", "alpha", "dat", "p", "entry"], "strData": ["STRData", "StrEl", "StrVal", "rVal", "rdata", " strString", "STRVal", "StrData", "STRArray", "Strdata", "STREl", " strBu", "rArray", "strVal", "StrArray", " strEl", "strArray", "strString", "strEl", "STRString", "STRdata", "StrBu", "strBu", "StrString", "STRBu", "rData", "strdata"], "fos": [" fros", "sfos", " foses", "fose", "forose", "afose", " fo", "forios", "infoss", "sfoses", "foross", "infoses", "foss", "ffoses", "ffos", "fo", "fros", "Fos", "fol", "afos", "infos", "Fo", "fios", "ffo", " fios", " fol", "infros", "sfros", "afoss", "afios", "foses", "ffol", "Fol", "Foses", "foros", "sfoss", " foss", " fose"]}}
{"id1": "2490462", "id2": "16706867", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private void prepareDigestFromTextArea() throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        log.println(\"\\nCalculating digest ...\\n\");\n        java.security.MessageDigest md5 = java.security.MessageDigest.getInstance(\"MD5\");\n        md5.update(dataArea.getText().getBytes(\"UTF8\"));\n        byte[] digest = md5.digest();\n        log.println(\"digest:\\n\" + formatAsHexString(digest));\n        log.println(\"Done.\");\n        setEncodedDigest(encodeFromBytes(digest));\n    }\n", "label": 1, "substitutes": {"secure": ["host", "active", "require", "deep", "safe", "secondary", "pure", "security", "Secure", "stable", "https", "remote", "zip", "smart", "server", "config", "external", "random", "force", "depth", "relative", " insecure", "allow", "sr", "exclusive", "timeout", "session", "sec", "confirmed", "seed", "encrypted", "debug", "ssl", "sensitive", "quiet", "service", "secret", "unsigned", "proxy", "weak", "use"], "md5": ["mand3", " md64", "MDito", "md3", "md64", "mp2", " md256", " MD2", "mand2", "MD5", "mand5", " mdito", " MD5", "mdito", "mp5", " md56", "mand56", "MD512", " MDito", "MD3", "md512", "md256", "mand256", "mp64", "mand512", "MD2", "MD56", " MD3", "md2", " md2", " md512", "MD64", " md3", "md56", "MD256", "mp3"], "sbValueBeforeMD5": ["sbValueBeforemd85", "sbValueBeforeMet5", "sbValueBeforeMD3", "sbValueBeforeMC512", "sbValueWithoutSHA3", "sbValueBeforeML68", "sbValueAfterMD85", "sbValueBeforeMD1", "sbValueBeforeMP9", "sbValueBeforeMD53", "sbValueAfterMSLink", "sbValueBeforeMS3", "sbValueWithoutSHA512", "sbValueBeforemd512", "sbValueBeforeAST512", "sbValueBeforeAMDFive", "sbValueBesidesMD68", "sbValueAfterMD53", "sbValueBeforeMPFive", "sbValueBeforeSHA5", "sbValueBeforeMCLink", "sbValueBeforeML3", "sbValueBeforeMSLink", "sbValueBeforeMF5", "sbValueBeforeAMD3", "sbValueWithoutMD1", "sbValueAfterMD5", "sbValueBeforeMP1", "sbValueBeforeMDFive", "sbValueBeforeSHA512", "sbValueBeforeAMD512", "sbValueBeforeML5", "sbValueAfterMD3", "sbValueBeforeAST3", "sbValueWithoutSHA1", "sbValueAfterMS5", "sbValueBeforeMD512", "sbValueBeforeM3", "sbValueBeforeMP25", "sbValueBeforeMD8", "sbValueBeforeMAC1", "sbValueBesidesMD8", "sbValueBeforeAMD85", "sbValueBeforeML8", "sbValueBeforeMAC5", "sbValueBeforeAMD1", "sbValueBeforeMP3", "sbValueWithoutMD3", "sbValueBeforemd3", "sbValueBeforeMet9", "sbValueBeforeMD25", "sbValueAfterAMD512", "sbValueAfterMP3", "sbValueBeforeMS53", "sbValueWithoutMD5", "sbValueBeforeM512", "sbValueBeforeMet25", "sbValueBeforeAST85", "sbValueAfterMS53", "sbValueBeforeMD68", "sbValueBeforeMC1", "sbValueBeforeMC5", "sbValueBeforeMF512", "sbValueAfterMDFive", "sbValueAfterMP1", "sbValueBeforeM5", "sbValueAfterAMD85", "sbValueBeforeAMD5", "sbValueBeforeMD9", "sbValueBeforemd53", "sbValueBeforeMF85", "sbValueWithoutMD512", "sbValueBeforeMACFive", "sbValueBeforeAST5", "sbValueBeforeM1", "sbValueBeforeMS5", "sbValueBeforeMD85", "sbValueBeforeMS85", "sbValueAfterMPFive", "sbValueAfterAMD3", "sbValueBeforeMF3", "sbValueBeforeSHA3", "sbValueAfterMDLink", "sbValueBeforeMDLink", "sbValueBeforeSHA1", "sbValueAfterMS3", "sbValueBeforeMC53", "sbValueBeforeMC3", "sbValueBeforeMS512", "sbValueAfterAMD5", "sbValueAfterMD512", "sbValueBeforeMS68", "sbValueBeforeMS8", "sbValueBeforemdLink", "sbValueBeforemd5", "sbValueBeforeMP5", "sbValueAfterMP5", "sbValueBeforeMet3", "sbValueAfterMD1", "sbValueBesidesMD3", "sbValueWithoutSHA5", "sbValueBeforeMAC3", "sbValueBesidesMD5"], "time": ["host", "size", "id", "user", "hour", "race", "year", "counter", "tim", "tz", "clock", "mode", "loc", "sleep", "version", "serial", "ime", "random", "etime", "depth", "name", "event", "length", "cost", "money", "timeout", "count", "seed", "delay", "live", "error", "times", "speed", "date", "TIME", "Time", "start", "timer", "rate", "value", "port", "month", "duration", "type"], "rand": ["id", "rar", "rank", "win", "year", "mid", "range", "right", "ro", "dev", "winner", "root", "bug", "gen", "loc", "version", "serial", "r", "clean", "round", "rage", "random", "depth", "rc", "pattern", "patch", "length", "max", "rh", "raid", "bit", "index", "rule", "count", "seed", "reg", "delay", "error", "live", "rr", "q", "order", "ng", "rate", "Rand", "alpha", "pick", "type"], "valueBeforeMD5": ["valueBeforeAMD2", "valueAfterMP3", "valueBeforeMC3", "valueBeforeMF25", "valueAfterMP2", "valueAfterMP50", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAfterMD25", "valueBeforeMP50", "valueBeforeAMD3", "valueBeforeMF2", "valueBeforeMP2", "valueBeforeME5", "valueAfterMD3", "valueBeforeMD3", "valueBeforeMD25", "valueBeforeME3", "valueBeforeAMD50", "valueBeforeAMD5", "valueBeforeMD50", "valueBeforeMF3", "valueAfterMP5", "valueBeforeMC2", "valueBeforeMF5", "valueAfterMD50", "valueBeforeME2", "valueAfterMD2", "valueBeforeMC5", "valueBeforeMC25", "valueBeforeME50"], "array": ["hash", "queue", "binary", "our", "Array", "arr", "range", "arrow", "function", "result", "message", "audio", "view", "object", "app", "ray", "number", "data", "r", "integer", "pair", "archive", "feature", "address", "angle", "shape", "element", "section", "batch", "allow", "api", "instance", "a", "area", "abc", "index", "string", "image", "list", "record", "error", "expression", "map", "database", "value", "collection", "sample"], "sb": ["sa", "cb", "bf", "mb", "bh", "si", "binary", "buffer", "sth", "buff", "usb", "sg", "pb", "src", "sf", "bc", "lr", "kb", "bm", "ruby", "abb", "bs", "obb", "rob", "erb", "bj", "bb", "SB", " SB", "ob", "sl", "sv", "zb", "buf", "gb", "xb", "eb", "ib", "orb", "bsp", "ab", "db", "bt", "wb", "fb", "sq", "lab", "nb", "lb", "s", "rb", "bp", "bl"], "j": ["jj", "num", "d", "ind", "br", "J", "jp", "k", "l", "y", "jo", "ja", "part", "aj", "f", "ij", "n", "ji", "adj", "js", "x", "bj", "o", "e", "uj", "dj", "length", "pr", "ch", "job", "li", "v", "key", "dy", "index", "obj", "c", "i", "ii", "im", "jl", "oj", "q", "z", "p", "ie"], "b": ["cb", "bf", "d", "mb", "be", "br", "k", "BB", "pb", "l", "y", "f", "p", "n", "bs", "x", "e", "bb", "ob", "bit", "bar", "job", "a", "B", "eb", "orb", "c", "ab", "db", "i", "obj", "wb", "fb", "nb", "lb", "bin", "rb", "ib"], "valueAfterMD5": ["valueAfterMP3", "valueAfterMP2", "valueAfterMDType", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAftermd2", "valueAfterAMD3", "valueBeforeMP2", "valueAftermd3", "valueAfterMD3", "valueAfterMPType", "valueAfterAMD5", "valueBeforeMD3", "valueAftermdType", "valueAfterMP5", "valueAfterAMD2", "valueBeforeMDType", "valueAfterMD2", "valueBeforeMPType", "valueAfterAMDType", "valueAftermd5"]}}
{"id1": "9970377", "id2": "19746605", "code1": "    public void doWrite() {\n        System.out.print(\"\\nSerializing...\");\n        try {\n            IFile ifile = null;\n            File file = null;\n            if (null != method.getResource()) {\n                ifile = method.getJavaProject().getResource().getProject().getFile(Statics.CFG_DIR + Statics.SEPARATOR + path.substring(path.lastIndexOf(Statics.SEPARATOR)));\n            }\n            file = new File(path);\n            if (file.exists()) {\n                boolean ans = MessageDialog.openQuestion(wb.getSite().getShell(), \"Flow Plug-in\", \"File already exists. Do you want to overwrite it?\");\n                if (ans) {\n                    file.delete();\n                }\n            }\n            if (!file.exists()) {\n                FileOutputStream fos = new FileOutputStream(path);\n                ObjectOutputStream oos = new ObjectOutputStream(fos);\n                BufferedOutputStream bo = new BufferedOutputStream(oos);\n                oos.writeObject(anode);\n                oos.flush();\n                oos.close();\n                InputStream is = new FileInputStream(path);\n                if (null != ifile) {\n                    if (ifile.exists()) ifile.delete(true, null);\n                    ifile.create(is, IResource.NONE, null);\n                }\n                Path fullpath = new Path(path);\n                IDE.openEditorOnFileStore(wb.getSite().getPage(), EFS.getLocalFileSystem().getStore(fullpath));\n                method.getResource().refreshLocal(10, null);\n                System.out.println(\"Serializing ...Done!\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (CoreException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private synchronized Frame insertFrame(int index, File source, INSERT_TYPE type) throws IOException {\n        if (source == null) throw new NullPointerException(\"Parameter 'source' is null\");\n        if (!source.exists()) throw new IOException(\"File does not exist: \" + source.getAbsolutePath());\n        if (source.length() <= 0) throw new IOException(\"File is empty: \" + source.getAbsolutePath());\n        if (index < 0) throw new IndexOutOfBoundsException(\"index < 0\");\n        if (index >= frames_.size()) throw new IndexOutOfBoundsException(\"index >= frames_.size()\");\n        File tmp = new File(Settings.getPropertyString(ConstantKeys.project_dir), \"tmp.jpg\");\n        switch(type) {\n            case MOVE:\n                if (source.getParentFile().compareTo(new File(Settings.getPropertyString(ConstantKeys.project_dir))) == 0 && source.getName().matches(\"img_[0-9]{5}\\\\.jpg\")) {\n                    for (int i = 0; i < frames_.size(); i++) {\n                        Frame f = frames_.get(i);\n                        if (f.getFile().compareTo(source) == 0) {\n                            frames_.remove(i);\n                            break;\n                        }\n                    }\n                }\n                source.renameTo(tmp);\n                break;\n            case COPY:\n                FileChannel inChannel = new FileInputStream(source).getChannel();\n                FileChannel outChannel = new FileOutputStream(tmp).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n                break;\n        }\n        for (int i = frames_.size() - 1; i >= index; i--) {\n            Frame newFrame = new Frame(new File(Settings.getPropertyString(ConstantKeys.project_dir), formatFileName(i)));\n            frames_.get(i).moveTo(newFrame);\n            frames_.set(i, newFrame);\n        }\n        File newLocation = new File(Settings.getPropertyString(ConstantKeys.project_dir), formatFileName(index));\n        tmp.renameTo(newLocation);\n        Frame f = new Frame(newLocation);\n        f.createThumbNail();\n        frames_.set(index, f);\n        return f;\n    }\n", "label": 1, "substitutes": {"ifile": [" iframe", "iffipe", " iffile", " ifime", "Ifail", "afffile", "tifil", "elfiled", "Ifil", "ifiles", "IFfile", "afile", "ifiler", "elfile", "IFime", "IFil", "afime", "iffiler", "elfil", "affile", "Ifili", " ifili", "filer", "afail", "inffile", "tifile", "ifime", "infail", "IFail", "affail", " ifiler", "ifipe", "ifil", "IFrame", "iffiles", "tifail", "fili", " ifole", "fipe", "elfole", "ifail", "iframe", "infile", "tiffile", " ifail", "inframe", "fail", "iffile", "IFile", " ifipe", "files", "affiled", "affil", "ifili", " ifiled", "ifole", "affole", " ifil", "ifiled", "Ifile", "fil", " ifiles"], "file": ["source", "play", "page", "parent", "folder", "ile", "url", "ban", "binary", "pe", "user", "place", "feed", "connection", "buffer", "be", "function", "File", "io", "l", "letter", "http", "view", "one", "fp", "b", "object", "home", "model", "f", "base", "fe", "auto", "zip", "resource", "handler", "work", "plane", "el", "force", "filename", "null", "name", "full", "e", "fly", "ife", "log", "book", "il", "path", "pool", "rule", "image", "lock", " File", "let", "or", "current", "local", "FILE", "line", "use", "unit"], "ans": ["ANS", "ks", "an", "anc", "ANN", "man", "cas", " sk", "AN", "aces", "An", "ars", "ane", "lan", " cans", "leans", "os", "can", "atan", "cons", "san", " can", "anan", "na", " ads", "s", "ani", "anas", "ann", "ays", "gan", " bans", "sk", "aus", "anes", "ants", "annot", "anus", "aned", "anned", "ras", "aning", " ang", "ents", "nas", " means"], "fos": ["sfos", "Foos", "Fops", " foses", " fo", "sfoses", "flOS", " foos", "flos", "fo", " fops", " fOS", "Fos", "Fols", "fols", "fops", "Fo", "sfo", "FOS", "fOS", " fols", "foos", "foses", "sfops", "flols", "Foses", "floos"], "oos": ["lbs", "los", "obi", "oid", "opa", "oses", "aco", "foo", "ros", "bos", "oes", "osa", "oa", "os", "oxy", "oo", "dos", "oi", "lo", "atos", "oin", "oss", "asio", "oS", "oops", "o", "aos", "ob", "ooo", "obos", "mos", "OO", "ios", "ops", "elo", "opus", "oids", "flo", "obo", "ois", "ox", "uo", "ilo", "cos", "obs", "rots", " bos"], "bo": ["ao", "BO", "co", "ro", "io", "foo", "Bo", "bos", "po", "mo", "bs", "oo", "lo", "o", "ob", "ooo", "oe", "ko", "buf", "OO", "obj", "ox", "flo", "obo", "cro", "boot", "so"], "is": ["nis", "isa", "io", "ais", "fs", "ros", "as", "was", "iss", "sis", "os", "bs", "ris", "es", "ai", "ir", "ics", "has", "gets", "vs", "isi", "iris", "IS", "api", "ri", "lis", "ios", "its", "ori", "i", "im", "or", "ois", "us", "bis", "Is", "iso", "ps", "s", "does"], "fullpath": ["Fullpage", " fullpage", " fulltext", " fullath", "Fullpath", " fullurl", "realpage", "Fullath", "rawpath", " fullPath", "realurl", "fullath", "realpath", "Fullurl", "fullpage", "realtext", "fulltext", "rawPath", "fullurl", "FullPath", "fullPath", "rawtext", "Fulltext", "rawath"]}}
{"id1": "23598855", "id2": "3109015", "code1": "    public void requestConfirm() throws Exception {\n        if (!this._c.checkProperty(\"directory.request\", \"request\")) {\n            throw new Exception(\"product has no active request\");\n        }\n        if (!new File(WBSAgnitioConfiguration.getHARequestFile()).canWrite()) {\n            throw new Exception(\"cannot remove request from system\");\n        }\n        HashMap<String, String> values = getValues(WBSAgnitioConfiguration.getHARequestFile());\n        if (!values.containsKey(\"address.virtual\")) {\n            throw new Exception(\"failed to determine the virtual address\");\n        }\n        if (!values.containsKey(\"address.real\")) {\n            throw new Exception(\"failed to determine the remote address\");\n        }\n        HTTPClient _hc = new HTTPClient(values.get(\"address.real\"));\n        if (TomcatConfiguration.checkHTTPS()) {\n            _hc.setSecure(true);\n        }\n        _hc.load(\"/admin/Comm?type=\" + CommResponse.TYPE_HA + \"&command=\" + CommResponse.COMMAND_REQUEST_CONFIRM + \"&virtual=\" + values.get(\"address.virtual\"));\n        String _reply = new String(_hc.getContent());\n        if (_reply.isEmpty()) {\n            throw new Exception(\"remote product has not sent any reply\");\n        } else if (_reply.indexOf(\"done\") == -1) {\n            throw new Exception(_reply);\n        }\n        HAConfiguration.setSlave(values.get(\"address.virtual\"), values.get(\"address.real\"));\n        File _f = new File(WBSAgnitioConfiguration.getOptionalSchemaRequestFile());\n        if (_f.exists()) {\n            FileOutputStream _fos = new FileOutputStream(WBSAgnitioConfiguration.getOptionalSchemaFile());\n            FileInputStream _fis = new FileInputStream(_f);\n            while (_fis.available() > 0) {\n                _fos.write(_fis.read());\n            }\n            _fis.close();\n            _fos.close();\n            _f.delete();\n        }\n        _f = new File(WBSAgnitioConfiguration.getSchemaObjectRequestFile());\n        if (_f.exists()) {\n            FileOutputStream _fos = new FileOutputStream(WBSAgnitioConfiguration.getSchemaObjectFile());\n            FileInputStream _fis = new FileInputStream(_f);\n            while (_fis.available() > 0) {\n                _fos.write(_fis.read());\n            }\n            _fis.close();\n            _fos.close();\n            _f.delete();\n        }\n        new File(WBSAgnitioConfiguration.getHARequestFile()).delete();\n        this._c.removeProperty(\"directory.request\");\n        this._c.setProperty(\"directory.virtual\", values.get(\"address.virtual\"));\n        this._c.setProperty(\"directory.status\", \"slave\");\n        this._c.store();\n    }\n", "code2": "    private void copy(File parent) {\n        System.out.println(\"parent---\" + parent.getAbsolutePath());\n        if (parent.isDirectory() && !\".svn\".equals(parent.getName())) {\n            File cases = new File(parent, \"cases\");\n            if (cases.exists()) {\n                File answers = new File(parent, \"answers\");\n                if (!answers.exists()) {\n                    answers.mkdir();\n                    File answers_linux = new File(parent, \"answers_linux\");\n                    for (File file : answers_linux.listFiles()) {\n                        if (file.isDirectory()) {\n                            continue;\n                        }\n                        File target = new File(answers, file.getName());\n                        try {\n                            IOUtils.copy(new FileInputStream(file), new FileOutputStream(target));\n                        } catch (Throwable t) {\n                            t.printStackTrace();\n                        }\n                    }\n                }\n            } else {\n                for (File son : parent.listFiles()) {\n                    System.out.println(\"parent---\" + son.getAbsolutePath());\n                    copySon(son);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"values": ["tests", "als", "ples", "states", "strings", "events", "errors", "ends", "pes", "holders", "ils", "settings", "lines", "keys", "properties", "items", "params", "stores", "issues", "writers", "codes", "objects", "changes", "flows", "es", "ages", "models", "forms", "vs", "groups", "ports", "iv", "boxes", "plugins", "owners", "results", "pages", "members", "rules", "versions", "fields", "roots", "docs", "vals", "maps", "utils", "limits", "details", "files", "vi", "ids", "services", "views", "Values", "value", "ves"], "_hc": ["_wc", " _hpc", "_vc", "_ohxc", "_ehc", "placehc", "_Hfc", "_htxc", "_hmfc", "_hhcs", "placeghxc", "_Hnc", "_ohl", "_hcu", "_ghcu", "_wfc", "_shcs", " _hfc", "_hnc", "_htcu", "_hfc", "_hl", "_Hc", "_wcs", "_ohrc", "_Hpc", "_hmc", "placeghc", "_ohpc", " _hrc", "_vfc", "_ehdc", "_hcs", "_vcs", "_hxc", "_ohfc", "_wpc", "placeghl", "_hmpc", "placeghcu", "_ghxc", "_ohcu", "_htl", "placehcu", " _Hc", "_hmrc", "_hpc", "_shfc", "_Hrc", "_Hdc", "_hdc", " _Hrc", "_hhc", "_ehcs", " _Hpc", "_Hcs", "_shpc", "placehl", "_hhnc", " _Hfc", "_htc", "_ghl", "_vpc", "_shc", "_hhdc", "_ohc", "_ehnc", "_ghc", "_hrc", "placehxc"], "_reply": ["_Reply", "passrepl", "passreply", "passresponse", " _message", "_answer", "_response", " _repl", "passanswer", "_repl", " _Reply", "Jrepl", " _response", "logmessage", "Jmessage", "logresponse", "Jresponse", "Jreply", "_message", " _answer", "loganswer", "logreply"], "_f": ["_b", " _fd", "_fe", "_fi", " _c", "_sf", " _fi", "_fs", "upf", "_fd", "_c", "_cf", "upfe", "upfi", "upc", " _b", " _fe"], "_fos": ["_bios", " _fops", "_lis", "_fout", "_bos", "_fops", " _lout", " _los", "_pos", "_bops", "_lios", "_eios", " _fout", "_eops", " _lops", "_eis", "_pout", "_bout", "_bis", " _lis", "_eos", "_lops", "_fios", "_los", "_lout", "_pis", "_pops"], "_fis": ["_dis", "_fp\n", "_fileis", "_dfos", "_fileys", "_fops", "_fi", " _dos", "_fileas", "lexfp\n", "_ifios", "_fs\n", "lexf\n", "_fpys", "_dos", "_dils", "_dfops", " _fi", "_fils", "_fys", "_sis", "_dios", "_bi", "_ifi", "_bios", "_fpis", "_dfils", " _di", "_lis", "_bos", "_sils", "_sops", "_sos", "_fpas", "_las", "_ifis", "_file\n", "_bis", "_di", "_los", "_fileos", "_fpos", " _fios", " _dios", "_fas", "_ifos", "_fios", "_dops", " _dis", "_dfis", "_lys"]}}
{"id1": "14974844", "id2": "6413929", "code1": "    public boolean backupFile(File oldFile, File newFile) {\n        boolean isBkupFileOK = false;\n        FileChannel sourceChannel = null;\n        FileChannel targetChannel = null;\n        try {\n            sourceChannel = new FileInputStream(oldFile).getChannel();\n            targetChannel = new FileOutputStream(newFile).getChannel();\n            targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IO exception occurred while copying file\", e);\n        } finally {\n            if ((newFile != null) && (newFile.exists()) && (newFile.length() > 0)) {\n                isBkupFileOK = true;\n            }\n            try {\n                if (sourceChannel != null) {\n                    sourceChannel.close();\n                }\n                if (targetChannel != null) {\n                    targetChannel.close();\n                }\n            } catch (IOException e) {\n                logger.log(Level.INFO, \"closing channels failed\");\n            }\n        }\n        return isBkupFileOK;\n    }\n", "code2": "    public HogsCustomizer() {\n        m_filename = PathFinder.getCustsFile();\n        m_currenttaunts = new String[10];\n        m_textfields = new JTextField[10];\n        m_color = new Color(255, 255, 255);\n        boolean exists = (new File(m_filename)).exists();\n        m_inverted = false;\n        m_chooser = new JColorChooser();\n        AbstractColorChooserPanel[] panels = m_chooser.getChooserPanels();\n        m_chooser.removeChooserPanel(panels[0]);\n        m_chooser.removeChooserPanel(panels[2]);\n        m_chooser.setPreviewPanel(new JPanel());\n        Reader reader = null;\n        if (exists) {\n            try {\n                reader = new FileReader(m_filename);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        } else {\n            Object[] options = { \"Yes\", \"No, Thanks\" };\n            int n = JOptionPane.showOptionDialog(this, \"You do not have a customization file in your home directory.\\n                 \" + \"Would you like to create one?\", \"Hogs Customization\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n            if (n == 0) {\n                try {\n                    FileChannel srcChannel = new FileInputStream(HogsConstants.CUSTS_TEMPLATE).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(m_filename).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    System.exit(0);\n                }\n            } else {\n                System.exit(0);\n            }\n            try {\n                reader = new FileReader(m_filename);\n            } catch (FileNotFoundException e1) {\n                e1.printStackTrace();\n                System.exit(0);\n            }\n        }\n        try {\n            readFromFile(reader);\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n        Box mainpanel = Box.createVerticalBox();\n        mainpanel.add(buildTauntsPanel());\n        mainpanel.add(buildMouseStylePanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        mainpanel.add(buildColorPanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        mainpanel.add(buildButtonsPanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setContentPane(mainpanel);\n        this.pack();\n        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n        this.setLocation(dim.width / 2 - (this.getWidth() / 2), dim.height / 2 - (this.getHeight() / 2));\n        this.setTitle(\"Hogs Customizer\");\n        this.setVisible(true);\n    }\n", "label": 1, "substitutes": {"oldFile": [" oldfile", "Oldfile", "OldSourceFile", "olderSourceFile", "oldDirectory", "oldFolder", " oldDirectory", "oldSourceFile", "olderFolder", "oldfile", "olderFile", "olderDirectory", " oldFolder", "oldDir", "olderfile", "OldDirectory", "OldDir", " oldSourceFile", " oldDir", "OldFile", "olderDir", "OldFolder"], "newFile": ["newSourceFile", " newDir", "newPage", "remoteFile", "newfile", "NewDir", "NewPath", "remoteFiles", "NewSourceFile", "NewFilename", "updatePage", "oldDir", "remoteDir", "updatefile", "newPath", "NewFile", "newFiles", "nowfile", "newDir", " newFilename", "nowFile", "targetSourceFile", "targetfile", " newPage", "oldFiles", "oldFilename", "updateDir", "remoteFilename", " newSourceFile", "targetFile", "NewPage", " newFiles", " newfile", "oldPath", "nowSourceFile", "targetDir", "updateFile", "Newfile", " newPath", "NewFiles", "newFilename", "nowFilename"], "sourceChannel": ["sourceConnection", " sourceStream", "targetStream", "proxyChannel", " sourceChan", "resourcechannel", "resourceClient", "sourceChan", "targetBuffer", "Sourcechannel", "resourceChannel", " sourceConnection", " sourceClient", "proxyConnection", "SourceBuffer", "targetClient", " sourceHandler", " sourceBuffer", "proxychannel", "targetHandler", "sourceBuffer", "inputChannel", "targetChan", "targetConnection", "inputchannel", "targetchannel", "inputChan", "SourceConnection", "sourceClient", "SourceChan", "resourceChan", "inputHandler", "sourcechannel", "sourceHandler", "proxyChan", "proxyStream", "SourceChannel", " sourcechannel", "sourceStream"], "targetChannel": ["sourceConnection", "argetPage", "targetStream", " targetStream", "TargetFile", "targetPage", "argetConnection", "TargetManager", "masterChan", "sourceChan", "argetChan", " targetChan", "masterConnection", "masterChannel", "argetchannel", " targetPage", "masterStream", "sourceFile", "Targetchannel", "TargetConnection", "TargetChan", "targetChan", "targetConnection", "targetchannel", "targetManager", "argetManager", "argetChannel", " targetFile", "targetFile", "targetScope", " targetScope", "TargetStream", "argetScope", "sourcePage", "sourcechannel", " targetManager", "TargetChannel", " targetConnection", " targetchannel", "sourceScope"], "isBkupFileOK": ["isBkupfileO", "isBkupFilesSync", "isBkupfileOk", "isBkupFileok", "isBkupefileO", "isBkupDirectoryO", "isBkupFilesOk", "isBkupfileOK", "isBkupTimeO", "isBkupeFileO", "isBkupTimeok", "isBkupFilesOK", "isBkupefileSync", "isBkupFileOk", "isBkupfileok", "isBkupeFileok", "isBkupefileOk", "isBkupStreamOk", "isBkupefileok", "isBkupfileSync", "isBkupefileOK", "isBkupStreamSync", "isBkupTimeOk", "isBkupStreamok", "isBkupStreamOK", "isBkupTimeOK", "isBkupeFileOK", "isBkupFilesok", "isBkupeFileOk", "isBkupeFileSync", "isBkupFileSync", "isBkupFileO", "isBkupDirectoryOk", "isBkupDirectoryOK", "isBkupDirectoryok"]}}
{"id1": "5055545", "id2": "19746605", "code1": "    public static void copy(File fromFile, File toFile) throws IOException {\n        if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFile.getAbsolutePath());\n        if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFile.getAbsolutePath());\n        if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFile.getAbsolutePath());\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        String parent = toFile.getParent();\n        if (parent == null) parent = System.getProperty(\"user.dir\");\n        File dir = new File(parent);\n        if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n        if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent);\n        if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private synchronized Frame insertFrame(int index, File source, INSERT_TYPE type) throws IOException {\n        if (source == null) throw new NullPointerException(\"Parameter 'source' is null\");\n        if (!source.exists()) throw new IOException(\"File does not exist: \" + source.getAbsolutePath());\n        if (source.length() <= 0) throw new IOException(\"File is empty: \" + source.getAbsolutePath());\n        if (index < 0) throw new IndexOutOfBoundsException(\"index < 0\");\n        if (index >= frames_.size()) throw new IndexOutOfBoundsException(\"index >= frames_.size()\");\n        File tmp = new File(Settings.getPropertyString(ConstantKeys.project_dir), \"tmp.jpg\");\n        switch(type) {\n            case MOVE:\n                if (source.getParentFile().compareTo(new File(Settings.getPropertyString(ConstantKeys.project_dir))) == 0 && source.getName().matches(\"img_[0-9]{5}\\\\.jpg\")) {\n                    for (int i = 0; i < frames_.size(); i++) {\n                        Frame f = frames_.get(i);\n                        if (f.getFile().compareTo(source) == 0) {\n                            frames_.remove(i);\n                            break;\n                        }\n                    }\n                }\n                source.renameTo(tmp);\n                break;\n            case COPY:\n                FileChannel inChannel = new FileInputStream(source).getChannel();\n                FileChannel outChannel = new FileOutputStream(tmp).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n                break;\n        }\n        for (int i = frames_.size() - 1; i >= index; i--) {\n            Frame newFrame = new Frame(new File(Settings.getPropertyString(ConstantKeys.project_dir), formatFileName(i)));\n            frames_.get(i).moveTo(newFrame);\n            frames_.set(i, newFrame);\n        }\n        File newLocation = new File(Settings.getPropertyString(ConstantKeys.project_dir), formatFileName(index));\n        tmp.renameTo(newLocation);\n        Frame f = new Frame(newLocation);\n        f.createThumbNail();\n        frames_.set(index, f);\n        return f;\n    }\n", "label": 1, "substitutes": {"fromFile": ["sourceDir", " fromFolder", " fromStream", "apiPath", "leftFile", "toFiles", "FromPage", "remoteFile", "apiFiles", "startPage", "newfile", "newStream", "remoteFiles", "formFolder", "FromDir", "FromStream", "fromStream", "forLibrary", "startfile", " fromFilename", "fromFolder", "forPage", "leftFiles", "startFolder", "sourcefile", "sourceFile", "leftDir", "fromLibrary", "startFile", " fromLibrary", "toFilename", "newDir", "formfile", "fromPage", "fromfile", "FromFolder", "sourceFiles", "forFile", "sourcePath", "newFile", " fromFiles", "newFolder", "toDir", "formPage", "fromFilename", "FromLibrary", " fromfile", "apiFile", "Fromfile", "fromFiles", "apifile", "formFile", " fromDir", " fromPage", "remotePath", "forDir", "leftFilename", "sourcePage", " fromPath", "fromPath", "forFolder", "fromDir", "FromFile"], "toFile": ["ToFile", "Tofile", "toDirectory", "sourceFolder", "toFiles", "targetStream", "toFolder", " toFolder", "toPlace", "templateFile", "ToLibrary", " tofile", "templatePlace", " toLibrary", "TODir", "TOFolder", " toPath", " toDir", " toFiles", "sourcefile", "targetPlace", "sourceFile", "toStream", "ToFolder", "templateStream", "TOfile", "ToDirectory", "soPath", "ToFiles", "ToPath", "toDir", "toLibrary", "targetFile", "ToDir", "templateDir", " toPlace", "soFile", "soDir", "fromDirectory", "toPath", "fromFiles", "tofile", " toDirectory", "targetDir", " toStream", "sourceDirectory", "TOFile", "fromDir", "sofile"], "parent": ["source", "host", "Parent", "page", "div", "id", "memory", "inc", "user", "term", "connection", "complete", "function", "parents", "am", "any", "home", "client", "owner", "root", "part", "loc", "p", "region", "directory", "tree", "master", "resource", "handler", "child", "par", "fat", "address", "ac", "name", "ppa", "pa", "it", "large", "old", "per", "unit", "patch", "api", "content", "session", "key", "pt", "rule", "path", "point", "pool", "pointer", "cache", "string", "file", "uri", "search", "and", "current", "valid", "option", "test", "port", "null", "ip", "location", "type"], "dir": ["folder", "div", "dec", "dc", "id", "url", " directory", "user", "d", "rel", "dep", "dict", "director", "iter", "cat", "dev", "doc", "DIR", "wd", "out", "object", "home", "fd", "root", "part", "loc", "base", "ver", "data", "directory", "di", "def", "dis", "dn", "der", "ir", "fun", "cur", "name", "direction", "da", "mod", "container", "per", "keep", "dr", "up", "col", "path", "file", "db", "manager", "dist", "md", "group", "entry", "coll", "Dir"], "from": ["source", "get", "via", "left", "url", "link", "pe", "connection", "cm", "range", "with", "io", "conn", "one", "http", "view", "out", "client", "in", "con", "of", "ou", "part", "normal", "base", "without", "po", "From", "by", "find", "auto", "stream", "data", "class", "server", "address", "low", "module", "component", "name", "ci", "o", "two", "per", "api", "max", "ch", "se", "c", "file", "parse", "flo", "or", "vol", "ce", "start", "form", "who", "when", "add", "empty", "on", "so"], "to": ["source", "via", "page", "size", "su", "site", "url", "about", "token", "office", "connection", "not", "with", "top", "co", "tto", "io", "output", "ma", "TO", "one", "http", "thro", "out", "client", "b", "To", "part", "base", "op", "po", "no", "by", "on", "auto", "server", "eto", "until", "name", "o", "two", "target", "see", "per", "log", "api", "too", "cache", "socket", "db", "file", "flo", "or", "pi", "who", "store", "copy", "so", "type"], "buffer": ["page", "read", "reader", "size", "queue", "memory", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "limit", "layer", "number", "data", "bytes", "available", "resource", "server", "address", "writer", "pad", "uffer", "transfer", "null", "batch", "length", "flush", "comment", "wave", "buf", "offset", "variable", "border", "seed", "cache", "character", "header", "block", "position", "bin", "vector", "port", "duration"], "bytesRead": ["BytesAct", " bytesLength", "tesNeed", "BytesWrite", "usersReader", "tesRead", "bytesReader", " bytesCount", "filesUse", "BytesWritten", "usersLoad", "tesWrite", "BytesUse", "usersCount", "bytesUse", "BytesNeed", "bytesWritten", "tesLength", "filesNeed", "filesWrite", " bytesLoad", "bytesAct", "filesRead", "stringsRead", "BytesLength", "stringsReader", "tesUse", "bytesLoad", " bytesWritten", "tesWritten", "bytesLength", "bytesNeed", "usersRead", " bytesReader", " bytesAct", "bytesCount", "stringsLoad", "bytesWrite", "tesAct", "stringsCount", "BytesRead"]}}
{"id1": "14518760", "id2": "20125816", "code1": "    public void connect(final URLConnectAdapter urlAdapter) {\n        if (this.connectSettings == null) {\n            throw new IllegalStateException(\"Invalid Connect Settings (is null)\");\n        }\n        final HttpURLConnection httpConnection = (HttpURLConnection) urlAdapter.openConnection();\n        BufferedReader in;\n        try {\n            in = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n            final StringBuilder buf = new StringBuilder(200);\n            String str;\n            while ((str = in.readLine()) != null) {\n                buf.append(str);\n                buf.append('\\n');\n            }\n            final ConnectResult result = new ConnectResult(httpConnection.getResponseCode(), buf.toString());\n            final Map<String, List<String>> headerFields = httpConnection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : headerFields.entrySet()) {\n                final String key = entry.getKey();\n                final List<String> val = entry.getValue();\n                if ((val != null) && (val.size() > 1)) {\n                    System.out.println(\"WARN: Invalid header value : \" + key + \" url=\" + this.connectSettings.getUrl());\n                }\n                if (key != null) {\n                    result.addHeader(key, val.get(0), val);\n                } else {\n                    result.addHeader(\"Status\", val.get(0), val);\n                }\n            }\n            this.lastResult = result;\n        } catch (IOException e) {\n            throw new ConnectException(e);\n        }\n    }\n", "code2": "    public static String getHash(String password) {\n        if (password == null || password.length() == 0) {\n            return null;\n        }\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            password = saltPassword(password);\n            digest.update(password.getBytes());\n            String result = getHexString(digest.digest());\n            return result;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"urlAdapter": ["webapter", "httpConnector", "webConnector", "httpConfig", "httpapter", "urlConfig", "webConfig", " urlConnection", "webConnection", "urlapter", "urlConnector", "urlConnection", "webAdapter", " urlConfig", " urlapter", " urlConnector", "httpAdapter"], "httpConnection": ["webClient", " httpClient", "httpsConnector", "httpConnector", "httpConnect", "HTTPConn", " httpConnect", "urlConnect", "httpsConnection", " httpconnection", "httpsConnect", " httpInterface", "httpsconnection", "httpInterface", "httpClient", " httpConn", "urlconnection", "webConnection", "HTTPConnect", "httpconnection", " httpconn", "httpconn", "urlConnector", "urlClient", "HTTPconn", "urlConnection", "urlConn", "httpsConn", "urlconn", "httpConn", " httpConnector", "webConnect", "httpsInterface", "webconnection", "urlInterface", "HTTPConnection"], "in": ["source", "read", "reader", "h", "url", "input", "inc", "din", "id", "win", "connection", "buffer", "min", "doc", "nin", "conn", "l", "con", "out", "b", "login", "f", "as", "gen", "In", "pin", "again", "re", "r", "fac", "isin", "inner", "ins", "ini", "a", "m", "ex", "kin", "rec", "cin", "c", "socket", "i", "IN", "err", "builder", "inn", "is", "bin", "s", "fa", "ac"], "buf": ["cb", "tmp", "url", "queue", "binary", "txt", "la", "uc", "buffer", "buff", "cf", "br", "Buffer", "cat", "pb", "cas", "fp", "b", "aux", "bc", "fd", "base", "cv", "data", "bytes", "ctx", "box", "config", "cur", "func", "grab", "bb", "ob", "runner", "text", "seq", "uf", "abs", "temp", "bag", "auc", "string", "ab", "wb", "map", "builder", "array", "header", "fb", "conv", "nb", "bu", "rb", "coll", "pkg"], "str": ["dec", "wr", "STR", "read", "url", "reader", "arr", "br", "iter", "l", "char", "b", "st", "fr", "f", "data", "r", "enc", "er", "cur", "e", "s", "exp", "spec", "cl", "Str", "text", "sr", "pr", "hr", "dr", "lc", "tr", "string", "cr", "list", "obj", "sp", "rev", "i", "err", "rr", "stri", "line", "coll", "sl"], "result": ["next", "source", "value", "continue", "default", "user", "our", "success", "Result", "complete", "function", "extra", "message", "output", "view", "this", "object", "root", "part", "pack", "ver", "row", "data", "summary", "future", "response", "r", "resource", "master", "ret", "repl", "server", "info", "event", "results", "report", "json", "runner", "job", "status", "up", "done", "session", "pass", "obj", "error", "db", "err", "builder", "manager", "current", "valid", "res", "coll"], "headerFields": ["headerForms", "HeaderFields", "HeaderColumngs", "headerColumnsets", "headerPrefes", "headerColgs", "headerFieldsets", "headerSignments", "headerSignerences", "headerFieldments", " headerColumnments", " headerFieldes", "headerColumnes", "headerColsets", "headerColumnments", "HeaderColumnes", " headerColumnes", "headerColumngs", "headerFielderences", "headerPrefsets", "headerSignes", "headerColes", " headerColumns", "headerPrefs", " headerFielderences", "headerFieldgs", " headerColumnerences", "headerFormes", "HeaderColumns", "HeaderColumnsets", "HeaderFieldsets", "headerFormments", "headerCols", "HeaderFieldes", "headerSigns", " headerFieldments", "headerFormerences", "HeaderFieldgs", "headerColumnerences", "headerFieldes", "headerColumns", "headerPrefgs"], "entry": ["mission", "reader", "ner", "inc", "term", "pe", "la", "si", "ent", "ger", "ry", "letter", "ence", "cell", "part", "row", "ries", "r", "set", "pair", "second", "inner", "section", "element", "er", "inter", "ge", "member", "e", "enter", "lc", "se", "index", "string", "entity", "record", "or", "Entry", "value", "line", "ie"], "key": ["nice", "sel", "parent", "id", "link", "pe", "cy", "ee", "co", "k", "letter", "op", "part", "ver", "by", "Key", "style", "set", "match", "ie", "box", "KEY", "section", "element", "word", "x", "name", "ace", "step", "length", "text", "col", "ke", "string", "path", "index", "change", "lock", "error", "code", "check", "i", "title", "label", "service", "header", "type", "ce", "order", "field", "oy", "option", "reason", "value", "ip"], "val": ["sel", "split", "url", "default", "msg", "la", "alt", "len", "arr", "Val", "ee", "l", "ul", "lv", "part", "base", "loc", "p", "data", "elt", "serv", "al", "el", "element", "VAL", "section", "iv", "x", "va", "it", "eval", "unit", "values", "text", "sl", "pr", "fl", "ls", "li", "v", "col", "il", "string", "list", "aval", "vals", "obj", "error", "sol", "ol", "err", "vol", "Value", "arg", "vi", "valid", "item", "detail", "value", "line", "pl", "bl"], "lastResult": ["nextReturn", " lastStatus", " lastResponse", "nextResponse", "prevResult", "lastReturn", "nextResult", " lastReturn", "lastResponse", "prevResponse", "lastStatus", "nextStatus", "prevReturn", "prevStatus"]}}
{"id1": "19044532", "id2": "7170603", "code1": "    public boolean exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        boolean found = false;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, Config.getFtpPort());\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = true;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    private static void generateSQLUpgradeFile(String milestoneDefFileName, String sqlDirectoryName, String fromMilestone, String destMilestone, String destFileName) throws Exception {\n        File milestoneDefFile = new File(milestoneDefFileName);\n        if (!milestoneDefFile.exists()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : does not exists\");\n        }\n        if (!milestoneDefFile.isFile()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : not a file\");\n        }\n        if (!milestoneDefFile.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : not readable\");\n        }\n        File sqlDirectory = new File(sqlDirectoryName);\n        if (!sqlDirectory.exists()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : does not exists\");\n        }\n        if (!sqlDirectory.isDirectory()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : not a directory\");\n        }\n        if (!sqlDirectory.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : not readable\");\n        }\n        File destFile = new File(destFileName);\n        if (destFile.exists()) {\n            throw new IllegalArgumentException(\"Cannot write to [\" + destFileName + \"] : already exists\");\n        }\n        destFile.createNewFile();\n        SqlUpgradeXmlParser parser = SqlUpgradeXmlParser.newParser();\n        FileInputStream milestoneDefFIS = null;\n        try {\n            milestoneDefFIS = new FileInputStream(milestoneDefFile);\n            parser.parse(milestoneDefFIS);\n        } catch (XMLParseException e) {\n            printXmlError(e, milestoneDefFileName);\n        } finally {\n            try {\n                if (milestoneDefFIS != null) milestoneDefFIS.close();\n            } catch (Exception e) {\n                _logger.warn(\"Exception caught when closing inputstream \", e);\n            }\n        }\n        int fromMilestoneIdx = parser.getMilestoneIndex(fromMilestone);\n        int toMilestoneIdx = parser.getMilestoneIndex(destMilestone);\n        if (fromMilestoneIdx < 0) {\n            throw new IllegalArgumentException(\"Cannot upgrade from milestone [\" + fromMilestone + \"] : does not exist . (Exisiting milestones \" + parser.listMilestones() + \")\");\n        }\n        if (toMilestoneIdx < 0) {\n            throw new IllegalArgumentException(\"Cannot upgrade to milestone [\" + destMilestone + \"] : does not exist . (Exisiting milestones \" + parser.listMilestones() + \")\");\n        }\n        if (fromMilestoneIdx == toMilestoneIdx) {\n            throw new IllegalArgumentException(\"Cannot upgrade to the same milestone\");\n        }\n        List<String> files = parser.getFilesForMilestones(fromMilestoneIdx, toMilestoneIdx);\n        List<String> views = parser.getViewsForMilestones(fromMilestoneIdx, toMilestoneIdx);\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(destFile);\n            for (Iterator<String> it = files.iterator(); it.hasNext(); ) {\n                appendFileToOutputStream(fos, sqlDirectory, it.next());\n            }\n            for (Iterator<String> it = views.iterator(); it.hasNext(); ) {\n                appendFileToOutputStream(fos, sqlDirectory, it.next());\n            }\n        } catch (Exception e) {\n            fos.close();\n            destFile.delete();\n            throw e;\n        } finally {\n            try {\n                if (fos != null) fos.close();\n            } catch (Exception e) {\n                _logger.warn(\"Exception caught when closing outputstream \", e);\n            }\n        }\n        System.out.println(\"An SQL update file has been generated to \" + destFileName + \".\");\n    }\n", "label": 0, "substitutes": {"fileToCheck": ["filenameToWork", "fileTOWork", "filenameTOCheck", "file2Che", "filetoWork", "nameToCheck", "fileToChe", "fileTOCheck", "fileTOChe", "nameToChe", "filenameTOTest", "filetoCheck", "fileTocheck", "nameTOcheck", "filenameToCheck", "filetocheck", "fileTOTest", "fileToWork", "file2check", "file2Test", "filetoChe", "filetoTest", "fileToTest", "nameToTest", "file2Check", "nameTOChe", "nameTOCheck", "filenameToTest", "filenameTOcheck", "nameTocheck", "nameTOTest", "fileTOcheck", "filenameTOWork", "filenameTocheck"], "ftp": ["webbase", " ftplug", "aftpc", "rtcp", "fdtp", "webtp", "rtpc", " fttp", "iftP", " ftpc", " ftcp", " ftbase", "fdpi", "ntcp", "fxpa", "ctcp", " ftps", " ftsp", "ntpc", "cfpi", " ftpa", " fts", "overs", "rtap", "ctp", "htps", "touchper", " ftP", "aftcp", "overpa", "FTpi", "ifttp", "cftp", "fastap", "htsp", "aftv", "cffp", "iftdp", " ftfp", "ftper", "overp", "ftbase", "fttp", " ftap", "vttp", "webp", "fdp", " ftper", "vtv", "ftplug", "ftap", "touchplug", "fxsp", "htfp", "aftp", "htbase", "aftap", "gtP", "oversp", "rtp", "cttp", "http", "fastsp", "fastp", "FTb", "ftdp", "iftp", "htpc", " ftv", "ntp", "ftP", "fxs", "ftps", "gttp", "FTtp", "ntap", "ftpa", "webpc", "cfp", "ctv", "ftpc", "fdb", "vtcp", "ftfp", "ftsp", "fxp", " ftpi", " ftb", "fts", "htpi", " ftdp", "ftcp", "touchp", "touchv", "gtdp", "ftb", "vtp", "htap", "aftplug", "aftper", "ftpi", "gtp", "fastps", "htp", "FTp", "ftv"], "reply": ["next", "respond", "link", "write", "connection", "len", "buffer", "result", "echo", "message", "ry", "join", " replied", "request", "mode", "ply", "base", "data", "response", " answer", "repl", "server", "call", "info", "address", "ret", "force", "Reply", " response", "send", "sync", "query", "ix", "text", "comment", "post", "status", "index", "dy", "answer", "error", "code", "err", "resp", "command", "service", "rr", "ignore", "bot", "reason"], "found": ["successful", "left", "land", "read", "default", "compl", "first", "fall", "success", "not", "sent", "filled", "expected", "result", "function", "allowed", "flat", "true", "l", "less", "in", "val", "inf", "Found", "used", "normal", "f", "ver", "loaded", "find", "full", "old", "failed", "bound", "fl", "done", "count", "given", " Found", "built", "search", "printed", "required", "pos", "err", "valid", "could", "fixed", "changed", "good", "defined", "ed"]}}
{"id1": "18340402", "id2": "15424571", "code1": "    public String tranportRemoteUnitToLocalTempFile(String urlStr) throws UnitTransportException {\n        URL url = null;\n        File tempUnit = null;\n        BufferedOutputStream bos = null;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e1) {\n            logger.error(String.format(\"The url [%s] is illegal.\", urlStr), e1);\n            throw new UnitTransportException(String.format(\"The url [%s] is illegal.\", urlStr), e1);\n        }\n        URLConnection con = null;\n        BufferedInputStream in = null;\n        try {\n            con = url.openConnection();\n            in = new BufferedInputStream(con.getInputStream());\n        } catch (IOException e) {\n            logger.error(String.format(\"Can't open url [%s].\", urlStr));\n            throw new UnitTransportException(String.format(\"Can't open url [%s].\", urlStr), e);\n        } catch (Exception e) {\n            logger.error(String.format(\"Unknown error. Maybe miss the username and password in url [%s].\", urlStr), e);\n            throw new UnitTransportException(String.format(\"Unknown error. Maybe miss the username and password in url [%s].\", urlStr), e);\n        }\n        String unitName = urlStr.substring(urlStr.lastIndexOf('/') + 1);\n        try {\n            if (!StringUtils.isEmpty(unitName)) tempUnit = new File(CommonUtil.getTempDir(), unitName); else tempUnit = new File(CommonUtil.createTempFile());\n        } catch (DeployToolException e) {\n            logger.error(String.format(\"Can't get temp file [%s].\", tempUnit));\n            throw new UnitTransportException(String.format(\"Can't get temp file [%s].\", tempUnit), e);\n        }\n        try {\n            bos = new BufferedOutputStream(new FileOutputStream(tempUnit));\n            logger.info(String.format(\"Use [%s] for ftp unit [%s].\", tempUnit, urlStr));\n        } catch (FileNotFoundException e) {\n            logger.error(String.format(\"File [%s] don't exist.\", tempUnit));\n            throw new UnitTransportException(String.format(\"File [%s] don't exist.\", tempUnit), e);\n        }\n        try {\n            IOUtils.copy(in, bos);\n            bos.flush();\n        } catch (IOException e) {\n            logger.error(String.format(\"Error when download [%s] to [%s].\", urlStr, tempUnit), e);\n            throw new UnitTransportException(String.format(\"Error when download [%s] to [%s].\", urlStr, tempUnit), e);\n        } finally {\n            IOUtils.closeQuietly(bos);\n            IOUtils.closeQuietly(in);\n        }\n        logger.info(String.format(\"Download unit to [%s].\", tempUnit.getAbsolutePath()));\n        return tempUnit.getAbsolutePath();\n    }\n", "code2": "    private File copyFile(File source, File destiny) {\n        try {\n            FileInputStream fileinputstream = new FileInputStream(source);\n            FileOutputStream fileoutputstream = new FileOutputStream(destiny);\n            byte abyte0[] = new byte[4096];\n            int i;\n            while ((i = fileinputstream.read(abyte0)) != -1) fileoutputstream.write(abyte0, 0, i);\n            fileinputstream.close();\n            fileoutputstream.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            LOGGER.error(e.getMessage());\n        } catch (IOException e) {\n            e.printStackTrace();\n            LOGGER.error(e.getMessage());\n        }\n        return destiny;\n    }\n", "label": 1, "substitutes": {"urlStr": ["UrlString", "urlSpec", "servicestr", "urlSTR", " urlString", "webBr", "uristr", "URLSTR", "uriSt", "emailSTR", "urlWr", "resourceSt", "logSt", "uriWr", "urlstr", "urlEl", "fileString", "URLString", "URLStr", "URLBr", " urlBr", "sourcestr", "resourceStr", " urlSpec", " urlCh", "URLstr", "logStr", " urlstr", "uriStr", "urlBr", "resourceSTR", "strstr", "urlString", "sourceStr", "fileStr", "UrlSTR", "UrlSpec", "emailDec", "emailStr", "URLDec", "serviceStr", "UrlStr", "urlSt", "uriString", "sourceSTR", "uriCh", "URLCh", "resourcestr", "logEl", "serviceString", "emailString", "urlCh", " urlDec", "Urlstr", "resourceString", " urlSTR", "resourceBr", "strSTR", "UrlSt", "webStr", " urlSt", "sourceString", "URLSt", "urlDec", "strStr", "webSt", "filestr", " urlEl", " urlWr", "strString", "logBr", "URLWr", "URLSpec", "webEl"], "url": ["input", "rel", "l", "uu", "model", "channel", "ctrl", "style", "resource", "address", "name", "log", "image", "impl", "secure", "file", "ssl", "web", "location", "ll", "feed", "xml", "conn", "lib", "ul", "ur", "ob", "job", "il", "rl", "URL", "Url", "www", "str", "source", "page", "link", "user", "open", "http", "base", "f", "loc", "version", "ref", "org", "server", "el", "e", "text", "string", "path", "service", "account", "gl", "play", "host", "connection", "pull", "download", "username", "format", "lr", "layer", "config", "api", "bel", "fl", "course", "socket", "uri", "form", "blog", "proxy", "coll", "sl", "unit"], "tempUnit": ["thinKit", "tempTest", "tempunit", "tmpTest", "baseUnity", " tempUnity", "tmpUn", "tempFile", "testUn", "localTest", "TempUnit", "baseUnit", "tempRule", "TempFile", " tempFamily", "tmpunit", "testKit", "testingUnit", "thinUnity", "fakeUnit", "TempUn", "testUnit", " tempUn", "masterUnit", "poraryFamily", "localUnity", "fakeFamily", "poraryHome", "localUnit", "singleHome", "thinUnit", " tempFile", "masterHome", " tempTest", "thinUn", "testUnity", "fakeUnity", "baseFile", "tmpRule", "tempKit", "tmpFile", "masterunit", "singleUnit", "baseRule", "poraryUnit", " tempRule", "testFile", "tmpUnity", " tempHome", "singleunit", "testingUnity", "tempHome", "testunit", "tempUnity", "tmpUnit", " tempunit", "localUn", "Tempunit", "tempFamily", "TempUnity", "fakeHome", "testingUn", "testingKit", "tempUn", "poraryUnity"], "bos": ["los", "bott", "ubis", "bh", "abi", "oses", "fs", "pins", "bps", "ros", "bm", "osa", "bi", "os", "bs", "outs", "org", "bo", "uts", "iban", "lo", "oin", "oss", "oos", "zo", "oks", "zos", "oops", "aos", "ob", "tis", "mos", "mis", "fits", "ios", "ops", "opus", "obo", "cos", "boot", "bis", "obs", "bits", "bin"], "con": ["en", "inc", "win", "connection", "cm", "uc", "open", "cf", "co", "conn", "fc", "l", "out", "bc", "Conn", "fr", "login", "f", "pin", "xc", "enc", "can", "inner", "pc", "cn", "conf", "cons", "aff", "func", "rc", "hel", "CON", "cl", "syn", "ocon", "ch", "com", "close", "cr", "connect", "cache", "c", "ran", "conv", "cc", "bin", "ca", "fa", "coll", "Con"], "in": ["id", "en", "input", "inc", "din", "win", "connection", "with", "io", "conn", "src", "out", "b", "bc", "diff", "login", "as", "gen", "In", "into", "pin", "n", "again", "org", "info", "isin", "pc", "conf", "init", "it", "ins", "unin", "s", "per", "zin", "m", "kin", "index", "string", "cin", "image", "make", "file", "ran", "i", "IN", "check", "inn", "rin", "is", "cos", "bis", "lin", "cms", "fin", "bin", "on", "ac"], "unitName": ["componentDesc", "UnitPath", " unitDesc", "pluginPath", "unitUnit", "unDesc", "componentname", "unitPath", "UnitName", "pluginName", "fileName", "componentName", "connectionPath", "UnitUnit", "unName", "connectionUnit", "connectionName", "pluginname", "unname", "unitname", "filename", "unitDesc", "componentPath", " unitUnit", "connectionname", "filePath", "unPath", "Unitname", " unitname", " unitPath"]}}
{"id1": "8364554", "id2": "386316", "code1": "    @Override\n    public void executeInterruptible() {\n        EncodeFilesDialog dialog = (EncodeFilesDialog) this.dialog;\n        File encoderFile = null;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            if (Platform.isWindows()) {\n                encoderFile = new File(\".\", \"lame.exe\");\n                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"lame/lame.exe\");\n            } else if (Platform.isLinux()) {\n                encoderFile = new File(\".\", \"lame\");\n                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"lame/lame\");\n            } else {\n                MainWindowInterface.showError(new Exception(Messages.getString(\"operations.file.encode.dialog.notsupported\")));\n                return;\n            }\n            os = new FileOutputStream(encoderFile);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            LOG.error(\"Cannot extract encoder executable\", e);\n            MainWindowInterface.showError(e);\n            return;\n        } finally {\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n        encoderFile.setExecutable(true, true);\n        try {\n            long totalSize = 0l;\n            for (int i = 0, l = filesModel.getSize(); i < l; i++) {\n                if (isInterrupted()) return;\n                IconAndFileListElement element = (IconAndFileListElement) filesModel.get(i);\n                File origFile = element.getFile();\n                totalSize += origFile.length();\n            }\n            rangeModel = dialog.getProgressBar().getModel();\n            rangeModel.setMinimum(0);\n            rangeModel.setMaximum((int) totalSize);\n            int parallelProcesses = dialog.getParallelProcesses();\n            List<Thread> encodingThreads = new ArrayList<Thread>();\n            encodingRunnables = new ArrayList<EncoderLauncherRunnable>(parallelProcesses);\n            for (int i = 0; i < parallelProcesses; i++) {\n                EncoderLauncherRunnable encoderLauncherRunnable = new EncoderLauncherRunnable(i, dialog, encoderFile);\n                Thread thread = new Thread(encoderLauncherRunnable);\n                encodingRunnables.add(encoderLauncherRunnable);\n                encodingThreads.add(thread);\n                thread.start();\n            }\n            for (Thread thread : encodingThreads) {\n                thread.join();\n            }\n            if (!isInterrupted()) MainWindowInterface.showMessage(Messages.getString(\"operations.file.encode.execute.done.title\"), Messages.getString(\"operations.file.encode.execute.done.message\").replace(\"${number}\", \"\" + filesModel.getSize()));\n        } catch (Exception e) {\n            LOG.error(\"Cannot encode files\", e);\n            MainWindowInterface.showError(e);\n        } finally {\n            if (encoderFile != null) encoderFile.delete();\n            dialog.setVisible(false);\n        }\n    }\n", "code2": "    private static File copyFileTo(File file, File directory) throws IOException {\n        File newFile = new File(directory, file.getName());\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(file);\n            fos = new FileOutputStream(newFile);\n            byte buff[] = new byte[1024];\n            int val;\n            while ((val = fis.read(buff)) > 0) fos.write(buff, 0, val);\n        } finally {\n            if (fis != null) fis.close();\n            if (fos != null) fos.close();\n        }\n        return newFile;\n    }\n", "label": 1, "substitutes": {"dialog": ["dialogue", "slbo", "challog", "dialOG", "winogs", "calogs", "challogue", "slog", "diffug", "Dialogue", "logogue", "Dialogs", "logog", "calogg", "collogue", "dialogg", "helbo", "helug", "DialOG", "dialug", "slogue", "slOG", "helog", "dialect", "Dialog", "slogs", " dialogs", "dialogs", "slug", "diffogue", "diffog", "calog", "collect", "helogue", "slect", "calogue", "winogue", "challogg", "logogg", " dialogue", "winect", "collogs", "dialbo", "challogs", "collog", "winog", "logogs", "diffbo", " dialOG"], "encoderFile": ["encodeSourceFile", "decodingModel", "engoderfile", "encoderDir", "encodedFiles", "encodingFolder", "encodeF", "enccodeF", "encoderSourceFile", "enodefile", "encodingSourceFile", "encodingModel", "decodingFiles", "decoderFiles", "EncoderDir", "Encoderfile", "decoderfile", "encodedF", "engoderFiles", "engoderFile", "enoderFiles", "EncoderFiles", "engoderSourceFile", "engodeFolder", "encodingFiles", "encaserfile", "encodingFile", "enccodefile", "engodeSourceFile", "encodeFolder", "encodedFile", "enoderF", "encodingfile", "enoderfile", "enodeFile", "enodeFiles", "encodefile", "encodeFiles", "encoderF", "engodefile", "engodeFile", "encodingDir", "encoderFiles", "encodedDir", "decodingFile", "encaserFile", "encaserFiles", "decodingfile", "EncodeFile", "encoderFolder", "Encodefile", "enccodeFile", "encodeModel", "engodeFiles", "EncodeFiles", "encaserModel", "engoderFolder", "decoderFile", "encodedfile", "enoderFile", "enccodeSourceFile", "encodedFolder", "enccodeFiles", "EncodeDir", "enodeF", "decoderModel", "EncoderFile", "encodeDir", "encoderfile", "encodeFile", "encoderModel"], "is": ["get", "nis", "id", "si", "isa", "ws", "fs", "http", "isl", "out", "in", "ais", "ms", "as", "isp", "was", "iss", "sis", "es", "serv", "ai", "info", "ris", "ir", "js", "ics", "has", "vs", "isi", "it", "ui", "s", "iris", "IS", "api", "mis", "abs", "ls", "ri", "il", "lis", "ios", "image", "ops", "isc", "its", "uri", "ori", "or", "us", "ar", "Is", "bis", "iso", "ps", "res", "ip", "ie"], "os": ["los", "ils", "oses", "ws", "io", "ons", "ais", "acs", "fs", "ns", "ros", "OS", "ms", "bos", "as", "oes", "bs", "ens", "es", "dos", "sys", "vs", "oss", "oos", "o", "aos", "ok", "ob", "cs", "ls", "Os", "ose", "ios", "ops", "ori", "socket", "or", "pos", "us", "cos", "boot", "ds", "obs", "osi", "iso", "ps", "s", "ot"], "totalSize": ["totalTime", "postTime", " totalLength", "TotalTime", "TotalSize", "postSize", "otalTime", "catTime", "currentSize", "otalSize", "totalsize", "postLength", "catSize", "currentsize", " totalWeight", "totalLength", " totalTime", "TotalLength", "currentTime", "totalWeight", "Totalsize", " totalsize", "otalLength", "postsize", "catsize", "currentLength", "TotalWeight", "otalWeight"], "i": ["console", "bi", "gi", "info", "name", "xi", "ri", "slice", "ori", "mini", "ip", "id", "phi", "io", "yi", "app", "b", "part", "zi", "I", "ni", "ti", "ai", "it", "ui", "ini", "all", "index", "ii", "pi", "start", "fi", "source", "si", "multi", "open", "hi", "in", "this", "f", "n", "exec", "e", "o", "eni", "_", "v", "j", "process", "s", "p", "ie", "qi", "iu", "y", "layer", "di", "mu", "inner", "ix", "ci", "m", "li", "uri", "Error", "z"], "l": ["dl", "lp", "nl", "ln", "la", "len", "lf", "ld", "ll", "limit", "ul", "lv", "L", "loc", "p", "lt", "n", "kl", "al", "el", "shell", "cl", "length", "fl", "lc", "li", "m", "ls", "ell", "il", "rl", "j", "c", "jl", "ol", "lin", "z", "pl", "sl"], "element": ["next", "source", "page", "folder", "reader", " structure", "token", "lement", "lements", "buffer", "flower", "actor", "letter", "article", "object", "environment", "layer", "number", "data", "resource", "email", "editor", "child", "el", "er", "component", "event", "e", "container", "instance", "image", "list", "file", "Element", "service", "array", "item", "et", "group", "entry", "month", "ele", "type"], "origFile": ["OrigFiles", "originFiles", "originDir", "Origfile", "origFiles", "originImage", " origfile", "OrigImage", " origDir", "originFile", "OrigDir", "origfile", "OrigFile", " origImage", "origImage", " origFiles", "originfile", "origDir"], "rangeModel": ["RangeModel", "RangeSize", " rangeManager", " rangeMin", "angeContainer", " rangeSize", "angeManager", "rangeBar", "rangeContainer", "rangeSize", "RangeManager", "angeModel", "angeMode", "angeSize", "angeMin", " rangeMode", "rangeManager", "RangeMode", "rangeMin", " rangeBar", "RangeContainer", "angeBar", "RangeMin", "rangeMode", "RangeBar", " rangeContainer"], "parallelProcesses": ["paranoRuns", "parallelThreade", "parallelRuns", "paranoRunions", "parallelThreads", "parallelprocesse", "parallelprocesses", "paranoProcessions", "parallelRunions", "parallelRunors", "parallelprocesss", "paranoRunors", "parallelprocessions", "paranoProcesses", "paranoProcessors", "parallelProcesse", "parallelProcesss", "parallelPasses", "paranoProcesss", "parallelThreades", "parallelThreadors", "parallelExecions", "parallelThreadions", "parallelPasse", "parallelPassions", "parallelExecors", "paranoRunes", "parallelRunes", "parallelProcessors", "parallelExeces", "parallelPasss", "parallelProcessions", "parallelExecs"], "encodingThreads": ["encodingPaths", "encoderThreades", "encodingLoges", "encodingPathes", "encodingThreades", "encoderProcessors", "encodingPathments", "encodingLogors", "encodingProcessments", "encodingThreadors", "encodingProcesses", "encodingProcessors", "encoderProcessments", "encodingLogments", "encodingThreadments", "encodingPathors", "encodingLogs", "encoderThreadments", "encoderProcesses", "encoderProcesss", "encoderThreads", "encodingProcesss", "encoderThreadors"], "encodingRunnables": ["encodingRunlators", "encodingThreadnable", "encodingRunnators", "encodingRunnable", "encodingRunpators", "encodingThreadcable", "encodingRunlables", "encodingRunlas", "encodingThreadcas", "encodingRunpables", "encodingRuncas", "encodingThreadnables", "encodingRunlable", "encodingThreadcables", "encodingRuncators", "encodingThreadnas", "encodingRuncables", "encodingThreadnators", "encodingThreadcators", "encodingRuncable", "encodingRunnas", "encodingRunpas", "encodingRunpable"]}}
{"id1": "7902699", "id2": "19332849", "code1": "    public static List<String> getLevelIndex(URL fetchUrl) {\n        List<String> levelNames = new ArrayList<String>();\n        BufferedReader bufferedreader;\n        try {\n            URLConnection urlconnection = fetchUrl.openConnection();\n            urlconnection.setConnectTimeout(30000);\n            if (urlconnection.getContentEncoding() != null) {\n                bufferedreader = new BufferedReader(new InputStreamReader(urlconnection.getInputStream(), urlconnection.getContentEncoding()));\n            } else {\n                bufferedreader = new BufferedReader(new InputStreamReader(urlconnection.getInputStream(), \"utf-8\"));\n            }\n        } catch (IOException _ex) {\n            System.err.println(\"HexTD::readFile:: Can't read from \" + fetchUrl);\n            return levelNames;\n        }\n        String sLine1;\n        try {\n            while ((sLine1 = bufferedreader.readLine()) != null) {\n                if (sLine1.trim().length() != 0) {\n                    levelNames.add(sLine1);\n                }\n            }\n        } catch (IOException ex) {\n            Logger.getLogger(MapLoaderClient.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return levelNames;\n    }\n", "code2": "    public String getResponse(String URLstring) {\n        String str = \"\";\n        try {\n            URL url = new URL(URLstring);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String st = \"\";\n            while ((st = in.readLine()) != null) {\n                str += \"\\n\" + st;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return str;\n    }\n", "label": 1, "substitutes": {"fetchUrl": ["bachUrl", "refetchUr", "faitURL", "FetchUrl", "fachUr", "refachUrl", "forkUrl", "fractURL", "betchUrl", "betchURL", "Fetchurl", "FetchFile", "fetchFile", "betchurl", "fachUrl", "fractUrl", "FetchURL", "fachURL", "refetchURL", "refetchurl", "faitUr", "refachUr", "forkurl", "faiturl", "bachURL", "fetchurl", "forkURL", "refachurl", "faitUrl", "fractFile", "refetchUrl", "bachurl", "betchUr", "bachUr", "fetchUr", "fetchURL", "fracturl", "forkUr", "faitFile", "fachurl", "refachURL"], "levelNames": [" levelFeatures", "levelWords", " levelMembers", "levelnames", " levelnames", " levelWords", "levelInfo", "indexNames", "entrynames", "indexWords", "logFiles", "LevelNames", "indexKeys", "lognames", "levelsNames", "listNames", "fileMembers", "levelsFeatures", " levelList", " levelNs", "levelFiles", " levelKeys", "levelsTags", "entryNames", "LevelList", "LevelNs", "levelKeys", " levelFiles", "fileWords", "logStars", "lineNames", "levelList", "levelFeatures", " levelStars", "levelNs", "indexMembers", "levelsnames", "listList", "LevelInfo", " levelInfo", "levelMembers", "listInfo", "levelTags", "logNames", "levelStars", "entryTags", "lineFiles", " levelTags", "linenames", "entryFeatures", "listNs", "lineStars", "fileNames", "fileKeys"], "bufferedreader": ["Buffereder", "buffendedwriter", " buffererreader", " buffererReader", " buffenedstream", "buffererstream", "Buffenedreader", " buffenedwriter", "bufferingreader", "bufforedreader", "bufferredauthor", " bufferedstream", "buffendedReader", "Bufferedstream", "BufferedReader", "buffererReader", "buffenedauthor", " buffererwriter", "bufferredreader", "buffredReader", "bufferingReader", "buffleder", "buffenedwriter", "buffendedreader", "bufferedauthor", "bufferingwriter", "Buffenedwriter", "buffenedstream", "buffeneder", "buffendeder", "bufferredwriter", "bufferedstream", " buffererauthor", " bufferedReader", "Buffeneder", "buffenedreader", "bufferedwriter", "buffererauthor", "Buffenedstream", "bufferredReader", "buffredwriter", "buffledreader", "buffledwriter", " bufferedauthor", "buffredreader", "buffererreader", "Bufferedreader", "buffererwriter", " buffenedReader", " bufferedwriter", "buffenedReader", "buffledReader", "bufforedstream", "bufforedwriter", "BuffenedReader", " buffenedreader", "Bufferedwriter", "buffredstream", "buffereder", "bufferingstream", "bufforedReader", "bufferedReader"], "urlconnection": ["urlservice", "httpcommunication", "httpcontext", "urlconfig", "urlcontext", "lConnection", "webconn", "webconnect", "URLconn", "urlconnect", "httpConnection", "llconfig", "urlcommunication", "collconnection", " urlcontext", "URLConnection", "lconnection", " urlservice", "httpconfig", " urlconfig", "collConnection", " urlConnection", "webConnection", " urlconnect", "httpconnection", "lconnect", "httpconn", " urlconn", "httpconnect", "urlConnection", "llconnect", "collconnect", "URLconnection", "urlconn", "llConnection", "URLcommunication", "webcommunication", "elcontext", "URLservice", "collconfig", "lservice", "webconnection", "lconn", "elconn", "webconfig", "elconnection", "llconnection", "elconnect"], "sLine1": ["sL2", "sBlock2", "pLine6", "sLine2", " sBlock1", "sline1", "sBlock0", "sBlockOne", "sUnit1", "sLWeb", " sLU", " sBlockOne", "sLineWeb", "pLin6", " sLineOnce", " sLOne", "sline2", "sByte6", "pLine1", "sPass1", "sLookOne", "sBlock1", "sLin1", "pLin1", "sLineOnce", "sBlockOnce", "sL1", " sL2", "slineWeb", "sLin6", "sL0", " sLine0", "sLookOnce", "sLinOne", " sL1", " sBlockOnce", "sPassOne", "sUnitOne", "sUnit6", "sLook0", "sLU", "sLineU", "sByte0", "sLine0", "sLin2", "sByteOnce", " sLine2", " sBlock0", "sline0", "sByte1", "sByteOne", "sLineOne", " sLineU", "sPass2", "sPassU", "sBlockWeb", "sLine6", " sLineOne", "sLinU", "pLineOne", "pLinOne", "sLook1", "sLOne"]}}
{"id1": "20409303", "id2": "5810755", "code1": "    private String md5(String input) {\n        MessageDigest md5Digest;\n        try {\n            md5Digest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new UserException(\"could not get a md5 message digest\", e);\n        }\n        md5Digest.update(input.getBytes());\n        return new String(md5Digest.digest());\n    }\n", "code2": "    @Override\n    public Response callService(RemoteCallUrl urlModel) throws RemoteCallFailedException {\n        String path;\n        if (urlModel.getRootPath() != null) path = urlModel.getRootPath() + urlModel.getServicePath(); else path = urlModel.getServicePath();\n        try {\n            URL url = new URL(HTTP_PROTOCOL, urlModel.getHost(), urlModel.getPort(), path);\n            URLConnection urlConnection = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            String data = \"\";\n            while ((inputLine = in.readLine()) != null) data += inputLine;\n            Response remoteData = new Response(new String(data));\n            remoteData.setStatus(urlConnection.getHeaderField(Response.RPC_STATUS_NAME));\n            in.close();\n            return remoteData;\n        } catch (MalformedURLException e) {\n            logger.error(\"Illegal URL. Cannot connect to this remote object\", e);\n            throw new RemoteCallFailedException(\"Illegal URL:\" + e.getMessage(), e);\n        } catch (IOException e) {\n            logger.error(\"Cannot read from source. Please check remote object address\", e);\n            throw new RemoteCallFailedException(\"Fatal transport error:\" + e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"input": ["source", "plus", "reader", "operator", "binary", "connection", "buffer", "xml", "message", "output", "audio", "format", "alpha", "out", "this", "in", "request", "client", "inf", "base", "data", "hex", "class", "resource", "address", "config", "Input", "method", "s", "pattern", "password", "text", "content", "temp", "string", "image", "file", "context", "i", "ssl", "addin", "form", "str", " Input", "type"], "md5Digest": ["md5Signest", "md5Sequester", "md5Sequener", "md5SandEST", "md3Digeter", "md3Digested", "md5Signse", "md2digener", "md5Signests", "md3Digest", "md5Digested", "md2digist", "md2digEST", "md2Digest", "md5Signester", "md5digist", "md5Sandested", "md2DigEST", "md5Pse", "md3digested", "md2digests", "md5Pests", "md2Digener", "md5Codester", "md2Digist", "md5digener", "md5Codener", "md5Digeter", "md5DEST", "md5digester", "md5Sequest", "md5Pest", "md2Digse", "md5digests", "md5digest", "md2digested", "md5DigEST", "md2Digester", "md5Digist", "md5diger", "md5digEST", "md3digest", "md5Digests", "md5Digester", "md5Digener", "md3diger", "md5digse", "md5Dest", "md2digse", "md5Signeter", "md2Digested", "md5Codist", "md2Digests", "md5Diger", "md2digest", "md5digeter", "md5Sandester", "md5digested", "md5Codest", "md5Digse", "md3digeter", "md5Signested", "md3Diger", "md5Pester", "md2digester", "md5Signer", "md5Dested", "md5Sequist", "md5Sandest", "md5Dester"]}}
{"id1": "12269678", "id2": "19246986", "code1": "    private void copyResource(String relResourceName) {\n        String projectName = layout.getRootDir().getName();\n        String resourceName = \"/protoj/\" + projectName + \"/\" + relResourceName;\n        InputStream source = getClass().getResourceAsStream(resourceName);\n        if (source == null) {\n            throw new RuntimeException(\"couldn't find resource \" + resourceName);\n        }\n        File dest = new File(layout.getRootDir(), relResourceName);\n        dest.getParentFile().mkdirs();\n        dest.createNewFile();\n        InputStreamReader in = new InputStreamReader(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                IOUtils.closeQuietly(out);\n            }\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    private List<String> readDescriptor(URL url) {\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            List<String> lines = new ArrayList<String>();\n            String line = reader.readLine();\n            while (line != null) {\n                line = line.trim();\n                if (line.length() > 0 && !line.startsWith(\"#\")) lines.add(line);\n                line = reader.readLine();\n            }\n            return lines;\n        } catch (IOException e) {\n            throw new ExtensionException(\"Failed to read extension descriptor '%s'\", e).withArgs(url);\n        } finally {\n            IoUtil.closeQuietly(reader);\n        }\n    }\n", "label": 0, "substitutes": {"relResourceName": ["relresourceCode", " relResourcePart", "relResourcePath", "relReferencename", "relFilePath", "relresourceKey", "localResourceNames", "relResourceNames", "relativeResourceName", "localresourceNames", "localResourcename", "relModuleKey", "localResourceFile", "relModuleNames", "relFolderPath", "relResourceKey", "relFileCode", "relresourcePath", "relativeFileName", "relResourcePart", "relModuleFile", "relFileFile", "relFolderName", "relativeResourceCode", "relresourceName", "relativeFileKey", "relModuleCode", " relFileFile", "relresourceNames", "relResourceFile", "relResourceCode", " relResourcePath", "relFolderFile", " relResourceFile", "relResourcename", "relFileName", "localresourceFile", "relresourcePart", " relFilePart", "relModuleName", "relFileKey", "localresourcename", "relReferenceNames", "relativeResourcePath", "localResourceName", "relFolderPart", " relFileName", " relFilePath", "relReferenceName", "relresourceFile", "relativeFileCode", "relModulename", "relresourcename", "relModulePath", "relReferenceFile", "relFilePart", "localresourceName", "relativeFilePath", "relativeResourceKey"], "projectName": [" projectUrl", "ProjectName", "ProjectPath", "ProjectUrl", "packagePath", "Projectname", "packagename", "projectUrl", "resourcename", " projectDir", "projectPath", "ProjectDir", "projectname", "resourceUrl", "projectDir", " projectPath", "packageDir", " projectname", "packageName", "resourcePath"], "resourceName": ["referencename", "ResourceUrl", " resourceUrl", "referencePath", "fileUrl", "rPath", "fileType", "fileName", "ResourceName", "referenceType", " resourceType", "resourcename", " resourcePath", "rUrl", "rName", "rname", "resourceUrl", "Resourcename", "resourceType", "filePath", "ResourcePath", "ResourceType", " resourcename", "resourcePath", "referenceName"], "source": ["via", "get", "parent", "plus", "reader", "url", "input", "connection", "iter", "result", "io", "src", "l", "from", "view", "inf", "Source", "sf", "object", "client", "f", "channel", "stream", "storage", "resource", "inner", "ources", "use", "it", "target", "sr", "ource", "se", "sin", "status", "slice", "SOURCE", "image", "seed", "sp", "load", "parse", "uri", "i", "file", "inside", "service", "start", "form", "proxy", "sl"], "dest": ["folder", "parent", "tmp", "dc", "later", "proc", "export", "default", "d", "txt", "trans", "result", "output", "flat", "outer", "src", "cdn", "home", " destination", "toc", "delete", "loc", "prop", "di", "class", "style", "resource", "slave", " Dest", "sup", "name", "desc", "dir", "target", "de", "transform", "Dest", "temp", "done", "path", "file", "comb", "wb", "dist", "destroy", "project", "test", "exit", "null", "rest"], "in": ["plus", "reader", "id", "url", "input", "inc", "win", "connection", "io", "nin", "src", "conn", "con", "this", "login", "as", "data", "In", "again", "n", "r", "resource", "inner", "x", "init", "ins", "e", "a", "m", "kin", "up", "sin", "c", "i", "IN", "inside", "err", "inn", "is", "lin", "bin", "on", "qa", "null", "p"], "out": ["page", "inc", "user", "connection", "io", "output", "outer", "conn", "b", "client", "this", "ou", "data", "to", "In", "OUT", "Out", "class", "outs", "resource", "again", "serv", "writer", "inner", "exec", "sync", "null", "init", "o", "target", "exp", "gin", "a", "ex", "copy", "up", "path", "file", "i", "err", "IN", "outside", "bin", "project", "s", "line", "ext"]}}
{"id1": "15861394", "id2": "9793984", "code1": "    public static String md5(String string) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException exception) {\n            LOGGER.warn(exception.getMessage());\n        }\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(string.getBytes(\"iso-8859-1\"), 0, string.length());\n        } catch (UnsupportedEncodingException exception) {\n            LOGGER.warn(exception.getMessage());\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void setChecksum() {\n        try {\n            java.security.MessageDigest md5 = java.security.MessageDigest.getInstance(\"MD5\");\n            String fqn = this.path + this.name;\n            md5.update(fqn.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & BYTE_CLEANER_FF;\n                if (b < BYTE_CLEANER_10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            this.checksum = sb.toString();\n        } catch (java.security.NoSuchAlgorithmException nsae) {\n            this.checksum = this.path + this.name;\n        }\n    }\n", "label": 1, "substitutes": {"string": ["source", "str", "strings", "input", "binary", "connection", "buffer", "space", "result", "function", "message", "format", "letter", "object", "in", "this", "number", "data", "version", "class", "single", "setting", "ident", "address", "sequence", "section", "word", "name", "filename", "ring", "s", "password", "text", "content", "slice", "document", "file", "uri", "parse", "expression", "array", "service", "database", "value", "null", "duration", "type"], "md": ["cb", "hash", "cd", "bf", "d", "mb", "cm", "dd", "ld", "hd", "sm", "mm", "ma", "mem", "pd", " MD", "wd", "am", "pg", "cmd", "ms", "mode", "po", "mo", "mac", "bd", "hm", "mand", "mag", "meta", "mc", "sha", "mp", "dm", "mod", "MD", "mt", "m", "od", "gb", "pm", "docker", "mg", "mage", "grad", "metadata", "nd", "amd", "nm", "dig", "amp", "ad", "pkg"], "md5hash": ["md512Hash", "md6header", "md5header", "md5sum", " md6sum", "md75copy", "md6hash", "md005hash", "md75hash", "md005sum", "md6sum", "mdhedkey", "md2sum", " md5byte", "md2hash", "mddownHash", " md512hash", "md5key", "md6copy", " md5sum", "mdblocksum", "md2Hash", "mddownhash", "md005header", "mddownsum", "md512sum", "md6byte", "md005byte", " md6byte", "md5copy", " md5key", " md5header", " md6hash", "md512hash", " md512Hash", " md6header", "md6key", " md5Hash", "mdblockbyte", " md6copy", "md75key", " md512sum", "md5byte", "mdhedhash", " md6key", "mdblockhash", "mdblockheader", " md5copy", "md5Hash", "mdhedcopy"]}}
{"id1": "7993946", "id2": "8496070", "code1": "    public void unsplit(String newFilename, File[] files) throws Exception {\n        FileOutputStream stream = new FileOutputStream(new File(newFilename));\n        for (int i = 0; i < files.length; i++) {\n            FileInputStream fin = new FileInputStream(files[i].getAbsolutePath());\n            DataInputStream din = new DataInputStream(fin);\n            while (din.available() > 0) {\n                stream.write(din.read());\n            }\n            din.close();\n            fin.close();\n        }\n        stream.close();\n    }\n", "code2": "    private void removeSessionId(InputStream inputStream, Output output) throws IOException {\n        String jsessionid = RewriteUtils.getSessionId(target);\n        boolean textContentType = ResourceUtils.isTextContentType(httpClientResponse.getHeader(\"Content-Type\"));\n        if (jsessionid == null || !textContentType) {\n            IOUtils.copy(inputStream, output.getOutputStream());\n        } else {\n            String charset = httpClientResponse.getContentCharset();\n            if (charset == null) {\n                charset = \"ISO-8859-1\";\n            }\n            String content = IOUtils.toString(inputStream, charset);\n            content = removeSessionId(jsessionid, content);\n            if (output.getHeader(\"Content-length\") != null) {\n                output.setHeader(\"Content-length\", Integer.toString(content.length()));\n            }\n            OutputStream outputStream = output.getOutputStream();\n            IOUtils.write(content, outputStream, charset);\n        }\n        inputStream.close();\n    }\n", "label": 1, "substitutes": {"newFilename": ["newSourceFile", "newfilename", " newFile", "Newfilename", "NewFile", "newFile", "oldfilename", "oldFilename", "oldSourceFile", " newSourceFile", "NewSourceFile", " newfilename", "oldFile", "NewFilename"], "files": ["balls", "Files", "classes", "resources", "cells", "opens", "strings", "tests", "links", "lines", "keys", "fs", "items", "pins", "books", "sheets", "f", "blocks", "scenes", "loaded", "bs", "objects", "flows", "models", "children", "stars", "filename", "users", "boxes", "plugins", "full", "results", "ins", "images", "pages", "names", "ls", "fits", "path", "thumbnails", "features", "file", "iles", "projects", "ids", "assets", "fil"], "stream": ["source", "reader", "draft", "input", "sem", "write", "upload", "feed", "Stream", "result", "pipe", "io", "output", "view", "w", "http", "out", "this", "in", "driver", "client", "fd", "f", "channel", "data", "zip", "enc", "clean", "usher", "server", "zen", "handler", "writer", "sync", "php", "per", "log", "keep", "transform", "temp", "path", "socket", "file", "ssl", "context", "raf", "self", "form", "stack", "coll", "standard"], "i": ["id", "si", "multi", "abi", "qi", "iu", "hi", "io", "phi", "in", "b", "f", "di", "bi", "zi", "n", "I", "mu", "ni", "ti", "oi", "ai", "gi", "inner", "ji", "x", "ix", "ui", "ci", "u", "o", "eni", "ini", "li", "v", "xi", "ri", "index", "j", "ori", "uri", "ii", "pi", "fi", "mi", "uni", "ip", "p", "ie"], "fin": ["bas", "tin", "rf", "ln", "Fin", "fine", "conn", "fs", "in", "fd", "fr", "f", "data", "pin", "di", "thin", "ris", "fat", "inner", "oin", "skin", "den", "init", "pid", "vin", "FIN", "fn", "ini", "ino", "sin", "kin", "ri", "done", "cin", "ori", "file", "flo", "raf", "fb", "inn", "fen", "front", "rin", "lin", "fi", "bin", "inv", "fa"], "din": ["tin", "su", "reader", "die", "uni", "uin", "nin", "udi", "in", "pin", "di", "bi", "thin", "pal", "ni", "gi", "inner", "oin", "den", "unin", "pid", "da", "ani", "vin", "zin", "eni", "gin", "ini", "fan", "ino", "sin", "kin", "ri", "dy", "done", "cin", "raf", "inn", "fen", "rin", "lin", "bin", "dra", "mini"]}}
{"id1": "1789990", "id2": "20389366", "code1": "    public String getHash(final String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash;\n        digest.update(password.getBytes(\"utf-8\"), 0, password.length());\n        md5hash = digest.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String getMD5EncodedString(String strIn) {\n        try {\n            java.security.MessageDigest md5 = java.security.MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(strIn.getBytes());\n            byte[] digest = md5.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (byte aDigest : digest) {\n                hexString.append(Integer.toHexString(0xFF & aDigest));\n            }\n            return hexString.toString();\n        } catch (java.security.NoSuchAlgorithmException n) {\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"password": [" Password", "hash", "input", "token", "auth", "buffer", "sword", "username", "message", "python", "wd", "PASS", "description", "number", "data", "phrase", "hex", "resource", "prefix", "address", "word", "null", " passwords", "pattern", "paste", "text", "words", "key", "path", "seed", "encrypted", "secret", "database", "Password", "crypt", "wallet", "value", "padding", "p", "pass"], "digest": ["Diger", "mdester", "signests", "digester", "mdusher", "digests", "signester", "DigEST", "mdest", "Digher", "diger", "signEST", " digusher", "mdher", "generest", "digusher", "digEST", "Digester", " digEST", "generests", "mder", " digher", "generester", "digher", " digester", "signest", "generEST", "Digusher", " diger", "Digests", "Digest", "mdEST"], "md5hash": ["MD6address", "mdokHash", "MD5sum", "md4sum", "MD5hash", " md4sum", "md4url", "mdoksum", "md5sum", "md8hash", "md4hash", "md6hash", "md6array", "md6address", "md6sum", "mdokurl", "md2sum", "md2hash", "md8Hash", " md5url", "md5url", " md5sum", "md8array", "MD5Hash", "md4array", "md2Hash", " md4url", "md4address", "md8address", " md4hash", "md6url", "MD6sum", "md6Hash", "MD5array", "MD6array", " md5Hash", "md5address", "md5array", "MD6hash", "MD5address", " md4Hash", "MD6Hash", "md5Hash", "mdokhash", "md4Hash"]}}
{"id1": "2897046", "id2": "2021569", "code1": "    public boolean execute_check() {\n        FTPClient ftp = new FTPClient();\n        File filename = null;\n        FileChannel channel;\n        InputStream is;\n        OutputStream os;\n        int reply;\n        if (super.verbose > 0) verbose = true;\n        ftp.setDefaultPort(port);\n        ftp.setDefaultTimeout(timeout);\n        if (verbose) {\n            System.out.println(\"Using FTP Server: \" + hostname);\n            System.out.println(\"Using FTP Port: \" + port);\n            System.out.println(\"Using Timeout of: \" + timeout);\n        }\n        if (passive) {\n            ftp.enterLocalPassiveMode();\n            if (verbose) System.out.println(\"Using Passive Mode\");\n        }\n        try {\n            filename = new File(file);\n            channel = new RandomAccessFile(filename, \"rw\").getChannel();\n            if (verbose) System.out.println(\"Attempting FTP Connection to \" + hostname);\n            ftp.connect(hostname);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                if (verbose) System.out.println(\"FTP Connection to \" + hostname + \" failed\");\n                check_state = common_h.STATE_CRITICAL;\n                check_message = ftp.getReplyString();\n                filename.delete();\n                ftp.disconnect();\n                return true;\n            }\n            if (username != null && password != null) {\n                if (verbose) System.out.println(\"Attempting to log in into FTP Server \" + hostname);\n                if (!ftp.login(username, password)) {\n                    if (verbose) System.out.println(\"Unable to log in to FTP Server \" + hostname);\n                    check_state = common_h.STATE_CRITICAL;\n                    check_message = ftp.getReplyString();\n                    ftp.disconnect();\n                    filename.delete();\n                    return true;\n                }\n            }\n            if (verbose) System.out.println(\"Attempting to change to required directory\");\n            if (!ftp.changeWorkingDirectory(directory)) {\n                if (verbose) System.out.println(\"Required directory cannot be found!\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            if (verbose) System.out.println(\"Attempting to retrieve specified file!\");\n            is = ftp.retrieveFileStream(file);\n            if (is == null) {\n                if (verbose) System.out.println(\"Unable to locate required file.\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            os = Channels.newOutputStream(channel);\n            byte[] buf = new byte[4096];\n            if (verbose) System.out.println(\"Beginning File transfer...\");\n            for (int len = -1; (len = is.read(buf)) != -1; ) os.write(buf, 0, len);\n            if (verbose) {\n                System.out.println(\"...transfer complete.\");\n                System.out.println(\"Attempting to finalise Command\");\n            }\n            if (!ftp.completePendingCommand()) {\n                if (verbose) System.out.println(\"Unable to finalise command\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            if (verbose) System.out.println(\"Check Completed.\");\n            check_state = common_h.STATE_OK;\n            check_message = ftp.getReplyString();\n            is.close();\n            os.close();\n            channel.close();\n            filename.delete();\n        } catch (IOException e) {\n            check_state = common_h.STATE_CRITICAL;\n            check_message = e.getMessage();\n            if (filename != null) filename.delete();\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (Exception e) {\n                }\n            }\n        }\n        return true;\n    }\n", "code2": "    public boolean getFile(String local, String remote) throws IOException {\n        boolean result = false;\n        GridFTP ftp = new GridFTP();\n        ftp.setDefaultPort(port);\n        System.out.println(this + \".getFile \" + remote);\n        try {\n            ftp.connect(host);\n            ftp.login(username, password);\n            int reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                System.err.println(\"FTP server refused connection.\");\n                return false;\n            }\n            ftp.get(local, remote);\n            ftp.logout();\n            result = true;\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        System.out.println(this + \".getFile return \" + result);\n        return result;\n    }\n", "label": 1, "substitutes": {"ftp": ["ufuser", " ftplug", "aftpc", "cfw", "xfb", "rtsp", "webtp", "rtpc", " fttp", "fc", " ftw", "xfp", " ftpc", " ftcp", "afi", "ctw", "ctpc", "ctcp", "uftp", " ftsp", "lfp", "FTplug", "aftm", "afc", "fb", "ctp", " ftc", "lfpi", "cfcp", "fdc", "aftcp", " ftP", "fspc", "xfc", " fti", "cftp", "ctpb", "ftm", "ctP", "fsm", "ftpre", "rtm", "ufpre", "ftjp", "webpart", "lfc", "aftpb", " ftpart", "fttp", "ftl", "webp", "fdp", "ftplug", "webjp", "ufp", "cfuser", "ctb", "fP", "ufpc", "fdcp", "fi", "ctpre", "aftp", "ctport", "xfplug", "ftuser", "aftjp", "rtp", "cttp", "aftsp", "FTc", "fp", "ufport", "ftw", "FTb", "afp", "ftpart", "ufcp", "afl", "fti", "ftc", "ftpb", "ftP", "lftp", "fdl", "fsp", " ftuser", "ftport", "cfp", "ftpc", "aftpart", "ftsp", " ftpi", " ftb", "cfpc", "fpi", "ftcp", "fcp", "fstp", "ftb", "fdpc", " ftm", "ftpi", "ufpb", "afcp", "fl", "aftpre", "FTp", " ftjp", "fdport", "afttp"], "filename": ["source", "via", "folder", "journal", "url", "processor", "queue", "binary", "txt", "memory", "SourceFile", "connection", "download", "jet", "fax", "dll", "username", "message", "output", "audio", "l", "fp", "sf", "fd", "f", "loader", "application", "directory", "phrase", "profile", "resource", "Filename", "prefix", "archive", "config", "ppa", "name", "tp", "password", "fn", "json", "picture", "session", "slice", "string", "il", "document", "socket", "ssl", "file", "uri", "lua", "files", "manager", "database", "sudo", "FILE", "metadata", "nil", "location", "fil"], "channel": ["source", "page", "url", "queue", "connection", "buffer", "username", "chan", "io", "message", "conn", "Channel", "client", "out", "directory", "stream", "resource", "handler", "server", "slave", "config", "writer", "can", "name", "transfer", "target", "password", "log", "ch", "session", "path", "pool", "socket", "file", "command", "self", "entry"], "is": ["id", "rx", "abi", "ais", "fs", "was", "isu", "irc", "ai", "ir", "iv", "isi", "it", "ins", "ci", "tis", "IS", "ri", "il", "image", "ios", "uri", "iii", "ii", "bis", "Is", "ip", "ib"], "os": ["options", "oper", " o", "ws", "io", "ou", "root", "OS", "outs", "oss", "res", "o", "aos", "ok", "log", "flush", "Os", "O", "ios", "ops", "obj", "or", "pos", "opt", "et", " bos", "op"], "reply": ["next", "respond", "continue", "notice", "queue", "link", "write", "msg", " replies", "connection", "buffer", "result", "message", "request", "mode", "ply", "ise", "enable", "response", "repl", "ret", "address", "info", "send", "Reply", "sync", "transfer", "force", "query", "ix", "rc", "report", "flush", "length", "comment", "status", "back", "ping", "dy", "install", "lock", "answer", "delay", "replace", "code", "callback", "resp", "error", "err", "attribute", "wait", "service", "i", "rr", "reason"], "verbose": ["verbore", "mutosed", "combosity", "quosed", "prettyose", "fosity", "combose", "buffosity", "logisy", " verbressed", "logosed", "verbressed", "verbsade", "logoise", "comblier", "logore", "labote", " verbote", "verbitive", "mutosity", "logout", "buffout", "silose", "verbosity", "silative", "fOSE", "verbade", "verbsosed", "prettyressive", "logosity", " verbisy", "vvote", "verbressive", "logose", "labOSE", "verbOSE", "mutout", "verbative", "labosity", "labose", " verbosed", "fose", "quose", "buffoise", "vvose", "vvisy", "logressive", "buffressive", "laboise", "prettyosity", "labressed", "verblier", "logade", "verbout", "buffosed", "querosity", "buffote", "verbisy", "logressed", " verbative", "loglier", "verbsose", "logOSE", "verbote", "silitive", "verbosed", "querose", "quore", "verboise", "quade", " verbitive", "silosity", "buffOSE", "verbsore", "prettyote", "logitive", "logative", "mutose", " verbOSE", " verbout", "buffose", "querlier", "fote", " verbosity", "logote", "vvosity"], "check_state": ["info64state", "check_source", "check64manager", "checkvalmedia", "check_cause", "block_media", "info64source", "check_manager", "info_source", "checkpremanager", "info64manager", "checkvalState", "blockxstate", "checkprestate", "check64source", "info64output", "check64output", "blockxcause", "checkpresource", "checkxstate", "checkxcause", "checkpreoutput", "block_cause", "check_output", "check64state", "block_state", "checkxState", "info_output", "check_media", "check_State", "checkxmedia", "checkvalcause", "info_state", "info_manager", "blockxState", "blockxmedia", "checkvalstate", "block_State"], "check_message": ["comment_message", "comment64member", "block_code", "block___code", "comment_mail", "block___output", "comment_address", "comment64mail", "block_language", "check_address", "check___output", "block_message", "check64language", "check___language", "block___language", "check_member", "checkJoutput", "check64output", "check64mail", "block___message", "block_output", "checkJmessage", "comment_member", "check64member", "check_output", "check___code", "checkJlanguage", "check_code", "checkJcode", "check___message", "check_mail", "check64code", "check64address", "check64message", "comment64address", "comment64message", "check_language"]}}
{"id1": "8731413", "id2": "14067271", "code1": "    public ImportFromFile() {\n        JFrame jf = new JFrame();\n        JFileChooser fc = new JFileChooser(KTH.data._path);\n        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        int returnVal = fc.showOpenDialog(jf);\n        File file = null;\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            file = fc.getSelectedFile();\n            KTH.data._path = file.getParent();\n            System.out.println(file.getAbsolutePath() + \"\\n\");\n        } else {\n        }\n        if (file != null) {\n            File f = new File(KTH.data.getHomeDir() + File.separator + KTH.data.katalogName);\n            System.out.println(f + (f.exists() ? \" is found \" : \" is missing \"));\n            if (f.exists() && !IOUtils.isNewerContent(file, f)) {\n            } else {\n                try {\n                    IOUtils.copyFile(file, f, true);\n                } catch (Exception e) {\n                    KTH.out.err(e);\n                }\n            }\n            KTH.dc2.removeDc(\"Import\");\n        } else {\n        }\n    }\n", "code2": "    private static void addFolderToZip(File folder, ZipOutputStream zip, String baseName) throws IOException {\n        File[] files = folder.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n                addFolderToZip(file, zip, baseName);\n            } else {\n                String name = file.getAbsolutePath().substring(baseName.length());\n                ZipEntry zipEntry = new ZipEntry(name);\n                zip.putNextEntry(zipEntry);\n                IOUtils.copy(new FileInputStream(file), zip);\n                zip.closeEntry();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"jf": ["bf", "jfd", " jfs", "jjfd", "ojfd", "bc", "jrf", "jfile", "jjcf", "ojf", "bfile", "gf", "Jf", "ojfs", "gc", "gfile", "jcf", "jjf", "jfs", "ojcf", "Jrf", "jc", "grf", "Jfile", " jfd", " jcf", "jjfs", "Jc", "brf"], "fc": ["xf", "af", "dc", "rf", "bf", "uc", "lf", "cf", "vc", "fs", "con", " FC", "fp", "sf", "fd", "bc", "fr", "cv", "wic", "fe", "ec", "ctrl", "fw", "circ", "xc", "enc", "mc", "pc", "FC", "GF", "cl", "fn", "fl", "lc", "jc", "abc", "il", "CF", "c", "flo", "fb", "fm", "cc", "fi", "ct", "nc", "fa", "fx"], "returnVal": ["resultval", " returnValue", " returnval", "ReturnNum", "returnValue", "returnval", "returnNum", " returnNum", "ReturnVal", "ReturnValue", "resultValue", " returnTx", "openTx", "resultNum", "Returnval", "openVal", "openval", "ReturnTx", "openValue", "resultVal", "returnTx"], "file": ["cf", "l", "sf", "model", "directory", "resource", "info", "name", "log", "cl", " files", "le", "image", "files", "fa", "line", "folder", "bf", "place", "feed", "lf", "lib", "object", "b", "po", "future", "handler", "child", "it", "F", "found", "il", "pool", "cache", "c", "live", "local", "FILE", "self", "fi", "source", "page", "parent", "url", "pe", "function", "fo", "http", "fp", "base", "work", "el", "x", "filename", "full", "e", "o", "path", "null", "p", "h", "ile", "File", "letter", "fr", "fe", "where", "dir", "document", " File", "db", "form", "unit"], "KTH": ["NKTH", " KATH", "KITT", "JETH", " KAST", "KOTH", "JTH", "HKCOM", " KTh", " KCOM", " Kth", "KSTh", "SKCH", "KINGth", " KETH", "kATH", "KINGTH", "KTh", "kAST", "KSth", "KINGITT", "SKATH", " KITT", "HKITT", "KETH", "SKETH", " KOTH", " KTD", "KSOTH", "ELCOM", "HKTH", "AKth", "NKTD", "OKTh", "KCOM", "kTH", "SKAST", " KTHER", "SKTH", "SKTHER", "ELTH", "KATH", "AKETH", "NKth", "KTD", "AKTH", "KTHER", "Kth", "HKth", "OKTH", "OKth", "KAST", "NKETH", "Jth", "AKTD", "HKTh", "ELTh", "ELth", "kTHER", "KINGTh", "KCH", "KSTH", " KCH", "OKOTH", "JCH", "SKth"], "data": ["language", "resources", "div", "parent", "next", "reader", "site", "general", "default", "input", "memory", "user", "layout", "admin", "output", "join", "this", "state", "root", "model", "base", "loader", "di", "storage", "system", "style", "resource", "server", "config", "info", "writer", "module", "body", "DATA", "management", "da", "results", "json", "api", "internal", "media", "cache", "apps", "service", "database", "group", "design", "dat"], "_path": ["_dir", " _dir", " _cat", " _location", "_Path", "_location", " _Path", " _name", "_cat", "_name"], "f": ["af", "folder", "h", "rf", "url", "d", "feed", "cf", "function", "File", "fo", "l", "fs", "w", "foo", "fp", "b", "sf", "fd", "fr", "base", "fe", "n", "x", "fun", "name", "filename", "dir", "u", "e", "o", "flow", "fn", "t", "F", "found", "m", "df", "fold", "v", "fl", "path", "j", "c", "i", "fb", "g", "fen", "s", "fa", "p", "fx"]}}
{"id1": "12764800", "id2": "272355", "code1": "    public static void extractZipFile(String filename) {\n        try {\n            byte[] buf = new byte[1024];\n            ZipInputStream zipinputstream = null;\n            ZipEntry zipentry;\n            zipinputstream = new ZipInputStream(new FileInputStream(filename));\n            zipentry = zipinputstream.getNextEntry();\n            while (zipentry != null) {\n                String entryName = zipentry.getName();\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(entryName);\n                String directory = newFile.getParent();\n                if (directory == null) {\n                    if (newFile.isDirectory()) break;\n                }\n                fileoutputstream = new FileOutputStream(entryName);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n                zipentry = zipinputstream.getNextEntry();\n            }\n            zipinputstream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"filename": ["source", "utf", "folder", "journal", "url", "queue", "binary", "txt", "SourceFile", "connection", "jet", "dll", "username", "File", "l", "fp", "sf", "fd", "f", "loader", "data", "zip", "Filename", "archive", "prefix", "kl", "name", "json", "fn", "length", "string", "path", "document", "lock", "file", "uri", "that", "files", "database", "FILE", "which", "sheet", "nil", "s", "location", "fil"], "buf": ["cb", "bf", "la", "bh", "binary", "uc", "buffer", "buff", "br", "Buffer", "lim", "src", "que", "fp", "b", "aux", "alloc", "fd", "bc", "cmd", "loc", "cv", "data", "bd", "blocks", "bytes", "ctx", "Buff", "func", "batch", "rc", "seq", "uf", "bag", "gb", "uv", "vec", "wb", "fb", "bus", "conv", "img", "lb", "rb", "bp"], "zipinputstream": ["archiveInputport", "zipfeedstream", "fileinputStream", "zipinputsample", "fileinputsystem", "archiveinputStream", "zipInputsession", "zipinputStream", "zipInputsample", "archiveinputsample", "zinputsc", "archiveinputstream", "zipbitthread", "fileinputsession", "zipinputport", "zinputStream", "fileoutputsample", "archiveInputstream", "fileoutputchannel", "zInputstream", "zipbitstream", "fileinputsample", "archiveInputStream", "zinputstream", "zipuploadstream", "zipoutputsample", "zipfeedchannel", "zInputsc", "zipinputchannel", "fileinputchannel", "fileInputstream", "zipoutputchannel", "archiveinputport", "zipcontextstream", "zipInputsystem", "zipcontextsystem", "archiveInputsample", "zipoutputsc", "zipinputsystem", "zipimportsc", "zipuploadsession", "fileInputsystem", "fileinputstream", "zipoutputport", "zipinputthread", "fileInputStream", "zipexecsample", "zipinputsc", "zipbitStream", "zipInputsc", "zInputthread", "zipexecStream", "zipimportport", "zipimportsample", "zipuploadStream", "fileoutputStream", "zipoutputsession", "zipoutputstream", "zipInputthread", "zipfeedsample", "zipInputstream", "zipoutputStream", "fileoutputsession", "zipinputsession", "zipInputport", "zipimportchannel", "zipfeedStream", "zipimportStream", "zipcontextStream", "zinputthread", "zInputStream", "zipimportstream", "zipInputStream", "zipoutputsystem", "zipexecstream", "zipoutputthread"], "zipentry": ["zipletter", "lockelement", "zipEntry", "feedreader", "zelement", "zobj", "zipsource", "feedEntry", "gzception", " zipelement", "lexEntry", "zipreader", "feedelement", "lexentry", "gzreader", "fileletter", " zipsource", "fileobj", "ceenter", " zipenter", "zipindex", "zentry", " zipception", "lexreader", "zipobj", "zipception", "zletter", "cereader", "zoneelement", " zipletter", "zoneenter", "lockreader", " zipEntry", "gzindex", "gzenter", "zEntry", "zonesource", " zipreader", "locksource", "gzentry", "zreader", "zipelement", "lockception", "lexelement", "ceentry", "fileEntry", "zoneentry", " zipindex", "feedentry", "fileentry", "zipenter", " zipobj", "lockenter", "ceindex", "lockentry"], "entryName": ["folderName", "entryType", "folderNAME", "entryNAME", "patchName", " entryNumber", "archiveName", "elementPart", "archivePart", "elementname", "archivename", "baseNumber", "patchType", "baseName", "folderType", "entrySize", "entryPart", " entryNAME", " entryType", "elementAlias", "folderTitle", "entryAlias", " entryTitle", " entryPart", "elementName", "enterSize", "baseSize", "patchNAME", "entryNumber", " entrySize", "enterNumber", "entryTitle", "enterName", " entryname", " entryAlias", "patchTitle", "archiveAlias", "entryname"], "n": ["size", "none", "en", "num", "d", "nn", "len", "nr", "k", "l", "y", "w", "out", "b", "ns", "f", "number", "no", "r", "dn", "nor", "cn", "x", "name", "ne", "u", "e", "o", "nt", "t", "m", "nu", "v", "index", "N", "node", "j", "c", "i", "g", "pos", "un", "nc", "nb", "ng", "sn", "z", "s", "p"], "fileoutputstream": ["fileoperationstream", "fileoutStream", " fileoutputStream", "zipoutputstack", " fileoutputsw", "fileOutputstream", "fileoutstream", "fileproductioncontrol", "fileinputStream", "fileproductionstream", "zipoutputstream", " fileoperationStream", "fileinputcontrol", "filetargetstream", "fileoutstage", "fileoperationsw", "zipoutputStream", "zipoutputview", "fileoutputsw", "fileoperationstage", " fileoperationstage", "fileoutputview", "fileinputpath", "zipOutputstack", "fileproductionStream", "fileinputstack", "Fileoutputpath", "FileinputStream", "zipinputStream", "fileoperationStream", "fileOutputstage", "fileoutputstack", " fileoutputstage", "fileOutputstack", "fileOutputsw", "zipOutputstream", "fileoutputpath", "fileoutview", "zipinputview", "fileOutputpath", "fileOutputcontrol", "FileoutputStream", " fileoperationsw", "fileinputview", "Fileoutputcontrol", " fileoperationstream", "Fileinputstream", "Fileoutputstream", "fileoutputcontrol", "fileinputstream", "fileoutputstage", "fileoutsw", "filetargetStream", "fileproductionpath", "Fileinputpath", "filetargetstack", "Fileinputcontrol", "fileOutputStream", "fileOutputview", "fileoutputStream", "zipOutputStream"], "newFile": ["missingFolder", " newDir", "missingfile", "NewDir", "newfile", "oldFolder", "oldDirectory", " newDirectory", "missingFiles", "missingFile", "oldDir", "NewFile", "newFiles", "NEWDir", "newDir", "NEWFolder", "NewFolder", "NEWfile", "newFolder", "NewDirectory", " newFiles", "oldFile", " newfile", "Newfile", "NewFiles", "NEWFile", "newDirectory", " newFolder"], "directory": ["language", "folder", "parent", "url", "d", "connection", "director", "division", "Directory", "python", "class", "archive", "creator", "module", "section", "machine", "volume", "component", "dir", "direction", "container", "category", "whatever", "variable", "path", "document", "manager", "service", "database", "which", "position", "project", "copy", "collection", "entry", "location", "either"]}}
{"id1": "3377427", "id2": "9088422", "code1": "    public void execute() throws BuildException {\n        Enumeration list = getIndividualTests();\n        String srcRptFile = \"\";\n        String destRptFile = \"\";\n        while (list.hasMoreElements()) {\n            J3DPerfUnitTest test = (J3DPerfUnitTest) list.nextElement();\n            if (test.shouldRun(getProject())) {\n                try {\n                    execute(test);\n                    try {\n                        srcRptFile = getProject().resolveFile(\".\").getAbsolutePath() + \"\\\\\" + test.getName() + \".txt\";\n                        destRptFile = getProject().resolveFile(test.getName() + \".txt\", new File(test.getTodir())).getAbsolutePath();\n                        FileChannel srcChannel = new FileInputStream(srcRptFile).getChannel();\n                        FileChannel dstChannel = new FileOutputStream(destRptFile).getChannel();\n                        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                        srcChannel.close();\n                        dstChannel.close();\n                        if (!srcRptFile.equals(destRptFile)) {\n                            new File(srcRptFile).delete();\n                        }\n                    } catch (IOException e) {\n                    }\n                } catch (BuildException e) {\n                    e.printStackTrace();\n                } catch (CloneNotSupportedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"list": ["lp", "get", "en", "queue", "pe", "la", "LIST", "not", "the", "chain", "l", "que", "out", "loop", "part", "table", "r", "set", "testing", "stack", "name", "batch", "e", "see", "cont", "cl", "lists", "t", "keep", "ls", "li", "v", "lc", "listed", "index", "load", "live", "i", "array", "www", "group", "add", "collection", "coll", "p", "bl", "type"], "test": ["tests", " Test", "py", "export", "default", "txt", "pe", "task", "build", "result", "iter", "true", "example", "app", "this", "driver", "f", "ver", "est", "data", "version", "style", "class", " testing", "ester", "match", "set", "trial", "call", "feature", "tested", "testing", "stage", "server", "script", "config", "er", "transfer", "it", "event", "e", "pattern", "unit", "target", "t", "trip", "temp", "v", "fit", "install", "file", "check", "code", "fail", "or", "valid", "Test", "train", "empty", "project", "str", "null", "p", "type"], "srcRptFile": ["srcUotFile", "srcRaptPath", "srcRpcPath", "srcLpcFile", "srcRprFile", "srcRptName", "srcNprFilename", "srcLptDir", "srcDptfile", "srcUptfile", "srcRPTFiles", "srcrxtSourceFile", "srcNprPlace", "srcRprPlace", "srcRprFilename", "srcRptFilename", "srcRxtfile", "srcRpcFile", "srcRpointFile", "srcrptSourceFile", "srcRpointFilename", "srcDpointFile", "srcRpcDir", "srcRPTSourceFile", "srcRxtFile", "srcUotfile", "srcRPTFilename", "srcNprFile", "srcLptFile", "srcRptPlace", "srcrxtPlace", "srcRptSourceFile", "srcRotName", "srcLpcName", "srcLpcDir", "srcRotDir", "srcRprfile", "srcNptfile", "srcRptfile", "srcLpcPath", "srcLptPath", "srcDptLine", "srcUotFilename", "srcRpointfile", "srcRPTfile", "srcUptFile", "srcrptPlace", "srcRpointSourceFile", "srcRctFile", "srcDpointfile", "srcRptFiles", "srcRptDir", "srcRptStream", "srcRpcName", "srcRPTFile", "srcRPTPlace", "srcrxtStream", "srcUptFiles", "srcRctFilename", "srcRotFilename", "srcRotPath", "srcRxtPlace", "srcRotFiles", "srcDpointLine", "srcNptFilename", "srcRpcStream", "srcRaptName", "srcUptFilename", "srcRpcfile", "srcDptFile", "srcRaptFile", "srcRpointLine", "srcRptLine", "srcRptPath", "srcLptName", "srcRpointPlace", "srcNptPlace", "srcRxtLine", "srcrptStream", "srcRpcPlace", "srcRaptDir", "srcRotFile", "srcUotFiles", "srcRPTStream", "srcRpcFilename", "srcRxtStream", "srcRpcSourceFile", "srcRctfile", "srcDptSourceFile", "srcRpcFiles", "srcNprfile", "srcRPTLine", "srcRxtSourceFile", "srcRctPlace", "srcrptFile", "srcRotfile", "srcDpointSourceFile", "srcrxtFile", "srcNptFile"], "destRptFile": ["destRctDir", "destWptPage", "destPctFilename", "destRpFiles", "destRctPath", "destRpDir", "destWptPath", "destDpcfile", "destRotFile", "destWptfile", "destRpcPath", "destRptPath", "destPptPath", "destRaptFile", "destRotPath", "destLptFiles", "destWpointPage", "destRpcfile", "destRpPath", "destRPTPath", "destRpcLine", "destRotFiles", "destDptfile", "destRaptFiles", "destPptFile", "destRpName", "destRctFilename", "destRotName", "destWpointFile", "destRptFilename", "destWptFile", "destRpointPath", "destWpointfile", "destDpcFile", "destRpointPage", "destDptPath", "destDptLine", "destRpointLine", "destRptFiles", "destRPTPage", "destRntLine", "destPctFile", "destRpcPage", "destRpFilename", "destRPTFile", "destRpointfile", "destRptPage", "destRpFile", "destPctPath", "destRntFile", "destDpcPath", "destLotFiles", "destRaptPath", "destPptFilename", "destLptPath", "destRptLine", "destRctFile", "destRpointFile", "destPctDir", "destDpcLine", "destLptName", "destWpointPath", "destRPTfile", "destRptName", "destPptDir", "destLotName", "destLotFile", "destLptFile", "destRpcFile", "destRntfile", "destRpcDir", "destDptFile", "destLotPath", "destRptDir", "destRntPath", "destRptfile", "destRpcFilename", "destRaptName"], "srcChannel": ["sourceConnection", "srcchannel", "sslchannel", "sourceChan", "rcChan", "destChan", " srcChan", "rcStream", "inputConnection", " srcStream", " srcConnection", "destchannel", "rcchannel", "srcChan", "rcChannel", "sslStream", "inputChannel", "sslConnection", "inputchannel", "inputChan", "destConnection", "inputPage", "rcConnection", "destChannel", "srcStream", " srcPage", " srcchannel", "sslChannel", "destPage", "sourcechannel", "sourceChannel", "srcConnection", "srcPage"], "dstChannel": ["dstsConnection", "ddestChan", "dstsChan", "ddestchannel", "doutChannel", "dstStream", "Destchannel", "ddestChannel", "DstConnection", "DstStream", "destChan", "doutStream", "DstChan", "DestStream", "drcChannel", "drdChannel", "dstContext", "drcChan", "DstChannel", "doutContext", "ddestConnection", "destContext", "Dstschannel", "destchannel", "drdchannel", "dstChan", "DestContext", "dstsStream", "dstsContext", "DestChannel", "destStream", "dstschannel", "drcchannel", "drdChan", "destConnection", "DstsChan", "DstsConnection", "DestChan", "DstContext", "destChannel", "Dstchannel", "DstsChannel", "dstConnection", "dstchannel", "doutchannel", "dstsChannel"]}}
{"id1": "9857413", "id2": "11426721", "code1": "    @Override\n    public byte[] readData(byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        if (!server.contains(PORT_SEPARATOR)) {\n            server += PORT_SEPARATOR + DEFAULT_PORT;\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        ByteArrayOutputStream baos = null;\n        try {\n            InputStream is = urlc.getInputStream();\n            baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int br;\n            while ((br = is.read(buffer)) > 0) {\n                baos.write(buffer, 0, br);\n                if (!transferMetaData) {\n                    transferredBytesNum += br;\n                    elapsedTime = System.currentTimeMillis() - startTime;\n                    fireOnProgressEvent(transferredBytesNum, elapsedTime);\n                }\n            }\n            baos.close();\n            is.close();\n        } catch (FileNotFoundException fnfe) {\n        }\n        return baos != null ? baos.toByteArray() : null;\n    }\n", "code2": "    public boolean uploadToUrl(URL url, Map postData) {\n        boolean success = false;\n        OutputStream oStream;\n        HttpURLConnection urlConn = null;\n        try {\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setAllowUserInteraction(false);\n            String parametersAsString = \"\";\n            Iterator itParams = postData.entrySet().iterator();\n            while (itParams.hasNext()) {\n                Map.Entry param = (Map.Entry) itParams.next();\n                parametersAsString += (String) param.getKey() + \"=\" + URLEncoder.encode((String) param.getValue(), \"UTF-8\") + \"&\";\n            }\n            byte[] parameterAsBytes = parametersAsString.getBytes();\n            urlConn.setRequestProperty(\"Content=length\", String.valueOf(parameterAsBytes.length));\n            oStream = urlConn.getOutputStream();\n            oStream.write(parameterAsBytes);\n            oStream.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n            String line;\n            while ((line = rd.readLine()) != null) {\n                System.err.println(\"Response: \" + line);\n            }\n            oStream.close();\n            rd.close();\n            success = true;\n        } catch (MalformedURLException ex) {\n            System.err.println(ex + \" (uploadToUrl)\");\n            success = false;\n        } catch (java.io.IOException iox) {\n            System.out.println(iox + \" (uploadToUrl)\");\n            success = false;\n        } catch (Exception generic) {\n            System.out.println(generic.toString() + \" (uploadToUrl)\");\n            success = false;\n        } finally {\n            success = false;\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"options": ["resources", "Options", "points", "settings", "keys", "io", "optional", "properties", "http", "params", "object", "types", "table", "data", "style", "os", "objects", "outs", "config", "info", "meta", "groups", "results", "o", "json", "values", "timeout", "ios", "headers", "ops", "or", "details", "files", "opt", "option", "ts"], "transferMetaData": ["transferMetClose", "writeMetaFlow", " transferMetMemory", " transferMetaText", "transferMetaRead", "writeMetaDATA", "writeMultiData", "transferMetaMemory", "transfermetaData", "transferMetFlow", " transferMetaClose", "transferMetaFlow", "transferMetRead", "transferMetText", "transferMetaText", "transferMultiDATA", "transferMetDATA", "writeMultiDATA", "transfermetaMemory", "transfermetaText", "transferMetData", "writeMetaData", "transfermetaRead", "transfermetaClose", " transferMetText", " transferMetaRead", "transferMultiFlow", "transferMultiData", "writeMultiFlow", "transferMetMemory", " transferMetaMemory", " transferMetRead", "transferMetaDATA", " transferMetClose", " transferMetData", "transferMetaClose"], "startTime": ["startTimes", " startTimes", "startingTIME", "middleTime", "http", "this", "startingFile", "startTIME", " startFile", "startFile", " startTIME", "HTTP", "startingTime", "middleTimes", "_", "middleFile", "startingTimes", "middleTIME", "Url", "s"], "transferredBytesNum": ["transendedBytesnum", "transfixedFramesNum", "transferredFramesSum", "transferredBytesSum", "transferredFramesnum", "transfixedBytesNum", "transendedByteMsg", "transendedBytenum", "transfixedFramesSum", "transferredFilesMu", "transferredFilesNum", "transferredWordsnum", "transferredFramesNum", "transendedBytesMu", "transferredWordsNum", "transferredFilesMsg", "transferredFilesnum", "transendedByteNum", "transendedByteMu", "transfixedBytesSum", "transfixedFramesVal", "transferredWordsMu", "transferredbytesnum", "transfixedBytesVal", "transendedBytesNum", "transferredBytesVal", "transferredFilesVal", "transferredBytesnum", "transendedBytesMsg", "transferredByteMu", "transfixedFramesnum", "transferredBytesMsg", "transferredBytesMu", "transferredBytenum", "transfixedBytesnum", "transferredbytesVal", "transferredByteNum", "transferredFilesSum", "transferredByteMsg", "transferredbytesSum", "transferredFramesVal", "transferredWordsMsg", "transferredbytesNum"], "elapsedTime": ["eladjustedStream", "elapsesTimes", "elapsedTimes", "elagoTim", "elagoTimes", "elapseTime", "ElapsedTimes", "ElapsedStream", "elocationTim", "elagoMode", "eladjustedTimes", "elapseTim", "elapsedStream", "ElapseTim", "ElapseMode", "elapseStream", "ElapsedTime", "elocationTimes", "elapsedTim", "ElapseTimes", "ElapseStream", "ElapsedTim", "elapsedMode", "elagoTime", "elocationTime", "elocationStream", "elapsesTime", "eladjustedTime", "ElapsedMode", "elapsesMode", "elapseMode", "ElapseTime", "elapsesTim", "elapseTimes", "eladjustedTim"], "opts": ["obrs", "optments", "OPments", " optts", " optt", "OPms", " opters", " opqs", " optTS", "opters", "optps", "obTS", " opns", "oprs", "OPts", "opTs", "OPqs", "opns", "OPns", " opms", "opments", "OPtt", "OPTS", "optt", "opps", "optTS", "obTs", "OPTs", "OPrs", "obts", "optns", "OPters", "opms", "opTS", "opqs", "optms", " opps", " optters", " oprs", "optts", "optqs", " opTS", " opTs", "OPps", " opttt", " opments"], "server": ["source", "host", "site", "user", "si", "Server", "connection", "ser", "peer", "http", "client", "home", "description", "root", "hello", "version", "directory", "remote", "system", "resource", "prefix", "serv", "address", "email", "slave", "master", "inner", "name", "method", "device", "api", "enter", "erver", "localhost", "string", "path", "seed", "socket", "uri", "ssl", "error", "service", "database", "domain", "project", "port", "location", "type"], "username": ["host", "user", "token", "auth", "sword", "nick", "client", "driver", "login", "profile", "prefix", "email", "config", "dn", "address", "alias", "filename", "name", "users", "usr", "USER", "names", "key", "ername", "string", "uri", "attribute", "property", "character", "header", "manager", "database", "service", "subject", "account", "mobile", "port", "author", "uid"], "password": ["host", "user", "token", "auth", "sword", "fax", "wd", "security", "client", "PASS", "column", "login", "profile", "phrase", "resource", "address", "pad", "word", "name", "api", "money", "picture", "timeout", "session", "key", "path", "pass", "uri", "attribute", "mask", "service", "secret", "database", "Password", "account", "wallet", "port", "padding", "device"], "filePath": ["logPath", " fileLog", " fileUrl", "FileSystem", "fName", "fileFile", "FilePath", "sourceInfo", "ileName", "fileUrl", "sourceName", "resourceFile", "fileLog", "filePoint", "imageName", "fPath", "filepath", "fInfo", "resourceLength", " fileLength", " filepath", "resourceInfo", "FILELength", "logpath", " fileFile", "logName", "ilePath", "resourceUrl", "FILESystem", "pageUrl", "FileLog", "sourcePath", "fileInfo", "imagePath", " filePoint", "resourceName", "resourcePoint", " fileInfo", "ileUrl", "sourcepath", "pageFile", "FileName", "FILEpath", "FILEPath", "imagepath", "Filepath", "imagePoint", "pagePath", "fileLength", "resourcePath", "pageName", "fpath", "FileUrl", "FILEName", "logUrl", "resourcepath", "ileLog", "fileSystem", " fileSystem"], "idx": [" idxx", " idp", " idb", "inx", "indb", "indx", "inxx", "idxx", "inb", "indxx", " idy", "indX", "Idxc", "indxs", "Idy", "Idw", " idw", "indw", "Idx", "indxc", "idy", "idX", "idp", "idxs", "IdX", "Idp", " idX", "indp", "idb", " idxc", "inxc", "indy", " idxs", "inX", "idxc", "idw", "inxs"], "fileName": ["FileInfo", "filePart", " fileAddress", "FilePath", "classPath", "FilePart", "fileAddress", "FILEPart", "fileInfo", " fileInfo", "className", "FileName", "FILEPath", " filePart", "classPart", "classInfo", "FILEAddress", "FILEName", "FileAddress"], "url": ["host", "page", "user", "browser", "connection", "open", "build", "io", "l", "http", "client", "b", "object", "base", "f", "p", "channel", "resource", "org", "config", "ur", "gl", "event", "t", "fl", "li", "v", "path", "image", "uri", "ssl", "i", "g", "URL", "service", "Url", "www", "proxy", "web", "sl"], "urlc": ["Urlconn", "jsonC", "jsonc", "urlpc", "urlt", "urlcon", "URLr", "urlC", "webl", "URLconn", " urlC", "updateconn", "URLp", "jsoncon", "urlcs", "Urlpc", "updatec", "URLc", " urll", "urll", "urlr", "webcs", "updatecon", "urlp", " urlr", " urlconn", " urlt", "Urlc", " urlp", "urlconn", "urlm", "URLt", "URLcs", " urlcs", " urlm", "URLm", "URLl", "webc", "jsonconn", "updateC", "Urlr", "URLpc", " urlpc", " urlcon", "Urlt", "Urlp", "webm"], "baos": ["baor", "boos", "vaus", "BAis", "haus", "baot", "Baot", "hao", "hais", " baor", "bao", "BAus", "Baos", "boo", "vaos", "bools", "BAos", "BAols", "haos", "baus", "BAo", "Baols", "vao", "vais", "Bao", "Baor", "Bais", "bais", "baols", " bais", "BAor", "boot", " bao", "BAot"], "is": ["id", "nis", "browser", "isa", "ais", "http", "isl", "in", "app", "as", "was", "iss", "are", "os", "bs", "ris", "irc", "ai", "ir", "has", "isi", "it", "ci", "iris", "IS", "api", "ri", "lis", "ios", "ori", "i", "im", "ish", "isol", "bis", "Is", "iso", "ip", "ic", "does"], "buffer": ["page", "reader", "button", "memory", "queue", "binary", "input", "feed", "reference", "buff", "iter", "result", "Buffer", "message", "b", "layer", "channel", "data", "table", "resource", "address", "writer", "uffer", "shape", "padding", "batch", "bb", "bridge", "length", "flush", "wave", "uf", "bar", "buf", "FFER", "document", "border", "cache", "fb", "array", "header", "block", "texture", "position", "balance", "stack"], "br": ["next", "ber", "div", "bp", "wr", "gr", "ru", "bf", "arr", "min", "nr", "bg", "pre", "Br", "b", "bc", "lr", "fr", "base", "ver", "BR", "bd", "ref", "bi", "r", "n", "bal", "el", "shr", "body", "batch", "bridge", "hr", "dr", "buf", " dr", "tr", " str", "span", "bar", "ch", "cr", "j", "err", "width", "or", "bro", "img", "ctr", "str", "line", "p", "bl"]}}
{"id1": "13555475", "id2": "6893385", "code1": "    public boolean testConnection(FTPSite site) throws IOException {\n        FTPClient testclient = new FTPClient();\n        testclient.connect(site.getHost(), site.getPort());\n        boolean check = testclient.login(site.getUser(), site.getPassword());\n        testclient.disconnect();\n        return check;\n    }\n", "code2": "    @Override\n    public void end() {\n        m_zipFormatter.end();\n        IOUtils.closeQuietly(m_outputStream);\n        final FTPClient ftp = new FTPClient();\n        FileInputStream fis = null;\n        try {\n            if (m_url.getPort() == -1 || m_url.getPort() == 0 || m_url.getPort() == m_url.getDefaultPort()) {\n                ftp.connect(m_url.getHost());\n            } else {\n                ftp.connect(m_url.getHost(), m_url.getPort());\n            }\n            if (m_url.getUserInfo() != null && m_url.getUserInfo().length() > 0) {\n                final String[] userInfo = m_url.getUserInfo().split(\":\", 2);\n                ftp.login(userInfo[0], userInfo[1]);\n            } else {\n                ftp.login(\"anonymous\", \"opennmsftp@\");\n            }\n            int reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                LogUtils.errorf(this, \"FTP server refused connection.\");\n                return;\n            }\n            String path = m_url.getPath();\n            if (path.endsWith(\"/\")) {\n                LogUtils.errorf(this, \"Your FTP URL must specify a filename.\");\n                return;\n            }\n            File f = new File(path);\n            path = f.getParent();\n            if (!ftp.changeWorkingDirectory(path)) {\n                LogUtils.infof(this, \"unable to change working directory to %s\", path);\n                return;\n            }\n            LogUtils.infof(this, \"uploading %s to %s\", f.getName(), path);\n            ftp.setFileType(FTP.BINARY_FILE_TYPE);\n            fis = new FileInputStream(m_zipFile);\n            if (!ftp.storeFile(f.getName(), fis)) {\n                LogUtils.infof(this, \"unable to store file\");\n                return;\n            }\n            LogUtils.infof(this, \"finished uploading\");\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"Unable to FTP file to %s\", m_url);\n        } finally {\n            IOUtils.closeQuietly(fis);\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"site": ["source", "host", "page", "user", "pe", "si", "network", "xml", "plugin", "sit", "result", "space", "ee", "build", "edge", "complete", "conn", "http", "security", "object", "client", "home", "environment", "login", "base", "data", "class", "response", "set", "server", "config", "info", "sites", "sync", "shell", "name", "ite", "zone", "it", "facebook", "project", "unit", "instance", "course", "localhost", "session", "status", "pse", "fit", "se", "node", "connect", "install", "socket", "file", "ssl", "live", "www", "bot", "Site", "blog", "proxy", "test", "domain", "sample", "use", "type"], "testclient": ["hostconn", "testingconnection", "tempcase", "newClient", "tempserver", "hostserver", "tempclient", " testClient", "testconn", "testClient", " testapi", "tempClient", " testconn", "testingapi", "testingClient", "newapi", "Testserver", "Testclient", "testconnection", "testapi", "hostClient", "testingconn", "Testcase", "newclient", "testingcase", " testconnection", "testingserver", "newconnection", "testcase", "testserver", " testcase", " testserver", "testingclient", "Testapi", "TestClient", "hostclient"], "check": ["get", "read", "id", "open", "pull", "view", "fix", " Check", "end", "pack", "delete", "base", "set", "work", "match", "ctx", "call", "info", "update", "sync", "action", "x", "Check", "ack", "it", "ok", "stat", "checked", "post", "run", "lock", "load", "checks", "wait", "valid", "start", "ck", "add"]}}
{"id1": "22366636", "id2": "8561732", "code1": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Project project = (Project) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_PROJECT\"));\n            pst.setString(1, project.getName());\n            pst.setString(2, project.getDescription());\n            pst.setInt(3, project.getIdAccount());\n            pst.setInt(4, project.getIdContact());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_project) from project\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "code2": "    public boolean actualizarRondaActual(division div) {\n        int intResult = 0;\n        String sql = \"UPDATE divisionxTorneo \" + \" SET rondaActual = \" + div.getRondaActual() + \" WHERE idDivisionxTorneo = \" + div.getidDivision();\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"o": ["ado", "none", "ao", "d", "oid", "office", "connection", "object", " object", "op", "po", "mo", "oa", "os", "ono", "oo", "bo", "oi", "online", "e", "ob", "ion", "t", "oe", "OO", "od", "O", "Obj", " O", "obj", "or", "obo", " os", "PO", " obj", "bot", "s", "p", "type"], "insert": ["select", "plus", "read", "inc", "write", "append", "feed", "pull", "exist", "repeat", "result", "ride", "join", "Insert", "row", "delete", "sleep", "put", "save", "push", "update", "sync", "ert", "edit", "step", "length", "enter", "post", "index", "seed", "load", "connect", "replace", "error", "check", "search", "zero", "create", "start", "position", "throw", "add", "copy", "apply", "ip", "use", "entry"], "id": ["parent", "read", "url", "test", "oid", "result", "val", "root", "aid", "delete", "Id", "number", "no", "ret", "info", "update", "x", "action", "name", "event", "it", "edit", "pid", "length", "show", "time", "index", "count", "load", "error", "code", "i", "search", "and", "vid", "ids", "create", "ip", "start", "order", "kid", "add", "ID", "uid", "type"], "project": ["language", "source", "select", "parent", "contract", "operation", "Project", "user", "phase", "pe", "period", "office", "connection", "product", "plugin", "build", "division", "result", "jp", "object", "app", "request", "client", "home", "model", "environment", "base", "application", "po", "data", "to", "future", "version", "zip", "resource", "contact", "config", "primary", "push", "component", "name", "purpose", "target", "patch", "device", "password", "text", "post", "job", "index", "document", "company", "context", "db", "projects", "priority", "service", "database", "subject", "development", "bot", "port", "p", "type"], "pst": ["pretd", "Pft", "dST", "lpse", "lpst", "lpth", "pth", " pste", " psp", "pcr", " ptd", "precr", "Pss", "prst", "Pst", " pcr", "pnd", "epst", " psth", "psp", "opnd", "pct", "Pct", " pse", "Pth", " pss", " pft", "opst", "ptd", "pft", "prft", "opct", "pste", "psth", "epse", "prest", "prese", "pse", " pct", "lpct", "Psth", "dct", "epcr", "prct", "Pnd", "Pse", "pss", "PST", "dst", "dsp", "eptd", " pth", "pST", "Pste", "Psp", " pST", "prste", "opsth", " pnd", "prss"], "st": ["sa", "sb", "ST", "ost", "ld", "ss", " St", "statement", "src", "sw", "ist", "est", "ess", "r", "sc", "sh", "tx", "sta", "inst", " est", "s", "cl", "t", "mt", "pr", "St", "se", "pt", "cr", "sts", "SS", "sp", "rd", "struct", "ust", "ts", "ct", "ps", "str", "rest", "sl", "bl"], "rs": ["ums", "Rs", "ys", "RC", "hs", "ks", "rys", "ows", "ra", "runs", "lines", "ss", "ws", "RS", "rss", "ns", "ros", "ars", "ries", "r", "ris", "rg", "eers", "vs", " rows", " res", "ins", "results", "icks", "rc", "cs", "sr", "hr", "dr", "ls", "pr", "rows", "cr", "rl", " sr", "rd", "mr", "vers", "rr", "ras", "ds", " RS", "ps", "res"]}}
{"id1": "2490462", "id2": "3635291", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static String getSHA1Digest(String inputStr) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        byte[] sha1hash = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        sha1hash = new byte[40];\n        md.update(inputStr.getBytes(\"iso-8859-1\"), 0, inputStr.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"secure": ["host", "active", "require", "deep", "safe", "secondary", "pure", "security", "Secure", "stable", "https", "remote", "zip", "smart", "server", "config", "external", "random", "force", "depth", "relative", " insecure", "allow", "sr", "exclusive", "timeout", "session", "sec", "confirmed", "seed", "encrypted", "debug", "ssl", "sensitive", "quiet", "service", "secret", "unsigned", "proxy", "weak", "use"], "md5": ["mand3", " md64", "MDito", "md3", "md64", "mp2", " md256", " MD2", "mand2", "MD5", "mand5", " mdito", " MD5", "mdito", "mp5", " md56", "mand56", "MD512", " MDito", "MD3", "md512", "md256", "mand256", "mp64", "mand512", "MD2", "MD56", " MD3", "md2", " md2", " md512", "MD64", " md3", "md56", "MD256", "mp3"], "sbValueBeforeMD5": ["sbValueBeforemd85", "sbValueBeforeMet5", "sbValueBeforeMD3", "sbValueBeforeMC512", "sbValueWithoutSHA3", "sbValueBeforeML68", "sbValueAfterMD85", "sbValueBeforeMD1", "sbValueBeforeMP9", "sbValueBeforeMD53", "sbValueAfterMSLink", "sbValueBeforeMS3", "sbValueWithoutSHA512", "sbValueBeforemd512", "sbValueBeforeAST512", "sbValueBeforeAMDFive", "sbValueBesidesMD68", "sbValueAfterMD53", "sbValueBeforeMPFive", "sbValueBeforeSHA5", "sbValueBeforeMCLink", "sbValueBeforeML3", "sbValueBeforeMSLink", "sbValueBeforeMF5", "sbValueBeforeAMD3", "sbValueWithoutMD1", "sbValueAfterMD5", "sbValueBeforeMP1", "sbValueBeforeMDFive", "sbValueBeforeSHA512", "sbValueBeforeAMD512", "sbValueBeforeML5", "sbValueAfterMD3", "sbValueBeforeAST3", "sbValueWithoutSHA1", "sbValueAfterMS5", "sbValueBeforeMD512", "sbValueBeforeM3", "sbValueBeforeMP25", "sbValueBeforeMD8", "sbValueBeforeMAC1", "sbValueBesidesMD8", "sbValueBeforeAMD85", "sbValueBeforeML8", "sbValueBeforeMAC5", "sbValueBeforeAMD1", "sbValueBeforeMP3", "sbValueWithoutMD3", "sbValueBeforemd3", "sbValueBeforeMet9", "sbValueBeforeMD25", "sbValueAfterAMD512", "sbValueAfterMP3", "sbValueBeforeMS53", "sbValueWithoutMD5", "sbValueBeforeM512", "sbValueBeforeMet25", "sbValueBeforeAST85", "sbValueAfterMS53", "sbValueBeforeMD68", "sbValueBeforeMC1", "sbValueBeforeMC5", "sbValueBeforeMF512", "sbValueAfterMDFive", "sbValueAfterMP1", "sbValueBeforeM5", "sbValueAfterAMD85", "sbValueBeforeAMD5", "sbValueBeforeMD9", "sbValueBeforemd53", "sbValueBeforeMF85", "sbValueWithoutMD512", "sbValueBeforeMACFive", "sbValueBeforeAST5", "sbValueBeforeM1", "sbValueBeforeMS5", "sbValueBeforeMD85", "sbValueBeforeMS85", "sbValueAfterMPFive", "sbValueAfterAMD3", "sbValueBeforeMF3", "sbValueBeforeSHA3", "sbValueAfterMDLink", "sbValueBeforeMDLink", "sbValueBeforeSHA1", "sbValueAfterMS3", "sbValueBeforeMC53", "sbValueBeforeMC3", "sbValueBeforeMS512", "sbValueAfterAMD5", "sbValueAfterMD512", "sbValueBeforeMS68", "sbValueBeforeMS8", "sbValueBeforemdLink", "sbValueBeforemd5", "sbValueBeforeMP5", "sbValueAfterMP5", "sbValueBeforeMet3", "sbValueAfterMD1", "sbValueBesidesMD3", "sbValueWithoutSHA5", "sbValueBeforeMAC3", "sbValueBesidesMD5"], "time": ["host", "size", "id", "user", "hour", "race", "year", "counter", "tim", "tz", "clock", "mode", "loc", "sleep", "version", "serial", "ime", "random", "etime", "depth", "name", "event", "length", "cost", "money", "timeout", "count", "seed", "delay", "live", "error", "times", "speed", "date", "TIME", "Time", "start", "timer", "rate", "value", "port", "month", "duration", "type"], "rand": ["id", "rar", "rank", "win", "year", "mid", "range", "right", "ro", "dev", "winner", "root", "bug", "gen", "loc", "version", "serial", "r", "clean", "round", "rage", "random", "depth", "rc", "pattern", "patch", "length", "max", "rh", "raid", "bit", "index", "rule", "count", "seed", "reg", "delay", "error", "live", "rr", "q", "order", "ng", "rate", "Rand", "alpha", "pick", "type"], "valueBeforeMD5": ["valueBeforeAMD2", "valueAfterMP3", "valueBeforeMC3", "valueBeforeMF25", "valueAfterMP2", "valueAfterMP50", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAfterMD25", "valueBeforeMP50", "valueBeforeAMD3", "valueBeforeMF2", "valueBeforeMP2", "valueBeforeME5", "valueAfterMD3", "valueBeforeMD3", "valueBeforeMD25", "valueBeforeME3", "valueBeforeAMD50", "valueBeforeAMD5", "valueBeforeMD50", "valueBeforeMF3", "valueAfterMP5", "valueBeforeMC2", "valueBeforeMF5", "valueAfterMD50", "valueBeforeME2", "valueAfterMD2", "valueBeforeMC5", "valueBeforeMC25", "valueBeforeME50"], "array": ["hash", "queue", "binary", "our", "Array", "arr", "range", "arrow", "function", "result", "message", "audio", "view", "object", "app", "ray", "number", "data", "r", "integer", "pair", "archive", "feature", "address", "angle", "shape", "element", "section", "batch", "allow", "api", "instance", "a", "area", "abc", "index", "string", "image", "list", "record", "error", "expression", "map", "database", "value", "collection", "sample"], "sb": ["sa", "cb", "bf", "mb", "bh", "si", "binary", "buffer", "sth", "buff", "usb", "sg", "pb", "src", "sf", "bc", "lr", "kb", "bm", "ruby", "abb", "bs", "obb", "rob", "erb", "bj", "bb", "SB", " SB", "ob", "sl", "sv", "zb", "buf", "gb", "xb", "eb", "ib", "orb", "bsp", "ab", "db", "bt", "wb", "fb", "sq", "lab", "nb", "lb", "s", "rb", "bp", "bl"], "j": ["jj", "num", "d", "ind", "br", "J", "jp", "k", "l", "y", "jo", "ja", "part", "aj", "f", "ij", "n", "ji", "adj", "js", "x", "bj", "o", "e", "uj", "dj", "length", "pr", "ch", "job", "li", "v", "key", "dy", "index", "obj", "c", "i", "ii", "im", "jl", "oj", "q", "z", "p", "ie"], "b": ["cb", "bf", "d", "mb", "be", "br", "k", "BB", "pb", "l", "y", "f", "p", "n", "bs", "x", "e", "bb", "ob", "bit", "bar", "job", "a", "B", "eb", "orb", "c", "ab", "db", "i", "obj", "wb", "fb", "nb", "lb", "bin", "rb", "ib"], "valueAfterMD5": ["valueAfterMP3", "valueAfterMP2", "valueAfterMDType", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAftermd2", "valueAfterAMD3", "valueBeforeMP2", "valueAftermd3", "valueAfterMD3", "valueAfterMPType", "valueAfterAMD5", "valueBeforeMD3", "valueAftermdType", "valueAfterMP5", "valueAfterAMD2", "valueBeforeMDType", "valueAfterMD2", "valueBeforeMPType", "valueAfterAMDType", "valueAftermd5"]}}
{"id1": "19999376", "id2": "624490", "code1": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"zipfile": ["zipFile", "zFile", "Zipdir", "zfile", "clipfile", "zentry", "zipfiles", "clipfiles", "zipdir", "gzdir", "Zipfiles", " zipfiles", "zipentry", "Zipfile", "clipFile", "Zipstream", "clipstream", "gzFile", "Zipentry", "gzentry", " zipstream", " zipFile", "zdir", "ZipFile", "gzfile", "zipstream"], "entry": ["next", "source", "folder", "route", "reader", "draft", "id", "export", "input", "link", "queue", "si", "line", "connection", "feed", "xml", "plugin", "ry", "audio", "lock", "in", "object", "cell", "ries", "base", "data", "directory", "zip", "system", "her", "archive", "server", "address", "info", "inner", "element", "module", "name", "dir", "it", "e", "country", "nt", "container", "log", "cel", "parser", "api", "enter", "comment", "se", "session", "path", "image", "cache", "install", "file", "record", "uri", "error", "or", "parse", "Entry", "service", "sea", "add", "ie"], "outputDir": ["inputFolder", " outputDIR", "outFile", " outputdir", "writeDIR", "inputdir", "inputDIR", "writeFolder", "outDir", "outDirectory", "exitDIR", "outputFolder", "exitDir", "outDIR", "outputDirectory", "outputDIR", "writeDir", "writeDirectory", "outFolder", "targetFolder", "exitdir", " outputDirectory", "targetFile", "inputDirectory", "targetDirectory", "outputdir", "targetDir", "inputDir", "exitDirectory", "inputFile"], "outputFile": [" outputfile", "inputfile", "inputFolder", "outFile", "inputPath", " outputPath", "outLine", "inputLine", "OutputPath", "outDir", "outDirectory", "outputLine", "outputFolder", "inputJar", "outputDirectory", " outputFolder", "responseFile", "OutputDir", "outputJar", " outputLine", " outputDirectory", "OutputFile", "responsefile", "inputDirectory", "outStream", "responseFolder", "responseDir", " outputJar", "inputDir", "outputPath", "OutputJar", "inputFile", "outputfile"], "inputStream": [" inputReader", "outputSteam", " inputChannel", "inputSteam", "InputStream", " inputView", " inputSteam", " inputFile", "inputReader", "InputView", "inputView", "outputReader", "outputChannel", "inputChannel", "InputFile", "InputChannel", "outputView", "InputSteam", "InputReader", "inputFile"], "outputStream": ["outputSteam", "inputSteam", "OutputSteam", "execStream", " outputChannel", "OutputStream", "execFile", "inputStreamer", "outputChannel", "inputChannel", " outputSteam", "OutputFile", "OutputStreamer", "execStreamer", "OutputChannel", "inputFile", "outputStreamer", "execSteam"]}}
{"id1": "3109016", "id2": "10789070", "code1": "    private void copySon(File parent) {\n        System.out.println(\"parent---\" + parent.getAbsolutePath());\n        if (parent.isDirectory() && !\".svn\".equals(parent.getName())) {\n            File cases = new File(parent, \"cases\");\n            if (cases.exists()) {\n                File answers = new File(parent, \"answers\");\n                if (!answers.exists()) {\n                    answers.mkdir();\n                    File answers_linux = new File(parent, \"answers_linux\");\n                    for (File file : answers_linux.listFiles()) {\n                        if (file.isDirectory()) {\n                            continue;\n                        }\n                        File target = new File(answers, file.getName());\n                        try {\n                            IOUtils.copy(new FileInputStream(file), new FileOutputStream(target));\n                        } catch (Throwable t) {\n                            t.printStackTrace();\n                        }\n                    }\n                }\n            } else {\n                for (File son : parent.listFiles()) {\n                    System.out.println(\"parent---\" + son.getAbsolutePath());\n                    copySon(son);\n                }\n            }\n        }\n    }\n", "code2": "    public List<Datastream> getFiles(final String pFile) throws IOException {\n        List<Datastream> tDatastreams = new ArrayList<Datastream>();\n        new File(this.getTmpExtractDirName()).mkdir();\n        ZipFile tZipFile = new ZipFile(pFile);\n        Enumeration tEntries = tZipFile.entries();\n        ZipEntry tEntry = null;\n        File tFile = null;\n        String tFileLocation = \"\";\n        LocalDatastream tLocalDs = null;\n        while (tEntries.hasMoreElements()) {\n            tEntry = (ZipEntry) tEntries.nextElement();\n            if (tEntry.isDirectory()) {\n                continue;\n            }\n            tFileLocation = this.getTmpExtractDirName() + System.getProperty(\"file.separator\") + tEntry.getName();\n            tFile = new File(tFileLocation);\n            LOG.debug(\"Saving \" + tEntry.getName() + \" to \" + tFile.getPath());\n            tFile.getParentFile().mkdirs();\n            IOUtils.copy(tZipFile.getInputStream(tEntry), new FileOutputStream(tFile));\n            tLocalDs = new LocalDatastream(tFile.getName().split(\"\\\\.\")[0], FindMimeType.getMimeType(tFile.getName().split(\"\\\\.\")[1]), tFileLocation);\n            tLocalDs.setLabel(tEntry.getName());\n            tDatastreams.add(tLocalDs);\n        }\n        return tDatastreams;\n    }\n", "label": 1, "substitutes": {"parent": ["contract", "parents", "python", "home", "father", "model", "directory", "mac", "name", "temp", "central", "plant", "create", "mount", "project", "location", "Parent", "folder", "closure", "one", "object", "app", "part", "to", "remote", "child", "shape", "script", "tax", "instance", "point", "c", "self", "ca", "ps", "copy", "port", "source", "draw", "mother", "complete", "function", "example", "this", "client", "request", "fat", "testing", "filename", "path", "context", "valid", "null", "fork", "p", "host", "anc", "connection", "out", "root", "config", "children", "ppa", "pa", "large", "container", "content", "document", "current", "form", "test", "unit"], "cases": ["options", "tests", "comments", "cells", "test", "closure", "reports", "events", "acts", "pes", "sections", "settings", "lines", "packs", "parents", "cas", "books", "app", "types", "ca", "ups", "ctx", "forms", "rooms", "cus", "devices", " tests", "ports", "ches", "phones", "plugins", "cs", "clips", "ls", "rules", "fits", "roots", "scripts", "les", "ops", "features", "thumbnails", "apps", "projects", "files", "aps", "times", "details", "videos", "modules", "project", "ps", "assets", "except"], "answers": ["annwerers", "answwers", "ansswerers", "ansiwERS", "anwered", "ansswars", "anewer", "answiner", "ansewERS", "anewars", "annwers", "annswerers", "ansswters", "ansiwers", "ansewered", "answars", "anwers", "answerers", "answered", "ansewering", "ansewerers", "anshwer", "annwered", "ansowered", "anwars", "ansowerers", "answwering", "ansactering", "annswer", "anewers", "answiners", "answERS", "answering", "ansewer", "anwters", "ansacter", "ansowers", "anwerers", "ansswERS", "ansactered", "ansewars", "anshwering", "answinters", "answinering", "ansiwerers", "answwer", "ansswered", "anshwers", "anwERS", "ansiwer", "anshwars", "ansswering", "anewering", "answer", "anwer", "annwer", "ansswer", "anwering", "annswers", "annswered", "ansewers", "answters", "ansacters", "answwters", "ansswers", "ansower"], "answers_linux": ["answERS_linux", "answer_ux", "answers_ux", "answer_Linux", "answers_cross", "answer_linux", "answERS_lite", "answers_lite", "answer_lite", "answers_Linux", "answers_windows", "answer_windows", "answERS_windows", "answERS_cross"], "file": ["source", "get", "folder", "id", "ile", "url", "queue", "pe", "place", "connection", "build", "function", "File", "l", "lib", "http", "object", "b", "part", "f", "base", "profile", "layer", "fe", "future", "class", "single", "handler", "child", "el", "module", "er", "force", "name", "filename", "it", "full", "dir", "php", "unit", "per", "log", "cl", "comment", "le", "il", "path", "rule", "entity", "socket", " File", "files", "local", "FILE", "et", "test", "line", "use", "type"], "target": ["source", "next", "site", "test", "tor", "connection", "settings", "result", "top", "output", "conn", "object", "client", "driver", "root", "model", "base", "remote", "resource", "master", "match", "child", "external", "shadow", "dest", "bean", "Target", "event", "project", "session", "path", "point", "socket", "support", "goal", "local", "tail", "manager", "proxy", "platform", "value", "location", "unit"], "son": ["source", "select", "sel", "su", "pe", "token", "tor", "phone", "xml", "ton", "conn", "one", "fruit", "sw", "object", "client", "age", "model", "loc", "jack", "directory", "osa", "single", "zip", "Son", "os", "ass", "child", "oss", "pa", "json", "ion", "mos", "se", "kin", "port", "document", "node", "don", "db", "person", "service", "local", "create", "SON", "sn", "project", "test", "two", "collection", "null", "unit"]}}
{"id1": "5317769", "id2": "19044529", "code1": "    private <T> Collection<Class<? extends T>> loadProviders(final Class<T> providerClass) throws BootstrapException {\n        try {\n            final String providerNamePrefix = providerClass.getName() + \".\";\n            final Map<String, Class<? extends T>> providers = new TreeMap<String, Class<? extends T>>(new Comparator<String>() {\n\n                public int compare(final String key1, final String key2) {\n                    return key1.compareTo(key2);\n                }\n            });\n            final File platformProviders = new File(this.getPlatformProviderLocation());\n            if (platformProviders.exists()) {\n                InputStream in = null;\n                final java.util.Properties p = new java.util.Properties();\n                try {\n                    in = new FileInputStream(platformProviders);\n                    p.load(in);\n                } finally {\n                    if (in != null) {\n                        in.close();\n                    }\n                }\n                for (Map.Entry e : p.entrySet()) {\n                    if (e.getKey().toString().startsWith(providerNamePrefix)) {\n                        final Class<?> provider = this.findClass(e.getValue().toString());\n                        if (provider == null) {\n                            throw new BootstrapException(getMessage(\"implementationNotFound\", providerClass.getName(), e.getValue().toString(), platformProviders.getAbsolutePath()));\n                        }\n                        if (!providerClass.isAssignableFrom(provider)) {\n                            throw new BootstrapException(getMessage(\"illegalImplementation\", providerClass.getName(), e.getValue().toString(), platformProviders.getAbsolutePath()));\n                        }\n                        providers.put(e.getKey().toString(), provider.asSubclass(providerClass));\n                    }\n                }\n            }\n            final Enumeration<URL> classpathProviders = this.findResources(this.getProviderLocation() + '/' + providerClass.getName());\n            while (classpathProviders.hasMoreElements()) {\n                final URL url = classpathProviders.nextElement();\n                final BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    if (line.contains(\"#\")) {\n                        continue;\n                    }\n                    final Class<?> provider = this.findClass(line);\n                    if (provider == null) {\n                        throw new BootstrapException(getMessage(\"implementationNotFound\", providerClass.getName(), line, url.toExternalForm()));\n                    }\n                    if (!providerClass.isAssignableFrom(provider)) {\n                        throw new BootstrapException(getMessage(\"illegalImplementation\", providerClass.getName(), line, url.toExternalForm()));\n                    }\n                    providers.put(providerNamePrefix + providers.size(), provider.asSubclass(providerClass));\n                }\n                reader.close();\n            }\n            return providers.values();\n        } catch (final IOException e) {\n            throw new BootstrapException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public void put(File fileToPut) throws IOException {\n        FTPClient ftp = new FTPClient();\n        try {\n            int reply;\n            ftp.connect(this.endpointURL, Config.getFtpPort());\n            log.debug(\"Ftp put reply: \" + ftp.getReplyString());\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp put server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.setFileType(FTP.BINARY_FILE_TYPE);\n            ftp.enterLocalPassiveMode();\n            InputStream input = new FileInputStream(fileToPut);\n            if (ftp.storeFile(fileToPut.getName(), input) != true) {\n                ftp.logout();\n                input.close();\n                throw new IOException(\"FTP put exception\");\n            }\n            input.close();\n            ftp.logout();\n        } catch (Exception e) {\n            log.error(\"Ftp client exception: \" + e.getMessage(), e);\n            throw new IOException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"providerClass": ["provoverParent", "provIDERType", "explainerFactory", "providableClass", "proideSpec", "proviperClass", "provoverType", "providerStr", "pricatorFunction", "providediderClass", "providerParent", "proviverclass", "proiderType", "providerFunction", " providerLine", "provProviderKind", "provideName", "promideLine", "pricatorType", "provpperName", "provicatorType", "promiderCount", "promideParent", "providerFactory", "proviperLine", "priderStr", "provideContext", "provpperSpec", "proviperLock", "promiderLock", "providerLock", "providableParent", "proiderSpec", "proideType", "provideKind", "provideSpec", "providableCount", "proviverLine", "provideType", "pricatorClass", "providerCount", "proviverType", "expliderKind", "provProviderClass", "providableType", "provProviderFactory", " provicatorClass", "provProviderName", "providerCode", "provideFunction", "promiderClass", "provainerFactory", "providerContext", "priderType", "proviperContext", "provpperClass", "providersCode", "providediderCode", "provIDERKey", "explainerType", "providerName", "providersName", "providersKey", "provideFactory", "pricatorStr", "provokerContext", "providerSpec", "providerLine", "provainerClass", "provpperType", "proideClass", "provIDERCode", "provIDERStr", "promiderType", "provIDERName", "expliderClass", "provideLock", "provicatorclass", "provokerClass", " provicatorType", "provIDERClass", " provicatorLine", "provokerLock", "promideCount", "provProviderSpec", " providerclass", "provoverClass", "promideLock", "proiderClass", "priderFunction", "provainerKind", "providerKey", "provideStr", "providedProviderKey", "provideCount", "provicatorFunction", "provideClass", "providedProviderCode", "providerclass", "providedProviderClass", "provProviderType", "provoverCount", "promiderParent", "proideName", "promiderLine", "provicatorLine", "provProviderKey", "providerType", "promideType", "provideclass", "promideContext", "providediderName", "provainerType", "providersClass", "expliderFactory", "explainerClass", "priderClass", "provokerLine", "provideParent", " provicatorclass", "providerKind", " providerType", "promideClass", "providedProviderName", "proviverClass", "provideLine", "proiderName", "providediderKey", "expliderType", "explainerKind", "provicatorClass", "promiderContext", "provIDERFunction", "provProviderCode", "provicatorStr"], "providerNamePrefix": ["providerNamePoix", "providerNamePreffix", "providerNamePoixed", "providerClassPrefprefix", "providerClassPrefixed", "providerClassPreuff", "providerNamePreix", "providerNameGenerix", "providerClassPreprefix", "providerNamePprefix", "providerNamesPreprefix", "providerNamePoprefix", "providerNamePouff", "providerNameGenerixed", "providerClassPreixed", "providerNamesPrefix", "providerNamePreixed", "providerNamesPrefixed", "providerNameRepluff", "providerClassPrefuff", "providerNamePrefuff", "providerClassPrefix", "providerNameGenerprefix", "providerNamesPrefprefix", "providerNamesPreix", "providerNamePreprefix", "providerNamePrefprefix", "providerNamePreuff", "providerClassPreix", "providerNameReplixed", "providerNameGenerfix", "providerNamePfix", "providerNamesPreixed", "providerNamePix", "providerNamePrefixed", "providerNamePixed", "providerNameReplix", "providerNameReplprefix", "providerNamesPreffix"], "providers": ["spiers", "dependides", "PROVides", "incider", "incides", "divides", "incistries", "provides", "proviers", "PROViders", "diviers", "dependiers", "Providers", "spiders", "PROVider", "spators", "spides", "divators", "dividers", "Provider", "provistries", "inciders", "Provistries", "provators", "Provides", "PROVistries", "dependiders", "dependators"], "key1": ["key18", "pick3", "value2", "pick1", "Key1", "KeyOne", "pick18", "keyOne", "Key2", "value3", " keyOne", "pick2", "Key18", " key18", "value1", "valueOne", " key3", "key3", "Key3"], "key2": ["key0", "keys1", "value2", "Key1", "KeyB", "keysB", " key0", "value0", "keyB", "Key4", "Key0", "value4", "Key2", "keys2", "keys0", " keyB", "key4", "value1", " key4"], "platformProviders": ["platformPlatformurers", " platformProvurers", "platformProduides", "platformProvider", "platformSuccessides", "platformStringiders", " platformPROVurers", "platformProduIDER", "platformStringides", "PlatformProviderides", "PlatformProvides", "platformPROVider", "platformProviderords", "platformSuccessuers", "platformRequords", "platformStringider", "platformRequiders", "platformProvIDER", "platformPROViders", "platformProviderIDER", "platformPlatformuers", "PlatformProviderords", "platformProvideriders", "platformPlatformords", "platformPROVides", "platformProviderider", "platformProviderids", " platformProvides", "platformprovids", "platformprovides", "PlatformProviders", "platformProvators", "platformProvurers", " platformProvider", "platformprovider", "platformPROVuers", "PlatformProviderators", "platformProvids", " platformPROVuers", "PlatformProviderIDER", "platformSuccessurers", "PlatformProviderids", "PlatformProvords", "PlatformProvIDER", "platformProviderators", "platformSuccessiders", "platformRequators", "platformPROVIDER", "platformPlatformators", "PlatformProvider", "PlatformProvideriders", "PlatformProviderider", "platformProduiders", "platformPlatformiders", "platformproviders", "platformPlatformides", " platformPROVider", "platformProvides", "PlatformProvids", "platformProduider", "platformProvuers", "platformRequides", " platformPROVides", "platformStringids", "platformProvords", "platformProviderides", " platformProvuers", "PlatformProvators", " platformPROViders", "platformPROVurers"], "in": ["source", "id", "input", "inc", "din", "win", "asin", "impl", "min", "nin", "conn", "l", "con", "out", "b", "login", "f", "as", "on", "data", "In", "pin", "stream", "again", "r", "inas", "resource", "thin", "serv", "ac", "isin", "inner", "pc", "init", "ins", "ax", "vin", "gin", "ini", "a", "ex", "m", "kin", "index", "image", "lock", "c", "socket", "ssl", "i", "IN", "err", "or", "inside", "inn", "rin", "is", "lin", "bin", "s"], "p": ["lp", "bp", "py", "h", "proc", "P", "pe", "d", "jp", "pb", "l", "properties", "pins", "fp", "part", "f", "prop", "po", "cp", "wp", "tp", "vp", "hp", "o", "patch", "per", "api", "t", "parser", "pr", "m", "v", "pro", "sp", "c", "j", "cache", "i", "np", "pp", "g", "pi", "ps", "op"], "e": ["ea", "pe", "be", "edge", "ee", "l", "que", "ue", "f", "E", "fe", "ec", "n", "r", "re", "es", "he", "esi", "el", "element", "er", "ne", "event", "ge", "o", "de", "see", "ae", "ve", "oe", "enter", "je", "v", "key", "se", "le", "entity", "ze", "c", "i", "ele", "ce", "eu", "et", "me", "te", "entry", "ie"], "provider": ["provicer", " provicer", "enciver", "prider", "divker", " provker", "peurer", "suppurer", "peider", "peender", "provIDER", "pride", "divicer", " proviver", "encide", "provker", "divide", "promker", "suppender", "provender", "devker", "enciders", "devince", "devide", "divider", " provide", "peIDER", "operurer", "encider", "promide", "prker", "proviver", "promider", "provide", "broince", "broide", "dividers", "operIDER", "diviver", "suppider", "pricer", "promince", "devider", "suppIDER", "broker", "province", "operender", "provurer", "operider", "broider"], "classpathProviders": ["classpathprovcers", "classcaseProduorers", "classpathProvppers", "classpathprovonents", "classloaderprovides", "classpathProduppers", " class\n", "classpathDividers", "classloader", "classpathDivcers", "classpathProvonents", "classloaderprovcers", "classpathProvorers", "classloaderProvcers", "classpathProduappers", "classloaderProvonents", "classcaseProviders", "classcaseProvorers", "classcaseProvppers", "classpathProduiders", "classpathDivides", "classpathPredappers", "class\n", "Classloader", "classpathPredppers", " classloader", "classpathPredorers", "classcaseProvappers", "classloaderProviders", "clloader", "classpathProvcers", "classcaseProduppers", "classpathProduorers", "classpathprovides", "classcaseProduiders", "Class\n", "classcaseProduappers", "classloaderprovonents", "classloaderProvides", "classpathPrediders", "classpathProvappers", "classpathProvides", "cl\n", "classloaderproviders", "classpathDivonents", "classpathproviders"], "url": ["source", "resources", "l", "http", "app", "client", "object", "base", "loader", "data", "href", "class", "r", "resource", "server", "config", "address", "element", "name", "sl", "string", "path", "uri", "file", "URL", "Url", "str", "location"]}}
{"id1": "17977185", "id2": "19650324", "code1": "    private String getServerData(String returnString) {\n        InputStream is = null;\n        String result = \"\";\n        ArrayList<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>();\n        nameValuePairs.add(new BasicNameValuePair(\"usuario\", Login.usuario));\n        nameValuePairs.add(new BasicNameValuePair(\"amigoABorrar\", amigoABorrar.trim()));\n        nameValuePairs.add(new BasicNameValuePair(\"grupo\", MisGrupos.seleccion.trim()));\n        try {\n            HttpClient httpclient = new DefaultHttpClient();\n            HttpPost httppost = new HttpPost(returnString);\n            httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = httpclient.execute(httppost);\n            HttpEntity entity = response.getEntity();\n            is = entity.getContent();\n        } catch (Exception e) {\n            Log.e(\"AmigosPorGrupo\", \"Error en la conexion http \" + e.toString());\n        }\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"iso-8859-1\"), 8);\n            String line = reader.readLine();\n            is.close();\n            result = line.trim().toString();\n            Log.d(\"AmigosPorGrupo\", \"Longitud line: \" + line.trim().length());\n        } catch (Exception e) {\n            Log.e(\"AmigosPorGrupo\", \"Error converting result \" + e.toString());\n        }\n        Log.d(\"AmigosPorGrupo\", \"Funciono json\" + result);\n        return result;\n    }\n", "code2": "        public void perform(Context context) {\n            Long workflowIdParentProcess;\n            SimpleProvider config;\n            VariablesContext var;\n            String xmldocument;\n            Service service;\n            Object[] param;\n            String method;\n            String wsurl;\n            Object ret;\n            Call call;\n            URL url;\n            try {\n                var = Variables.getContext();\n                if (var.get(\"wsurl\") == null || var.get(\"method\") == null) {\n                    System.out.println(\"----- Need the url of the webservice and the method! -----\");\n                    log_.error(\"Need the url of the webservice and the method!\");\n                    return;\n                }\n                method = var.get(\"method\");\n                wsurl = var.get(\"wsurl\");\n                url = new java.net.URL(wsurl);\n                try {\n                    url.openConnection().connect();\n                } catch (IOException ex) {\n                    System.out.println(\"----- Could not connect to the webservice! -----\");\n                    log_.error(\"Could not connect to the webservice!\");\n                    return;\n                }\n                if (var.get(\"param0\") == null || var.get(\"param1\") == null) {\n                    System.out.println(\"----- Need parameters! -----\");\n                    log_.error(\"Need parameters!\");\n                    return;\n                }\n                xmldocument = var.get(\"param0\");\n                workflowIdParentProcess = new Long(var.get(\"param1\"));\n                param = new Object[] { xmldocument, workflowIdParentProcess };\n                config = new SimpleProvider();\n                config.deployTransport(\"http\", new HTTPSender());\n                service = new Service(config);\n                call = (Call) service.createCall();\n                call.setTargetEndpointAddress(new java.net.URL(wsurl));\n                call.setOperationName(new QName(\"http://schemas.xmlsoap.org/soap/encoding/\", method));\n                try {\n                    ret = call.invoke(param);\n                    context.set(CTX_ANSW, \"=> notifyIhk invoked - Result: \" + ret);\n                    System.out.println(\"----- notifyIhk invoked! -----\");\n                    log_.info(\"notifyIhk invoked!\");\n                } catch (RemoteException ex) {\n                    System.out.println(\"----- Could not invoke the method! -----\");\n                    log_.error(\"Could not invoke the method!\");\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace(System.err);\n            }\n        }\n", "label": 0, "substitutes": {"returnString": ["resultText", " returnValue", "returnValue", "outputFile", "ReturnString", "ReturnStr", "returnText", "resultFile", "resultString", "outputString", "ReturnValue", "resultValue", "resultStr", "outputText", "returnFile", "ReturnText", "returnStr", " returnText", "ReturnFile", " returnStr", "outputStr"], "is": ["get", "page", "id", "url", "si", "web", "xml", "ils", "iter", "isa", "ws", "io", "conn", "ais", "http", "isl", "in", "object", "part", "as", "p", "data", "iss", "was", "stream", "os", "resource", "es", "serv", "address", "info", "ris", "inner", "ai", "ir", "js", "has", "isi", "it", "ui", "e", "s", "iris", "IS", "api", "mis", "content", "iri", "ri", "il", "lis", "image", "ios", "its", "uri", "error", "i", "err", "or", "details", "service", "array", "bis", "Is", "cms", "ar", "iso", "ps", "res", "ip", "ib", "ie"], "nameValuePairs": ["nameValuesPair", "nameValueFair", "nameNamePair", "nameNamepars", "nameValueCairs", "nameValueCars", "nameNamePagers", "nameNameFars", "nameValuePares", "nameValuesPairs", "nameNameCars", "nameValuesCairs", "nameNamepares", "nameValueHorts", "nameValueVars", "nameStringpairs", "nameValuepairs", "nameNamepair", "nameValueVares", "nameValueports", "nameValueFairs", "nameValuesParms", "nameValueFars", "nameValuesPars", "nameStringparms", "nameValueHars", "nameValuepagers", "nameValuepares", "nameStringpair", "nameValuepars", "nameValuesCair", "nameValueHagers", "nameValueVairs", "nameNamepairs", "nameNamePares", "nameValueparms", "nameValuePagers", "nameNameFairs", "nameNamePars", "nameValuePorts", "nameStringpars", "nameValueVair", "nameValueParms", "nameStringPair", "nameStringPars", "nameStringPairs", "nameValuesCars", "nameNameParms", "nameValueCarms", "nameValueHairs", "nameNameCairs", "nameValueCares", "nameValuepair", "nameNameCarms", "nameNameForts", "nameNameFagers", "nameNamePairs", "nameStringParms", "nameValuePars", "nameNameCair", "nameValueFagers", "nameValueForts", "nameValuesCarms", "nameValuePair", "nameNamePorts", "nameValueCair", "nameValueFarms"], "httpclient": ["phpco", "webClient", " httpClient", "phpresource", "Httpclient", " httpresource", "phpClient", " httpconnection", "httpClient", "httpco", "httpconnection", " httpco", "Httpconnection", "webclient", "phpclient", "phpconnection", "Httpco", "HttpClient", "webresource", "webconnection", "httpresource"], "httppost": ["httpost", "httepost", "httPPpost", " httpposter", "httpcoster", "httpppost", "httPPost", "httPPosition", "httpport", "httppoint", "httppeoster", "recicpport", "htteppost", "httpcost", "httppeost", "httposter", "httcpposition", "recicpppost", "httpppoint", "recippost", " httepoint", "httcpppost", "httppppost", "httPPort", " httppoint", " httepPost", " htteposter", "httppPost", "httepPost", " httppPost", "httphosition", " httepost", "httpcPost", "httpPost", "httphpost", "recipppost", "httpcoint", "httppepost", "recipposition", "httpoint", "httppeoint", "httphost", "recicppost", "htteposter", "httcppost", "recipport", "httphort", "httcpport", "httpposition", "recicpposition", "httepoint", "httppposter", "httpposter"], "response": ["host", "page", "successful", "respond", "parent", "default", "connection", "success", "feed", "reply", "message", "output", "http", "request", "object", "client", "application", "onse", "data", "re", "resource", "server", "serv", "body", "event", "full", "json", "api", "wave", "status", "Response", "document", "error", "resp", "received", "collection", "entry"], "entity": ["page", "parent", "ent", "connection", "xml", "output", "conn", "article", "object", "client", "environment", "onse", "data", "ec", "resource", "server", "el", "equ", "element", "body", "event", "e", "Entity", "unit", "json", "ae", "instance", "comment", "content", "issue", "pse", "document", "image", "file", "error", "person", "ilo", "em", "collection", "entry"], "reader": ["source", "ner", "read", "input", "Reader", "feed", "buffer", "iter", "keeper", "io", "rator", "ler", "in", "row", "loader", "data", "oder", "worker", "stream", "ruby", "r", "resource", "handler", "server", "her", "writer", "inner", "er", "e", "per", "bird", "parser", "ri", "i", "or"], "line": ["page", "url", "link", "connection", "lf", "buffer", "lines", "message", "l", "letter", "end", "LINE", "cell", "Line", "row", "profile", "data", "ine", "inline", "lo", "sync", "name", "body", "ge", "e", "unit", "log", "status", "le", "se", "string", "frame", "pass", "file", "error", "code", "header", "block", "lin", "sheet", "str", "sl", "entry"], "result": ["source", "page", "entry", "value", "continue", "notice", "default", "url", "msg", "our", "success", "dict", "Result", "lines", "message", "output", "request", "description", "diff", "root", "row", "data", "resource", "match", "ret", "server", "name", "results", "report", "json", "text", "comment", "found", "instance", "content", "df", "status", "job", "Response", "all", "string", "up", "answer", "file", "error", "code", "err", "search", "db", "record", "array", "date", "valid", "current", "order", "reason", "test", "res", "dat"]}}
{"id1": "17972560", "id2": "19645104", "code1": "    private void folderFileChooserActionPerformed(java.awt.event.ActionEvent evt) {\n        if (evt.getActionCommand().equals(JFileChooser.APPROVE_SELECTION)) {\n            File selectedFolder = folderFileChooser.getSelectedFile();\n            File collectionCopyFile;\n            String newDocumentName;\n            Document newDocument;\n            StringBuilder distinguisherReplacer = new StringBuilder();\n            int matchingFilenameDistinguisher;\n            String nextToken;\n            Term newTerm;\n            String userHome;\n            String fileSeparator;\n            int userOption;\n            ArrayList<File> folderTextFiles = new ArrayList<File>();\n            ArrayList<File> folderRejectedFiles = new ArrayList<File>();\n            HashSet<File> ignoredFiles = new HashSet<File>();\n            FileNameExtensionFilter textFileFilter = new FileNameExtensionFilter(\"Text Files\", \"txt\");\n            Scanner tokenizer = null;\n            FileChannel fileSource = null;\n            FileChannel collectionDestination = null;\n            HashMap<String, Integer> termHashMap = null;\n            Index collectionIndex = activeCollection.getIndex();\n            int documentTermMaxFrequency;\n            int currentTermFrequency;\n            for (File folderFile : selectedFolder.listFiles()) if (textFileFilter.accept(folderFile)) folderTextFiles.add(folderFile); else folderRejectedFiles.add(folderFile);\n            for (File selectedFile : folderTextFiles) {\n                newDocumentName = selectedFile.getName();\n                newDocument = new Document(newDocumentName);\n                if (activeCollection.containsDocument(newDocument)) {\n                    matchingFilenameDistinguisher = 1;\n                    newDocumentName = newDocumentName.concat(\"(\" + matchingFilenameDistinguisher + \")\");\n                    newDocument.setDocumentName(newDocumentName);\n                    while (activeCollection.containsDocument(newDocument)) {\n                        matchingFilenameDistinguisher++;\n                        newDocumentName = distinguisherReplacer.replace(newDocumentName.length() - 2, newDocumentName.length() - 1, new Integer(matchingFilenameDistinguisher).toString()).toString();\n                        newDocument.setDocumentName(newDocumentName);\n                    }\n                }\n                termHashMap = new HashMap<String, Integer>();\n                try {\n                    tokenizer = new Scanner(new BufferedReader(new FileReader(selectedFile)));\n                    tokenizer.useDelimiter(Pattern.compile(\"\\\\p{Space}|\\\\p{Punct}|\\\\p{Cntrl}\"));\n                    while (tokenizer.hasNext()) {\n                        nextToken = tokenizer.next().toLowerCase();\n                        if (!nextToken.isEmpty()) if (termHashMap.containsKey(nextToken)) termHashMap.put(nextToken, termHashMap.get(nextToken) + 1); else termHashMap.put(nextToken, 1);\n                    }\n                    documentTermMaxFrequency = 0;\n                    for (String term : termHashMap.keySet()) {\n                        newTerm = new Term(term);\n                        if (!collectionIndex.termExists(newTerm)) collectionIndex.addTerm(newTerm);\n                        currentTermFrequency = termHashMap.get(term);\n                        if (currentTermFrequency > documentTermMaxFrequency) documentTermMaxFrequency = currentTermFrequency;\n                        collectionIndex.addOccurence(newTerm, newDocument, currentTermFrequency);\n                    }\n                    newDocument.setTermMaxFrequency(documentTermMaxFrequency);\n                    activeCollection.addDocument(newDocument);\n                    userHome = System.getProperty(\"user.home\");\n                    fileSeparator = System.getProperty(\"file.separator\");\n                    collectionCopyFile = new File(userHome + fileSeparator + \"Infrared\" + fileSeparator + activeCollection.getDocumentCollectionName() + fileSeparator + newDocumentName);\n                    collectionCopyFile.createNewFile();\n                    fileSource = new FileInputStream(selectedFile).getChannel();\n                    collectionDestination = new FileOutputStream(collectionCopyFile).getChannel();\n                    collectionDestination.transferFrom(fileSource, 0, fileSource.size());\n                } catch (FileNotFoundException e) {\n                    System.err.println(e.getMessage() + \" This error should never occur! The file was just selected!\");\n                    return;\n                } catch (IOException e) {\n                    userOption = JOptionPane.showConfirmDialog(this, \"A file insertion has failed. If you want it to ignore this\" + \"file, press YES, else press NO to repeat the insertion\", \"FileInsertionFailure\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                    if (userOption == JOptionPane.NO_OPTION) {\n                        activeCollection.removeDocument(newDocument);\n                        for (String term : termHashMap.keySet()) {\n                            collectionIndex.removeAllOccurences(new Term(term), newDocument);\n                        }\n                        folderTextFiles.add(selectedFile);\n                    } else ignoredFiles.add(selectedFile);\n                } finally {\n                    try {\n                        if (tokenizer != null) tokenizer.close();\n                        if (fileSource != null) fileSource.close();\n                        if (collectionDestination != null) collectionDestination.close();\n                    } catch (IOException e) {\n                        System.err.println(e.getMessage());\n                    }\n                }\n            }\n            if (ignoredFiles.size() > 0) {\n                IgnoredFilesDialog ignoredFilesDialog = new IgnoredFilesDialog(ignoredFiles, this);\n                ignoredFilesDialog.setVisible(true);\n            }\n            processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));\n        } else if (evt.getActionCommand().equalsIgnoreCase(JFileChooser.CANCEL_SELECTION)) processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));\n    }\n", "code2": "    public void write(HttpServletResponse res) throws MalformedURLException, IOException {\n        if (m_url.equals(\"\")) {\n            return;\n        }\n        URL url = new URL(m_url);\n        URLConnection con = url.openConnection();\n        con.setUseCaches(false);\n        BufferedInputStream in = new BufferedInputStream(con.getInputStream(), BUF_SIZE);\n        BufferedOutputStream out = new BufferedOutputStream(res.getOutputStream());\n        byte[] buf = new byte[BUF_SIZE];\n        int size = 0;\n        String contentType = con.getContentType();\n        if (contentType != null) {\n            res.setContentType(con.getContentType());\n        }\n        while ((size = in.read(buf)) > 0) {\n            out.write(buf, 0, size);\n        }\n        out.flush();\n        out.close();\n        in.close();\n    }\n", "label": 0, "substitutes": {"evt": [" evte", "evts", "ekte", "evmt", "ekt", " Evts", "evT", " Evtz", "evte", " Evte", " Evt", " evts", " evtz", "emt", "evtz", " evT", "ekT", "emte", "ekmt", " evmt", " awte", "emmt", " awtz", " awt", "emT", " awts"], "selectedFolder": ["currentArea", "lectedFolder", " selectedDir", "lectedArea", " selectedArea", "selectedContainer", " selectedDirectory", "lectedContainer", "currentDirectory", "currentFolder", "currentFile", "currentContainer", "lectedDirectory", " selectedContainer", "selectedDir", "lectedDir", "currentDir", "lectedFile", "selectedArea", "selectedDirectory"], "collectionCopyFile": ["collectionActivefile", "collectionEditedSourceFile", "collectionEditedFile", " collectionCopyfile", " collectionCopySourceFile", "collectionActiveFile", "collectionActiveSourceFile", "collectionCopyfile", "collectionEditedfile", "collectionCopySourceFile"], "newDocumentName": ["newdocumentUrl", "newFileLine", "freshDocumentLength", "newDocumentDefinition", "newDocAlias", "newFeaturePath", "newProductname", " newDocumentInfo", "newMediaName", "oldDocumentName", "newFileDefinition", "newQuerySync", " newDocumentNames", "NEWDocumentAlias", "newFileUrl", "newDocumentNames", " newDirectoryDefinition", "newContextName", " newDocumentUrl", "newProductAlias", "newFileNames", "newDocUrl", "newDirectoryName", " newDocumentLine", "olddocumentname", "NEWDocAlias", "newDocumentLine", "initialDocumentInfo", "newProductName", "newFileName", "newDocumentSync", " newDocumentAlias", "olddocumentAlias", "newConnectionname", "newQueryInfo", "newDocumentAlias", "newdocumentname", "newdocumentPath", "newdocumentInfo", "freshApplicationname", "freshDocumentName", " newDocumentPath", " newDirectoryInfo", "newConnectionLength", "newDocname", "newDirectoryNames", "newFeatureName", "newFeatureUrl", "newDocSync", "newDocumentPath", "oldDocumentAlias", "newFileAlias", "newdocumentLine", "newApplicationLength", " newDocumentDefinition", "NEWDocumentSync", "NEWDocName", "newDirectoryInfo", "freshApplicationLength", "initialMediaName", " newDirectoryUrl", "newDocumentUrl", "newApplicationName", "NEWDocumentName", "newdocumentAlias", " newDirectoryLine", "newContextname", "newFilePath", "newContextLength", "initialMediaInfo", "newQueryAlias", "newdocumentNames", "newdocumentTime", "NEWDocSync", "newDocumentLength", " newDirectoryName", "newDocumentname", "newdocumentSync", " newDirectoryAlias", "newDirectoryUrl", "newQueryTime", "newQueryName", "newMediaInfo", "NEWDocumentTime", " newDirectoryPath", "oldDocumentname", "newDirectoryAlias", "newdocumentName", "freshApplicationName", "initialDocumentName", "newDocName", "newApplicationname", "newDirectoryLine", "newDirectoryPath", "newDocDefinition", "NEWDocTime", "newFileInfo", "olddocumentName", "newConnectionName", "freshDocumentname", "newDocTime", "newDocumentTime", "newDocPath", "newDirectoryDefinition", "newDocumentInfo", " newDirectoryNames"], "newDocument": ["viewdocument", "nextNumber", "differentdocument", "differentProduct", "olddocument", "oldDirectory", "nextNode", "nextDoc", "newProduct", "currentDocument", "freshDirectory", " newContent", "newContent", "nextProduct", "differentContent", "freshProduct", "differentDocument", "oldProduct", " newDoc", "freshDocument", "oldDocument", "newNode", "currentDoc", " newDocuments", " newProduct", "newNumber", "newSession", "differentDocuments", "NewFile", "NewDoc", "freshDoc", "nextDocument", "Newdocument", "NewDocument", "nextContent", "oldDoc", "newDocuments", "NewNode", "currentFile", "currentdocument", "viewDoc", "newFile", "differentSession", "viewDocument", " newdocument", "nextFile", " newNumber", "freshNumber", "oldSession", "newdocument", "freshSession", "newDoc", "differentDirectory", "nextdocument", " newFile", "nextDocuments", "newDirectory", " newNode", "viewDocuments", "oldDocuments", "NewDocuments"], "distinguisherReplacer": ["distinguisherPrefacer", "distinguisherPlacers", "distinguishersPlacer", "distinguishReplacer", "distinguishReplacement", "distinguisherPrefacement", "distinguisherReplacers", "distinguishreplacement", "distinguishRepliner", "distinguishReplacers", "distinguisherJoaser", "distinguisherJoacer", "distinguisherPlaser", "distinguishreplacer", "distinguishersReplaser", "distinguisherPlacer", "distinguisherPlformer", "distinguisherreplacer", "distinguisherrepliner", "distinguisherJoformer", "distinguishersReplformer", "distinguisherPrefiner", "distinguishersReplacement", "distinguisherreplacement", "distinguishreplacers", "distinguisherPlacement", "distinguishersPlaser", "distinguisherPliner", "distinguisherPrefformer", "distinguisherReplaser", "distinguishersReplacer", "distinguisherreplacers", "distinguisherReplformer", "distinguisherPrefaser", "distinguishersPlformer", "distinguisherReplacement", "distinguisherJoacement", "distinguisherPrefacers", "distinguishersPlacement", "distinguisherRepliner", "distinguishrepliner"], "matchingFilenameDistinguisher": ["matchingFilenameDistinctisher", "matchingFilenameDistinguishers", "matchingFilenameDistributer", "matchingFilenameRestinctisher", "matchingFilenameDistanguishes", "matchingFilenameDistinctiner", "matchingFilenameDistinctioninger", "matchingFilenameContinguiner", "matchingFilenameRestinguishedcher", "matchingFilenameChinctionisher", "matchingFilenameChinguinger", "matchingFilenameRestinguishedishing", "matchingFilenameDistinguishedisher", "matchingFilenameChinctionishes", "matchingFilenameDistinguer", "matchingFilenameContinguishers", "matchingFilenameDistortioniner", "matchingFilenameDistinguish", "matchingFilenameDistortionishers", "matchingFilenameDistinquinger", "matchingFilenameDistinguished", "matchingFilenameContortionishers", "matchingFilenameDistinctcher", "matchingFilenameDistanguisher", "matchingFilenameRestinctishers", "matchingFilenameDistinctioncher", "matchingFilenameChinguished", "matchingFilenameContinguisher", "matchingFilenameDistricishers", "matchingFilenameDistributish", "matchingFilenameDistortionish", "matchingFilenameDistinquisher", "matchingFilenameDistriccher", "matchingFilenameRestinguish", "matchingFilenameDistributishing", "matchingFilenameDistinctishers", "matchingFilenameRestinguisher", "matchingFilenameDistricishing", "matchingFilenameDistingucher", "matchingFilenameDistributcher", "matchingFilenameDistinctionishes", "matchingFilenameDistinguishedishing", "matchingFilenameDistinctionished", "matchingFilenameChinguishes", "matchingFilenameRestingucher", "matchingFilenameContortionisher", "matchingFilenameDistinguishedishers", "matchingFilenameDistinctionisher", "matchingFilenameDistinctish", "matchingFilenameDistinguishedcher", "matchingFilenameDistinctionishers", "matchingFilenameRestinguishers", "matchingFilenameDistributishers", "matchingFilenameRestinguishedish", "matchingFilenameRestinguishing", "matchingFilenameDistinguinger", "matchingFilenameRestincter", "matchingFilenameDistinguishediller", "matchingFilenameDistinguishing", "matchingFilenameChinctioninger", "matchingFilenameDistanguished", "matchingFilenameRestinctish", "matchingFilenameDistinctioniner", "matchingFilenameDistinquished", "matchingFilenameDistinguiner", "matchingFilenameChinguisher", "matchingFilenameRestinguiller", "matchingFilenameRestinguishedisher", "matchingFilenameDistricisher", "matchingFilenameDistortioniller", "matchingFilenameDistinquishes", "matchingFilenameDistortioncher", "matchingFilenameRestinguer", "matchingFilenameContingucher", "matchingFilenameRestinguishediller", "matchingFilenameDistinguishedish", "matchingFilenameDistributisher", "matchingFilenameDistinguiller", "matchingFilenameDistinctioniller", "matchingFilenameDistinguishes", "matchingFilenameContortioniner", "matchingFilenameDistinctionish", "matchingFilenameRestinguishedishers", "matchingFilenameDistinguisheder", "matchingFilenameContortioncher", "matchingFilenameDistanguinger", "matchingFilenameDistincter", "matchingFilenameDistortionisher", "matchingFilenameChinctionished"], "nextToken": ["NextTerm", "newWord", " nextTerm", "NextWord", "NextTokens", "nextWord", "nextTokens", "newToken", "newTokens", " nextWord", " nextTokens", "nextTerm", "NextToken"], "newTerm": [" nextText", "newterm", " newWord", " nextTerm", " newText", " nextterm", "nextWord", " nextWord", "nextterm", "nextText", "newText", "nextTerm", " newterm", "newWord"], "userHome": [" userLocation", "humanHome", "UserHome", "Userhome", " userhome", "humanLocation", "userLocation", "UserLocation", "userhome", "humanhome"], "fileSeparator": ["fileDelatation", "fileDelatate", "fileDelatator", "fileSeparate", "fileSepparator", "fileSeparateator", "fileSeparateation", "fileSepparation", "fileDelarate", "fileSeparation", "fileSepparater", "fileDelatater", "fileDelarater", "fileSeparateater", "fileSeparater", "fileSepparate", "fileDelarator", "fileSeparateate", "fileSepatator", "fileDelaration", "fileSepatater", "fileSepatate", "fileSepatation"], "userOption": [" userOptions", "userEnd", "userOpt", "useOptions", "useOpt", "fileOption", " userEnd", " userOpt", "fileEnd", "fileOpt", "useOption", "fileOptions", "useEnd", "userOptions"], "folderTextFiles": ["folderInputSources", "folderEmptyParents", " folderTextSources", "folderReadFile", "folderTEXTFiles", " folderTextBooks", "folderTextBooks", "folderReadFiles", " folderInputBooks", " folderTextParents", "folderTextPages", "folderEmptyFiles", "folderTEXTPages", "FolderTextPages", "foldertextFiles", "folderInputPages", "folderTEXTBooks", " folderInputFiles", "folderInputItems", "folderReadPages", "folderTextParents", " folderInputItems", "FolderReadFile", " folderInputPages", "folderTEXTFile", "foldertextParents", "foldertextItems", "FolderTextFile", " folderTextfiles", " folderTextItems", "FolderReadFiles", " folderInputfiles", "folderTextSources", "folderInputFiles", " folderInputSources", "folderInputParents", " folderInputParents", "FolderTextFiles", "foldertextBooks", "folderEmptySources", "folderInputBooks", "foldertextSources", "folderTEXTItems", "folderInputfiles", " folderTextPages", "folderTextItems", "folderEmptyfiles", "FolderReadPages", "foldertextPages", "foldertextfiles", "folderTextfiles", "folderTextFile"], "folderRejectedFiles": ["folderPrejectedPages", "folderRejectedItems", "folderReceivedFile", "folderPrejectionFiles", "folderPreceivedItems", "folderRecludedFiles", "folderRejectionFiles", "folderReceivedItems", "folderReruptedFile", "folderPreceivedFile", "folderPrejectedFile", "folderReruptedItems", "folderPrejectionItems", "folderRejectionDocuments", "folderRecludedFile", "folderReceivedFiles", "folderReruptedDocuments", "folderReruptedFiles", "folderRejectionPages", "folderPreceivedPages", "folderPrejectionFile", "folderPrejectionDocuments", "folderPrejectedDocuments", "folderRecludedItems", "folderRejectedDocuments", "folderReruptedPages", "folderReceivedPages", "folderRejectedPages", "folderRejectionItems", "folderRecludedDocuments", "folderRejectionFile", "folderPrejectedItems", "folderPreceivedFiles", "folderRejectedFile", "folderPrejectedFiles"], "ignoredFiles": ["ignoveredParents", "colorableFolder", "ignoveredFiles", "ignouredParents", "ignorableFolder", "coloredFiles", "ignouredFiles", "colorableParents", "ignoredFolder", "coloredParents", "coloredFS", "ignoveredFS", "colorableFiles", "ignorableFS", "ignorableFiles", "ignoveredFolder", "ignorableParents", "ignouredFS", "ignouredFolder", "ignoredParents", "colorableFS", "coloredFolder", "ignoredFS"], "textFileFilter": ["textLineFilter", "classfileParser", "classFileHandler", "textFileParser", "classfileFilter", "textMessageFilter", "classFileFilter", "textFilesFilter", "classFileParser", "classfileManager", "textFilesHandler", "textMessageHandler", "textStringReader", "textLineManager", "TextFilesHandler", "textFileReader", "TextFilesReader", "textFilesExt", "TextFileReader", "textStringHandler", "textFileHandler", "classFileManager", "textFileExt", "TextFileFilter", "TextFileExt", "textfileHandler", "textLineHandler", "TextFilesExt", "textFilesManager", "TextFilesFilter", "TextFileHandler", "textLineParser", "textfileParser", "textStringFilter", "classfileHandler", "textFileManager", "textMessageExt", "textFilesReader", "textFilesParser", "textMessageReader", "textfileFilter", "textStringExt", "textfileManager"], "tokenizer": ["initializer", " tokenize", " tokenization", "tokenization", "Tokenized", "Tokenize", "tokenized", "Tokenizer", " tokenized", "initialized", "tokenize", "Tokenization", "initialize", "initialization"], "fileSource": ["FileResource", "collectionService", "FileSources", "selectionSource", "selectionResource", "FileService", "fileResource", "selectionService", "collectionSource", "collectionResource", "FileSource", "fileService", "collectionSources", "selectionSources", "fileSources"], "collectionDestination": ["collectionOrdribution", "collectionDestinator", "archiveDestribution", "collectionDestinate", "archiveOrdribution", "collectionOrdinator", "collectionHomeinator", "archiveDestinator", "archiveOrdinator", "collectionOrdinate", "collectionOrdination", "collectiondestinate", "collectiondestination", "collectionHomeination", "collectionDestribution", "archiveOrdinate", "archiveDestinate", "archiveOrdination", "collectiondestinator", "collectionHomeinate", "collectionHomeribution", "archiveDestination", "collectiondestribution"], "termHashMap": ["termHandMap", " termHandArray", "termChSet", "termHashSet", "termHashList", "TermMatMap", "termCacheSet", "termHashArray", "TermMatSet", "termChArray", "termHMap", "termMatList", "termHList", "termHandList", " termHashSet", "TermHashList", " termHandSet", "TermMatList", "TermMatArray", "termShSet", "termCacheMap", "TermHashSet", "TermHashArray", "termShMap", "termCacheList", "termMatSet", "termCacheArray", "termHSet", " termHandList", "termHandArray", " termHashList", " termHandMap", "termMatMap", "termChMap", "termChList", " termHashArray", "termShArray", "termMatArray", "termHandSet", "TermHashMap", "termShList", "termHArray"], "collectionIndex": ["collIndex", "containerIndex", " collectionId", "collectionAddress", "collId", "containerindex", "containerAddress", " collectionindex", "collindex", "collectionindex", "collAddress", " collectionAddress", "collectionId", "containerId"], "documentTermMaxFrequency": ["documentTermLimitFraction", "documentTermLimitFrequent", "documentTermLimitRepidelity", "documentTermMaxFrequent", "documentTermMaxWidelity", "documentTermMaxFraction", "documentTermLimitReprequency", "documentTermMaxWrequency", "documentTermMaxfraction", "documentTermLimitReprequent", "documentTermMaxfidelity", "documentTermLimitRepraction", "documentTermMaxfrequent", "documentTermMaxfrequency", "documentTermMaxRepidelity", "documentTermMaxReprequency", "documentTermMaxReprequent", "documentTermMaxRepraction", "documentTermMaxFidelity", "documentTermMaxWraction", "documentTermMaxWrequent", "documentTermLimitFrequency", "documentTermLimitFidelity"], "currentTermFrequency": ["currentWordFreshold", "currentTermPrequently", "currentWordRefrance", "currentTermPrance", "currentTermFrance", "currentTermRefrequently", "currentTermPreshold", "currentWordRefrequently", "currentTermPrequency", "currentTermRefreshold", "currentWordFrance", "currentTermRefrance", "currentWordRefreshold", "currentWordRefrequency", "currentTermBFrequency", "currentTermRefrequency", "currentTermBFrequently", "currentWordFrequently", "currentTermBFrance", "currentTermBFreshold", "currentTermFreshold", "currentWordFrequency", "currentTermFrequently"], "folderFile": ["draftChild", "folderImage", " folderFolder", "FolderFile", "draftF", "directoryFolder", "draftFile", "containerFiles", "archiveFolder", "archiveLine", "folderFolder", "projectFolder", "folderLine", "containerfile", "projectChild", "Folderfile", "containerImage", "flatfile", "folderF", "archiveFile", "directoryfile", "archiveFiles", " folderFiles", "folderChild", "directoryLine", "flatFile", "draftFolder", "projectF", "archiveChild", "FolderFiles", "FolderImage", "archivefile", "directoryFile", "folderfile", "flatFolder", "archiveF", "projectFile", "directoryLocal", " folderImage", "folderLocal", " folderLine", " folderLocal", "directoryFiles", " folderfile", "containerFile", "flatLocal", "folderFiles"], "selectedFile": ["selectionPage", "copyFile", "copyFiles", " selectedDocument", "currentDocument", "copyFolder", " selectedFiles", " selectedPage", "copyDocument", "selectionFolder", "currentFolder", "currentFile", "selectionFiles", "currentPage", "selectedDocument", "selectionDocument", "selectedPage", "selectionFile", "selectedFiles"]}}
{"id1": "10735044", "id2": "880885", "code1": "    public static byte[] getBytes(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        int contentLength = connection.getContentLength();\n        ByteArrayOutputStream tmpOut;\n        if (contentLength != -1) {\n            tmpOut = new ByteArrayOutputStream(contentLength);\n        } else {\n            tmpOut = new ByteArrayOutputStream(16384);\n        }\n        byte[] buf = new byte[512];\n        while (true) {\n            int len = in.read(buf);\n            if (len == -1) {\n                break;\n            }\n            tmpOut.write(buf, 0, len);\n        }\n        in.close();\n        tmpOut.close();\n        byte[] array = tmpOut.toByteArray();\n        return array;\n    }\n", "code2": "    public static void main(final String... args) {\n        int returnCode = 0;\n        if (args.length == 0) {\n            System.err.println(\"Usage: JWGet url...\");\n            returnCode++;\n        }\n        final byte[] buf = new byte[8192];\n        for (final String arg : args) {\n            try {\n                final URL url = new URL(arg);\n                OutputStream out = null;\n                InputStream in = null;\n                try {\n                    final URLConnection con = url.openConnection();\n                    in = con.getInputStream();\n                    final String location = con.getHeaderField(\"Content-Location\");\n                    final String outputFilename = new File((location != null ? new URL(url, location) : url).getFile()).getName();\n                    System.err.println(outputFilename);\n                    out = new FileOutputStream(outputFilename);\n                    for (int bytesRead; (bytesRead = in.read(buf)) != -1; out.write(buf, 0, bytesRead)) ;\n                } catch (final IOException e) {\n                    System.err.println(e);\n                    returnCode++;\n                } finally {\n                    try {\n                        in.close();\n                    } catch (final Exception ignore) {\n                    }\n                    try {\n                        out.close();\n                    } catch (final Exception ignore) {\n                    }\n                }\n            } catch (final MalformedURLException e) {\n                System.err.println(e);\n                returnCode++;\n            }\n        }\n        System.exit(returnCode);\n    }\n", "label": 0, "substitutes": {"url": ["source", "id", "user", "open", "download", "plugin", "conn", "l", "http", "client", "object", "request", "bug", "loc", "base", "loader", "remote", "resource", "server", "config", "address", "name", "cli", "string", "rule", "image", "path", "cache", "c", "file", "uri", "ssl", "or", "URL", "Url", "position", "proxy", "str", "sl"], "connection": ["source", "cone", "general", "open", "between", "io", "output", "conn", "l", "communication", "http", "con", "out", "b", "client", "connected", "loc", "application", "channel", "directory", "resource", "ctx", "server", "org", "config", "condition", "inner", "tc", "password", "relation", "lc", "cli", "session", "image", "connect", "lock", "socket", "c", "uri", "context", "URL", "database", "conv", "Connection", "proxy", "use"], "in": ["reader", "id", "input", "inc", "din", "conn", "http", "con", "out", "b", "client", "login", "as", "data", "In", "into", "stream", "pin", "inner", "init", "ins", "ini", "m", "kin", "cin", "socket", "c", "uri", "i", "IN", "file", "err", "inn", "is", "ilo", "start", "lin", "bin", "ie"], "contentLength": ["ContentType", "codelength", " contentId", "ContentLen", "contentLen", " contentType", "responsePath", " contentLevel", "codeBuffer", "responseType", "ContentSize", "Contentlength", "loadLength", "loadLen", "contentId", " contentlength", "contentPath", "loadId", "contentBuffer", "contentLevel", "ContentId", "ContentBuffer", "ContentLength", "responseLength", " contentLen", "ContentPath", "contentSize", "codeLength", "loadSize", "contentlength", " contentBuffer", "contentType", "ContentLevel", " contentPath", " contentSize", "responseLevel"], "tmpOut": ["vtOut", "cmpout", " tmpout", " tmpOUT", "tempOut", "txtOutput", "tmpOUT", "apiout", "cmpOutput", "tmpIn", " tmpObj", "apiOUT", "mpIn", "tmpout", " tmpOutput", "tempObj", "tempout", " tmpIn", "cmpIn", "txtOut", "tempOUT", "vtOUT", "cmpOut", "tmpOutput", "apiIn", "tempIn", "tempOutput", "txtout", "mpOutput", "tmpObj", "mpOut", "apiOut", "vtObj", "vtout", "mpout"], "buf": ["cb", "tmp", "queue", "la", "uc", "buffer", "buff", "cf", "br", "cat", "Buffer", "src", "cas", "b", "cmd", "bc", "fd", "val", "loc", "base", "data", "bd", "ctx", "box", "raw", "pad", "func", "rc", "length", "seq", "wave", "uf", "cap", "bag", "lc", "count", "border", "cache", "vec", "wb", "fb", "pos", "header", "ff", "bin", "bu", "rb"], "len": ["size", "en", "num", "ln", "la", "lit", "lf", "iter", "limit", "l", "ler", "val", "end", "part", "loc", "lan", "Len", "data", "n", "elt", "el", "body", "nt", "length", "seq", "fl", "lc", "ls", "li", "ann", "le", "count", "c", "rev", "i", "pos", "lin", "fin", "bin", "str", "line", "coll", "ie"], "array": ["Array", "arr", "buffer", "range", "ception", "result", "message", "out", "object", "ray", "val", "channel", "data", "bytes", "response", "r", "pair", "raw", "air", "address", "var", "section", "length", "instance", "wave", "area", "content", "book", "all", "string", "image", "list", "load", "record", "map", "addr", "ar", "value", "collection"]}}
{"id1": "20292404", "id2": "15416857", "code1": "    protected void convertInternal(InputStream inputStream, DocumentFormat inputFormat, OutputStream outputStream, DocumentFormat outputFormat) {\n        File inputFile = null;\n        File outputFile = null;\n        try {\n            inputFile = File.createTempFile(\"document\", \".\" + inputFormat.getFileExtension());\n            OutputStream inputFileStream = null;\n            try {\n                inputFileStream = new FileOutputStream(inputFile);\n                IOUtils.copy(inputStream, inputFileStream);\n            } finally {\n                IOUtils.closeQuietly(inputFileStream);\n            }\n            outputFile = File.createTempFile(\"document\", \".\" + outputFormat.getFileExtension());\n            convert(inputFile, inputFormat, outputFile, outputFormat);\n            InputStream outputFileStream = null;\n            try {\n                outputFileStream = new FileInputStream(outputFile);\n                IOUtils.copy(outputFileStream, outputStream);\n            } finally {\n                IOUtils.closeQuietly(outputFileStream);\n            }\n        } catch (IOException ioException) {\n            throw new OpenOfficeException(\"conversion failed\", ioException);\n        } finally {\n            if (inputFile != null) {\n                inputFile.delete();\n            }\n            if (outputFile != null) {\n                outputFile.delete();\n            }\n        }\n    }\n", "code2": "    private boolean extract(File archive, File dir, IProgressMonitor monitor) {\n        monitor.subTask(\"Extract : \" + archive.getName());\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else {\n            File[] files = dir.listFiles();\n            for (int j = 0; j < files.length; j++) {\n                files[j].delete();\n            }\n        }\n        ZipInputStream zis = null;\n        try {\n            zis = new ZipInputStream(new FileInputStream(archive));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                File indexFile = new File(dir, entry.getName());\n                FileOutputStream fos = null;\n                try {\n                    fos = new FileOutputStream(indexFile);\n                    IOUtils.copy(zis, fos);\n                } finally {\n                    IOUtils.closeQuietly(fos);\n                }\n            }\n            return true;\n        } catch (Exception ex) {\n            M4EclipsePlugin.log(new Status(IStatus.ERROR, M4EclipsePlugin.PLUGIN_ID, -1, \"For index '\" + dir.getName() + \"' Unable to initialize indexes\", ex));\n        } finally {\n            IOUtils.closeQuietly(zis);\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"inputStream": [" inputContent", "outputSteam", "inputSteam", "InputLine", "inputContent", "inputLine", "InputFormat", "pullFile", "outputLine", "InputStream", " inputSteam", "outputContent", " inputLine", "pullContent", "InputFile", "pullSteam", "pullStream"], "inputFormat": ["outputUnit", "InputUnit", "inputPath", "documentPath", "InputFormat", " inputUnit", "documentStream", "documentFormat", " inputPath", "outputType", "InputType", "inputUnit", "inputType", " inputType", "documentFile", "InputFile", "outputPath"], "outputStream": ["OutputFormat", "outputSteam", "doubleStream", "outputThread", "inputSteam", "OutputThread", "OutputStream", " outputSource", " outputSteam", "inputSource", "doubleFile", "OutputFile", " outputThread", "outputSource", "doubleSteam", "doubleSource", "inputThread"], "outputFormat": ["OutputFormat", "inputPath", "outputUnit", "OutputForm", " outputPath", "inputForm", "OutputPath", "documentFormat", "documentType", "OutputType", "outputType", " outputForm", "inputType", "documentFile", "documentUnit", " outputType", "OutputUnit", "OutputFile", "outputForm", "outputPath", " outputUnit"], "inputFile": ["inputFolder", "audioFile", " inputLibrary", "inputfile", "sourceFolder", "outputLog", "InputLine", "audioPage", "imageFile", "imageStream", "requestStream", "inputLine", " inputfile", " inputTime", "InputFormat", " inputFolder", "InputStream", "audioLibrary", "documentStream", "InputTime", "inputFiles", "inputTime", "outputFiles", "Inputfile", "requestFolder", "sourceFile", "inputLog", "documentLog", "InputPage", "outputTime", "documentFile", "sourceFormat", " inputLine", "requestLine", "imageFolder", "audioStream", "outputLibrary", "InputFile", "outputPage", "requestFile", " inputFiles", "inputLibrary", "inputPage", "imagefile", " inputLog", "InputFolder", "InputLibrary", "documentLibrary", "InputFiles", "sourceStream"], "outputFile": ["controlTable", "targetStream", "outFile", "operationTable", "outputHandler", "outputType", "outputFactory", " outputDirectory", "OutputFile", "inputDirectory", "outStream", "targetUnit", "entityFile", " outputCode", "outputTable", "OutputFormat", " outputLock", "outputUnit", " outputfile", "responseTable", "outputSourceFile", "processHandler", "updateFiles", "OutputStream", "updatefile", "jobfile", "outputDirectory", "jobFile", "OutputFiles", "issueCode", "operationHandler", "operationSourceFile", "controlHandler", "jobCode", "outFormat", "issuefile", "targetTable", "outputfile", "updateFactory", "productionFiles", "environmentUnit", "issueFile", "processFile", "processSourceFile", "outType", "responseStream", "environmentFile", "outputLock", "inputLock", "outputFiles", "entityStream", " outputType", "responseFile", "productionFile", "entityLock", "updateFile", "productionfile", "responseUnit", "entityDirectory", "OutputFactory", "Outputfile", "productionFactory", "operationFile", "OutputType", "controlSourceFile", "environmentStream", "controlFile", "targetFile", "processTable", "environmentTable", "outputCode"], "inputFileStream": ["InputStreamObject", "inputDirectorySteam", "inputWatchSteam", "binaryFileChannel", "inputStreamstream", "inputFilesStep", "outputFilePath", "inputFilePath", "inputLogSteam", "outputFileStep", "inputLineSteam", "InputFileReader", "binaryFileStreamer", "inputFactoryStream", "inputLineStreamer", "inputWatchReader", "inputfileReader", "binaryFactoryStreamer", "inputFilesSteam", "InputStreamSteam", "binaryFileSteam", "inputDirectoryStreamer", "outputStreamStream", "inputFactoryStreamer", "inputDirectoryReader", "InputFileObject", "outputDirectoryStep", "inputFilestream", "inputfileStep", "inputfilestream", "inputWatchStream", "outputDirectoryStream", "outputStreamstream", "inputFactoryChannel", "inputFilesStream", "inputDirectoryPath", "inputDirectoryObject", "inputLogReader", "inputFileChannel", "inputStreamStream", "inputStreamSteam", "outputStreamReader", "inputfilePath", "inputFactorySteam", "InputStreamReader", "outputFilestream", "inputLineStream", "binaryFactoryStream", "inputLogStream", "inputFileStep", "inputDirectoryChannel", "outputFileSteam", "inputFileStreamer", "inputLineChannel", "outputDirectorySteam", "inputDirectoryStep", "outputStreamSteam", "binaryFactoryChannel", "outputDirectoryPath", "InputStreamStream", "inputWatchstream", "InputFileStream", "inputStreamReader", "inputFilesPath", "inputfileSteam", "binaryFileStream", "binaryFactorySteam", "inputFileSteam", "inputFileReader", "outputFileReader", "InputFileSteam", "inputfileStream", "inputLogObject", "inputFileObject", "inputDirectoryStream", "inputStreamObject"], "outputFileStream": ["outputBasestream", " outputDirectorySt", "outLineStream", "outputFileChannel", " outputFileSt", "outputFilePath", "inputLineSteam", "outFileStream", "outputContentThread", "outputfilestream", "inputFileThread", "outputFileSt", "inputLineSt", "outputFileSh", "outLineSteam", "outputContentStream", "outputLineSteam", "outputStreamStream", "outputFileThread", "inputLineThread", "outputFilesSteam", " outputFileChannel", "outputDirectoryStream", "outputStreamSt", "outputLockStream", "outputStreamPath", "outputLineSt", "outputLineStream", "outputLockChannel", "inputFileChannel", "outFileSh", "outputfileStream", "inputStreamStream", "inputStreamSteam", "outputfileSteam", "outputFilesStream", "outputLinestream", "outLinestream", "outputFilestream", "inputLineStream", "outputLockSteam", "outputStreamCam", "outputContentSt", "outputBaseSh", " outputDirectoryChannel", "outputFileSteam", "outputBaseSteam", "outputDirectorySteam", "outputStreamChannel", "outputStreamSteam", " outputFilePath", "outputLockCam", "outputDirectoryPath", "outputLineChannel", "outLineSh", "outputLineThread", "outputFilesChannel", "outputFilesCam", "inputStreamChannel", "outputDirectoryChannel", " outputDirectoryStream", "inputFileCam", "outputDirectoryThread", "outFileSteam", "outFilestream", "outputBaseStream", "inputFileSteam", "outputFileCam", " outputDirectoryPath", "outputContentSteam", "outputLinePath", "outputfileSh", "outputDirectorySt", "inputStreamCam", "outputLineSh", "inputFileSt"]}}
{"id1": "17874922", "id2": "8988243", "code1": "    public static boolean buildPerMovieDiffBinary(String masterFile) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            System.out.println(inC.size());\n            short movie1, movie2;\n            int count;\n            float diffRating, sumXY, sumX, sumY, sumX2, sumY2, pearsonCorr, adjustedCosineCorr, cosineCorr;\n            long position;\n            for (long i = 1; i < 17770; i++) {\n                File outFile = new File(\"C:\\\\NetflixData\\\\download\\\\SmartGrape\\\\CFItemToItemStats\\\\Movie--\" + i + \"-MatrixData.txt\");\n                FileChannel outC = new FileOutputStream(outFile, true).getChannel();\n                ByteBuffer buf = ByteBuffer.allocate(17770 * 44);\n                for (long j = 1; j < i; j++) {\n                    ByteBuffer bbuf = ByteBuffer.allocate(44);\n                    position = 0;\n                    position += new Long(17769).longValue() * new Long(17770).longValue() * new Long(22).longValue();\n                    position -= new Long((17769 - (j - 1))).longValue() * new Long((17770 - (j - 1))).longValue() * new Long(22).longValue();\n                    position += new Long((i - j - 1) * 44).longValue();\n                    inC.position(position);\n                    inC.read(bbuf);\n                    bbuf.flip();\n                    buf.putShort(bbuf.getShort());\n                    bbuf.getShort();\n                    buf.putInt(bbuf.getInt());\n                    buf.putFloat(-bbuf.getInt());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                }\n                buf.putShort(new Long(i).shortValue());\n                buf.putInt(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                position = 0;\n                position += new Long(17769).longValue() * new Long(17770).longValue() * new Long(22).longValue();\n                position -= new Long((17769 - (i - 1))).longValue() * new Long((17770 - (i - 1))).longValue() * new Long(22).longValue();\n                ByteBuffer remainingBuf = inC.map(FileChannel.MapMode.READ_ONLY, position, (17770 - i) * 44);\n                while (remainingBuf.hasRemaining()) {\n                    remainingBuf.getShort();\n                    buf.putShort(remainingBuf.getShort());\n                    buf.putInt(remainingBuf.getInt());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                }\n                buf.flip();\n                outC.write(buf);\n                buf.clear();\n                outC.close();\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    private static void extractSOUNDFILES() throws Exception {\n        ArrayList<File> soundFiles = new ArrayList<File>();\n        File soundsFolder = new File(\"/var/lib/asterisk/sounds/\");\n        if (soundsFolder.exists()) {\n            File soundFiles1[] = soundsFolder.listFiles(new FilenameFilter() {\n\n                @Override\n                public boolean accept(File dir, String name) {\n                    if (NullStatus.isNull(name)) {\n                        return false;\n                    }\n                    if (name.endsWith(\"-sounds.jar\")) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            for (int i = 0; i < soundFiles1.length; i++) {\n                soundFiles.add(soundFiles1[i]);\n            }\n        }\n        soundsFolder = new File(\"/opt/jboss/server/default/deploy/Tobe.war/WEB-INF/lib/\");\n        if (soundsFolder.exists()) {\n            File soundFiles1[] = soundsFolder.listFiles(new FilenameFilter() {\n\n                @Override\n                public boolean accept(File dir, String name) {\n                    if (NullStatus.isNull(name)) {\n                        return false;\n                    }\n                    if (name.endsWith(\"-sounds.jar\")) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            for (int i = 0; i < soundFiles1.length; i++) {\n                soundFiles.add(soundFiles1[i]);\n            }\n        }\n        for (int i = 0; i < soundFiles.size(); i++) {\n            ZipFile zipFile = new ZipFile(soundFiles.get(i));\n            InputStream inputStream = null;\n            Enumeration<? extends ZipEntry> oEnum = zipFile.entries();\n            while (oEnum.hasMoreElements()) {\n                ZipEntry zipEntry = oEnum.nextElement();\n                File file = new File(\"/var/lib/asterisk/sounds/\", zipEntry.getName());\n                if (zipEntry.isDirectory()) {\n                    file.mkdirs();\n                } else {\n                    inputStream = zipFile.getInputStream(zipEntry);\n                    FileOutputStream fos = new FileOutputStream(file);\n                    IOUtils.copy(inputStream, fos);\n                    fos.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"masterFile": ["distPath", "configFilename", "parentFile", "masterPath", "masterFilename", "mastersFile", "MasterFilename", "Masterfile", "distfile", "masterStream", "configfile", "MasterStream", "parentPath", "mastersfile", "MasterPath", "configStream", "configFile", "parentfile", "MasterFile", "mastersStream", "parentFilename", "masterfile", "distFilename", "mastersFilename", "distFile"], "inFile": ["outF", "InC", "InFILE", "linC", "outFILE", " inF", "inF", "linFile", "inFILE", "outfile", "incF", "linfile", "infile", "InFile", "incfile", "outFiles", "incFile", "inFiles", " inFiles", "incFiles", "linFILE", " infile", "Infile"], "inC": ["InCL", "outF", "tryF", "inT", "inc", "InCA", "inCL", " inCL", "outCL", "inB", "InC", "tryB", " inF", "winB", "InT", "inF", "inCA", "outB", "outT", "tryC", "winCL", "InB", "InFile", "tryc", "outc", " inCA", "winC", "winCA", " inc", " inB", " inT"], "movie1": ["movieOne", "imageA", "playerone", "playerOne", "movieA", "image1", "imageone", "MovieA", "Movie1", "MovieOne", "imageOne", "player1", "playerA", "movieone", "Movieone"], "movie2": ["videoSecond", "video0", "movie0", "video4", " movieSecond", "series4", "series2", " movie4", "series0", "video2", "movie4", "seriesSecond", " movie0", "movieSecond"], "count": ["id", "last", "len", "counter", "ind", "weight", "score", "base", "sum", "child", "Count", "depth", "batch", "length", "found", "screen", "content", "col", "index", "list", "cache", "code", "err", "process", "mean", "start", "coll", "type"], "diffRating": ["diffRank", "DiffRank", "DiffRating", "meanRat", "DiffScore", "meanRating", " diffRank", " diffScore", "meanScore", "meanRank", "diffRat", "DiffRat", " diffRat", "diffScore"], "sumXY": ["numY", "scaleXY", "scaleY", "sumYY", "numYY", "numZ", "scaleZ", "sumZ", " sumZ", " sumYY", "numXY", "scaleYY"], "sumX": ["summaryZ", "summaryX", "SumX", "SumY", "SumXY", "summaryY", "summaryXY", "sumZ", " sumZ", "SumZ"], "sumY": ["sumy", "simY", "sumYY", "SumYY", "SumY", "simy", "SumXY", " sumy", "simYY", " sumYY", "simXY", "Sumy"], "sumX2": ["sumYTwo", " sumXYTwo", " sumXY1", "sumXX1", " sumXY2", " sumXTwo", "sumX1", "sumXY1", "sumXX2", "sumXY2", "sumY1", "sumXXTwo", "sumXYTwo", " sumX1", "sumXTwo"], "sumY2": ["sumYTwo", " sumXYTwo", " sumXY1", " sumYTwo", " sumXY2", "sumX1", "sumXY1", "sumXY2", "sumY1", " sumY1", "sumYY2", "sumXYTwo", "sumYYTwo", "sumYY1", "sumXTwo"], "pearsonCorr": ["pelevisionCorr", "pearsoncorrs", "pelevisionCorp", "pearsonArrs", "pearsonCorp", "pearsonErrs", "pearsonCorrs", "pearsonArp", "pearsonArc", "pearsonErr", "pelevisioncorp", "pelevisioncorrs", "pearsonErc", "pearsonArr", "pelevisionCorc", "pearsonErp", "pearsoncorc", "pearsoncorr", "pelevisioncorc", "pelevisionCorrs", "pelevisioncorr", "pearsoncorp", "pearsonCorc"], "adjustedCosineCorr": ["adjustedCosineErr", "adjustedCosineCorb", "adjustedCosieCorp", "adjustedCosineErR", "adjustedCosieCorr", "adjustedCosineCorp", "adjustedCosineErp", "adjustedCosineErb", "adjustedCosineCorR", "adjustedCosieCorb", "adjustedCosieCorR"], "cosineCorr": ["cosinesCorp", "cosinescorrd", "cosinescorrs", "cosineErrs", "cosineMirrs", "cosineErr", "cosinecorrd", "cosineMirp", "cosinesCorrs", "cosinescorp", "cosinesCorr", "cosinesCorrd", "cosineErrd", "cosineCorrs", "cosinecorrs", "cosinecorp", "cosineCorrd", "cosineMirrd", "cosineErp", "cosineCorp", "cosineMirr", "cosinescorr", "cosinecorr"], "position": ["select", "adjust", "shift", "read", "pixel", "display", "layout", "connection", "axis", "player", "pose", "weight", "params", "object", "portion", "state", "move", "part", "loc", "number", "data", "version", "cover", "style", "response", "condition", "address", "angle", "sequence", "shape", "Position", "update", "use", "action", "direction", "selection", "patch", "length", "ion", "job", "offset", "release", "index", "media", "sort", "image", "point", "pointer", "time", "run", "record", "slice", "expression", "motion", "coord", "property", "seek", "pos", "character", "block", "speed", "type", "mount", "osition", "order", "option", "value", "port", "location", "duration", "unit"], "i": ["id", "ik", "si", "qi", "d", "iu", "phi", "io", "k", "hi", "yi", "l", "y", "b", "part", "f", "number", "ij", "di", "bi", "zi", "n", "I", "ni", "ti", "ai", "gi", "info", "ji", "x", "sup", "ix", "init", "ui", "ci", "e", "u", "o", "api", "ini", "m", "li", "xi", "v", "ri", "index", "slice", "c", "ori", "uri", "ii", "im", "pi", "is", "start", "fi", "z", "mi", "mini", "ip", "p", "ie"], "outFile": [" outTable", "outF", "OutFolder", "outTable", "outputF", " outF", "OutFile", " outfile", "outDir", "outputFile", "outputC", " outFolder", " outDir", "outfile", "OutTable", "OutF", "incTable", "Outfile", "outFolder", "OutDir", "outputDir", "incfile", "incFolder", "incFile", "OutC"], "outC": ["outF", "OutF", "inL", " outF", " outL", "inF", "OutFile", "OutC", "outL", "OutL"], "buf": ["af", "cb", "queue", "bf", "bh", "uc", "buffer", "buff", "cf", "cmp", "ux", "Buffer", "bg", "cas", "fp", "b", "home", "bc", "fd", "aux", "console", "cmd", "f", "cv", "loc", "data", "bd", "ctx", "box", "config", "Buff", "func", "rc", "CB", "tc", "uf", "cap", "bag", "v", "ba", "book", "port", "window", "pool", "border", "utils", "socket", "db", "context", "vec", "wb", "fb", "BU", "header", "block", "conv", "fx", "img", "ff", "bu", "rb", "coll", "pkg", "BA"], "j": ["h", "jj", "d", "kj", "si", "jet", "J", "br", "jp", "k", "l", "y", "jo", "b", "fr", "ja", "f", "aj", "ij", "bi", "n", "ji", "el", "x", "js", "bj", "u", "o", "e", "ci", "uj", "dj", "pr", "ch", "m", "job", "jc", "v", "li", "obj", "c", "ii", "jl", "g", "q", "oj", "z", "p", "ie"], "bbuf": ["obuff", "obbdef", "ppuf", "bdef", "mbbuff", "bootuff", "mbbuf", "kkff", "obbbuff", "dbuff", "BBdef", "dbuf", "buffer", "obblf", "buff", "bbuffer", "ebbuf", "mbuff", "buffbuff", "bbuff", "obbuff", "BBff", "buffbuf", "bbbuf", "buffdef", "kkuff", "bufflf", "dbbuf", "mbuf", "kkuf", "bbdef", "buffuff", "ebbuff", "obff", "obbuf", "kkbuf", "dbuffer", "ebuff", "ppuff", "bootbuff", "buffff", "BBuff", "bbbuff", "buffuf", "obuf", "BBbuf", "ppbuff", "blf", "BBbuff", "bff", "bbff", "BBuf", "obbuffer", "bootuf", "bootbuf", "bblf", "oblf", "obbbuf", "obdef", "dbbuff", "ppbuf", "ebuf"]}}
{"id1": "4540202", "id2": "7157998", "code1": "    public void myClickHandler(View view) {\n        switch(view.getId()) {\n            case R.id.ReadWebPage:\n                try {\n                    textView.setText(\"\");\n                    URL url = new URL(urlText.getText().toString());\n                    BufferedReader rd = new BufferedReader(new InputStreamReader(url.openStream()));\n                    String line = \"\";\n                    while ((line = rd.readLine()) != null) {\n                        textView.append(line);\n                    }\n                } catch (Exception e) {\n                    System.out.println(\"Nay, did not work\");\n                    textView.setText(e.getMessage());\n                }\n                break;\n        }\n    }\n", "code2": "    public static synchronized String encrypt(String x) throws Exception {\n        MessageDigest d = MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(String.valueOf(x).getBytes());\n        return byteArrayToHexString(d.digest());\n    }\n", "label": 0, "substitutes": {"view": ["source", "page", "route", "reader", "id", "input", "link", "layout", "review", "message", "widget", "object", "out", "this", "controller", "model", "row", "stream", "response", "resource", "View", "server", "template", "element", "update", "action", "event", "e", "VIEW", "see", "container", "content", "v", "session", "window", "index", "change", "image", "context", " View", "item", "block", "views", "iew"], "url": ["source", "page", "ball", "reader", "connection", "feed", "ll", "output", "src", "l", "conn", "http", "client", "fr", "channel", "data", "stream", "r", "resource", "email", "server", "address", "ur", "log", "api", "text", "bel", "fl", "ls", "string", "path", "rl", "file", "uri", "ssl", "db", "URL", "service", "Url", "www", "blog", "web", "sl"], "rd": ["reader", "cd", "ra", "d", "rx", "rowd", "ded", "dig", "dd", "ld", "xd", "vd", "pd", "wd", "ird", "fd", "fr", "idd", "red", "bd", "std", "r", "rob", "rg", "erd", "rs", "rod", "rh", "dr", "adr", "hr", "ri", "rl", "rw", "rt", "rr", "ds", "nd", "dra", "rb", "RD"], "line": ["page", "split", "link", "feed", "buffer", "lf", "lines", "message", "l", "letter", "char", "val", "LINE", "cell", "end", "Line", "row", "part", "data", "inline", "style", "response", "strip", "el", "word", "name", "e", "unit", "cl", "text", "comment", "content", "lc", "key", "string", "rule", "frame", "point", "pass", "file", "error", "code", "character", "block", "lin", "str", "sl", "entry"]}}
{"id1": "23598855", "id2": "15424571", "code1": "    public void requestConfirm() throws Exception {\n        if (!this._c.checkProperty(\"directory.request\", \"request\")) {\n            throw new Exception(\"product has no active request\");\n        }\n        if (!new File(WBSAgnitioConfiguration.getHARequestFile()).canWrite()) {\n            throw new Exception(\"cannot remove request from system\");\n        }\n        HashMap<String, String> values = getValues(WBSAgnitioConfiguration.getHARequestFile());\n        if (!values.containsKey(\"address.virtual\")) {\n            throw new Exception(\"failed to determine the virtual address\");\n        }\n        if (!values.containsKey(\"address.real\")) {\n            throw new Exception(\"failed to determine the remote address\");\n        }\n        HTTPClient _hc = new HTTPClient(values.get(\"address.real\"));\n        if (TomcatConfiguration.checkHTTPS()) {\n            _hc.setSecure(true);\n        }\n        _hc.load(\"/admin/Comm?type=\" + CommResponse.TYPE_HA + \"&command=\" + CommResponse.COMMAND_REQUEST_CONFIRM + \"&virtual=\" + values.get(\"address.virtual\"));\n        String _reply = new String(_hc.getContent());\n        if (_reply.isEmpty()) {\n            throw new Exception(\"remote product has not sent any reply\");\n        } else if (_reply.indexOf(\"done\") == -1) {\n            throw new Exception(_reply);\n        }\n        HAConfiguration.setSlave(values.get(\"address.virtual\"), values.get(\"address.real\"));\n        File _f = new File(WBSAgnitioConfiguration.getOptionalSchemaRequestFile());\n        if (_f.exists()) {\n            FileOutputStream _fos = new FileOutputStream(WBSAgnitioConfiguration.getOptionalSchemaFile());\n            FileInputStream _fis = new FileInputStream(_f);\n            while (_fis.available() > 0) {\n                _fos.write(_fis.read());\n            }\n            _fis.close();\n            _fos.close();\n            _f.delete();\n        }\n        _f = new File(WBSAgnitioConfiguration.getSchemaObjectRequestFile());\n        if (_f.exists()) {\n            FileOutputStream _fos = new FileOutputStream(WBSAgnitioConfiguration.getSchemaObjectFile());\n            FileInputStream _fis = new FileInputStream(_f);\n            while (_fis.available() > 0) {\n                _fos.write(_fis.read());\n            }\n            _fis.close();\n            _fos.close();\n            _f.delete();\n        }\n        new File(WBSAgnitioConfiguration.getHARequestFile()).delete();\n        this._c.removeProperty(\"directory.request\");\n        this._c.setProperty(\"directory.virtual\", values.get(\"address.virtual\"));\n        this._c.setProperty(\"directory.status\", \"slave\");\n        this._c.store();\n    }\n", "code2": "    private File copyFile(File source, File destiny) {\n        try {\n            FileInputStream fileinputstream = new FileInputStream(source);\n            FileOutputStream fileoutputstream = new FileOutputStream(destiny);\n            byte abyte0[] = new byte[4096];\n            int i;\n            while ((i = fileinputstream.read(abyte0)) != -1) fileoutputstream.write(abyte0, 0, i);\n            fileinputstream.close();\n            fileoutputstream.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            LOGGER.error(e.getMessage());\n        } catch (IOException e) {\n            e.printStackTrace();\n            LOGGER.error(e.getMessage());\n        }\n        return destiny;\n    }\n", "label": 1, "substitutes": {"values": ["tests", "als", "ples", "states", "strings", "events", "errors", "ends", "pes", "holders", "ils", "settings", "lines", "keys", "properties", "items", "params", "stores", "issues", "writers", "codes", "objects", "changes", "flows", "es", "ages", "models", "forms", "vs", "groups", "ports", "iv", "boxes", "plugins", "owners", "results", "pages", "members", "rules", "versions", "fields", "roots", "docs", "vals", "maps", "utils", "limits", "details", "files", "vi", "ids", "services", "views", "Values", "value", "ves"], "_hc": ["_wc", " _hpc", "_vc", "_ohxc", "_ehc", "placehc", "_Hfc", "_htxc", "_hmfc", "_hhcs", "placeghxc", "_Hnc", "_ohl", "_hcu", "_ghcu", "_wfc", "_shcs", " _hfc", "_hnc", "_htcu", "_hfc", "_hl", "_Hc", "_wcs", "_ohrc", "_Hpc", "_hmc", "placeghc", "_ohpc", " _hrc", "_vfc", "_ehdc", "_hcs", "_vcs", "_hxc", "_ohfc", "_wpc", "placeghl", "_hmpc", "placeghcu", "_ghxc", "_ohcu", "_htl", "placehcu", " _Hc", "_hmrc", "_hpc", "_shfc", "_Hrc", "_Hdc", "_hdc", " _Hrc", "_hhc", "_ehcs", " _Hpc", "_Hcs", "_shpc", "placehl", "_hhnc", " _Hfc", "_htc", "_ghl", "_vpc", "_shc", "_hhdc", "_ohc", "_ehnc", "_ghc", "_hrc", "placehxc"], "_reply": ["_Reply", "passrepl", "passreply", "passresponse", " _message", "_answer", "_response", " _repl", "passanswer", "_repl", " _Reply", "Jrepl", " _response", "logmessage", "Jmessage", "logresponse", "Jresponse", "Jreply", "_message", " _answer", "loganswer", "logreply"], "_f": ["_b", " _fd", "_fe", "_fi", " _c", "_sf", " _fi", "_fs", "upf", "_fd", "_c", "_cf", "upfe", "upfi", "upc", " _b", " _fe"], "_fos": ["_bios", " _fops", "_lis", "_fout", "_bos", "_fops", " _lout", " _los", "_pos", "_bops", "_lios", "_eios", " _fout", "_eops", " _lops", "_eis", "_pout", "_bout", "_bis", " _lis", "_eos", "_lops", "_fios", "_los", "_lout", "_pis", "_pops"], "_fis": ["_dis", "_fp\n", "_fileis", "_dfos", "_fileys", "_fops", "_fi", " _dos", "_fileas", "lexfp\n", "_ifios", "_fs\n", "lexf\n", "_fpys", "_dos", "_dils", "_dfops", " _fi", "_fils", "_fys", "_sis", "_dios", "_bi", "_ifi", "_bios", "_fpis", "_dfils", " _di", "_lis", "_bos", "_sils", "_sops", "_sos", "_fpas", "_las", "_ifis", "_file\n", "_bis", "_di", "_los", "_fileos", "_fpos", " _fios", " _dios", "_fas", "_ifos", "_fios", "_dops", " _dis", "_dfis", "_lys"]}}
{"id1": "18288470", "id2": "7599114", "code1": "    public static void unzip(String zipfile, String outputDirectory) {\n        try {\n            byte[] buf = new byte[1024];\n            ZipInputStream zipinputstream = null;\n            ZipEntry zipentry;\n            zipinputstream = new ZipInputStream(new FileInputStream(zipfile));\n            zipentry = zipinputstream.getNextEntry();\n            while (zipentry != null) {\n                String entryName = zipentry.getName();\n                System.out.println(\"entryname \" + entryName);\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(entryName);\n                String directory = newFile.getParent();\n                if (directory == null) {\n                    if (newFile.isDirectory()) break;\n                }\n                fileoutputstream = new FileOutputStream(outputDirectory + entryName);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n                zipentry = zipinputstream.getNextEntry();\n            }\n            zipinputstream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static byte[] readBytes(URL url) throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        byte[] buf = new byte[8192];\n        InputStream in = url.openStream();\n        try {\n            int readlen;\n            while ((readlen = in.read(buf)) > 0) bos.write(buf, 0, readlen);\n        } finally {\n            in.close();\n        }\n        return bos.toByteArray();\n    }\n", "label": 0, "substitutes": {"zipfile": ["zipFile", "zFile", "zfilename", "archivefiles", "zfile", "zentry", "lockfiles", "zipfiles", "archivefilename", "lockfilename", " zipfiles", "archiveFile", "zipfilename", "lockFile", "archivefile", " zipFile", "lockfile", "archiveentry", "lockentry"], "outputDirectory": ["outputdirectory", "inputFolder", " outputdirectory", "imageFile", "targetCollection", "outputFile", "outputFolder", " outputDir", " outputFolder", "imageFolder", "outputCollection", "imageDirectory", "inputCollection", "OutputDirectory", "OutputDir", "targetFolder", "OutputFolder", "outputDir", "targetFile", "inputDirectory", "targetdirectory", "Outputdirectory", "targetDirectory", "imageCollection", "targetDir", "inputFile"], "buf": ["cb", "queue", "bf", "binary", "bh", "pkg", "uc", "la", "buffer", "buff", "br", "Buffer", "lim", "src", "cas", "que", "fp", "b", "cmd", "bc", "aux", "base", "cv", "data", "bd", "bytes", "pad", "Buff", "func", "batch", "rc", "bb", "seq", "uf", "bag", "gb", "ab", "uv", "vec", "wb", "fb", "conv", "img", "lb", "rb", "padding", "fab", "bp"], "zipinputstream": ["zipfileStream", " zipmainsteam", "zipinnersystem", "zipsourcethread", "fileinputStream", "zinputsystem", "zInputput", "zipcontrolstream", "archiveinputStream", "zipfilestream", "zipinputsem", "zipinputStream", "archiveinputstream", "zinputchannel", " zipinputStream", "zipInputsteam", "zipInputsem", "zipinputsteam", "zinputStream", "archiveInputstream", " zipmainStream", "zipInputloop", "zInputstream", "zipsourceStream", "zipcontrolStream", "zipbitstream", "zipmainStream", "zipbitchannel", "archiveInputStream", "fileoutputsem", "zinputstream", "zipinputchannel", "zipoutputloop", "zipfilesystem", "zinputput", "zipinputput", "zipoutputsem", "zipInputsystem", "zipinputsystem", "zipInputput", "zipfilethread", "zoutputStream", "fileinputstream", "zipinputthread", " zipmainstream", "zipcontrolput", "zipbitStream", "zipincludeStream", "zInputthread", "zInputsystem", "zipincludesem", "zipmainsteam", "zipInputchannel", "zipincludestream", "archiveInputloop", "fileoutputStream", "zipinnerthread", "zipimportloop", "zipoutputstream", "zipInputthread", "zipInputstream", "zoutputstream", "zipinnerStream", "zipoutputStream", "zipbitput", "zipsourcestream", "zoutputthread", "zipoutputsteam", "zipimportStream", "zipinnerstream", "fileinputsem", "zinputthread", "zipmainstream", "zoutputsystem", " zipinputsteam", "zInputStream", "zipimportstream", "zipInputStream", "zipinputloop", "zipoutputsystem", "archiveinputloop", "zipoutputthread", "zInputchannel", "zipcontrolchannel"], "zipentry": ["copEntry", "zipdata", "ziparchive", "zipletter", "zipEntry", "zelement", "zenter", "expEntry", "seaelement", "installarchive", " zipserver", "seaentry", "zipreader", "seaEntry", "copenter", "lexentry", "zeletter", " zipdata", "lexenter", "zentry", " zipenter", "downloadarchive", "zonedata", "expentry", "lexarchive", "downloadentry", "installentry", "lexdata", " zipletter", "zoneelement", "seaenter", "zoneenter", " ziparchive", " zipEntry", "zearchive", "zeserver", "installserver", "downloadelement", "zeentry", "zEntry", "copentry", "zipserver", " zipreader", "expenter", "zreader", "zipelement", "expelement", "downloadenter", "lexelement", "zonearchive", "zoneentry", "installletter", "zipenter", "copreader"], "entryName": ["entryType", "entryNAME", "zipname", "entityNames", "EntryYear", "zipName", "elementname", " entryYear", "entityType", "internalName", "stringname", "zipInfo", "entityname", " entryNames", "elementInfo", "entryYear", " entryInfo", "stringName", "elementNAME", "entryInfo", "Entryname", " entryNAME", "entryname", " entryType", "entityName", "entryNames", "stringYear", "elementType", "elementNames", "EntryType", "internalNAME", "internalname", " entryname", "EntryName", "stringType", "elementName", "zipType"], "n": ["none", "en", "num", "d", "nn", "len", "ind", "nr", "k", "l", "w", "out", "b", "ns", "f", "number", "no", "r", "x", "name", "ne", "na", "u", "e", "o", "nt", "t", "m", "nu", "v", "index", "N", "j", "c", "i", "g", "un", "pos", "nb", "nd", "ng", "sn", "z", "nc", "p"], "fileoutputstream": ["fileoutpath", "fileoutStream", " fileoutputStream", "fileinputsw", "fileimagestream", "fileinputmessage", "fileOutputstream", "fileresourceStream", "fileoutstream", "fileinputStream", "resourceinputStream", "fileOutputmessage", "zipoutputstream", "resourceinputsw", "resourceoutputsystem", "fileinputsystem", "fileoutputthread", "fileunitstream", "fileOutputthread", " fileunitthread", "resourceoutputsw", "fileresourcestream", "resourceinputpath", "zipoutputStream", "fileOutputsystem", "fileunitthread", "fileoutputsw", "fileinputpath", "fileoutputmessage", " fileunitStream", "fileinputthread", "resourceOutputstream", "fileoutputsystem", "fileOutputsw", "zipOutputstream", "resourceOutputstring", "fileresourcesystem", "fileoutputstring", "resourceoutputpath", "fileoutputpath", " fileoutputthread", "fileOutputpath", "zipoutputmessage", "fileinputstring", "resourceoutputstring", "fileOutputstring", "fileimagemessage", "fileimageStream", "fileinputstream", "resourceOutputsystem", "resourceoutputStream", "resourceinputstream", "fileoutsw", "fileunitStream", "resourceoutputstream", "fileOutputStream", "zipOutputmessage", "fileoutputStream", "fileresourcestring", "zipOutputStream", "resourceOutputStream", " fileunitstream"], "newFile": [" newDir", "NewPlace", "NewDir", "newfile", "newPlace", "addFile", "addDir", "fromFolder", "fromFile", "addFolder", " newPlace", "NewFile", "NEWDir", "newDir", "NEWFolder", "fromfile", "NewFolder", "addfile", "newFolder", " newfile", "Newfile", "NEWFile", "NEWPlace", " newFolder", "fromDir"], "directory": ["source", "folder", "parent", "url", "d", "office", "connection", "director", "division", "Directory", "python", "home", "description", "root", "class", "system", "tree", "prefix", "archive", "creator", "machine", "filename", "volume", "dir", "direction", "direct", "container", "length", "category", "path", "document", "uri", "manager", "database", "which", "project", "collection", "location"]}}
{"id1": "7993946", "id2": "16589432", "code1": "    public void unsplit(String newFilename, File[] files) throws Exception {\n        FileOutputStream stream = new FileOutputStream(new File(newFilename));\n        for (int i = 0; i < files.length; i++) {\n            FileInputStream fin = new FileInputStream(files[i].getAbsolutePath());\n            DataInputStream din = new DataInputStream(fin);\n            while (din.available() > 0) {\n                stream.write(din.read());\n            }\n            din.close();\n            fin.close();\n        }\n        stream.close();\n    }\n", "code2": "    private static String hash(String string) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (Exception e) {\n            return null;\n        }\n        try {\n            md.update(string.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            return null;\n        }\n        byte raw[] = md.digest();\n        return (new BASE64Encoder()).encode(raw);\n    }\n", "label": 0, "substitutes": {"newFilename": ["newSourceFile", "newfilename", " newFile", "Newfilename", "NewFile", "newFile", "oldfilename", "oldFilename", "oldSourceFile", " newSourceFile", "NewSourceFile", " newfilename", "oldFile", "NewFilename"], "files": ["balls", "Files", "classes", "resources", "cells", "opens", "strings", "tests", "links", "lines", "keys", "fs", "items", "pins", "books", "sheets", "f", "blocks", "scenes", "loaded", "bs", "objects", "flows", "models", "children", "stars", "filename", "users", "boxes", "plugins", "full", "results", "ins", "images", "pages", "names", "ls", "fits", "path", "thumbnails", "features", "file", "iles", "projects", "ids", "assets", "fil"], "stream": ["source", "reader", "draft", "input", "sem", "write", "upload", "feed", "Stream", "result", "pipe", "io", "output", "view", "w", "http", "out", "this", "in", "driver", "client", "fd", "f", "channel", "data", "zip", "enc", "clean", "usher", "server", "zen", "handler", "writer", "sync", "php", "per", "log", "keep", "transform", "temp", "path", "socket", "file", "ssl", "context", "raf", "self", "form", "stack", "coll", "standard"], "i": ["id", "si", "multi", "abi", "qi", "iu", "hi", "io", "phi", "in", "b", "f", "di", "bi", "zi", "n", "I", "mu", "ni", "ti", "oi", "ai", "gi", "inner", "ji", "x", "ix", "ui", "ci", "u", "o", "eni", "ini", "li", "v", "xi", "ri", "index", "j", "ori", "uri", "ii", "pi", "fi", "mi", "uni", "ip", "p", "ie"], "fin": ["bas", "tin", "rf", "ln", "Fin", "fine", "conn", "fs", "in", "fd", "fr", "f", "data", "pin", "di", "thin", "ris", "fat", "inner", "oin", "skin", "den", "init", "pid", "vin", "FIN", "fn", "ini", "ino", "sin", "kin", "ri", "done", "cin", "ori", "file", "flo", "raf", "fb", "inn", "fen", "front", "rin", "lin", "fi", "bin", "inv", "fa"], "din": ["tin", "su", "reader", "die", "uni", "uin", "nin", "udi", "in", "pin", "di", "bi", "thin", "pal", "ni", "gi", "inner", "oin", "den", "unin", "pid", "da", "ani", "vin", "zin", "eni", "gin", "ini", "fan", "ino", "sin", "kin", "ri", "dy", "done", "cin", "raf", "inn", "fen", "rin", "lin", "bin", "dra", "mini"]}}
{"id1": "17568209", "id2": "7993946", "code1": "    private static boolean CopyFile(File srcFile, File tagFile) throws IOException {\n        if (srcFile == null || tagFile == null) {\n            return false;\n        }\n        int length = 2097152;\n        File dirFile = new File(getFileFolder(tagFile.getAbsolutePath()));\n        if (!dirFile.exists()) {\n            dirFile.mkdirs();\n        }\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(tagFile.getAbsolutePath());\n        FileChannel inC = in.getChannel();\n        FileChannel outC = out.getChannel();\n        int i = 0;\n        while (true) {\n            if (inC.position() == inC.size()) {\n                inC.close();\n                outC.close();\n                break;\n            }\n            if ((inC.size() - inC.position()) < 20971520) length = (int) (inC.size() - inC.position()); else length = 20971520;\n            inC.transferTo(inC.position(), length, outC);\n            inC.position(inC.position() + length);\n            i++;\n        }\n        return true;\n    }\n", "code2": "    public void unsplit(String newFilename, File[] files) throws Exception {\n        FileOutputStream stream = new FileOutputStream(new File(newFilename));\n        for (int i = 0; i < files.length; i++) {\n            FileInputStream fin = new FileInputStream(files[i].getAbsolutePath());\n            DataInputStream din = new DataInputStream(fin);\n            while (din.available() > 0) {\n                stream.write(din.read());\n            }\n            din.close();\n            fin.close();\n        }\n        stream.close();\n    }\n", "label": 1, "substitutes": {"srcFile": ["sourceDir", "sourceUrl", "rcfile", "inputFolder", "inputfile", "srcFiles", "srcfile", "srcFolder", "rcDir", "sourceFILE", "viewFile", "rcFiles", "srcUrl", "viewFILE", "viewUrl", " srcFILE", " srcfile", "rcFolder", "sourcefile", "sourceFile", " srcFiles", "rcFilename", " srcUrl", "sourceFiles", "inputFilename", " srcFilename", "srcFILE", " srcDir", "srcFilename", "rcFile", " srcFolder", "viewfile", "inputFile", "srcDir"], "tagFile": ["logFILE", "logPath", "TagFile", "outBase", "tagPath", "ownFILE", "outFile", " tagFILE", "srcfile", "ownPath", "logfile", "outDir", " tagfile", "catPath", "outFILE", "tagfile", "TagDir", "tagDir", "outfile", "logFile", "modDir", " tagDir", "modFILE", "TagPath", "catFile", "ownfile", " tagBase", "srcFILE", "modFile", "TagBase", "catDir", "modfile", "Tagfile", "tagFILE", "catfile", "tagBase", "ownFile", " tagPath", "srcPath"], "length": ["size", "id", "split", "url", "h", "feed", "len", "range", "with", "build", "weight", "limit", "l", "ength", "join", "end", "diff", "pack", "loc", "L", "data", "j", "style", "zip", " Length", "match", "work", "angle", "child", "ime", "sequence", "section", "shape", "depth", "distance", "filename", "name", "iv", "full", "cost", "capacity", "partial", "height", "li", "time", "slice", "string", "count", "path", "load", "delay", "uri", "lock", "Length", "width", "speed", "character", "total", "position", "form", "value", "sl", "duration", "type"], "dirFile": ["buildBook", " directoryFiles", "dirDirectory", "parentFile", "DIRBase", "locFile", "dirBook", " dirfile", "locType", "parentType", " dirBase", "buildfile", "dirfile", "directoryFolder", "DIRFiles", " directoryfile", "directoryBook", "poFile", "directoryfile", " directoryFile", "parentfile", " dirFiles", "DIRFile", "locfile", "dirFiles", "locDirectory", "directoryFile", "poType", "parentDirectory", "dirBase", "poDirectory", " dirBook", "DIRfile", "dirType", "buildFolder", "pofile", "buildFile", " dirFolder", "dirFolder", " directoryBase"], "in": ["plus", "reader", "h", "id", "en", "input", "inc", "din", "arin", "win", "io", "l", "con", "this", "login", "f", "as", "In", "into", "pin", "n", "r", "again", "inner", "init", "ins", "o", "vin", "a", "up", "image", "c", "IN", "inside", "inn", "is", "lin", "bin", "on", "ac"], "out": ["inc", "write", "net", "extra", "down", "io", "output", "outer", "conn", "one", "w", "this", "ou", "on", "to", "OUT", "Out", "auto", "outs", "again", "writer", "inner", "off", "exec", "sync", "name", "o", "other", "ex", "timeout", "up", "point", "file", "or", "outside", "bin", "working", "s", "line"], "inC": [" inVC", "INc", "inL", "inB", "inputVC", "inputc", "InVC", "INC", " inL", " inP", "inputC", "intoL", "INI", "incCL", "intoC", "intoI", "isinCL", "INB", "InCL", " inFile", "uninCL", "inCL", " inU", "incO", "inVC", " inI", "outB", "diffc", "diffC", "incc", "InB", "inO", "InFile", "outL", "inN", "outc", "outP", " inB", "uninC", "uninc", "inc", "isinVC", "INL", " inCL", "InC", "INCL", "diffI", "innC", "INU", "outVC", "uninU", "inP", "inU", "innc", "inputFile", "isinC", " inO", "outCL", "inFile", "diffCL", "innCL", "intoc", " inN", "INO", "outN", "INN", "INP", "incC", "Inc", "inI", " inc", "innL", "INVC"], "outC": ["outCC", " outCC", "tagCD", "inChannel", "againChannel", "inL", "tagC", "outCL", "inCL", " outL", "againL", " outCR", "againC", "OutL", "OutE", "tagE", " outCD", "OUTCD", " outCL", "OutCD", "OUTCC", "outCD", " outChannel", "OUTC", "OUTL", " outE", "outL", "tagCR", "outChannel", "outE", "OutCR", "outCR", "againCL", "OutC", "OutCC"], "i": ["id", "si", "qi", "multi", "ind", "uli", "phi", "l", "b", "f", "di", "n", "zi", "I", "ti", "ni", "ai", "info", "ji", "it", "ui", "ci", "u", "o", "e", "ini", "li", "xi", "index", "slice", "count", "j", "c", "uri", "strength", "ii", "ori", "pi", "z", "ip", "p", "type"]}}
{"id1": "8561732", "id2": "15193222", "code1": "    public boolean actualizarRondaActual(division div) {\n        int intResult = 0;\n        String sql = \"UPDATE divisionxTorneo \" + \" SET rondaActual = \" + div.getRondaActual() + \" WHERE idDivisionxTorneo = \" + div.getidDivision();\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    @Override\n    public void copy(final String fileName) throws FileIOException {\n        try {\n            if (opened) {\n                fileChannel.position(0);\n            } else {\n                fileChannel = new FileInputStream(file).getChannel();\n            }\n            FileChannel dstChannel = null;\n            try {\n                dstChannel = new FileOutputStream(fileName).getChannel();\n                dstChannel.transferFrom(fileChannel, 0, fileChannel.size());\n            } finally {\n                try {\n                    if (dstChannel != null) {\n                        dstChannel.close();\n                    }\n                } catch (Exception exception) {\n                }\n            }\n            if (opened) {\n                fileChannel.position(currentPositionInFile);\n            } else {\n                fileChannel.close();\n            }\n        } catch (IOException exception) {\n            throw HELPER_FILE_UTIL.fileIOException(\"failed copy \" + file + \" to \" + fileName, null, exception);\n        }\n    }\n", "label": 0, "substitutes": {"div": ["draw", "dec", "contract", "dc", "DIV", "d", "director", "division", "dev", "Div", "definition", "this", "diff", "root", "part", "model", "def", "data", "config", "section", "exec", "element", "conf", "component", "desc", "dm", "de", "container", "instance", "dim", "c", "code", "form", "dom", "project", "decl", "dem", "coll"], "intResult": ["interResult", "interAmount", "INTSuccess", "INTResponse", "IntResponse", "INTResults", "IntSuccess", "INTRes", "IntResult", " intSuccess", "IntAmount", "INTReturn", "intAmount", "intRes", "interResponse", "IntReturn", " intRes", "interResults", "INTResult", "intSuccess", "IntResults", "intResponse", "IntRes", "intResults", "intReturn", "interReturn", " intReturn", "interRes", "INTAmount"], "sql": ["select", "dl", "general", "url", "statement", "conn", "params", "cmd", "base", "table", "zip", "serv", "ql", "section", "where", "sync", "eps", "plan", "query", "s", "printf", "QL", "log", "fn", "comment", "pr", "SQL", "job", "string", "seed", "install", "ssl", "db", "expression", "setup", "sq", "q", "database", " SQL", "expr", "str", "shell"], "connection": ["reader", "director", "function", "engine", "BC", "statement", "conn", "communication", "con", "client", "driver", "union", "connected", "environment", "loc", "application", "po", "table", "ctx", "server", "condition", "config", "writer", "mc", "section", "component", "query", "event", "log", "ion", "relation", "lc", "session", "index", "document", "connect", "socket", "c", "db", "context", "error", "manager", "database", "position", "Connection", "proxy", "collection", "p"], "ps": ["relations", "ks", "processor", "proc", "pe", "conn", "pd", "params", "gs", "pg", "ns", "ms", "po", "ups", "cp", "os", "bs", "posts", "qs", "pc", "eps", "ppa", "pa", "pps", "cs", "rs", "PS", "pr", "ls", "Ps", "pse", "pt", "pointer", "sp", "ips", "pp", "pos", "pi", "ds", "pers", "ts", "proxy", "p"]}}
{"id1": "12516574", "id2": "1760350", "code1": "    public static Image getImage(URL url) throws IOException {\n        InputStream is = null;\n        try {\n            is = url.openStream();\n            Image img = getImage(is);\n            img.setUrl(url);\n            return img;\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n        }\n    }\n", "code2": "    public static int deleteOrder(String likePatten) {\n        Connection conn = null;\n        PreparedStatement psmt = null;\n        StringBuffer SQL = new StringBuffer(200);\n        int deleted = 0;\n        SQL.append(\" DELETE FROM JHF_ALIVE_ORDER \").append(\" WHERE   ORDER_ID LIKE  ? \");\n        try {\n            conn = JdbcConnectionPool.mainConnection();\n            conn.setAutoCommit(false);\n            conn.setReadOnly(false);\n            psmt = conn.prepareStatement(SQL.toString());\n            psmt.setString(1, \"%\" + likePatten + \"%\");\n            deleted = psmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            if (null != conn) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    System.out.println(\" error when roll back !\");\n                }\n            }\n        } finally {\n            try {\n                if (null != psmt) {\n                    psmt.close();\n                    psmt = null;\n                }\n                if (null != conn) {\n                    conn.close();\n                    conn = null;\n                }\n            } catch (SQLException e) {\n                System.out.println(\" error  when psmt close or conn close .\");\n            }\n        }\n        return deleted;\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "id", "link", "buffer", "download", "io", "src", "l", "lib", "http", "view", "this", "lr", "fr", "loc", "f", "base", "ref", "zip", "resource", "address", "config", "el", "name", "ur", "ob", "api", "location", "job", "il", "path", "image", "obj", "uri", "file", "ssl", "err", "i", "URL", "service", "Url", "str", "null", "sl"], "is": ["get", "id", "nis", "isa", "src", "ais", "http", "isl", "out", "app", "in", "ms", "as", "was", "iss", "os", "bs", "es", "ris", "ai", "info", "serv", "ir", "js", "ics", "vs", "has", "isi", "init", "it", "ins", "iris", "IS", "api", "mis", "ls", "close", "ri", "isc", "path", "image", "lis", "its", "ab", "ori", "i", "err", "im", "or", "us", "bis", "Is", "ar", "iso", "ps", "s", "ip", "ib", "does", "ie"], "img": ["af", "div", "tmp", "id", "gif", "d", "cm", "arr", "cf", "br", "cat", "bg", "src", "gd", "app", "b", "f", "Image", "data", "jpg", "zip", "work", " image", "aff", "init", "aug", "big", "inst", "rc", "au", "images", "ani", "ae", "iframe", "api", "rb", "pic", "hr", "abc", "image", "obj", "html", "db", "i", "im", "g", "ff", "ig", "ng", "agi", "bin", "amp", "ib", "ie"]}}
{"id1": "5055545", "id2": "8364554", "code1": "    public static void copy(File fromFile, File toFile) throws IOException {\n        if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFile.getAbsolutePath());\n        if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFile.getAbsolutePath());\n        if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFile.getAbsolutePath());\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        String parent = toFile.getParent();\n        if (parent == null) parent = System.getProperty(\"user.dir\");\n        File dir = new File(parent);\n        if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n        if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent);\n        if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    @Override\n    public void executeInterruptible() {\n        EncodeFilesDialog dialog = (EncodeFilesDialog) this.dialog;\n        File encoderFile = null;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            if (Platform.isWindows()) {\n                encoderFile = new File(\".\", \"lame.exe\");\n                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"lame/lame.exe\");\n            } else if (Platform.isLinux()) {\n                encoderFile = new File(\".\", \"lame\");\n                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"lame/lame\");\n            } else {\n                MainWindowInterface.showError(new Exception(Messages.getString(\"operations.file.encode.dialog.notsupported\")));\n                return;\n            }\n            os = new FileOutputStream(encoderFile);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            LOG.error(\"Cannot extract encoder executable\", e);\n            MainWindowInterface.showError(e);\n            return;\n        } finally {\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n        encoderFile.setExecutable(true, true);\n        try {\n            long totalSize = 0l;\n            for (int i = 0, l = filesModel.getSize(); i < l; i++) {\n                if (isInterrupted()) return;\n                IconAndFileListElement element = (IconAndFileListElement) filesModel.get(i);\n                File origFile = element.getFile();\n                totalSize += origFile.length();\n            }\n            rangeModel = dialog.getProgressBar().getModel();\n            rangeModel.setMinimum(0);\n            rangeModel.setMaximum((int) totalSize);\n            int parallelProcesses = dialog.getParallelProcesses();\n            List<Thread> encodingThreads = new ArrayList<Thread>();\n            encodingRunnables = new ArrayList<EncoderLauncherRunnable>(parallelProcesses);\n            for (int i = 0; i < parallelProcesses; i++) {\n                EncoderLauncherRunnable encoderLauncherRunnable = new EncoderLauncherRunnable(i, dialog, encoderFile);\n                Thread thread = new Thread(encoderLauncherRunnable);\n                encodingRunnables.add(encoderLauncherRunnable);\n                encodingThreads.add(thread);\n                thread.start();\n            }\n            for (Thread thread : encodingThreads) {\n                thread.join();\n            }\n            if (!isInterrupted()) MainWindowInterface.showMessage(Messages.getString(\"operations.file.encode.execute.done.title\"), Messages.getString(\"operations.file.encode.execute.done.message\").replace(\"${number}\", \"\" + filesModel.getSize()));\n        } catch (Exception e) {\n            LOG.error(\"Cannot encode files\", e);\n            MainWindowInterface.showError(e);\n        } finally {\n            if (encoderFile != null) encoderFile.delete();\n            dialog.setVisible(false);\n        }\n    }\n", "label": 1, "substitutes": {"fromFile": ["sourceDir", " fromFolder", " fromStream", "apiPath", "leftFile", "toFiles", "FromPage", "remoteFile", "apiFiles", "startPage", "newfile", "newStream", "remoteFiles", "formFolder", "FromDir", "FromStream", "fromStream", "forLibrary", "startfile", " fromFilename", "fromFolder", "forPage", "leftFiles", "startFolder", "sourcefile", "sourceFile", "leftDir", "fromLibrary", "startFile", " fromLibrary", "toFilename", "newDir", "formfile", "fromPage", "fromfile", "FromFolder", "sourceFiles", "forFile", "sourcePath", "newFile", " fromFiles", "newFolder", "toDir", "formPage", "fromFilename", "FromLibrary", " fromfile", "apiFile", "Fromfile", "fromFiles", "apifile", "formFile", " fromDir", " fromPage", "remotePath", "forDir", "leftFilename", "sourcePage", " fromPath", "fromPath", "forFolder", "fromDir", "FromFile"], "toFile": ["ToFile", "Tofile", "toDirectory", "sourceFolder", "toFiles", "targetStream", "toFolder", " toFolder", "toPlace", "templateFile", "ToLibrary", " tofile", "templatePlace", " toLibrary", "TODir", "TOFolder", " toPath", " toDir", " toFiles", "sourcefile", "targetPlace", "sourceFile", "toStream", "ToFolder", "templateStream", "TOfile", "ToDirectory", "soPath", "ToFiles", "ToPath", "toDir", "toLibrary", "targetFile", "ToDir", "templateDir", " toPlace", "soFile", "soDir", "fromDirectory", "toPath", "fromFiles", "tofile", " toDirectory", "targetDir", " toStream", "sourceDirectory", "TOFile", "fromDir", "sofile"], "parent": ["source", "host", "Parent", "page", "div", "id", "memory", "inc", "user", "term", "connection", "complete", "function", "parents", "am", "any", "home", "client", "owner", "root", "part", "loc", "p", "region", "directory", "tree", "master", "resource", "handler", "child", "par", "fat", "address", "ac", "name", "ppa", "pa", "it", "large", "old", "per", "unit", "patch", "api", "content", "session", "key", "pt", "rule", "path", "point", "pool", "pointer", "cache", "string", "file", "uri", "search", "and", "current", "valid", "option", "test", "port", "null", "ip", "location", "type"], "dir": ["folder", "div", "dec", "dc", "id", "url", " directory", "user", "d", "rel", "dep", "dict", "director", "iter", "cat", "dev", "doc", "DIR", "wd", "out", "object", "home", "fd", "root", "part", "loc", "base", "ver", "data", "directory", "di", "def", "dis", "dn", "der", "ir", "fun", "cur", "name", "direction", "da", "mod", "container", "per", "keep", "dr", "up", "col", "path", "file", "db", "manager", "dist", "md", "group", "entry", "coll", "Dir"], "from": ["source", "get", "via", "left", "url", "link", "pe", "connection", "cm", "range", "with", "io", "conn", "one", "http", "view", "out", "client", "in", "con", "of", "ou", "part", "normal", "base", "without", "po", "From", "by", "find", "auto", "stream", "data", "class", "server", "address", "low", "module", "component", "name", "ci", "o", "two", "per", "api", "max", "ch", "se", "c", "file", "parse", "flo", "or", "vol", "ce", "start", "form", "who", "when", "add", "empty", "on", "so"], "to": ["source", "via", "page", "size", "su", "site", "url", "about", "token", "office", "connection", "not", "with", "top", "co", "tto", "io", "output", "ma", "TO", "one", "http", "thro", "out", "client", "b", "To", "part", "base", "op", "po", "no", "by", "on", "auto", "server", "eto", "until", "name", "o", "two", "target", "see", "per", "log", "api", "too", "cache", "socket", "db", "file", "flo", "or", "pi", "who", "store", "copy", "so", "type"], "buffer": ["page", "read", "reader", "size", "queue", "memory", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "limit", "layer", "number", "data", "bytes", "available", "resource", "server", "address", "writer", "pad", "uffer", "transfer", "null", "batch", "length", "flush", "comment", "wave", "buf", "offset", "variable", "border", "seed", "cache", "character", "header", "block", "position", "bin", "vector", "port", "duration"], "bytesRead": ["BytesAct", " bytesLength", "tesNeed", "BytesWrite", "usersReader", "tesRead", "bytesReader", " bytesCount", "filesUse", "BytesWritten", "usersLoad", "tesWrite", "BytesUse", "usersCount", "bytesUse", "BytesNeed", "bytesWritten", "tesLength", "filesNeed", "filesWrite", " bytesLoad", "bytesAct", "filesRead", "stringsRead", "BytesLength", "stringsReader", "tesUse", "bytesLoad", " bytesWritten", "tesWritten", "bytesLength", "bytesNeed", "usersRead", " bytesReader", " bytesAct", "bytesCount", "stringsLoad", "bytesWrite", "tesAct", "stringsCount", "BytesRead"]}}
{"id1": "948486", "id2": "8452567", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static JSONObject sendCouchRequest(HttpUriRequest request) {\n        try {\n            HttpResponse httpResponse = (HttpResponse) new DefaultHttpClient().execute(request);\n            HttpEntity entity = httpResponse.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                String resultString = convertStreamToString(instream);\n                instream.close();\n                JSONObject jsonResult = new JSONObject(resultString);\n                return jsonResult;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"infile": ["inputfile", "infilename", "outFile", "infiles", "inFile", "inputfiles", "inputfilename", "outfiles", " infilename", "infp", " infp", "inputfp", "outfilename", "Infiles", " infiles", "InFile", "outfp", "Infilename", "inputFile", "Infile"], "outfile": ["outputfp", "outFile", "infilename", "Outname", "newfile", "OutFile", "outputfilename", " outFile", "newname", "infp", "newfolder", "outfilename", "Outfile", " outfolder", "newFile", " outname", "outfolder", " outfp", "outputfolder", "outfp", "Outfolder", "infolder", "outname", " outfilename", "outputfile"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "min", "nin", "conn", "con", "b", "login", "as", "base", "data", "In", "pin", "into", "re", "r", "inas", "thin", "again", "ac", "isin", "inner", "init", "ins", "vin", "gin", "ini", "a", "m", "sin", "cin", "image", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "bin", "s", "ic", "pass"], "out": ["source", "parent", "inc", "write", "net", "co", "io", "output", "outer", "conn", "lib", "one", "client", "home", "ou", "base", "on", "to", "no", "In", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "ex", "post", "timeout", "session", "up", "job", "point", "image", "cache", "socket", "file", "obj", "error", "err", "or", "bin", "copy", "exit", "line"], "buffer": ["source", "size", "reader", "split", "url", "queue", "input", "write", "binary", "feed", "len", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "base", "layer", "data", "bytes", "server", "raw", "address", "uffer", "transfer", "null", "padding", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "count", "border", "seed", "cache", "fb", "value", "type"], "read": ["play", "select", "next", " write", "size", "reader", "ad", "input", "get", "write", "inc", "id", "feed", "len", "Read", "ind", "iter", " skip", "fill", "READ", "ride", "io", "limit", "end", "tell", "f", "sleep", "find", "n", "work", "raw", "exec", "x", "sync", "send", "reading", "_", "length", "allow", "run", "close", "se", "slice", "count", "pass", "load", "connect", "parse", "i", "seek", "check", "wait", "lex", "current", " copy", "start", " count", "ip", "add", "copy", " Read", "use", "reads"], "success": ["successful", "continue", "roll", "default", "warning", "first", "better", "successfully", "open", " succeed", "complete", "growth", "result", "right", "message", "Success", "true", "flash", "winner", " succ", "model", " successful", "cess", "data", "fast", "again", "response", "primary", "xx", "rolled", " Success", "method", "func", "results", "failed", "initial", "comment", "danger", "content", "status", "done", "path", "respons", "error", "fail", "modified", "valid", "construct", "ccess", "rolling", "follow", "ceed", "good", "value", "null", "pass"]}}
{"id1": "8731413", "id2": "153462", "code1": "    public ImportFromFile() {\n        JFrame jf = new JFrame();\n        JFileChooser fc = new JFileChooser(KTH.data._path);\n        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        int returnVal = fc.showOpenDialog(jf);\n        File file = null;\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            file = fc.getSelectedFile();\n            KTH.data._path = file.getParent();\n            System.out.println(file.getAbsolutePath() + \"\\n\");\n        } else {\n        }\n        if (file != null) {\n            File f = new File(KTH.data.getHomeDir() + File.separator + KTH.data.katalogName);\n            System.out.println(f + (f.exists() ? \" is found \" : \" is missing \"));\n            if (f.exists() && !IOUtils.isNewerContent(file, f)) {\n            } else {\n                try {\n                    IOUtils.copyFile(file, f, true);\n                } catch (Exception e) {\n                    KTH.out.err(e);\n                }\n            }\n            KTH.dc2.removeDc(\"Import\");\n        } else {\n        }\n    }\n", "code2": "    private static File copyFileTo(File file, File directory) throws IOException {\n        File newFile = new File(directory, file.getName());\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(file);\n            fos = new FileOutputStream(newFile);\n            byte buff[] = new byte[1024];\n            int val;\n            while ((val = fis.read(buff)) > 0) fos.write(buff, 0, val);\n        } finally {\n            if (fis != null) fis.close();\n            if (fos != null) fos.close();\n        }\n        return newFile;\n    }\n", "label": 1, "substitutes": {"jf": ["bf", "jfd", " jfs", "jjfd", "ojfd", "bc", "jrf", "jfile", "jjcf", "ojf", "bfile", "gf", "Jf", "ojfs", "gc", "gfile", "jcf", "jjf", "jfs", "ojcf", "Jrf", "jc", "grf", "Jfile", " jfd", " jcf", "jjfs", "Jc", "brf"], "fc": ["xf", "af", "dc", "rf", "bf", "uc", "lf", "cf", "vc", "fs", "con", " FC", "fp", "sf", "fd", "bc", "fr", "cv", "wic", "fe", "ec", "ctrl", "fw", "circ", "xc", "enc", "mc", "pc", "FC", "GF", "cl", "fn", "fl", "lc", "jc", "abc", "il", "CF", "c", "flo", "fb", "fm", "cc", "fi", "ct", "nc", "fa", "fx"], "returnVal": ["resultval", " returnValue", " returnval", "ReturnNum", "returnValue", "returnval", "returnNum", " returnNum", "ReturnVal", "ReturnValue", "resultValue", " returnTx", "openTx", "resultNum", "Returnval", "openVal", "openval", "ReturnTx", "openValue", "resultVal", "returnTx"], "file": ["cf", "l", "sf", "model", "directory", "resource", "info", "name", "log", "cl", " files", "le", "image", "files", "fa", "line", "folder", "bf", "place", "feed", "lf", "lib", "object", "b", "po", "future", "handler", "child", "it", "F", "found", "il", "pool", "cache", "c", "live", "local", "FILE", "self", "fi", "source", "page", "parent", "url", "pe", "function", "fo", "http", "fp", "base", "work", "el", "x", "filename", "full", "e", "o", "path", "null", "p", "h", "ile", "File", "letter", "fr", "fe", "where", "dir", "document", " File", "db", "form", "unit"], "KTH": ["NKTH", " KATH", "KITT", "JETH", " KAST", "KOTH", "JTH", "HKCOM", " KTh", " KCOM", " Kth", "KSTh", "SKCH", "KINGth", " KETH", "kATH", "KINGTH", "KTh", "kAST", "KSth", "KINGITT", "SKATH", " KITT", "HKITT", "KETH", "SKETH", " KOTH", " KTD", "KSOTH", "ELCOM", "HKTH", "AKth", "NKTD", "OKTh", "KCOM", "kTH", "SKAST", " KTHER", "SKTH", "SKTHER", "ELTH", "KATH", "AKETH", "NKth", "KTD", "AKTH", "KTHER", "Kth", "HKth", "OKTH", "OKth", "KAST", "NKETH", "Jth", "AKTD", "HKTh", "ELTh", "ELth", "kTHER", "KINGTh", "KCH", "KSTH", " KCH", "OKOTH", "JCH", "SKth"], "data": ["language", "resources", "div", "parent", "next", "reader", "site", "general", "default", "input", "memory", "user", "layout", "admin", "output", "join", "this", "state", "root", "model", "base", "loader", "di", "storage", "system", "style", "resource", "server", "config", "info", "writer", "module", "body", "DATA", "management", "da", "results", "json", "api", "internal", "media", "cache", "apps", "service", "database", "group", "design", "dat"], "_path": ["_dir", " _dir", " _cat", " _location", "_Path", "_location", " _Path", " _name", "_cat", "_name"], "f": ["af", "folder", "h", "rf", "url", "d", "feed", "cf", "function", "File", "fo", "l", "fs", "w", "foo", "fp", "b", "sf", "fd", "fr", "base", "fe", "n", "x", "fun", "name", "filename", "dir", "u", "e", "o", "flow", "fn", "t", "F", "found", "m", "df", "fold", "v", "fl", "path", "j", "c", "i", "fb", "g", "fen", "s", "fa", "p", "fx"]}}
{"id1": "11840745", "id2": "471591", "code1": "    public final void close() throws IOException {\n        if (dataStream == null) throw new NullPointerException(\"Write stream is null.\");\n        dataStream.flush();\n        dataStream.close();\n        dataStream = null;\n        File tmpFile = new File(packPath + \".tmp\");\n        FileOutputStream packStream = new FileOutputStream(packPath);\n        try {\n            String nbFiles = Long.toString(currentNbFiles) + \"\\0\";\n            packStream.write(FLAT_PACK_HEADER.getBytes(Charsets.ISO_8859_1));\n            structBufferWriter.flush();\n            structBufferWriter.close();\n            int headerSize = structBuffer.size() + nbFiles.length();\n            packStream.write(Integer.toString(headerSize).getBytes(Charsets.ISO_8859_1));\n            packStream.write('\\0');\n            packStream.write(nbFiles.getBytes(Charsets.ISO_8859_1));\n            structBuffer.writeTo(packStream);\n            structBufferWriter = null;\n            structBuffer = null;\n            FileInputStream in = new FileInputStream(tmpFile);\n            try {\n                byte[] buffer = new byte[FILE_COPY_BUFFER_LEN];\n                int read;\n                while ((read = in.read(buffer)) > 0) packStream.write(buffer, 0, read);\n                packStream.flush();\n                packStream.close();\n            } finally {\n                Utilities.closeStream(in);\n            }\n        } finally {\n            Utilities.closeStream(packStream);\n        }\n        if (tmpFile.isFile()) Utilities.deleteFile(tmpFile);\n        packPath = null;\n        structBuffer = null;\n    }\n", "code2": "    private String getFanFouMessage(int pageNo) throws IOException {\n        URL url = new URL(\"http://api.fanfou.com/statuses/user_timeline.json?page=\" + pageNo);\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"GET\");\n        String basicAuth = Base64.encode((getUsername() + \":\" + getPassword()).getBytes());\n        request.addRequestProperty(\"Authorization\", \"Basic \" + basicAuth);\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        StringBuffer sb = new StringBuffer();\n        while ((b = reader.readLine()) != null) {\n            sb.append(b);\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"dataStream": ["outputSteam", "outputStream", "dataSystem", "inputSteam", "dataSource", "DataReader", " datastream", "DataSteam", "writeStream", " dataSteam", "dataWriter", "inputstream", "dataSem", " dataStreamer", "downloadstream", "downloadStream", "writeWriter", "downloadSteam", "writeSource", " dataWriter", "inputStreamer", "inputReader", "outputstream", " dataSystem", "DataStreamer", " dataSem", "inputSource", "dataSteam", "inputSem", "inputWriter", "datastream", "inputSystem", " dataSource", "writeSteam", "downloadSem", "dataReader", "outputSystem", "inputStream", " dataReader", "dataStreamer", "DataStream"], "tmpFile": ["tempLine", "zipFile", "mpClass", "srcFiles", "tempFiles", "tempPath", "tempFile", " temporaryFile", "srcfile", "zipLine", "tmpPage", "tmpFolder", "pkgLine", "srcPlace", "mpPath", " tmpPath", " temporaryfile", " tmpClass", " tmpPage", "zipFiles", "tempPage", "mpFolder", " tmpfile", "tempfile", " temporaryPage", "tmpfile", "tmpPlace", "pkgFile", "zipfile", "zipPlace", " tmpFiles", "tmpLine", "tempClass", " tmpFolder", "mpFile", "srcFile", "tmpFiles", " temporaryFiles", "pkgfile", "tmpClass", "tempPlace", "tmpPath", "tempFolder", "pkgFiles"], "packStream": ["linkStream", "taskStream", "inputPath", "packContext", "packstream", "caseSteam", "pushStream", "packFile", "taskStreamer", "parseFile", "PackChannel", "loadStreamer", "ackFile", "packSteam", "sendStreamer", "parseStreamer", "PackSteam", "shapeStream", "ackstream", "ackContext", " packContext", "packChannel", "PackPath", "pushChannel", "parseStream", " packSteam", "linkFile", "linkSteam", " packstream", "linkStreamer", "taskSteam", "caseStream", "inputStreamer", "packStreamer", "sendStream", "shapeFile", "buildContext", "buildStreamer", "pushSteam", "PackFile", "ackSteam", "PackStreamer", " packFile", "ackStreamer", "ackStream", "parsestream", "caseStreamer", "caseThread", "taskstream", "loadStream", " packStreamer", "buildStream", "sendSteam", "loadstream", "pushStreamer", "packThread", "parseSteam", "buildSteam", " packThread", "PackStream", "Packstream", "shapeSteam", "parseThread", "shapeStreamer", "inputFile", "loadSteam", "inputStream", "sendChannel"], "nbFiles": ["nbBlocks", "nbFile", "NBPages", "npFrames", "NumBytes", "NBBytes", "nbPages", "NBFiles", "NBFrames", "nbCharacters", "numfiles", "NumFiles", "kbFrames", "nbfiles", "nrPoints", "kbBlocks", "npBlocks", "NBFile", "npPages", "NBPoints", "nrFile", "nbPoints", "nbBytes", "NBCharacters", "NBBlocks", "numFile", "numBytes", "Numfiles", "nbFrames", "kbPages", "nrFiles", "NumCharacters", "numPoints", "numCharacters", "kbFiles", "numFiles", "npFiles", "NBfiles"], "headerSize": ["Headersize", "bufferInfo", " headerLength", "numberLength", "HeaderSize", "headerLen", " headerCode", " headerInfo", " headersize", "headersize", "headerLength", "HeaderLength", "headerCode", "bufferLen", "numbersize", "numberCode", "bufferSize", " headerLen", "HeaderCode", "headerInfo", "numberSize", "HeaderInfo", "HeaderLen", "bufferLength"], "structBufferWriter": ["StructBufferReader", " structBufferWrite", " structBufferReader", "structContainerWrite", "structHeaderRW", "structBlockWrite", " structQueueReader", "structHeaderWritten", "structHeaderFile", "StructBufferWrite", " structQueueWrite", " structQueueRW", " structQueueWriter", "structFileWritten", " structBufferRW", "structBlockWriter", "structQueueWrite", "StructFileWritten", "StructBufferWritten", "structFileWriter", "StructFileWrite", "structQueueRW", "StructBufferFile", "structBufferRW", "structQueueWriter", "structFileFile", "structBlockFile", "structHeaderWriter", "structContainerReader", "structBufferFile", "structContainerWriter", "StructFileFile", "structContainerWritten", "structBufferWritten", "structFileReader", "structHeaderWrite", "StructFileReader", "StructBufferWriter", "structBlockReader", "structFileWrite", "structFileRW", "structHeaderReader", "structBufferWrite", "structBufferReader", "structQueueReader", "StructFileWriter"], "structBuffer": ["StructWriter", " structHeader", "structReader", "structCounter", "STRUCTHeader", " structWriter", "configBuff", "intHeader", "StructBuffer", "STRUCTWriter", "configQueue", "StructCounter", "intWriter", " structContainer", "packReader", "structQueue", "STRUCTReader", "intBuffer", "configReader", "structContainer", "intCounter", "packBuffer", "configBuffer", " structQueue", "configWriter", "STRUCTQueue", "packBuff", " structCounter", "structHeader", " structBuff", " structReader", "structWriter", "STRUCTBuffer", "StructHeader", "configContainer", "structBuff", "STRUCTContainer", "configHeader", "packWriter", "STRUCTBuff"], "in": ["reader", "h", "id", "url", "input", "inc", "din", "win", "connection", "min", "nin", "conn", "l", "con", "out", "b", "login", "f", "data", "In", "stream", "again", "r", "re", "thin", "serv", "isin", "inner", "exec", "it", "ins", "gin", "ini", "a", "ex", "rec", "image", "c", "file", "socket", "i", "IN", "err", "or", "ssl", "inn", "rin", "is", "bin", "on", "ac"], "buffer": ["source", "size", "reader", "queue", "write", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "message", "limit", "row", "layer", "channel", "number", "data", "table", "base", "resource", "server", "address", "writer", "pad", "uffer", "transfer", "null", "batch", "flush", "length", "wave", "capacity", "FFER", "buf", "offset", "variable", "slice", "border", "cache", "record", "character", "header", "block", "texture", "position", "bin", "value"], "read": ["select", "get", "next", " write", "reader", "size", "play", "input", "id", "write", "feed", "Read", "ind", "build", "fill", "READ", "k", "ride", "w", "end", "loop", "skip", "find", "n", "work", "raw", "child", "exec", "x", "send", "sync", "old", "reading", "_", "length", "allow", "text", "max", "run", "key", "index", "count", "pass", "load", "c", "readable", "parse", "i", "check", "seek", "each", "wait", "type", "lex", "create", "start", "add", "copy", " Read", "use", "reads"], "packPath": ["packFile", "parseFile", "packFolder", " packFolder", "packagePath", "zippath", "PackPath", " packDir", "parseLocation", "zipDir", "parseStream", "zipLocation", " packLocation", "packDirectory", "packpath", "PackFile", "packDir", "parseDirectory", "packageDir", " packFile", "zipPath", "packageFolder", "zipFolder", " packpath", "zipDirectory", "PackDir", "zipStream", "parsepath", "parseDir", "packagepath", " packDirectory", "Packpath", "packLocation", "parsePath"]}}
{"id1": "2980809", "id2": "5551857", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String url = request.getParameter(\"proxyurl\");\n        URLConnection conn = new URL(url).openConnection();\n        Reader in = new InputStreamReader(conn.getInputStream(), response.getCharacterEncoding());\n        response.setContentType(conn.getContentType());\n        response.setContentLength(conn.getContentLength());\n        Writer out = response.getWriter();\n        char[] buf = new char[256];\n        int len;\n        while ((len = in.read(buf)) != -1) {\n            out.write(buf, 0, len);\n        }\n        in.close();\n        out.close();\n        String log = request.getParameter(\"logging\");\n        if (log != null && log.toLowerCase().equals(\"true\")) logRequest(request);\n    }\n", "code2": "    public static String sha1(String src) {\n        MessageDigest md1 = null;\n        try {\n            md1 = MessageDigest.getInstance(\"SHA-1\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md1.update(src.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return hex(md1.digest());\n    }\n", "label": 0, "substitutes": {"request": ["page", "parent", "route", "reader", "rf", "input", "user", "queue", "req", "connection", "xml", "complete", "reply", "result", "message", "from", "view", "client", "object", "this", "model", "application", "worker", "version", "re", "resource", "server", "call", "child", "Request", "writer", "info", "use", "config", "method", "query", "event", "requ", "report", "instance", "post", "session", "frame", "path", "image", "uri", "context", "current", "q", "subject", "ware", "position", "order", "forward", "QUEST"], "response": ["next", "host", "page", "parent", "respond", "site", "default", "connection", "reply", "ception", "result", "message", "output", "view", "http", "object", "client", "model", "application", "onse", "version", "re", "resource", "server", "serv", "writer", "body", "results", "report", "json", "api", "content", "status", "session", "Response", "index", "document", "respons", "cache", "image", "error", "resp", "service"], "url": ["source", "host", "page", "connection", "feed", "download", "ll", "l", "http", "base", "loc", "f", "href", "channel", "resource", "server", "address", "config", "name", "fl", "location", "ls", "string", "path", "image", "uri", "file", "ssl", "URL", "secret", "Url", "www", "domain", "proxy", "sl"], "conn": ["host", "Config", "dc", "en", "ln", "net", "connection", "open", "auth", "cf", "core", "l", "ct", "con", "ns", "client", "connected", "f", "loc", "ca", "loader", "cp", "n", "enc", "ctx", "serv", "dn", "cn", "pc", "sync", "init", "res", "query", "ci", "act", "Connect", "Client", "ch", "cli", "content", "ann", "close", "col", "connect", "c", "socket", "ssl", "error", "err", "resp", "conv", "Connection", "Conn", "nc", "coll"], "in": ["reader", "h", "input", "inc", "din", "ln", "win", "connection", "buffer", "io", "nin", "w", "con", "login", "loader", "In", "pin", "again", "n", "r", "ac", "inner", "init", "ins", "rc", "gin", "ini", "kin", "rec", "cin", "c", "i", "IN", "err", "inn", "rin", "lin", "fin", "bin", "s", "p"], "out": ["default", "inc", "write", "user", "net", "connection", "buffer", "io", "output", "outer", "w", "b", "app", "part", "login", "f", "data", "n", "Out", "outs", "again", "OUT", "serv", "writer", "inner", "off", "exec", "name", "init", "o", "cookie", "ex", "up", "string", "cache", "socket", "file", "error", "i", "bin", "copy", "line", "ext"], "buf": ["dec", "cb", "la", "bh", "uc", "buffer", "ha", "buff", "cf", "br", "src", "cas", "b", "cmd", "bc", "fd", "loc", "cv", "data", "bd", "bytes", "ctx", "cur", "batch", "rc", "bb", "seq", "uf", "cap", "bag", "bound", "done", "lc", "c", "vec", "wb", "fb", "conv", "ff", "bin", "rb", "bp"], "len": ["size", "split", "en", "ln", "la", "lf", "ind", "iter", "min", "limit", "l", "pre", "b", "val", "ler", "end", "part", "f", "base", "Len", "no", "ref", "n", "r", "oa", "el", "nt", "cl", "length", "fl", "lc", "li", "ann", "le", "all", "il", "count", "c", "rev", "i", "err", "pos", "lin", "fin", "str", "line", "sl", "ie"], "log": ["id", "en", "msg", "write", "LOG", "sql", "feed", "plug", "ln", "core", "output", "ger", "og", "l", "Log", "hide", "bug", "model", "login", "loc", "zip", "config", "tool", "low", "lo", "tag", "shell", "ge", "cl", "stat", "plot", "job", "key", "le", "run", "path", "debug", "lock", "file", "fail", "lex", "broad", "level", "olog", "blog", "pl", "put", "line", "sl", "bl", "type"]}}
{"id1": "20254498", "id2": "17511631", "code1": "    public static void main(String[] args) throws IOException {\n        PrintStream filesTxt = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"temp/index/files.txt\")));\n        String[] files = new File(Constants.INDEX_PATH).list();\n        for (int i = 0; i < files.length; i++) {\n            String f = files[i];\n            if (f.equals(\"deletable\") || f.startsWith(\".\")) continue;\n            FileInputStream in = new FileInputStream(new File(Constants.INDEX_PATH, f));\n            FileOutputStream out = new FileOutputStream(new File(targetDir, f + \".t\"));\n            byte[] buf = new byte[16384];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n            in.close();\n            out.close();\n            filesTxt.println(f);\n        }\n        filesTxt.close();\n    }\n", "code2": "    private static void extract(final ZipFile zf, final ZipEntry zipEntry, final String desDir, final int... startDirLevel) throws IOException {\n        File desf = new File(desDir);\n        if (!desf.exists()) {\n            desf.mkdirs();\n        }\n        int start = 1;\n        if (null != startDirLevel && startDirLevel.length > 0) {\n            start = startDirLevel[0];\n            if (start < 1) {\n                start = 1;\n            }\n        }\n        String startDir = \"\";\n        String zeName = zipEntry.getName();\n        String folder = zeName;\n        boolean isDir = zipEntry.isDirectory();\n        if (null != folder) {\n            String[] folders = folder.split(\"\\\\/\");\n            if (null != folders && folders.length > 0) {\n                int len = folders.length;\n                if (start == 1) {\n                    startDir = zeName;\n                } else {\n                    if (start > len) {\n                    } else {\n                        for (int i = start - 1; i < len; i++) {\n                            startDir += \"/\" + folders[i];\n                        }\n                        if (null != startDir) {\n                            startDir = startDir.substring(1);\n                        }\n                    }\n                }\n            }\n        }\n        startDir = StringUtils.trim(startDir);\n        if (StringUtils.isNotEmpty(startDir)) {\n            StringBuilder desFileName = new StringBuilder(desDir);\n            if (!desDir.endsWith(\"/\") && !startDir.startsWith(\"/\")) {\n                desFileName.append(\"/\");\n            }\n            desFileName.append(startDir);\n            File destFile = new File(desFileName.toString());\n            if (isDir) {\n                if (!destFile.exists()) {\n                    destFile.mkdirs();\n                }\n            } else {\n                File parentDir = new File(destFile.getParentFile().getPath());\n                if (!parentDir.exists()) {\n                    parentDir.mkdirs();\n                }\n                InputStream is = zf.getInputStream(zipEntry);\n                OutputStream os = new FileOutputStream(destFile);\n                IOUtils.copy(is, os);\n                if (null != is) {\n                    is.close();\n                }\n                if (null != os) {\n                    os.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"filesTxt": ["fileNXT", "fileTtxt", "filesWXT", "fileNxt", "FilesWtxt", "FilesWxt", "filesFext", "filesWtxt", "indexFXT", "FilesTtxt", "filesMXT", "fileNext", "indexFext", "FilesTXT", "filesWxt", "FilesTxt", "filesNxt", "filesTXT", "filesWext", "fileTxt", "indexText", "indexFxt", "filesNXT", "filesText", "indexTxt", "indexTtxt", "filesNtxt", "filesFxt", "fileText", "FilesText", "filesMtxt", "fileNtxt", "FilesWext", "indexFtxt", "filesFXT", "filesMext", "FilesWXT", "filesMxt", "indexTXT", "fileTXT", "filesFtxt", "filesTtxt", "filesNext"], "files": ["ums", "Files", "classes", "tests", "balls", "strings", "fts", "events", "errors", "pes", "sections", "lines", "keys", "l", "fs", "items", "books", "blocks", "issues", "bytes", "scenes", "bs", "objects", "flows", "sites", "models", "archives", "groups", "filename", "users", "ins", "images", "pages", "requires", "names", "ls", "fields", "words", "index", "docs", "thumbnails", "features", "ips", "file", "iles", "projects", "jobs", "ids", "services", "uploads"], "i": ["id", "h", "si", "multi", "qi", "iu", "hi", "k", "io", "phi", "yi", "y", "b", "di", "bi", "mu", "I", "ni", "ti", "ai", "info", "oi", "gi", "x", "ui", "ci", "o", "u", "e", "eni", "t", "ini", "li", "v", "key", "xi", "index", "slice", "ri", "j", "uri", "ii", "pi", "is", "fi", "mi", "ip", "p", "ie"], "f": ["xf", "af", "h", "rf", "bf", "d", "feed", "lf", "cf", "k", "flat", "fo", "l", "fs", "fc", "format", "fp", "sf", "b", "of", "fd", "fr", "inf", "tf", "fe", "ref", "r", "info", "x", "filename", "name", "u", "e", "o", "fn", "t", "F", "m", "fold", "df", "v", "string", "j", "c", "file", "fb", "g", "fen", "fm", "field", "fi", "form", "s", "fa", "p", "fx"], "in": ["reader", "h", "id", "url", "input", "inc", "din", "d", "win", "pull", "cf", "nin", "l", "con", "b", "login", "as", "In", "pin", "again", "r", "into", "serv", "isin", "inner", "init", "ins", "e", "wave", "ini", "a", "up", "cin", "c", "socket", "IN", "inside", "err", "g", "inn", "rin", "is", "lin", "bin", "ic"], "out": ["plus", "parent", "plain", "inc", "net", "extra", "co", "io", "output", "outer", "conn", "lib", "w", "client", "base", "to", "Out", "OUT", "outs", "again", "prefix", "serv", "writer", "inner", "exec", "o", "exp", "log", "gin", "ex", "v", "up", "image", "socket", "file", "err", "builder", "bin", "copy", "p"], "buf": ["dec", "nob", "bp", "cb", "queue", "bf", "la", "bh", "uc", "buffer", "buff", "br", "uint", "b", "cmd", "bc", "base", "cv", "data", "bd", "bytes", "enc", "ctx", "box", "pad", "off", "cur", "batch", "rc", "bb", "seq", "uf", "cap", "bag", "v", "ba", "path", "c", "ab", "vec", "wb", "fb", "conv", "ff", "rb", "padding", "p"], "n": ["size", "an", "en", "num", "d", "nn", "len", "nr", "k", "nin", "l", "y", "b", "ns", "end", "number", "no", "rn", "ni", "nor", "x", "ne", "na", "u", "o", "e", "nt", "t", "m", "nu", "v", "index", "N", "j", "c", "pos", "un", "nb", "nd", "ng", "sn", "z", "nc", "ner", "p"]}}
{"id1": "5671908", "id2": "17568209", "code1": "    private static String readGeoJSON(String feature) {\n        StringBuffer content = new StringBuffer();\n        try {\n            URL url = new URL(feature);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = rd.readLine()) != null) {\n                content.append(line);\n            }\n            conn.disconnect();\n        } catch (Exception e) {\n        }\n        return content.toString();\n    }\n", "code2": "    private static boolean CopyFile(File srcFile, File tagFile) throws IOException {\n        if (srcFile == null || tagFile == null) {\n            return false;\n        }\n        int length = 2097152;\n        File dirFile = new File(getFileFolder(tagFile.getAbsolutePath()));\n        if (!dirFile.exists()) {\n            dirFile.mkdirs();\n        }\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(tagFile.getAbsolutePath());\n        FileChannel inC = in.getChannel();\n        FileChannel outC = out.getChannel();\n        int i = 0;\n        while (true) {\n            if (inC.position() == inC.size()) {\n                inC.close();\n                outC.close();\n                break;\n            }\n            if ((inC.size() - inC.position()) < 20971520) length = (int) (inC.size() - inC.position()); else length = 20971520;\n            inC.transferTo(inC.position(), length, outC);\n            inC.position(inC.position() + length);\n            i++;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"feature": ["source", "route", "id", "browser", "feed", "range", "edge", "format", "Features", "license", "request", "bug", "fr", "model", "layer", "base", "cover", "resource", "config", "info", "address", "filename", "name", "query", "feat", "report", " Feature", "family", "frame", "image", "document", "features", "uri", "error", "file", "grain", "attribute", "service", "Feature", "figure", "project", "concept", "type"], "content": ["default", "connection", "feed", "buffer", "xml", "Content", "result", "car", "core", "message", "output", "format", "object", "client", "column", "const", "layer", "loader", "data", "cover", "response", "clean", "resource", "server", "address", "config", "work", "ontent", "writer", "section", "word", "body", "event", "report", "cont", "json", "container", "comment", "job", "string", "document", "node", "load", "cache", "file", "code", "array", "header", "value"], "url": ["page", "nl", "link", "web", "connection", "feed", "pull", "build", "l", "http", "b", "lr", "fr", "base", "f", "layer", "r", "resource", "aur", "server", "org", "config", "update", "ur", "rc", "log", "bel", "sl", "fl", "rl", "c", "file", "ssl", "uri", "URL", "Url", "www", "blog", "gl", "str", "coll", "ll"], "conn": ["contract", "cb", "connection", "auth", "not", "cm", "open", "cf", "core", "ct", "http", "con", "client", "cmd", "fd", "Conn", "fr", "loc", "loader", "rn", "cp", "n", "enc", "ctx", "org", "ai", "cn", "pc", "conf", "exec", "sync", "ci", "rc", "nt", "act", "coll", "Connect", "ch", "cli", "lc", "ann", "close", "col", "cr", "connect", "c", "ssl", "db", "rt", "err", "conv", "cc", "Connection", "ca", "nc", "cmp"], "rd": ["reader", "dc", "cd", "ra", "rx", "d", "Reader", "ded", "dig", "dd", "ld", "xd", "ro", "vd", "pd", "td", "wd", "ird", "fd", "lr", "fr", "rn", "bd", "r", "rer", "rc", "erd", "rm", "rs", "rod", "rh", "dr", "hr", "ri", "cr", "rl", "rt", "rr", "ds", "nd", "dra", "rb", "rest", "RD"], "line": ["page", "reader", "continue", "value", "link", "pe", "connection", "feed", "lf", "lines", "message", "l", "letter", "one", "object", "char", "val", "column", "cell", "LINE", "Line", "part", "row", "end", "data", "response", "raw", "el", "word", "name", "ge", "e", "unit", "cl", "text", "comment", "lc", "key", "le", "string", "point", "file", "record", "code", "err", "header", "character", "block", "lin", "str", "sl", "entry"]}}
{"id1": "11371499", "id2": "7422454", "code1": "    public void sortArray() {\n        int a;\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array.length - 1; j++) {\n                if (array[j] < array[j + 1]) {\n                    a = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = a;\n                }\n            }\n        }\n    }\n", "code2": "    public void run() {\n        if (name == null) {\n            System.err.println(\"Must set file name for retrieval\");\n            return;\n        }\n        if (handle == null) {\n            System.err.println(\"Must set CCNHandle\");\n            return;\n        }\n        if (htmlPane == null) {\n            System.err.println(\"Must set JEditorPane\");\n            return;\n        }\n        JFrame frame = new JFrame();\n        JFileChooser chooser = new JFileChooser();\n        File f = null;\n        chooser.setCurrentDirectory(null);\n        int returnVal = chooser.showSaveDialog(frame);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            f = chooser.getSelectedFile();\n        } else {\n            htmlPane.setText(\"Save File cancelled\");\n            return;\n        }\n        boolean overwrite = false;\n        try {\n            if (f.exists()) {\n                htmlPane.setText(\"Overwriting contents of \" + f.getPath());\n                overwrite = true;\n            } else {\n                f.createNewFile();\n            }\n            if (f.canWrite()) {\n            } else {\n                htmlPane.setText(\"The ContentExplorer is unable to write the content to the specified file.\");\n                return;\n            }\n        } catch (IOException e) {\n            System.err.println(\"could not create \" + f.getPath() + \" for saving content to filesystem\");\n            htmlPane.setText(\"could not create \" + f.getPath() + \" for saving content to filesystem\");\n        }\n        try {\n            if (!overwrite) htmlPane.setText(\"saving \" + name + \" to \" + f.getCanonicalPath()); else htmlPane.setText(\"overwriting contents of \" + f.getCanonicalPath() + \" to save \" + name);\n            CCNFileInputStream fis = new CCNFileInputStream(name, handle);\n            FileOutputStream output = new FileOutputStream(f);\n            byte[] buffer = new byte[readsize];\n            int readcount = 0;\n            int readtotal = 0;\n            while ((readcount = fis.read(buffer)) != -1) {\n                readtotal += readcount;\n                output.write(buffer, 0, readcount);\n                output.flush();\n            }\n            htmlPane.setText(\"Saved \" + name + \" to \" + f.getCanonicalPath());\n        } catch (Exception e) {\n            htmlPane.setText(\"Could not save \" + name + \" to \" + f.getPath() + \" This may be a prefix for an object or just may not be available at this time.\");\n            System.err.println(\"Could not retrieve file: \" + name);\n        }\n    }\n", "label": 0, "substitutes": {"a": ["next", "af", "sa", "an", "active", "A", "d", "la", "ana", "k", "ma", "ia", "am", "y", "ga", "b", "wa", "ava", "f", "aj", "as", "data", "ata", "ada", "p", "auto", "ai", "x", "sup", "na", "pa", "u", "o", "da", "e", "au", "ae", "z", "area", "ba", "offset", "ab", "c", "aaa", "aa", "ca", "alpha", "fa", "qa", "ad", "ac", "va"], "i": ["ki", "h", "id", "si", "qi", "ind", "iu", "phi", "io", "l", "y", "in", "b", "f", "ij", "bi", "n", "zi", "I", "oi", "ji", "ai", "ni", "ix", "ui", "ci", "u", "m", "li", "v", "xi", "ri", "index", "ii", "pi", "z", "p"], "array": ["value", "Array", "arr", "the", "range", "analysis", "result", "function", "arrow", "now", "audio", "view", "object", "app", "ray", "equality", "row", "base", "data", "table", "auto", "integer", "pair", "archive", "address", "external", "air", "average", "element", "section", "module", "other", "allow", "complex", "angular", "instance", "area", "index", "image", "list", "document", "answer", "file", "expression", "current", "database", "item", "order", "square", "position", "group", "form", "alpha", "collection", "sample"], "j": ["next", "ik", "jj", "qi", "ah", "jet", "ind", "J", "jp", "k", "l", "y", "jo", "b", "ja", "jit", "aj", "f", "fr", "ij", "n", "oi", "ji", "adj", "js", "x", "bj", "ix", "u", "o", "e", "uj", "dj", "length", "je", "jc", "v", "li", "job", "index", "key", "obj", "jl", "ii", "oj", "q", "z", "jan", "p", "ie"]}}
{"id1": "545112", "id2": "1332258", "code1": "    public static void main(String[] args) throws Exception {\n        String uri = args[0];\n        Configuration conf = new Configuration();\n        FileSystem fs = FileSystem.get(URI.create(uri), conf);\n        Path inputPath = new Path(uri);\n        CompressionCodecFactory factory = new CompressionCodecFactory(conf);\n        CompressionCodec codec = factory.getCodec(inputPath);\n        if (codec == null) {\n            System.err.println(\"No codec found for \" + uri);\n            System.exit(1);\n        }\n        String outputUri = CompressionCodecFactory.removeSuffix(uri, codec.getDefaultExtension());\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = codec.createInputStream(fs.open(inputPath));\n            out = fs.create(new Path(outputUri));\n            IOUtils.copyBytes(in, out, conf);\n        } finally {\n            IOUtils.closeStream(in);\n            IOUtils.closeStream(out);\n        }\n    }\n", "code2": "    public void writeTo(OutputStream out) throws IOException {\n        if (!closed) {\n            throw new IOException(\"Stream not closed\");\n        }\n        if (isInMemory()) {\n            memoryOutputStream.writeTo(out);\n        } else {\n            FileInputStream fis = new FileInputStream(outputFile);\n            try {\n                IOUtils.copy(fis, out);\n            } finally {\n                IOUtils.close(fis);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"uri": ["source", "route", "id", "ki", "url", "qi", "si", "abi", "username", "io", "origin", "format", "http", " URI", "f", "base", "href", "directory", "afi", "resource", "prefix", "ris", "server", "config", "gi", "address", "umi", "filename", "name", "query", "ui", "dir", "ci", "prot", "ini", "cli", "iri", "ri", "string", "path", "ori", "file", "i", "code", "attribute", "database", "pi", "URI", "domain", "mi", "uni", "location"], "conf": ["af", "Config", "cb", "url", "req", "cm", "Conf", "cf", "co", "conn", "fc", "Configuration", "con", "cas", "http", "client", "bc", "fr", "f", "def", "prop", "ref", "cp", "ctx", "config", "info", "cn", "fam", "aff", "init", "cl", "spec", "cs", "password", "ch", "cli", "timeout", "cr", "cfg", "cache", "c", "file", "raf", "conv", "cc", " Conf", "fi", "cms", "ca", "cor"], "fs": ["host", "cb", "bf", "cf", "ws", "io", "conn", "fc", "http", "fp", "sf", "bc", "fd", "f", "base", "fe", "fw", "os", "bs", "ctx", "es", "server", "sys", "fn", "cs", "Fs", "FS", "df", "ls", "utils", "cache", "file", "fb", "raf", "files", "ds", "services", "ps", "s"], "inputPath": ["sourceUrl", "outputStream", "sourcePoint", " inputP", "inputPoint", "imageStream", "outputpath", "InputP", " inputUrl", "InputStream", "imageP", "InputPath", "inputUrl", "outputLocation", " inputLocation", " inputPoint", "sourcePath", "imagePath", " inputStream", "sourcepath", "Inputpath", "imagepath", "sourceLocation", "inputP", "inputLocation", "inputpath", "outputPoint", "outputPath", " inputpath", "inputStream", "outputUrl", "sourceStream"], "factory": [" fct", "compct", "compolver", "cfact", "colver", "compfact", "bffact", "fsFactory", "fault", "bfault", "fsault", "bfactory", " folver", "folver", "bfFactory", "fsactory", "fsfact", "fct", " ffact", "cct", "cactory", "compactory", "Fault", "Factory", "fFactory", "Ffact", "FFactory", "ffact"], "codec": ["odEC", "codesEC", "Codocol", "defEC", "Codec", "codoc", "defoc", "codenc", "codEc", "defef", " codoc", "odep", "codesenc", "codesec", "Codoc", " codEC", "codef", "compocol", "compEc", "CodEC", "oderer", "codEC", "odec", "Codenc", " coderer", "compec", " codocol", " codef", "codesep", "defec", "Codef", "codep", "compef", "Codep", "CodEc", "coderer", "odef", " codEc", "Coderer", "odenc", "compEC", "codocol"], "outputUri": ["outputFri", "OutputUpi", " outputFRI", "outputFileri", "OutputUri", "outputUris", "outputUio", "OutputUris", "outputFilepi", "outputUpi", "outputUsri", "outputFuri", "outputFris", " outputURI", "outputFRI", " outputFri", "outputIpi", "OutputIio", "OutputUio", "outputIuri", "outputFileuri", " outputFuri", "OutputIris", " outputUris", "outputFileris", "outputURI", "outputIri", "outputUsio", "outputIio", "outputUsris", "outputUspi", "outputIris", "outputUuri", "OutputIpi", "outputFileRI", "OutputIri", "outputFileio", "outputIRI", " outputFris", " outputUuri"], "in": ["source", "reader", "id", "input", "inc", "din", "anc", "token", "win", "asin", "min", "nin", "b", "login", "f", "base", "as", "data", "In", "pin", "again", "n", "r", "inas", "work", "thin", "ac", "isin", "inner", "x", "init", "ins", "ax", "vin", "ini", "a", "m", "kin", "up", "path", "cin", "image", "socket", "i", "IN", "err", "inn", "rin", "is", "bin", "s", "p"], "out": ["plain", "inc", "write", "user", "net", "io", "output", "conn", "lib", "b", "client", "object", "base", "data", "to", "In", "again", "OUT", "Out", "n", "outs", "prefix", "thin", "serv", "writer", "off", "exec", "sync", "action", "null", "version", "o", "dot", "exp", "flow", "password", "gin", "ext", "ex", "up", "path", "point", "image", "obj", "socket", "file", "err", "img", "bin", "copy", "qa", "line", "pass"]}}
{"id1": "17511631", "id2": "1332258", "code1": "    private static void extract(final ZipFile zf, final ZipEntry zipEntry, final String desDir, final int... startDirLevel) throws IOException {\n        File desf = new File(desDir);\n        if (!desf.exists()) {\n            desf.mkdirs();\n        }\n        int start = 1;\n        if (null != startDirLevel && startDirLevel.length > 0) {\n            start = startDirLevel[0];\n            if (start < 1) {\n                start = 1;\n            }\n        }\n        String startDir = \"\";\n        String zeName = zipEntry.getName();\n        String folder = zeName;\n        boolean isDir = zipEntry.isDirectory();\n        if (null != folder) {\n            String[] folders = folder.split(\"\\\\/\");\n            if (null != folders && folders.length > 0) {\n                int len = folders.length;\n                if (start == 1) {\n                    startDir = zeName;\n                } else {\n                    if (start > len) {\n                    } else {\n                        for (int i = start - 1; i < len; i++) {\n                            startDir += \"/\" + folders[i];\n                        }\n                        if (null != startDir) {\n                            startDir = startDir.substring(1);\n                        }\n                    }\n                }\n            }\n        }\n        startDir = StringUtils.trim(startDir);\n        if (StringUtils.isNotEmpty(startDir)) {\n            StringBuilder desFileName = new StringBuilder(desDir);\n            if (!desDir.endsWith(\"/\") && !startDir.startsWith(\"/\")) {\n                desFileName.append(\"/\");\n            }\n            desFileName.append(startDir);\n            File destFile = new File(desFileName.toString());\n            if (isDir) {\n                if (!destFile.exists()) {\n                    destFile.mkdirs();\n                }\n            } else {\n                File parentDir = new File(destFile.getParentFile().getPath());\n                if (!parentDir.exists()) {\n                    parentDir.mkdirs();\n                }\n                InputStream is = zf.getInputStream(zipEntry);\n                OutputStream os = new FileOutputStream(destFile);\n                IOUtils.copy(is, os);\n                if (null != is) {\n                    is.close();\n                }\n                if (null != os) {\n                    os.close();\n                }\n            }\n        }\n    }\n", "code2": "    public void writeTo(OutputStream out) throws IOException {\n        if (!closed) {\n            throw new IOException(\"Stream not closed\");\n        }\n        if (isInMemory()) {\n            memoryOutputStream.writeTo(out);\n        } else {\n            FileInputStream fis = new FileInputStream(outputFile);\n            try {\n                IOUtils.copy(fis, out);\n            } finally {\n                IOUtils.close(fis);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"zf": ["zfs", "zfc", "czfp", "zipfp", "czcf", "zfp", "zipfc", "czf", " zcf", "zzf", "zzcf", "azf", "azfs", "czfs", " zfp", "azcf", "zcf", "zipcf", "zipf", " zfs", "zzfc", "zzfs", "zipfs", "azfc"], "zipEntry": [" zipZip", "zipFile", " zipentry", "zFile", "zipObj", "sourceentry", "zoneEntry", "sourceObj", "ZipInfo", "zentry", "zipInfo", "ZipZip", " zipObj", "archiveEnt", "downloadentry", " zipEnter", "zipEnter", "sourceFile", "zeEnt", "archiveEntry", "zipZip", "zipEnt", "fileEnter", "zipentry", "zeSource", "zipSource", "zeentry", "zEntry", "downloadEntry", "ZipEnter", " zipInfo", "fileInfo", " zipEnt", "Zipentry", "zeEntry", "ZipEntry", "zObj", "downloadEnt", " zipFile", "downloadSource", "zoneZip", "fileEntry", "zoneEnt", "zoneentry", "sourceEntry", "fileentry", "archiveSource", "ZipEnt", "archiveentry"], "desDir": ["desDIR", "dsFolder", "desFolder", "dsDb", "dsRel", "desDb", "sesDirectory", "DesDirectory", "desUrl", "DesDb", "distDirectory", "deFolder", "sesDir", "DesDir", "deUrl", "dsDirectory", "onesDirectory", "dsFile", "desFile", "dsDir", "dsDIR", "distDb", "deDir", "onesDir", "DesFolder", "deDirectory", "sesRel", "DesDIR", "dsUrl", "DesUrl", "desRel", "DesFile", "distDir", "onesDIR", "sesFile", "DesRel", "onesFolder", "desDirectory", "distFile"], "startDirLevel": ["startDIROriginal", "firstFolderUnit", " startDirLC", "startDIRL", "firstDirFl", "dateDIRLast", "startDIRLast", " startDirL", "startVollevel", "startTierUnit", "startTierL", " startDirectoryOriginal", "startFileLevel", "firstFolderFl", "startFolderLow", "startCharLevel", " startLenLC", "startDirectoryLow", "startFolderLevel", "startFileLast", " startLenLevel", "startVolLevel", " startLenLow", "startdirlevel", " startDirectoryLevel", "dateDIRL", "startFolderL", " startLenlevel", "startTierFl", " startDirlevel", "startDirL", "startVolLow", "startDirectoryL", "startDIRLevel", "startdirLevel", "startFileLow", "startdirLC", "firstDirLevel", "dateDirL", "firstDirUnit", "dateDIRLow", "startFolderFl", "firstFolderL", "startDirLC", "firstDirL", "startVolLC", "startLenL", "startDirectoryOriginal", "firstFolderLevel", " startDirectoryL", "startFolderOriginal", "startLenLevel", "startCharLow", "startLenUnit", "dateDIRLevel", "startTierLevel", "startdirLow", "startCharL", "startDirFl", " startDirOriginal", "dateDirLow", " startDirectoryLow", "startDirectoryLevel", "startDirLast", "startDIRLow", "startFolderUnit", "startFileL", "startLenLC", "dateDirLevel", "startLenFl", " startDirLow", "startCharLast", "dateDirLast", "startLenlevel", "startDirOriginal", "startDirUnit", "startLenLow", "startDirlevel", "startDirLow"], "desf": ["DESfile", "Desfile", "dsf", "desv", " desb", "desFile", "DESf", "dsv", " desv", "desfile", "dsF", "Desv", "Desf", "DESF", " desF", "desF", "dsb", "Desb", "dsfile", " desfile", " desFile", "DesFile", "desb", "DESFile", "DesF"], "start": ["next", "source", "shift", "get", "Start", "id", "size", "en", "first", "rest", "open", "ind", "space", "min", "scale", "fill", "grade", "from", "l", "end", "diff", "st", "part", "skip", "p", "data", "no", "find", "style", "set", "sum", "stop", "info", "pad", "use", "cur", "send", "name", "sync", "init", "ix", "old", "step", "length", "max", "span", "show", "offset", "art", "index", "sort", "seed", "sp", "load", "parse", "check", "like", "pos", "starting", "type", "add", "line", "ad", "ie"], "zeName": ["zySize", "zedInfo", "zeSize", "zaAlias", "zaInfo", "zipName", "zyInfo", "zedNames", "zeInfo", "zedDir", "zipInfo", "zieSize", "zipDir", "zieName", "zaNames", "zaExt", "zieMeta", "zyExt", "zeNames", "zeAlias", "zaSize", "zedCode", "zyAlias", "zeCode", "zeDir", "zyCode", "zieAlias", "zyName", "zeMeta", "zaName", "zyDir", "zyNames", "zedExt", "zeExt", "zaMeta", "zedName", "zipCode", "zyMeta"], "folder": ["size", "id", "draft", "theme", "plugin", "space", "flat", "stuff", "license", "cdn", "end", "root", "layer", "data", "directory", "zip", "Folder", "handler", "archive", "server", "address", "editor", "filename", "name", "desc", "dir", "zone", "direction", "scope", "container", "fold", "content", "area", "path", "uri", "file", "title", "manager", "sea", "project", "collection", "line", "sample", "location", "entry"], "isDir": [" isFolder", "ISDir", "isFolder", "isLocal", "ISFile", " isDb", "issDir", "hasFile", " isFile", "hasDb", " isDirectory", " isLocal", "isDirectory", "isFile", "ISFolder", " isJar", "issJar", "hasDir", "issLocal", "isDb", "asJar", "asDirectory", "asLocal", "ISDb", "asDir", "isJar", "issDirectory", "hasFolder"], "folders": ["collings", "collers", "ferers", "followers", "varier", "buffars", "deflers", "contlers", "foldERS", "foldlers", "feedERS", "variers", "fars", "buffers", "older", "conterers", "flers", "centerers", "bufferers", "collered", "conthers", "centlers", "olders", "followlers", "foldhers", "defers", "coders", "varierers", "contars", "coderers", "followered", "feedlers", "coder", "foldered", "olderers", "conters", "fers", "buffhers", "defings", "foldels", "contings", "followings", "feederers", "codels", "fhers", "fERS", "collels", "folderers", "foldings", "feeders", "defered", "codings", "oldings", "variings", "contels", "centERS", "foldars", "codlers", "colllers", "centers"], "len": ["dl", "left", "split", "en", "num", "ln", "lf", "ind", "min", "limit", "lim", "l", "end", "part", "base", "loc", "Len", "n", "elt", "ni", "el", "nt", "length", "sl", "span", "li", "ls", "le", "lc", "dy", "count", "pos", "tail", "lin", "fin", "bin", "pl", "line", "ll"], "startDir": ["stopArea", "StartRel", "lineDir", " startUrl", "lineDIR", "artDIR", "startingFile", "startFolder", "StartFile", "startVol", " startdir", "startingLine", "currentDir", "startdir", "partVol", "StartDIR", "startingHour", " startHour", "showVer", "lineArea", "StartVol", "Startdir", "artUrl", "tryDIR", "StartDir", "endMin", "startingdir", "startVer", "partDirectory", "showUrl", "partDir", "startFile", "partUrl", "endDirectory", "currentDirectory", " startVer", "tryRel", "startingDirectory", "startTier", " startTier", "stopFile", "startingUrl", "stopDIR", "startLine", " startPart", "showDir", "startRel", " startDirectory", "startingPart", "startDirectory", "endLine", " startRel", "currentTier", " startDIR", "seedRel", "startArea", " startFile", "startingTier", "stopDir", "seeddir", "showDIR", "StartHour", "startUrl", "startMin", "endTier", "stopDirectory", "startingDir", "seedDir", "StartMin", "tryUrl", "startHour", "artDir", " startFolder", "stopUrl", "endDir", "startDIR", "endFile", "artVer", "stopdir", " startMin", "lineFolder", "currentdir", "endPart", "startPart", " startVol", " startArea", "endUrl", "stopLine", " startLine", "enddir", "StartUrl", "tryDir", "StartDirectory", "seedFolder", "stopFolder", "StartFolder"], "i": ["h", "si", "multi", "qi", "ind", "hi", "k", "phi", "b", "part", "data", "di", "bi", "zi", "n", "I", "ti", "ni", "ai", "oi", "gi", "x", "ix", "it", "ui", "ci", "u", "eni", "ini", "m", "li", "v", "xi", "index", "ri", "slice", "j", "c", "uri", "ii", "pi", "fi", "chi", "z", "ip", "p"], "desFileName": ["onesStringPath", "onesFilename", "onesFileSync", "onesFilePath", "desStringName", "dsFilename", "rosFilename", "desFolderPath", "onesLineByte", "desFolderPart", "dsFileName", "onesFileByte", "onesFileName", "desFolderSize", "desLinename", "desPageShare", "desFolderByte", "desStringSync", "desDirSize", "onesFileSize", "rosPerName", "desStringname", "desPerShare", "desDirname", "desUnitname", "desDirPath", "desFilePath", "onesStringname", "rosPername", "dsFilePath", "onesLinename", "rosPerShare", "desfilePath", "desDirSync", "desUnitShare", "dsPerPart", "desPername", "desFileByte", "desFileSync", "desfilename", "desLineName", "onesStringName", "desLineSize", "dsPername", "onesLineSize", "onesStringSync", "desPageName", "desDirName", "desFolderName", "desPagename", "dsPerName", "desPerName", "desFilename", "desFileSize", "desDirPart", "desStringPath", "desPerPath", "desFoldername", "desfileName", "rosFileName", "rosFileShare", "desLineByte", "onesLineName", "dsFilePart", "desFilePart", "desfileSync", "desDirByte", "desFileShare", "dsPerPath", "desUnitName", "desPerPart"], "destFile": ["DestFiles", "flatDirectory", "DestLine", " destPath", "srcFolder", "destFiles", "descFile", "destKey", " destFiles", "srcLine", "DestLog", "destLog", "destPath", "destfile", "destDirectory", " destfile", "Destfile", " destFolder", "flatfile", "DestDirectory", "descKey", "flatDir", "targetLog", "targetfile", "descFiles", "flatFile", "DestFolder", "destDir", "descLog", "srcDir", " destDirectory", "targetFile", " destKey", "descDirectory", "flatKey", "descPath", "srcFile", "destLine", "targetDir", " destLine", " destDir", "destFolder", "DestDir", "DestPath", "descfile", "descDir", "DestFile"], "parentDir": ["parentFile", "plainFile", "centralTier", "centralFolder", "centralDir", " parentFile", "parentsFile", "parentsDirectory", "centralFile", "plainDar", "parentsDir", "ParentFile", "ParentDar", "ParentTier", "parentsFolder", " parentFolder", "ParentDirectory", "plainFolder", "ParentFolder", " parentTier", "parentFolder", " parentDirectory", "parentDirectory", "parentDar", " parentDar", "ParentDir", "parentTier", "plainDir"], "is": ["nis", "id", "isa", "ais", "alis", "isl", "in", "ms", "as", "isp", "was", "iss", "sis", "ris", "es", "ai", "info", "ir", "has", "isi", "it", "ins", "iris", "IS", "rs", "cs", "mis", "lis", "ios", "ours", "ori", "its", "ii", "or", "ois", "us", "bis", "Is", "iso", "s", "ip", "does"], "os": ["opens", "los", "ks", "oid", "oses", "io", "ais", "fs", "ns", "ros", "OS", "ms", "bos", "oes", "ots", "bs", "oos", "oS", "o", "aos", "ob", "rs", "cs", "Os", "nos", "ios", "ops", "ori", "ol", "ols", "us", "cos", "boot", "bis", "obs", "osi", " bos", "iso", "ps", "s", "ot"]}}
{"id1": "22255481", "id2": "7157998", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        MessageDigest encript = MessageDigest.getInstance(\"MD5\");\n        encript.update(password.getBytes());\n        byte[] b = encript.digest();\n        int size = b.length;\n        StringBuffer h = new StringBuffer(size);\n        for (int i = 0; i < size; i++) {\n            h.append(b[i]);\n        }\n        return h.toString();\n    }\n", "code2": "    public static synchronized String encrypt(String x) throws Exception {\n        MessageDigest d = MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(String.valueOf(x).getBytes());\n        return byteArrayToHexString(d.digest());\n    }\n", "label": 1, "substitutes": {"password": [" Password", "hash", "input", "user", "token", "auth", "buffer", "sword", "username", "message", "wd", "PASS", "data", "phrase", "enc", "prefix", "email", "config", "address", "word", "name", " passwords", "pattern", "parser", "text", "content", "words", "key", "string", "path", "code", "array", "secret", "database", "sudo", "Password", "crypt", "account", "project", "padding", "p", "pass"], "encript": ["ensrypt", "enrypt", " enScript", "encec", "isencript", "encrypt", "isentext", " enparent", "encscript", "enec", "Enhead", "Entext", "Encript", "encparent", "enparent", "enhead", " enscript", "henject", "hencript", "Enparent", "enccript", "ensject", "encject", "entext", "enccode", "Enec", "enscode", "isenScript", " enec", "henrypt", "hencode", " enhead", "isenhead", "enscript", "encode", "enScript", "EnScript", "Enscript", "enject", " entext"], "b": ["cb", "sb", "binary", "d", "bh", "bf", "mb", "buffer", "buff", "br", "pb", "l", "lib", "f", "base", "bd", "bytes", "abb", "bs", "r", "batch", "bb", "ob", "a", "buf", "v", "gb", "blue", "B", "orb", "emb", "ab", "db", "wb", "fb", "array", "boot", "bis", "nb", "s", "rb", "p"], "size": ["shift", "si", "len", "range", "scale", "sized", "iz", "Size", "loc", "SIZE", "style", "enc", "sum", "sh", "address", "shape", "x", "send", "name", "ize", "length", "capacity", "max", "time", "count", "code", "width", "g", "empty", "small", "use", "unit"], "h": ["host", "head", "hash", "ih", "hl", "bh", "auth", "ha", "ah", "HH", "ht", "oh", "hi", "hh", "zh", "hd", "l", "http", "w", "f", "hex", "hm", "H", "sh", "he", "kh", "hp", "u", "o", "uh", "ph", "dh", "rh", "hr", "ch", "buf", "help", "html", "fb", "header", "q", "th", "gh", "eh", "p", "uth"], "i": ["id", "si", "d", "abi", "qi", "multi", "hi", "k", "io", "phi", "l", "f", "di", "n", "r", "bi", "I", "mu", "ti", "oi", "ai", "info", "ji", "gi", "off", "x", "init", "ix", "ui", "u", "o", "ci", "e", "it", "ini", "li", "v", "key", "xi", "index", "ri", "slice", "j", "c", "uri", "ii", "pi", "field", "fi", "chi", "z", "p"]}}
{"id1": "15385608", "id2": "2774850", "code1": "    public boolean setFavBoard(List<BoardObject> list) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        HttpPost post = new HttpPost(HttpConfig.bbsURL() + HttpConfig.BBS_FAV_SETTING);\n        List<NameValuePair> nvps = new ArrayList<NameValuePair>();\n        for (BoardObject board : list) nvps.add(new BasicNameValuePair(board.getId(), \"on\"));\n        try {\n            post.setEntity(new UrlEncodedFormEntity(nvps, BBSBodyParseHelper.BBS_CHARSET));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isHttp200(response) && HTTPUtil.isXmlContentType(response)) {\n                HTTPUtil.consume(response.getEntity());\n                return true;\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    protected Scanner loadSource(String country) {\n        if (httpProxy != null && httpProxy.isEnabled()) {\n            System.setProperty(\"proxySet\", \"true\");\n            System.setProperty(\"http.proxyHost\", httpProxy.getUrl());\n            System.setProperty(\"http.proxyPort\", Integer.toString(httpProxy.getPort()));\n        }\n        try {\n            URL url = new URL(this.url + country);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            return new Scanner(connection.getInputStream());\n        } catch (MalformedURLException e) {\n            return null;\n        } catch (ProtocolException e) {\n            return null;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"list": ["dl", "lp", "parent", "land", "queue", "LIST", "range", "chain", "result", "view", "l", "pre", "que", "object", "part", "base", "table", "set", "config", "can", "sequence", "stack", "name", "batch", "cl", "lists", "listed", "all", "pool", "load", "live", "array", "gallery", "many", "test", "collection", "entry", "coll"], "client": ["host", "head", "url", "pe", "connection", "io", "pb", "conn", "http", "request", "app", "object", "end", "to", "resource", "handler", "server", "config", "force", "method", "per", "patch", "bird", "api", "Client", "cli", "session", "media", "pool", "connect", "cache", "c", "ssl", "i", "cloud", "service", "ip", "self", "et", "project", "copy", "p"], "post": ["next", "get", "head", "POST", "proc", "upload", "feed", "pod", "submit", "the", "open", "ost", "build", "one", "http", "pre", "request", "object", "f", "to", "put", "set", "zip", "server", "push", "posts", "wp", "send", "body", "project", "patch", "od", "Post", "pass", "load", "install", "posted", "valid", "create", "form", "add", "copy", "rest", "p"], "nvps": ["NVp", "nvPS", "vPS", "nvips", "nvp", "NVPS", "nvpps", "vps", "NVips", "nvsp", "nwps", "nncs", "NVps", "svp", "svpps", "NVpps", "svps", "nlPS", "nlps", "vp", "nwpps", "nlcs", "nwPS", "nnsp", "nnps", "svips", "svsp", "nvcs", "nlsp", "nnPS", "svcs", "vips", "svPS", "nwp"], "board": [" row", "land", " lobby", " corporation", "upload", "feed", "division", " dashboard", "game", " builder", " video", " obstacle", "card", "deck", "view", "object", "model", "row", " chunk", " poll", " card", "server", " image", "boards", " bar", "Board", "flow", " deck", " block", " box", " game", " opponent", "hole", " logo", " clip", "pool", "node", " cross", " controller", " player", " billboard", "boarding", "database", "builder", "video", "bot", "league", " tile"], "response": ["page", "successful", "respond", "site", "connection", "success", "feed", "reply", "ception", "result", "message", "output", "view", "http", "request", "object", "model", "channel", "application", "onse", "data", "f", "stream", "resource", "handler", "server", "body", "full", "o", "report", "json", "api", "former", "wave", "session", "status", "Response", "index", "document", "image", "error", "resp", "code", "received", "res", "collection"], "entity": ["page", "translation", "pe", "ent", "connection", "xml", "feed", "ception", "result", "ee", "output", "message", "article", "ity", "object", "model", "environment", "onse", "data", "tree", "resource", "server", "el", "activity", "component", "body", "e", "Entity", "content", "node", "image", "document", "uri", "error", "resp", "person", "service", "ce", "collection", "entry"], "msg": ["str", "id", "mid", "sg", "message", "doc", "ma", "gs", "cmd", "ms", "op", "gen", "loc", "exc", "agg", "data", "comm", "desc", "body", "ge", "e", "gm", "log", "text", "comment", "ko", "m", "content", "dr", "status", "string", "Msg", "html", "reg", "error", "err", "map", "g", "mess", "md", "reason", "s", "ug", "pkg", "type"]}}
{"id1": "9796809", "id2": "3257108", "code1": "    @Override\n    protected byte[] computeHash() {\n        try {\n            final MessageDigest inputHash = MessageDigest.getInstance(\"SHA\");\n            inputHash.update(bufferFileData().getBytes());\n            return inputHash.digest();\n        } catch (final NoSuchAlgorithmException nsae) {\n            lastException = nsae;\n            return new byte[0];\n        } catch (final IOException ioe) {\n            lastException = ioe;\n            return new byte[0];\n        }\n    }\n", "code2": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            s = new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return s;\n    }\n", "label": 1, "substitutes": {"inputHash": ["InputBuild", "newBuild", "outputhash", "InputSHA", " inputhash", "InputHash", " inputBlock", "outputBlock", "outputHash", "Inputhash", "inputVersion", " inputSHA", "inputBuild", " inputVersion", "inputSalt", "InputVersion", "InputCache", "internalhash", "newHash", " inputCache", "newBlock", "newCache", "internalHash", "outputVersion", "inputhash", "InputSalt", "inputSHA", " inputSalt", "internalSHA", "InputBlock", " inputBuild", "inputCache", "inputBlock", "internalSalt"], "lastException": ["firstError", "firstception", "LastExc", "lastception", " lastception", "LastError", "lastExc", "lastError", "firstExc", " lastExc", "firstException", " lastError", "Lastception", "LastException"]}}
{"id1": "14297380", "id2": "19295911", "code1": "    private String hashPassword(String plainTextPassword) {\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA-1\");\n            digest.reset();\n            digest.update(plainTextPassword.getBytes());\n            BASE64Encoder enc = new BASE64Encoder();\n            return enc.encode(digest.digest());\n        } catch (NoSuchAlgorithmException e) {\n            log.error(e);\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void setTableEmbossage(String te, boolean sys) {\n        fiConf.setProperty(OptNames.pr_emboss_table, te);\n        fiConf.setProperty(OptNames.fi_is_sys_emboss_table, Boolean.toString(sys));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            String fichTable;\n            if (!(te.endsWith(\".ent\"))) {\n                te = te + \".ent\";\n            }\n            if (sys) {\n                fichTable = ConfigNat.getInstallFolder() + \"/xsl/tablesEmbosseuse/\" + te;\n            } else {\n                fichTable = ConfigNat.getUserEmbossTableFolder() + \"/\" + te;\n            }\n            in = new FileInputStream(fichTable).getChannel();\n            out = new FileOutputStream(ConfigNat.getUserEmbossTableFolder() + \"/Embtab.ent\").getChannel();\n            in.transferTo(0, in.size(), out);\n            in.close();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"plainTextPassword": ["plaintextText", "plainTextSecret", "plaintextPath", "plainMessagePass", "flatTextBody", "plaintextSecret", "plainTEXTText", "plainPasswordPassword", "flatPasswordPassword", " plainPasswordSecret", "flatPasswordPass", "plainTextString", "plainPasswordText", "plainPasswordBody", "plainPasswordSecret", "plainPasswordPass", "flatPasswordBody", "plainPasswordPath", "plaintextPassword", "plainMessagePassword", " plainPasswordText", "plaintextPass", "plainTextPass", "flatPasswordPath", " plainTextText", " plainPasswordString", " plainTextSecret", "plaintextBody", " plainTextString", "plainTextText", "plainMessagePath", "plainTEXTSecret", "plainPasswordString", " plainPasswordPassword", "plaintextString", "flatTextPassword", "plainTextBody", "plainTEXTString", "plainMessageBody", "flatTextPath", "plainTextPath", "flatTextPass", "plainTEXTPassword"], "digest": ["encger", "Diger", "digger", "digester", " digger", "signester", "rdester", "DigEST", "encester", "rdex", "Digger", "modest", "signusher", "encend", "modode", "Digen", "digend", "encen", "digode", "diger", "feedester", "signEST", "Digex", " digusher", "rder", "feedest", "digusher", "digEST", "Digester", "Digested", "digen", " digEST", "digex", " digex", "Digode", "moden", " digend", "encest", "rdest", "feedested", " digester", "modEST", "Digend", "signer", "signest", "Digusher", "encEST", "digested", "encode", " diger", " digested", "Digest", "feedEST"], "enc": ["div", "dec", "en", "inc", "ent", "uc", "alg", "util", "engine", "conn", "b", "end", "bc", "gen", "ec", "oder", "ens", "ac", "iv", "e", "ENC", "esc", "Enc", "abc", "sec", "load", "c", "ssl", "encrypted", "code", "obj", "oct", "conv", "eng", "crypt", "et", "env", "nc", "sl"]}}
{"id1": "15136801", "id2": "19044529", "code1": "    public static String readUrl(String urlString) {\n        try {\n            java.net.URL url = new java.net.URL(urlString);\n            BufferedReader br = null;\n            if (url != null) {\n                br = new BufferedReader(new InputStreamReader(url.openStream()));\n            }\n            StringBuffer fileString = new StringBuffer();\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                fileString.append(line + \"\\n\");\n            }\n            return fileString.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public void put(File fileToPut) throws IOException {\n        FTPClient ftp = new FTPClient();\n        try {\n            int reply;\n            ftp.connect(this.endpointURL, Config.getFtpPort());\n            log.debug(\"Ftp put reply: \" + ftp.getReplyString());\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp put server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.setFileType(FTP.BINARY_FILE_TYPE);\n            ftp.enterLocalPassiveMode();\n            InputStream input = new FileInputStream(fileToPut);\n            if (ftp.storeFile(fileToPut.getName(), input) != true) {\n                ftp.logout();\n                input.close();\n                throw new IOException(\"FTP put exception\");\n            }\n            input.close();\n            ftp.logout();\n        } catch (Exception e) {\n            log.error(\"Ftp client exception: \" + e.getMessage(), e);\n            throw new IOException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"urlString": ["urlstring", "fileStream", "httpStream", "resourcestring", "resourceSection", " urlSection", "fileSection", "urlStr", "filestring", "fileSource", " urlStream", " urlstring", "httpSource", "urlSection", " urlSource", "fileStr", "urlStream", "urlSource", "httpString", "resourceStr", "resourceString", "httpstring", " urlStr"], "url": ["user", "browser", "feed", "plug", "buffer", "connection", "open", "l", "lib", "http", "object", "b", "fr", "f", "base", "loc", "ref", "stream", "r", "resource", "org", "server", "address", "ur", "gl", "bb", "ob", "log", "bel", "fl", "string", "image", "rl", "impl", "html", "file", "uri", "ssl", "socket", "db", "URL", "service", "Url", "blog", "web", "str", "jar", "sl", "bl", "entry"], "br": ["ber", "brush", "reader", "cb", "gr", "bf", "browser", "bh", "arr", "result", "Br", "b", "ler", "bc", "fr", "BR", "ref", "r", "abb", "er", "ur", "bur", "bb", "bridge", "sr", "pr", "hr", "bar", "buf", "dr", "tr", "cr", "obj", "rt", "mr", "err", "yr", "bed", "fb", "bro", "img", "str", "rb", "jar", "bl"], "fileString": ["feedString", "fileInt", "feedStr", "FileBuffer", "fileFile", "resourceFile", "FileText", "feedFile", "baseBytes", "ruleBuffer", "baseLine", "FileBytes", "fileBytes", "ruleLine", " fileFile", "fileLine", "ruleString", "FileStr", "feedInt", "baseBuffer", "fileText", "FileInt", "ruleBytes", "FileFile", " fileText", "FileString", "resourceText", " fileStr", "resourceLine", " fileInt", "fileStr", "baseString", "fileBuffer", "resourceString", " fileLine", "FileLine"], "line": ["next", "source", "page", "entry", "reader", "link", "write", "pe", "feed", "buffer", "lf", "lines", "result", "output", "l", "letter", "out", "object", "char", "end", "LINE", "cell", "column", "Line", "row", "f", "data", "no", "inline", "style", "response", "e", "log", "cl", "text", "content", "lc", "le", "string", "frame", "file", "parse", "code", "character", "valid", "lin", "str", "sl", "pass"]}}
{"id1": "8988243", "id2": "14588787", "code1": "    private static void extractSOUNDFILES() throws Exception {\n        ArrayList<File> soundFiles = new ArrayList<File>();\n        File soundsFolder = new File(\"/var/lib/asterisk/sounds/\");\n        if (soundsFolder.exists()) {\n            File soundFiles1[] = soundsFolder.listFiles(new FilenameFilter() {\n\n                @Override\n                public boolean accept(File dir, String name) {\n                    if (NullStatus.isNull(name)) {\n                        return false;\n                    }\n                    if (name.endsWith(\"-sounds.jar\")) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            for (int i = 0; i < soundFiles1.length; i++) {\n                soundFiles.add(soundFiles1[i]);\n            }\n        }\n        soundsFolder = new File(\"/opt/jboss/server/default/deploy/Tobe.war/WEB-INF/lib/\");\n        if (soundsFolder.exists()) {\n            File soundFiles1[] = soundsFolder.listFiles(new FilenameFilter() {\n\n                @Override\n                public boolean accept(File dir, String name) {\n                    if (NullStatus.isNull(name)) {\n                        return false;\n                    }\n                    if (name.endsWith(\"-sounds.jar\")) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            for (int i = 0; i < soundFiles1.length; i++) {\n                soundFiles.add(soundFiles1[i]);\n            }\n        }\n        for (int i = 0; i < soundFiles.size(); i++) {\n            ZipFile zipFile = new ZipFile(soundFiles.get(i));\n            InputStream inputStream = null;\n            Enumeration<? extends ZipEntry> oEnum = zipFile.entries();\n            while (oEnum.hasMoreElements()) {\n                ZipEntry zipEntry = oEnum.nextElement();\n                File file = new File(\"/var/lib/asterisk/sounds/\", zipEntry.getName());\n                if (zipEntry.isDirectory()) {\n                    file.mkdirs();\n                } else {\n                    inputStream = zipFile.getInputStream(zipEntry);\n                    FileOutputStream fos = new FileOutputStream(file);\n                    IOUtils.copy(inputStream, fos);\n                    fos.close();\n                }\n            }\n        }\n    }\n", "code2": "    public void saveFile(final InputStream inputStream, final String fileName) {\n        final File file = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + fileName);\n        FileOutputStream fileOut = null;\n        try {\n            fileOut = new FileOutputStream(file);\n            IOUtils.copy(inputStream, fileOut);\n        } catch (FileNotFoundException e) {\n            LOGGER.error(\"saveFile() - File Not Found.\" + e);\n        } catch (IOException e) {\n            LOGGER.error(\"saveFile() - Error while saving file.\" + e);\n        } finally {\n            try {\n                inputStream.close();\n                if (fileOut != null) {\n                    fileOut.close();\n                }\n            } catch (IOException e) {\n                LOGGER.error(e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"soundFiles": ["soundParts", "audioFile", "softwarefiles", "shockImages", "Soundfiles", "shockFiles", "shockPages", "softwarePosts", "zipFeatures", " soundFeatures", " soundfiles", "playfiles", " soundFile", "soundfiles", "zipFs", "scrollPosts", "zipfiles", "scrollfiles", "playImages", "soundFile", "zipFiles", "soundPages", "softwareFiles", "playFs", "audiofiles", "scrollPages", " soundFs", "musicFiles", "soundFeatures", "soundFs", "audioFiles", "audioFs", "audioImages", "softwarePages", " soundImages", "playFiles", " soundPosts", "musicfiles", "scrollFiles", " soundPages", "SoundFeatures", "zipParts", "musicFile", "shockFs", "SoundParts", " soundParts", "zipImages", "SoundFiles", "soundImages", "musicPages", "audioPages", "soundPosts"], "soundsFolder": ["soudFile", "asoundsDirectory", "SoundsDirectory", "ssoundContainer", "asoundsfolder", "soundsFile", "poundDirectory", "poundContainer", "soundsArea", "poundsArea", "savesDirectory", "poundsCategory", "soundFolder", "poundFolder", "SoundsJar", "sillsFile", "asoundsFile", "asoundsArea", "soundContainer", "poundFlow", "soundFlow", "soundsfolder", "poundJar", "sacksFolder", "soudFlow", "asoundFile", "splayDirectory", "ssoundDirectory", "ssoundArea", "soundJar", "sillsJar", "poundsFlow", "soundsContainer", "soundsCategory", "soundDirectory", "soundsDirectory", "sacksDirectory", "samplesDirectory", "poundFile", "savesFile", "soudfolder", "soudFolder", "sacksCategory", "SamplesJar", "sillsArea", "sillsFolder", "soudDirectory", "asoundfolder", "SoundsFolder", "samplesJar", "SamplesDirectory", "samplesFolder", "poundCategory", "soundFile", "splayFolder", "asoundDirectory", "soudArea", "SamplesFolder", "poundsContainer", "soundsJar", "poundArea", "poundsDirectory", "poundsFile", "soundfolder", "savesFolder", "poundsJar", "ssoundFolder", "asoundArea", "splayfolder", "soundsFlow", "asoundsFolder", "sillsDirectory", "splayFile", "ssoundJar", "asoundFolder", "soundArea", "ssoundCategory", "soundCategory", "sacksContainer", "poundsFolder", "savesFlow"], "soundFiles1": ["soundItems1", "shockItems2", " soundFiles81", "soundKeys0", "audioFilesOne", "speechBooks0", "soundFile1", "speechBooks1", "audioFiles2", "soundFsOne", "soundNames0", "soundfiles2", "shockFiles0", "soundPagesOne", "speechFiles1", "soundFile3", "audioFile2", "shockFiles1", "soundResults1", "audioFile3", "soundFiles3", "shockFilesOne", "soundPages0", "soundFileOne", "soundKeysOne", "audioFiles1", "SoundFiles0", "soundBooks1", "soundPages81", "soundFs1", "SoundFiles1", "soundfilesOne", "speechBooks3", "soundItems2", "soundItemsOne", "speechBooks2", "audioFile1", "soundFiles81", "soundResults0", "musicFsOne", "soundKeys81", "soundEsOne", "soundEs0", "soundBooks2", "audioFiles3", "soundfiles1", "SoundFsOne", "soundFile0", "soundResults81", "speechFiles3", "soundFilesOne", "soundFile2", " soundPages1", " soundPages0", "shockItems1", "shockItems0", "soundFiles0", "musicFs0", "SoundFs0", "speechFiles2", "SoundFs1", "soundPages1", " soundPages81", "soundFs0", "shockFiles2", "speechFiles0", "soundItems3", "soundFiles2", "soundEs1", "soundKeys1", "musicFiles0", " soundFiles0", "musicFilesOne", "soundBooks0", "audioFileOne", "musicFs1", "soundNames1", "soundNames2", "SoundFilesOne", "soundNamesOne", "shockItemsOne", "soundfiles3", "soundBooks3", "musicFiles1", "soundItems0"], "dir": ["parent", "url", " directory", "req", "rel", "dict", "dep", "plugin", "doc", "DIR", "wd", "object", "root", "mode", "def", "directory", "re", "prefix", "ir", "module", "desc", "mod", "container", "unit", "area", "rec", "cache", "uri", "manager", "dist", "level", "md", "group", "ior", "pkg", "Dir"], "name": ["source", "NAME", "parent", "page", "ame", "size", "id", "en", "url", "Name", "default", "none", "num", "connection", "not", "space", "format", "object", "part", "model", "base", "layer", "common", "data", "no", "named", "number", "style", "n", "class", "resource", "version", "child", "address", "info", "word", "er", "alias", "null", "na", "member", "e", "non", "api", "comment", "names", "cap", "ext", "missing", "session", "key", "time", "string", "image", "pass", "uri", "search", "label", "service", "nm", "value", "entry", "ip", "type"], "i": ["id", "h", "my", "si", "d", "multi", "qi", "min", "iu", "phi", "k", "io", "hi", "yi", "l", "y", "b", "part", "f", "data", "di", "bi", "zi", "r", "I", "ti", "ni", "gi", "ai", "info", "inner", "x", "ix", "it", "ui", "ci", "e", "o", "u", "eni", "ini", "m", "lc", "xi", "li", "v", "key", "ri", "index", "slice", "j", "c", "uri", "ii", "code", "g", "q", "pi", "type", "field", "fi", "z", "mi", "me", "ip", "p", "ie"], "zipFile": ["ZipDir", "zipTable", "archiveDir", "ZipFolder", "cefile", "archiveFolder", "zipDir", "archiveUnit", "zipFiles", " zipTable", "soundFile", "archiveEntry", "soundTable", "archiveFile", "Zipfile", "archiveFiles", "ceDir", "zipfile", "ZipEntry", "zipFolder", "archiveTable", "zipUnit", " zipUnit", "ceFile", " zipFolder", " zipDir", "ceFolder", " zipFiles", "ZipFile", " zipfile", "soundUnit"], "inputStream": ["outputStream", " inputChannel", " inputFeed", "inputCh", " inputstream", "InputCh", "dataWriter", "inputstream", "inputFeed", "InputStream", "sourceFeed", "dataChannel", " inputWriter", "outputstream", "inputChannel", "outputChannel", "InputChannel", "inputWriter", "datastream", " inputCh", "InputFeed", "sourceCh", "dataStream", "sourceChannel", "outputWriter", "sourceStream"], "oEnum": ["nENumb", "oEnnum", "oCreum", " oEnUM", "nENume", "oAcumer", "oEntom", "oAnnumber", "oenum", "oCreume", " oEntnum", " oEnom", "oParume", "oENume", "oParum", "oCreumer", " oEntUM", " oAcue", "oENue", " oAcumer", "nEnume", " oEnumber", "oENum", " oAcumber", "oAcumber", "oCreumb", "oenUM", "oEnumber", "oEntUM", "oEnumer", "nEnumer", "nENum", "oAnnue", "nENumer", "oEUM", "oennum", " oEntum", "oAnnum", " oAcum", "oEnumb", "oEnUM", "oEnue", "oAnnumer", "oENumer", " oEntom", "oEntum", "oenom", "oParumer", "oEnom", " oEnue", " oEnumer", "oENumber", "oEntnum", "nEnumb", "oEom", "oAcue", "oENumb", "oParumb", "nEnum", "oEnume", "oAcum", " oEnnum", "oEum"], "zipEntry": ["zFile", " zipentry", "entryEntry", "zoneEntry", "zipLine", "ZipInfo", "zentry", "zipInfo", "archiveElement", "zInfo", "downloadentry", "zipElement", "ioEntry", "zEnt", " zipLine", "archiveEntry", "ioentry", "ioFile", "zoneElement", "zipEnt", "ioEnt", "archiveFile", "zipentry", "ZipLine", "zEntry", "downloadEntry", "downloadElement", " zipInfo", " zipEnt", " zipElement", "ZipEntry", "entryFile", "entryentry", "downloadEnt", "zoneEnt", "zoneentry", "zElement", "entryElement", "ZipFile", "zLine", "archiveentry"], "file": ["source", "h", "ile", "url", "pe", "place", "feed", "build", "function", "File", "lib", "l", "letter", "out", "fp", "b", "object", "root", "f", "base", "data", "resource", "work", "child", "call", "force", "filename", "full", "it", "e", "per", "unit", "log", "le", "rule", "path", "entity", "db", "check", "files", "un", "type", "local", "FILE", "line", "entry"], "fos": ["Fos", "foses", "fOs", " foses", "infOS", "FOS", "Foses", "FOs", "infoses", "infos", "fOS", "infOs", " fOS", " fOs"]}}
{"id1": "7317602", "id2": "1785987", "code1": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static String hashSourceCode(String source) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            return new sun.misc.BASE64Encoder().encode(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            _log.error(\"Failed to generate hashcode.\", e);\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"text": ["source", "translation", "contract", "value", "url", "input", "test", "TEXT", "txt", "token", "connection", " TEXT", "message", "output", "format", "letter", "object", "in", "this", "Text", "number", "data", "hex", "version", "class", "editor", "config", "template", "word", "name", "pattern", "password", "EXT", "content", "key", "string", "path", "image", "obj", "font", "code", "struct", "secret", " Text", "str", "ext"], "md": ["ad", "hash", "cd", "bf", "d", "mb", "dig", "dd", "ind", "ld", "hd", "message", " MD", "mm", "ma", "pd", "sm", "wd", "gd", "vd", "am", "cmd", "ms", "mode", "data", "mac", "mo", "di", "bd", "mand", "editor", "mag", "meta", "mc", "sha", "body", "mp", "dm", "mod", "rm", "MD", "mt", "m", "df", "od", "pm", "mg", "code", "map", "mad", "valid", "Cmd", "metadata", "amd", "nm", "me", "mn"], "sha1hash": ["SHA2hash", "sha5copy", "wa1sum", "wa1hash", "sha5hex", "sha1copy", "sha4hash", "wa1copy", "sha2Hash", "sha5hash", "sha64sum", "sha4sha", "SHA1sum", "wa1hex", "sha4h", "SHA2sum", "SHA2h", "sha4copy", "sha4hex", "sha5sum", "sha2hash", "SHA2Hash", "wa5copy", "sha256Hash", "sha2sha", "sha4sum", "SHA1hash", "sha2sum", "sha256sum", "sha1sum", "SHA1sha", "sha64copy", "wa5hash", "sha1Hash", "sha4Hash", "wa5sum", "sha64hash", "sha1h", "sha11hash", "sha256hash", "sha11sum", "SHA2sha", "sha64hex", "sha11sha", "sha1sha", "sha1hex", "wa5hex", "sha256h", "SHA1Hash", "sha2h", "SHA1h"]}}
{"id1": "21368983", "id2": "18623182", "code1": "    public APIResponse update(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/update\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"PUT\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Update Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"application": ["language", "page", "Application", "xml", "analysis", "message", "output", "audio", "http", "app", "object", "request", "apache", "base", "layer", "data", "version", "system", "resource", "address", "external", "config", "bean", "x", "component", "name", "api", "instance", "text", "document", "expression", "attribute", "service", "array", "database", "current", "video", "android", "project", "apply", "unit"], "response": ["next", "host", "respond", "site", "success", "feed", "dict", "complete", "reply", "ception", "result", "function", "reference", "message", "output", "example", "view", "http", "request", "client", "object", "description", "model", "part", "onse", "data", "version", "tree", "resource", "handler", "server", "esi", "writer", "body", "offer", "report", "json", "ae", "api", "instance", "status", "session", "Response", "index", "more", "document", "image", "answer", "error", "resp", "service", "manager", "value", "collection"], "connection": ["translation", "wrapper", "token", "network", "engine", "union", "connected", "channel", "number", "directory", "system", "writer", "log", "cli", "timeout", "image", "connect", "position", "Connection", "location", "reference", "io", "statement", "conn", "communication", "object", "bug", "part", "remote", "handler", "component", "event", "ion", "instance", "relation", "command", "database", "collection", "source", "operation", "url", "link", "office", "function", "client", "loc", "version", "server", "creator", "section", "text", "node", "context", "error", "builder", "manager", "message", "environment", "config", "condition", "inner", "machine", "query", "password", "session", "document", "graph", "entity", "socket", "uri", "character", "current", "proxy", "entry"], "obj": ["tmp", "active", "txt", "arr", "result", "co", "output", "conn", "cdn", "out", "object", "b", "ns", "part", "aj", "po", "data", "n", "r", "oa", "objects", "ctx", "ass", "info", "adj", "js", "body", "bj", "o", "ob", "json", "act", "art", "ose", "Obj", "list", "j", "code", "resp", "map", "obo", "array", "nb", "res", "so", "line", "coll"]}}
{"id1": "22095676", "id2": "10895680", "code1": "    public static String addTag(String tag_id, String tag_description, String tag_text, String tag_author, String application_code) {\n        String so = OctopusErrorMessages.UNKNOWN_ERROR;\n        if (tag_id == null || tag_id.trim().equals(\"\")) {\n            return OctopusErrorMessages.TAG_ID_CANT_BE_EMPTY;\n        }\n        if (tag_id.trim().equals(application_code)) {\n            return OctopusErrorMessages.TAG_ID_TOO_SHORT;\n        }\n        if (!StringUtil.isAlphaNumerical(StringUtil.replace(StringUtil.replace(tag_id, \"-\", \"\"), \"_\", \"\"))) {\n            return OctopusErrorMessages.TAG_ID_MUST_BE_ALPHANUMERIC;\n        }\n        if (!tag_id.startsWith(application_code)) {\n            return OctopusErrorMessages.TAG_ID_MUST_START + \" \" + application_code;\n        }\n        String tag_exist = exist(tag_id);\n        if (!tag_exist.equals(OctopusErrorMessages.DOESNT_ALREADY_EXIST)) {\n            return tag_exist;\n        }\n        if (tag_description != null && !tag_description.trim().equals(\"\")) {\n            tag_description = StringUtil.replace(tag_description, \"\\n\", \" \");\n            tag_description = StringUtil.replace(tag_description, \"\\r\", \" \");\n            tag_description = StringUtil.replace(tag_description, \"\\t\", \" \");\n            tag_description = StringUtil.replace(tag_description, \"<\", \"&#60;\");\n            tag_description = StringUtil.replace(tag_description, \">\", \"&#62;\");\n            tag_description = StringUtil.replace(tag_description, \"'\", \"&#39;\");\n        } else {\n            return OctopusErrorMessages.DESCRIPTION_TEXT_EMPTY;\n        }\n        if (tag_text != null && !tag_text.trim().equals(\"\")) {\n            tag_text = StringUtil.replace(tag_text, \"\\n\", \" \");\n            tag_text = StringUtil.replace(tag_text, \"\\r\", \" \");\n            tag_text = StringUtil.replace(tag_text, \"\\t\", \" \");\n            tag_text = StringUtil.replace(tag_text, \"<\", \"&#60;\");\n            tag_text = StringUtil.replace(tag_text, \">\", \"&#62;\");\n            tag_text = StringUtil.replace(tag_text, \"'\", \"&#39;\");\n        } else {\n            return OctopusErrorMessages.TRANSLATION_TEXT_EMPTY;\n        }\n        if (tag_author == null || tag_author.trim().equals(\"\")) {\n            return OctopusErrorMessages.MAIN_PARAMETER_EMPTY;\n        }\n        DBConnection theConnection = null;\n        try {\n            theConnection = DBServiceManager.allocateConnection();\n            theConnection.setAutoCommit(false);\n            String query = \"INSERT INTO tr_tag (tr_tag_id,tr_tag_applicationid,tr_tag_info,tr_tag_creationdate) \";\n            query += \"VALUES (?,?,'\" + tag_description + \"',getdate())\";\n            PreparedStatement state = theConnection.prepareStatement(query);\n            state.setString(1, tag_id);\n            state.setString(2, application_code);\n            state.executeUpdate();\n            String query2 = \"INSERT INTO tr_translation (tr_translation_trtagid, tr_translation_language, tr_translation_text, tr_translation_version, tr_translation_lud, tr_translation_lun ) \";\n            query2 += \"VALUES(?,'\" + OctopusApplication.MASTER_LANGUAGE + \"','\" + tag_text + \"',0,getdate(),?)\";\n            PreparedStatement state2 = theConnection.prepareStatement(query2);\n            state2.setString(1, tag_id);\n            state2.setString(2, tag_author);\n            state2.executeUpdate();\n            theConnection.commit();\n            so = OctopusErrorMessages.ACTION_DONE;\n        } catch (SQLException e) {\n            try {\n                theConnection.rollback();\n            } catch (SQLException ex) {\n            }\n            so = OctopusErrorMessages.ERROR_DATABASE;\n        } finally {\n            if (theConnection != null) {\n                try {\n                    theConnection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n                theConnection.release();\n            }\n        }\n        return so;\n    }\n", "code2": "    private DefaultMutableTreeNode parseTree() {\n        try {\n            DefaultMutableTreeNode root;\n            URL url = RebusHelp.class.getResource(\"/org/olga/rebus/gui/help/html/content.xml\");\n            InputStream is = url.openStream();\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(true);\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            Document document = parser.parse(is);\n            NodeList elements = document.getElementsByTagName(\"help\");\n            Element element = (Element) elements.item(0);\n            root = createTreeContent(element);\n            is.close();\n            return root;\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            return null;\n        } catch (ParserConfigurationException e1) {\n            System.out.println(e1.getMessage());\n            return null;\n        } catch (org.xml.sax.SAXException e2) {\n            System.out.println(e2.getMessage());\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"tag_id": ["bug_id", " tag_name", "bug_type", "attribute_name", " tag_ids", "tag_entry", "attribute_code", "tagacid", "tagacID", " tag_entry", "tag_main", "tag67id", "tag67entry", "tagacname", "attribute_id", "tag_type", "tagactype", " tag_title", "tagaccode", "attribute_author", " tag_main", "tag_length", "tag67title", "bug_name", "bug_length", "tagaclength", "bug_code", "tag_code", "tag_ids", "bug_description", "tag67name", "tagacdescription", "tag_title", "tag_ID", "tag_name", " tag_ID", " tag_type"], "tag_description": ["post_description", "optionftotal", "tag_duration", "option_name", "tag_value", "tagppassword", "post_translation", "cat_description", "optionfexpression", "tag_comment", "tag24name", "attribute_password", "tag_entry", "tagJsecret", "attribute_summary", "ack_description", "tag_summary", "post_design", "tag_secret", "tag_total", " tag_duration", "tag__description", "tag_design", "attribute_design", "taggexpression", "blog_display", "tag_release", "tag_desc", "blog24display", "tag_layout", "date_summary", "bug_category", "bug_secret", "post_type", "tag_detail", "option_description", "ack_creation", " tag_layout", "ack_release", "taggoption", "option_total", "post_option", "cat_details", "tag_type", "post_definition", "tag_category", "bug_entry", "date_details", "tagJtext", "tag24comment", "tagJdescription", "tag24expression", "tagfdescription", "tag__duration", "taggdescription", "blog24description", "tagpdescription", "tag24total", "tick_release", "tag24description", "attributepdesign", "date_password", "tag_report", "tag_display", "tick_description", "date_length", "cat_definition", "tag_length", "blog_description", "tag_translation", "optionfdescription", "tick_summary", "tick_detail", "bug_name", "option_expression", "date_desc", "tagftotal", "tagfexpression", "blog_comment", "tag_creation", "post_summary", "bug_author", "attributepdescription", "bug_report", "taggtype", "tag_option", "date_description", "date_author", "attribute_description", "tagpdesign", "tagfname", "tag__text", "bug_description", "tagJentry", "tagpsummary", "optionfname", "tag_expression", "tag_details", "post_creation", "ack_value", "tag24display", "tag__layout", "attributepsummary", "attributeppassword", "tag_name", "bug_text", "cat_text", "tag_password", "post_expression", "tag_definition", "blog24comment"], "tag_text": ["tag___description", "tag___writer", "tag_comment", "ag_name", "ag64name", "ag64text", "tag_message", "tag64id", "tag64text", "tag_secret", "comment_text", "tag64secret", "tag_desc", "ag_author", "comment_comment", "ag64id", "tag___translation", "ag64author", " tag_translation", "tag_content", "ag_text", "tag___text", "tag_translation", "ag_id", "tag64name", " tag_secret", " tag_message", " tag_writer", "comment_desc", "tag_writer", "tag_name", "tag64author", "tag64message", "comment_content"], "tag_author": ["tag67author", "atom_from", "tag67version", "atom_id", "tag67from", "tag_from", "atom\u00b7author", "tag__id", "tag__author", "tag\u00b7from", "atom_author", "atom_version", "tag__version", "tag__from", "atom\u00b7id", "tag\u00b7version", "tag67id", "atom\u00b7from", "tag\u00b7id", "atom\u00b7version", "tag_version", "tag\u00b7author"], "application_code": ["application_uri", " application_address", " application_codes", "application_id", "applicationingcontent", "company_code", " application_url", "applicationflowcode", "application1address", "application24url", "application24code", "applicationCtext", "company_id", "applicationflowtext", "companyflowtext", "packageinglength", "package_Code", "packageingcode", "application_url", "companyflowid", "application_length", "package_code", "applicationflowuri", " application_Code", "companyflowuri", "applicationinglength", "application_address", "applicationflowid", "applicationelength", "application_Code", "application1url", "application1codes", " application_name", "applicationeCode", "package_content", "applicationecontent", "company_uri", "application24codes", "application_codes", "applicationingcode", "application1code", "application_name", "company_text", "applicationecode", "applicationCcode", "application24address", "applicationCCode", "packageingcontent", "application_text", "applicationingCode", "package_length", "applicationCname", "application_content", "companyflowcode", " application_text", "packageingCode"], "so": [" Error", "msg", " fault", " o", " result", " exception", "result", " exc", "sg", "Message", " results", "ERROR", " output", " mess", " out", " ERROR", " resp", " res", " sw", " success", " er", " failure", " reply", "Msg", " rc", "error", " orig", "err", " ans"], "tag_exist": ["tag_edit", "message1exist", "tag_existence", " tag_existence", " tag_purpose", "tag1existent", "tag67existence", "tag67edit", "bug_existent", "bug_cont", "message1missing", "tag_cont", "message_missing", "message_exist", "message_existent", "tag1delete", "tag_existent", "tag_missing", "tag67purpose", "tag1exist", "bug_exist", "tag1missing", " tag_edit", "tag_delete", "message_delete", "tag_purpose", "message1delete", "bug_existence", "tag67exist", "message1existent"]}}
{"id1": "11902597", "id2": "1332258", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Start filtering zgps...\");\n        final Config config = Gbl.createConfig(args);\n        final String CONFIG_MODULE = \"GPSFilterZGPS\";\n        File sourceFileSelectedStages = new File(config.findParam(CONFIG_MODULE, \"sourceFileSelectedStages\"));\n        File sourceFileZGPS = new File(config.findParam(CONFIG_MODULE, \"sourceFileZGPS\"));\n        File targetFile = new File(config.findParam(CONFIG_MODULE, \"targetFile\"));\n        System.out.println(\"Start reading selected stages...\");\n        FilterZGPSSelectedStages selectedStages = new FilterZGPSSelectedStages();\n        selectedStages.createSelectedStages(sourceFileSelectedStages);\n        System.out.println(\"Done. \" + selectedStages.getSelectedStages().size() + \" stages were stored\");\n        System.out.println(\"Start reading and writing zgps...\");\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFileZGPS)));\n            BufferedWriter out = new BufferedWriter(new FileWriter(targetFile));\n            out.write(in.readLine());\n            out.newLine();\n            String lineFromInputFile;\n            while ((lineFromInputFile = in.readLine()) != null) {\n                String[] entries = lineFromInputFile.split(\"\\t\");\n                if (selectedStages.containsStage(Integer.parseInt(entries[0]), Integer.parseInt(entries[1]), Integer.parseInt(entries[2]))) {\n                    out.write(lineFromInputFile);\n                    out.newLine();\n                    out.flush();\n                }\n            }\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find source file for selected stages.\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.out.println(\"IO Exception while reading or writing zgps.\");\n            e.printStackTrace();\n        }\n        System.out.println(\"Done.\");\n    }\n", "code2": "    public void writeTo(OutputStream out) throws IOException {\n        if (!closed) {\n            throw new IOException(\"Stream not closed\");\n        }\n        if (isInMemory()) {\n            memoryOutputStream.writeTo(out);\n        } else {\n            FileInputStream fis = new FileInputStream(outputFile);\n            try {\n                IOUtils.copy(fis, out);\n            } finally {\n                IOUtils.close(fis);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"config": ["host", "Config", "url", "queue", "default", "connection", "cf", "settings", "output", "conn", "view", "Configuration", "con", "license", "app", "b", "driver", "bc", "client", "bug", "console", "f", "loader", "data", "system", "sc", "ctx", "info", "exec", "conf", "module", "gui", "init", "rc", "project", " Config", "log", "spec", "text", "ini", "ch", "lc", "cfg", "utils", "cache", "c", "file", "context", "load", "g", "support", "fig", "service", "manager", "front", "ca", "ext"], "CONFIG_MODULE": ["CONFIG_FORMUL", "CONFIG_Modules", "CONFIG_MOules", "CONFIG_MSUL", "CONFIG_MODAGE", "CONFIG_ModUME", "CONFIG_MODRIPT", "CONFIG_ModRIPT", "CONFIG_ModLE", "CONFIG_REGule", "CONFIG_ModUL", "CONFIG_MOUME", "CONFIG_FORMLE", "CONFIG_ModULE", "CONFIG_MRAGE", "CONFIG_MODLE", "CONFIG_MSule", "CONFIG_FORMULE", "CONFIG_MODules", "CONFIG_MOule", "CONFIG_MRRIPT", "CONFIG_METHODRIPT", "CONFIG_MRule", "CONFIG_MSULE", "CONFIG_REGLE", "CONFIG_METHODAGE", "CONFIG_MOULE", "CONFIG_Module", "CONFIG_FORMule", "CONFIG_REGUL", "CONFIG_MODule", "CONFIG_MSUME", "CONFIG_REGULE", "CONFIG_MRULE", "CONFIG_MODUL", "CONFIG_METHODule", "CONFIG_ModAGE", "CONFIG_METHODULE", "CONFIG_MODUME"], "sourceFileSelectedStages": ["sourceFileSelectedStrays", "sourceFileSelectedEstores", "sourceFileSelectedSTages", "sourceFileSearedStacks", "sourceFileSelectedSTaging", "sourceFileSelectedSTores", "sourceFileSelectedstases", "sourceFileSelectedSTays", "sourceFileSelectedStaging", "sourceFileSelectedRaging", "sourceFileSelectedRarts", "sourceFileSelectedTaging", "sourceFileSelectedRacks", "sourceFileSelectionstays", "sourceFileSearedSTarts", "sourceFileSelectedStays", "sourceFileSelectedTages", "sourceFileSelectionstages", "sourceFileSelectedSTacks", "sourceFileSelectedTacks", "sourceFileSelectedStacks", "sourceFileSearedStages", "sourceFileSelectionStases", "sourceFileSelectedstays", "sourceFileSearedSTages", "sourceFileSelectionStages", "sourceFileSelectionstaging", "sourceFileSelectedEstages", "sourceFileSelectedStrores", "sourceFileSelectedStarts", "sourceFileSelectionStaging", "sourceFileSelectedRages", "sourceFileSelectionStores", "sourceFileSelectedTarts", "sourceFileSelectedStrages", "sourceFileSelectionstores", "sourceFileSelectedstages", "sourceFileSearedStaging", "sourceFileSelectedStraging", "sourceFileSearedStarts", "sourceFileSelectedStases", "sourceFileSelectedEstases", "sourceFileSelectedStores", "sourceFileSelectedstaging", "sourceFileSearedSTacks", "sourceFileSelectedEstays", "sourceFileSelectionstases", "sourceFileSearedSTaging", "sourceFileSelectionStays", "sourceFileSelectedSTarts", "sourceFileSelectedstores"], "sourceFileZGPS": ["sourceFileYGeAPS", "sourceFileZGPPs", "sourceFileZGPps", "sourceFileZGUPC", "sourceFileZXGPFS", "sourceFileYGPC", "sourceFileYGPS", "sourceFileYGps", "sourceFileYGeps", "sourceFileZGPC", "sourceFileZXGFS", "sourceFileZXGPRS", "sourceFileZGFS", "sourceFileZXGPS", "sourceFileZDPS", "sourceFileXGPC", "sourceFileZGPRS", "sourceFileZGPAPS", "sourceFileZGeps", "sourceFileYGePC", "sourceFileZGps", "sourceFileXGUps", "sourceFileZXGRS", "sourceFileZDRS", "sourceFileZGPPC", "sourceFileXGUPC", "sourceFileZDFS", "sourceFileZGePs", "sourceFileZXGPPC", "sourceFileYGePS", "sourceFileZGUPS", "sourceFileXGps", "sourceFileZGPs", "sourceFileZGURS", "sourceFileZDPC", "sourceFileZGePS", "sourceFileXGUPS", "sourceFileZGRS", "sourceFileZGUFS", "sourceFileZGUps", "sourceFileZGUPs", "sourceFileXGPS", "sourceFileXGUPs", "sourceFileZGPFS", "sourceFileZGUAPS", "sourceFileXGPs", "sourceFileZGAPS", "sourceFileZGPPS", "sourceFileZGePC", "sourceFileZXGPC", "sourceFileZXGPPS", "sourceFileZGeAPS", "sourceFileYGAPS"], "targetFile": ["sourceDir", "effectWriter", " targetFILE", "targetFILE", "TargetFile", "defaultPath", "effectPath", "outputFile", "Targetfile", "outputFiles", "defaultFile", "sourcefile", " targetWriter", "targetPath", "sourceFile", "effectfile", "targetFiles", "defaultFILE", "targetfile", "targetWriter", "sourceFiles", " targetDir", "TargetPath", "sourcePath", " targetfile", " targetFiles", " targetPath", "outputDir", "effectFile", "targetDir", "defaultfile", "outputPath", "TargetFILE", "sourceWriter"], "selectedStages": ["selectedStrays", " selectedstarts", "selectedStides", "selectedSlags", "selectedMessarts", " selectedStags", " selectedStasks", "selectedstags", " selectedstages", "selectedStases", " selectedStacks", "selectedStrags", "selectedstides", "namedstages", "selectedSlases", " selectedStases", "selectedSTacks", " selectedStides", " selectedstasks", "namedstays", " selectedstags", "selectedSTarts", " selectedstides", "selectedStacks", "selectedStreamages", "namedStags", "selectedStreamides", "selectedstacks", "selectedStasks", "selectedstages", "selectedStags", "namedstags", "namedStores", "selectedStrases", " selectedstacks", "selectedSTags", "namedStages", "selectedStores", " selectedstases", "selectedSTases", "selectedstarts", "selectedstasks", "selectedMessags", "namedStays", "selectedSTasks", "selectedMessages", "selectedSTages", "selectedstores", "selectedStrores", "selectedStarts", "selectedStrages", " selectedStarts", "namedstores", "selectedstays", "selectedStays", "selectedStrides", "selectedStreamases", "selectedstases", "selectedSlages", "selectedMessacks", "selectedSlasks"], "in": ["get", "reader", "h", "id", "url", "input", "inc", "din", "token", "win", "min", "nin", "conn", "l", "con", "b", "diff", "part", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "re", "thin", "into", "serv", "isin", "inner", "er", "init", "it", "ins", "e", "t", "gin", "ini", "a", "ex", "image", "cin", "lock", "socket", "i", "IN", "inside", "err", "g", "inn", "or", "lin", "bin", "line"], "out": ["default", "wrapper", "net", "down", "extra", "doc", "over", "Out", "r", "call", "writer", "sys", "sync", "name", "log", "flush", "post", "cli", "temp", "image", "list", "obj", "file", "err", "group", "store", "line", "msg", "co", "io", "outer", "conn", "lib", "pre", "b", "part", "gen", "to", "table", "OUT", "exp", "bar", "ex", "key", "all", "point", "pool", "cache", "at", "copy", "ext", "page", "parent", "plain", "size", "inc", "write", "user", "client", "cmd", "f", "n", "work", "server", "raw", "sum", "exec", "o", "comment", "v", "error", "builder", "output", "view", "w", "dump", "state", "data", "again", "outs", "prefix", "serv", "inner", "query", "password", "gin", "session", "up", "window", "lock", "socket", "code", "bin"], "lineFromInputFile": ["lineFromOutputStream", "lineFromOutputFile", "lineFromSourceFile", "lineFrominputFiles", "lineToOutputFile", "lineFromOriginalLine", "linefromInputMessage", "lineFromRawDirectory", "linefromSourceLine", "linefrominputStream", "lineFromOriginalMessage", "linefromInputFile", "lineFromInputStream", "lineFromSourceDirectory", "lineFromInputFiles", "lineFrominputPlace", "lineFrominputFile", "lineFromInputPlace", "lineFrominputDirectory", "lineFromSourceLine", "lineToInputPlace", "lineFromOriginalFile", "lineFromOriginalStream", "lineFrominputStream", "lineToInputLine", "lineToOutputPlace", "lineToInputStream", "lineFromOutputMessage", "linefromInputFiles", "lineFromOutputPlace", "linefromSourceStream", "lineFromSourceFiles", "lineFromOutputLine", "linefromSourceFile", "lineFrominputMessage", "lineToOutputLine", "lineToInputFile", "linefromInputLine", "linefromInputStream", "lineFrominputLine", "linefrominputFiles", "linefrominputMessage", "lineFromOutputDirectory", "lineFromRawPlace", "lineFromRawFile", "lineToInputDirectory", "linefrominputFile", "lineToOutputDirectory", "lineFromSourceMessage", "lineFromRawLine", "lineToOutputStream", "linefromSourceMessage", "lineFromOriginalDirectory", "lineFromInputDirectory", "lineFromInputMessage", "lineFromOriginalFiles", "lineFromInputLine", "lineFromSourceStream"], "entries": ["endrants", "entsry", "entsrys", "endrings", "estents", "enles", "entrings", "entles", "entskeys", "entories", "contorts", "centles", "contry", "entrants", "equriers", "equents", "enries", "Entkeys", "pentrys", "centrants", "estriers", "pentkeys", "entrows", "anchrows", "endry", "entsries", "Entrys", "endorts", "entorts", "anchries", "centries", "pentries", "anchents", "pentrants", "entsrings", "entkeys", "anchriers", "Entrants", "centories", "Entries", "entrys", "enrants", "entents", "estrows", "entsorts", "entriers", "endories", "contrings", "endles", "endries", "contries", "estries", "equries", "entsrants", "equrows", "enories", "entry"]}}
{"id1": "8172652", "id2": "6842462", "code1": "    @Test\n    @JUnitHttpServer(port = 10342, https = false, webapps = { @Webapp(context = \"/fmpm\", path = \"src/test/resources/test-webapp\") })\n    public void testTestServlet() throws Exception {\n        TestServlet.reset();\n        HttpClient client = new DefaultHttpClient();\n        HttpEntity entity = new StringEntity(xml);\n        HttpPost method = new HttpPost(\"http://localhost:10342/fmpm/restful/NotificationMessageRelay\");\n        method.setEntity(entity);\n        HttpResponse response = client.execute(method);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(xml, TestServlet.getPosted());\n    }\n", "code2": "    private void playAudio(String mediaUrl) {\n        try {\n            URLConnection cn = new URL(mediaUrl).openConnection();\n            InputStream is = cn.getInputStream();\n            mediaFile = new File(this.getCacheDir(), \"mediafile\");\n            FileOutputStream fos = new FileOutputStream(mediaFile);\n            byte buf[] = new byte[16 * 1024];\n            Log.i(\"FileOutputStream\", \"Download\");\n            do {\n                int numread = is.read(buf);\n                if (numread <= 0) break;\n                fos.write(buf, 0, numread);\n            } while (true);\n            fos.flush();\n            fos.close();\n            Log.i(\"FileOutputStream\", \"Saved\");\n            MediaPlayer.OnCompletionListener listener = new MediaPlayer.OnCompletionListener() {\n\n                public void onCompletion(MediaPlayer mp) {\n                    mp.release();\n                    Log.i(\"MediaPlayer.OnCompletionListener\", \"MediaPlayer Released\");\n                }\n            };\n            mixPlayer.setOnCompletionListener(listener);\n            FileInputStream fis = new FileInputStream(mediaFile);\n            mixPlayer.setDataSource(fis.getFD());\n            mixPlayer.prepare();\n            Log.i(\"MediaPlayer\", \"Start Player\");\n            loading = false;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"client": ["host", "url", "connection", "plugin", "output", "conn", "http", "con", "app", "request", "channel", "https", "application", "resource", "handler", "server", "child", "config", "force", "per", "cl", "api", "Client", "cli", "m", "session", "pool", "cache", "c", "context", "service", "ce", "proxy", "project", "web", "collection"], "entity": ["translation", "url", "pe", "ent", "xml", "message", "output", "security", "object", "model", "ep", "environment", "data", "ec", "enc", "resource", "email", "server", "el", "element", "component", "body", "event", "e", "Entity", "json", "instance", "text", "content", "agent", "string", "document", "file", "code", "attribute", "em", "collection", "null"], "method": ["Method", "POST", "route", "operation", "url", "wrapper", "term", "plugin", "build", "function", "message", "http", "request", "this", "end", "object", "model", "data", "METHOD", "stream", "remote", "r", "resource", "server", "call", "address", "module", "send", "event", "report", "api", "instance", "rh", "post", "m", "content", "trip", "path", "document", "record", "uri", "each", "command", "service", "header", "array", "invoke", "manager", "process", "subject", "hod", "form", "project", "collection", "ip", "p"], "response": ["page", "respond", "site", "connection", "success", "reply", "result", "message", "output", "http", "request", "object", "model", "channel", "application", "data", "version", "resource", "server", "child", "writer", "body", "report", "json", "api", "content", "status", "Response", "document", "resp", "received", "collection"]}}
{"id1": "6795580", "id2": "22768445", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static String hashNative(String password, String algorithm, String prefixKey, boolean useDefaultEncoding) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            if (useDefaultEncoding) {\n                digest.update(password.getBytes());\n            } else {\n                for (char c : password.toCharArray()) {\n                    digest.update((byte) (c >> 8));\n                    digest.update((byte) c);\n                }\n            }\n            byte[] digestedPassword = digest.digest();\n            BASE64Encoder encoder = new BASE64Encoder();\n            String encodedDigested = encoder.encode(digestedPassword);\n            return prefixKey + encodedDigested;\n        } catch (NoSuchAlgorithmException ne) {\n            return password;\n        }\n    }\n", "label": 1, "substitutes": {"secure": ["host", "active", "require", "deep", "safe", "secondary", "pure", "security", "Secure", "stable", "https", "remote", "zip", "smart", "server", "config", "external", "random", "force", "depth", "relative", " insecure", "allow", "sr", "exclusive", "timeout", "session", "sec", "confirmed", "seed", "encrypted", "debug", "ssl", "sensitive", "quiet", "service", "secret", "unsigned", "proxy", "weak", "use"], "md5": ["mand3", " md64", "MDito", "md3", "md64", "mp2", " md256", " MD2", "mand2", "MD5", "mand5", " mdito", " MD5", "mdito", "mp5", " md56", "mand56", "MD512", " MDito", "MD3", "md512", "md256", "mand256", "mp64", "mand512", "MD2", "MD56", " MD3", "md2", " md2", " md512", "MD64", " md3", "md56", "MD256", "mp3"], "sbValueBeforeMD5": ["sbValueBeforemd85", "sbValueBeforeMet5", "sbValueBeforeMD3", "sbValueBeforeMC512", "sbValueWithoutSHA3", "sbValueBeforeML68", "sbValueAfterMD85", "sbValueBeforeMD1", "sbValueBeforeMP9", "sbValueBeforeMD53", "sbValueAfterMSLink", "sbValueBeforeMS3", "sbValueWithoutSHA512", "sbValueBeforemd512", "sbValueBeforeAST512", "sbValueBeforeAMDFive", "sbValueBesidesMD68", "sbValueAfterMD53", "sbValueBeforeMPFive", "sbValueBeforeSHA5", "sbValueBeforeMCLink", "sbValueBeforeML3", "sbValueBeforeMSLink", "sbValueBeforeMF5", "sbValueBeforeAMD3", "sbValueWithoutMD1", "sbValueAfterMD5", "sbValueBeforeMP1", "sbValueBeforeMDFive", "sbValueBeforeSHA512", "sbValueBeforeAMD512", "sbValueBeforeML5", "sbValueAfterMD3", "sbValueBeforeAST3", "sbValueWithoutSHA1", "sbValueAfterMS5", "sbValueBeforeMD512", "sbValueBeforeM3", "sbValueBeforeMP25", "sbValueBeforeMD8", "sbValueBeforeMAC1", "sbValueBesidesMD8", "sbValueBeforeAMD85", "sbValueBeforeML8", "sbValueBeforeMAC5", "sbValueBeforeAMD1", "sbValueBeforeMP3", "sbValueWithoutMD3", "sbValueBeforemd3", "sbValueBeforeMet9", "sbValueBeforeMD25", "sbValueAfterAMD512", "sbValueAfterMP3", "sbValueBeforeMS53", "sbValueWithoutMD5", "sbValueBeforeM512", "sbValueBeforeMet25", "sbValueBeforeAST85", "sbValueAfterMS53", "sbValueBeforeMD68", "sbValueBeforeMC1", "sbValueBeforeMC5", "sbValueBeforeMF512", "sbValueAfterMDFive", "sbValueAfterMP1", "sbValueBeforeM5", "sbValueAfterAMD85", "sbValueBeforeAMD5", "sbValueBeforeMD9", "sbValueBeforemd53", "sbValueBeforeMF85", "sbValueWithoutMD512", "sbValueBeforeMACFive", "sbValueBeforeAST5", "sbValueBeforeM1", "sbValueBeforeMS5", "sbValueBeforeMD85", "sbValueBeforeMS85", "sbValueAfterMPFive", "sbValueAfterAMD3", "sbValueBeforeMF3", "sbValueBeforeSHA3", "sbValueAfterMDLink", "sbValueBeforeMDLink", "sbValueBeforeSHA1", "sbValueAfterMS3", "sbValueBeforeMC53", "sbValueBeforeMC3", "sbValueBeforeMS512", "sbValueAfterAMD5", "sbValueAfterMD512", "sbValueBeforeMS68", "sbValueBeforeMS8", "sbValueBeforemdLink", "sbValueBeforemd5", "sbValueBeforeMP5", "sbValueAfterMP5", "sbValueBeforeMet3", "sbValueAfterMD1", "sbValueBesidesMD3", "sbValueWithoutSHA5", "sbValueBeforeMAC3", "sbValueBesidesMD5"], "time": ["host", "size", "id", "user", "hour", "race", "year", "counter", "tim", "tz", "clock", "mode", "loc", "sleep", "version", "serial", "ime", "random", "etime", "depth", "name", "event", "length", "cost", "money", "timeout", "count", "seed", "delay", "live", "error", "times", "speed", "date", "TIME", "Time", "start", "timer", "rate", "value", "port", "month", "duration", "type"], "rand": ["id", "rar", "rank", "win", "year", "mid", "range", "right", "ro", "dev", "winner", "root", "bug", "gen", "loc", "version", "serial", "r", "clean", "round", "rage", "random", "depth", "rc", "pattern", "patch", "length", "max", "rh", "raid", "bit", "index", "rule", "count", "seed", "reg", "delay", "error", "live", "rr", "q", "order", "ng", "rate", "Rand", "alpha", "pick", "type"], "valueBeforeMD5": ["valueBeforeAMD2", "valueAfterMP3", "valueBeforeMC3", "valueBeforeMF25", "valueAfterMP2", "valueAfterMP50", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAfterMD25", "valueBeforeMP50", "valueBeforeAMD3", "valueBeforeMF2", "valueBeforeMP2", "valueBeforeME5", "valueAfterMD3", "valueBeforeMD3", "valueBeforeMD25", "valueBeforeME3", "valueBeforeAMD50", "valueBeforeAMD5", "valueBeforeMD50", "valueBeforeMF3", "valueAfterMP5", "valueBeforeMC2", "valueBeforeMF5", "valueAfterMD50", "valueBeforeME2", "valueAfterMD2", "valueBeforeMC5", "valueBeforeMC25", "valueBeforeME50"], "array": ["hash", "queue", "binary", "our", "Array", "arr", "range", "arrow", "function", "result", "message", "audio", "view", "object", "app", "ray", "number", "data", "r", "integer", "pair", "archive", "feature", "address", "angle", "shape", "element", "section", "batch", "allow", "api", "instance", "a", "area", "abc", "index", "string", "image", "list", "record", "error", "expression", "map", "database", "value", "collection", "sample"], "sb": ["sa", "cb", "bf", "mb", "bh", "si", "binary", "buffer", "sth", "buff", "usb", "sg", "pb", "src", "sf", "bc", "lr", "kb", "bm", "ruby", "abb", "bs", "obb", "rob", "erb", "bj", "bb", "SB", " SB", "ob", "sl", "sv", "zb", "buf", "gb", "xb", "eb", "ib", "orb", "bsp", "ab", "db", "bt", "wb", "fb", "sq", "lab", "nb", "lb", "s", "rb", "bp", "bl"], "j": ["jj", "num", "d", "ind", "br", "J", "jp", "k", "l", "y", "jo", "ja", "part", "aj", "f", "ij", "n", "ji", "adj", "js", "x", "bj", "o", "e", "uj", "dj", "length", "pr", "ch", "job", "li", "v", "key", "dy", "index", "obj", "c", "i", "ii", "im", "jl", "oj", "q", "z", "p", "ie"], "b": ["cb", "bf", "d", "mb", "be", "br", "k", "BB", "pb", "l", "y", "f", "p", "n", "bs", "x", "e", "bb", "ob", "bit", "bar", "job", "a", "B", "eb", "orb", "c", "ab", "db", "i", "obj", "wb", "fb", "nb", "lb", "bin", "rb", "ib"], "valueAfterMD5": ["valueAfterMP3", "valueAfterMP2", "valueAfterMDType", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAftermd2", "valueAfterAMD3", "valueBeforeMP2", "valueAftermd3", "valueAfterMD3", "valueAfterMPType", "valueAfterAMD5", "valueBeforeMD3", "valueAftermdType", "valueAfterMP5", "valueAfterAMD2", "valueBeforeMDType", "valueAfterMD2", "valueBeforeMPType", "valueAfterAMDType", "valueAftermd5"]}}
{"id1": "16765164", "id2": "115129", "code1": "        private void open() throws IOException {\n            if (in != null) return;\n            try {\n                con = url.openConnection();\n                in = con.getInputStream();\n            } catch (IOException e) {\n                if (cached.exists()) {\n                    LOG.fine(\"Falling back to cached copy of wiki file \" + url);\n                    in = new FileInputStream(cached);\n                    con = null;\n                    return;\n                }\n                throw e;\n            }\n            try {\n                tmp = new File(cached.getAbsolutePath() + \".tmp\");\n                tmp.getParentFile().mkdirs();\n                out = new FileOutputStream(tmp);\n            } catch (IOException e) {\n                LOG.fine(\"can't write cached copy of wiki file \" + url);\n            }\n        }\n", "code2": "    public static void bubbleSort(String[] a) {\n        Collator myCollator = Collator.getInstance();\n        boolean switched = true;\n        for (int pass = 0; pass < a.length - 1 && switched; pass++) {\n            switched = false;\n            for (int i = 0; i < a.length - pass - 1; i++) {\n                if (myCollator.compare(a[i], a[i + 1]) > 0) {\n                    switched = true;\n                    String temp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"con": ["pen", "an", "url", "input", "inc", "en", "win", "connection", "uc", "open", "cm", "co", "conn", "fc", "client", "bc", "login", "channel", "cp", "ain", "can", "inner", "cn", "conf", "pc", "exec", "cur", "rc", "CON", "syn", "com", "close", "connect", "cache", "c", "socket", "ran", "file", "lock", "un", "conv", "bin", "ac", "Con"], "in": ["source", "reader", "id", "url", "input", "inc", "din", "win", "buffer", "min", "cgi", "conn", "lib", "client", "login", "In", "pin", "again", "n", "into", "resource", "config", "inner", "exec", "conf", "pc", "oin", "init", "ins", "ini", "m", "index", "cin", "socket", "ssl", "c", "i", "IN", "inn", "rin", "is", "bin", "on", "ac"], "tmp": ["source", "folder", "parent", "sb", "py", "cb", "pot", "txt", "pkg", "upload", "tab", "now", "cat", "src", "fp", "fake", "this", "part", "f", "tf", "po", "base", "tem", "cp", "storage", "zip", "cot", "dest", "ppa", "pa", "mp", "dir", "amp", "keep", "m", "buf", "temp", "path", "cache", "c", "sp", "file", "pty", "wb", "fb", "vt", "nb", "boot", "img", "perm", "copy", "rb", "p"], "out": ["parent", "write", "co", "io", "output", "w", "client", "part", "to", "put", "zip", "outs", "exec", "name", "o", "ax", "log", "temp", "path", "obj", "err", "opt", "img", "bin", "op", "ot", "ext"]}}
{"id1": "20177902", "id2": "16995204", "code1": "    public void execute(HttpServletRequest req, HttpServletResponse res, HttpServlet parent) throws Exception {\n        String path = req.getParameter(\"path\");\n        path = URLDecoder.decode(path, \"UTF-8\");\n        String name = req.getParameter(\"name\");\n        name = new String(name.getBytes(), \"UTF-8\");\n        String contentType = req.getParameter(\"contentType\");\n        if (path == null) {\n            NullPointerException e = new NullPointerException(\"The path attribute cannot be retrieved.\");\n            LOG.error(e);\n            throw e;\n        }\n        URL url = new URL(path);\n        InputStream inStream = null;\n        try {\n            inStream = URLUtils.getFileContent(url, req.getSession().getId());\n            res.setContentType(contentType);\n            res.addHeader(\"Content-Disposition\", \"attachment;filename=\\\"\" + name + \"\\\"\");\n            ServletOutputStream out = res.getOutputStream();\n            IOUtils.copy(inStream, out);\n            res.flushBuffer();\n        } finally {\n            if (inStream != null) {\n                inStream.close();\n            }\n        }\n    }\n", "code2": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        fields.put(item.getFieldName(), item.getString());\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                sendInstance.saveDraft(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, preferencesInstance.getPreferences().isHtmlMessage(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "label": 1, "substitutes": {"req": ["reader", "str", "rf", "proc", "sem", "rx", "require", "rel", "xml", "cook", "conn", "wx", "request", "app", "cmd", "fr", "rou", "loader", "progress", "ref", "r", "resource", "ctx", "repl", "comp", "config", "Request", "ir", "crit", "tar", "cur", "exec", "desc", "query", "requ", "exp", "spec", "Requ", "rs", "pr", "rh", "tr", "rec", "obj", "reg", "rt", "mr", "err", "resp", "war", "required", "q", "rr", "qt", "rb", "jar", "rest", "wr"], "res": ["rem", "resources", "Rs", "respond", "Res", "rel", "rep", "reply", "rex", "result", "rss", "RES", "conn", "css", "onse", "resolution", "re", "r", "response", "resource", "bs", "ret", "repl", "ris", "es", "os", "rus", "js", "vs", "full", "results", "exp", "json", "rs", "ress", "cs", "remote", "rec", "rows", "vals", "obj", "reg", "rev", "err", "resp", "Resp", "press", "RE", "ras", "pers", "cms", "ps", "rest", "wr", "pres"], "parent": [" ep", " self", " ap", " impl", " ps", "application", "ctx", "config", "body", "acl", " appl", "cl", " subp", "temp", "sp", "obj", " template", "service", " child", " pl", " app", "self", "cms", " sp", " ex", " proc", "port", "pl"], "path": ["source", "host", "page", "route", "str", "id", "none", "connection", "xml", "PATH", "object", "request", "Path", "root", "part", "data", "href", "ref", "style", "response", "clean", "resource", "prefix", "child", "config", "template", "address", "dest", "ath", "alias", "method", "desc", "filename", "full", "pattern", "target", "json", "param", "log", "text", "content", "key", "index", "string", "image", "node", "pointer", "pass", "point", "uri", "context", "code", "attribute", "error", "file", "font", "property", "mount", "test", "value", "location", "type"], "name": ["source", "nice", "NAME", "host", "ame", "size", "id", "default", "Name", "term", "connection", "username", "one", "object", "client", "description", "part", "base", "data", "version", "named", "no", "n", "clean", "resource", "prefix", "call", "address", "info", "child", "alias", "word", "filename", "action", "na", "method", "nam", "comment", "names", "content", "temp", "session", "key", "string", "image", "pass", "file", "title", "attribute", "search", "property", "label", "create", "group", "nm", "value", "type"], "contentType": ["ContentType", " contenttype", "methodInfo", "extFormat", "methodPath", " contentUnit", "extUnit", "extType", "imageName", "imagetype", "extInfo", "resourcetype", "ContentFormat", " contentName", " contentFormat", "contentPath", "contentInfo", " contentInfo", "contenttype", "imagePath", "resourceName", "ContentPath", "contentName", "methodType", "resourceType", "Contenttype", "ContentInfo", "methodtype", " contentPath", "resourcePath", "ContentUnit", "imageType", "contentUnit", "contentFormat"], "e": ["ea", "en", "pe", "be", "ception", "ee", " pe", "ger", "l", "ev", "this", "b", "ep", "f", "exc", "E", "fe", "ec", "re", "r", "ade", " E", "element", "er", "event", "ge", "o", "de", "me", "ae", "ace", "oe", " error", "a", "se", "ze", "j", "c", "error", "err", " me", "ce", "s", "ed", "p", "ie"], "url": ["source", "id", "connection", "buffer", "ll", "src", "l", "http", "in", "b", "this", "base", "f", "loc", "data", "remote", "r", "resource", "server", "address", "log", "sl", "ls", "string", "rule", "impl", "file", "uri", "ssl", "or", "URL", "Url", "www", "jar", "location"], "inStream": ["fileStream", "inContent", "workSteam", "inputSteam", "inBuffer", "outReader", "outStreamer", " inStreamer", "contentFrame", "inputstream", "outFrame", "inReader", "InStreamer", " instream", "workStream", "inFrame", "Instream", "outContent", "inputStreamer", "innContent", "contentStream", "inputReader", "inSteam", "workStreamer", "inStreamer", "outstream", "outSteam", "fileSteam", "outBuffer", "contentBuffer", "fileFrame", "instream", " inSteam", "outStream", "inputStream", "contentSteam", " inContent", " inReader", "InStream", "fileBuffer", "innStreamer", "workReader", "InSteam", "innSteam", "innStream"], "out": ["user", "net", "result", "co", "io", "output", " in", "conn", "view", "in", "b", "this", "client", "gen", "data", "OUT", "Out", "response", "outs", "again", "serv", "writer", "exec", "o", "s", "ext", "ex", "temp", "v", "window", "point", "obj", "file", "i", "err", "copy", "pass"]}}
{"id1": "7170603", "id2": "624490", "code1": "    private static void generateSQLUpgradeFile(String milestoneDefFileName, String sqlDirectoryName, String fromMilestone, String destMilestone, String destFileName) throws Exception {\n        File milestoneDefFile = new File(milestoneDefFileName);\n        if (!milestoneDefFile.exists()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : does not exists\");\n        }\n        if (!milestoneDefFile.isFile()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : not a file\");\n        }\n        if (!milestoneDefFile.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : not readable\");\n        }\n        File sqlDirectory = new File(sqlDirectoryName);\n        if (!sqlDirectory.exists()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : does not exists\");\n        }\n        if (!sqlDirectory.isDirectory()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : not a directory\");\n        }\n        if (!sqlDirectory.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : not readable\");\n        }\n        File destFile = new File(destFileName);\n        if (destFile.exists()) {\n            throw new IllegalArgumentException(\"Cannot write to [\" + destFileName + \"] : already exists\");\n        }\n        destFile.createNewFile();\n        SqlUpgradeXmlParser parser = SqlUpgradeXmlParser.newParser();\n        FileInputStream milestoneDefFIS = null;\n        try {\n            milestoneDefFIS = new FileInputStream(milestoneDefFile);\n            parser.parse(milestoneDefFIS);\n        } catch (XMLParseException e) {\n            printXmlError(e, milestoneDefFileName);\n        } finally {\n            try {\n                if (milestoneDefFIS != null) milestoneDefFIS.close();\n            } catch (Exception e) {\n                _logger.warn(\"Exception caught when closing inputstream \", e);\n            }\n        }\n        int fromMilestoneIdx = parser.getMilestoneIndex(fromMilestone);\n        int toMilestoneIdx = parser.getMilestoneIndex(destMilestone);\n        if (fromMilestoneIdx < 0) {\n            throw new IllegalArgumentException(\"Cannot upgrade from milestone [\" + fromMilestone + \"] : does not exist . (Exisiting milestones \" + parser.listMilestones() + \")\");\n        }\n        if (toMilestoneIdx < 0) {\n            throw new IllegalArgumentException(\"Cannot upgrade to milestone [\" + destMilestone + \"] : does not exist . (Exisiting milestones \" + parser.listMilestones() + \")\");\n        }\n        if (fromMilestoneIdx == toMilestoneIdx) {\n            throw new IllegalArgumentException(\"Cannot upgrade to the same milestone\");\n        }\n        List<String> files = parser.getFilesForMilestones(fromMilestoneIdx, toMilestoneIdx);\n        List<String> views = parser.getViewsForMilestones(fromMilestoneIdx, toMilestoneIdx);\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(destFile);\n            for (Iterator<String> it = files.iterator(); it.hasNext(); ) {\n                appendFileToOutputStream(fos, sqlDirectory, it.next());\n            }\n            for (Iterator<String> it = views.iterator(); it.hasNext(); ) {\n                appendFileToOutputStream(fos, sqlDirectory, it.next());\n            }\n        } catch (Exception e) {\n            fos.close();\n            destFile.delete();\n            throw e;\n        } finally {\n            try {\n                if (fos != null) fos.close();\n            } catch (Exception e) {\n                _logger.warn(\"Exception caught when closing outputstream \", e);\n            }\n        }\n        System.out.println(\"An SQL update file has been generated to \" + destFileName + \".\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"milestoneDefFileName": ["milestoneDefFILESource", "milestoneDefSourceFilePart", "milestoneInfFILEPart", "milestoneDeffileName", "milestoneDefFILEUrl", "milestoneDeclFileFile", "milestonedefSourceFileName", "milestonedeffileSource", "milestoneDefinitionFilePath", "milestonedefFileDesc", "milestoneDefLineUrl", "milestoneDefFileFile", "milestoneDefPlaceUrl", "milestoneDefPlacePath", "milestoneDefDirectoryPart", "milestoneDefFilePath", "milestoneDeffileUrl", "milestoneDeclfilePart", "milestoneDefFilename", "milestoneDeffileShare", "milestoneDefDirectoryIn", "milestoneDeclfileName", "milestonedefSourceFileDir", "milestoneDefinitionLineName", "milestoneDefinitionLinePath", "milestonedeffileUrl", "milestoneDefFilePart", "milestoneDeffileSource", "milestonedeffileDesc", "milestoneDefFileShare", "milestoneDefinitionFileSize", "milestoneDefClassFile", "milestoneInfFileString", "milestoneDefSourceFileLine", "milestonedefFilePart", "milestoneDefStreamname", "milestoneDefStreamString", "milestoneDefinitionLineSize", "milestonedefSourceFileUrl", "milestoneDefFILEIn", "milestoneDefSourceFileInfo", "milestoneInfFILEString", "milestoneDefDirectoryLine", "milestoneDefFILEString", "milestoneDefSourceFileIn", "milestoneDefinitionFileUrl", "milestoneDefFILEDesc", "milestoneDefClassname", "milestoneDefLineName", "milestoneDefFileDir", "milestoneDefDirectoryName", "milestoneInfFILEName", "milestoneDefClassName", "milestoneDefFileSource", "milestoneInfFileShare", "milestoneDeffileDir", "milestoneInfFileName", "milestoneDefSourceFileUrl", "milestoneDefSourceFileDir", "milestoneInfFilePart", "milestoneDefSourceFileName", "milestoneDefClassUrl", "milestonedefFileDir", "milestonedefSourceFilePart", "milestoneDefFileInfo", "milestoneDeffileFile", "milestoneDefFileString", "milestoneDefFILEPart", "milestoneDefStreamPart", "milestoneDefStreamName", "milestoneDefFileLine", "milestoneDeclfilename", "milestonedefFileUrl", "milestoneDefDirectoryDir", "milestoneDeclFilename", "milestoneDefinitionLineUrl", "milestoneDefFileUrl", "milestoneDeffileDesc", "milestonedefFileName", "milestoneDefFILELine", "milestonedefFileSource", "milestoneDeclFileName", "milestoneDefFileDesc", "milestoneDefClassPart", "milestoneDeffileString", "milestoneDefFileSize", "milestoneDefClassSize", "milestoneDefPlaceName", "milestoneDefPlaceSize", "milestoneDefDirectoryInfo", "milestoneDefStreamShare", "milestoneDefDirectoryUrl", "milestonedeffileName", "milestoneDeffilePart", "milestoneDefFILEShare", "milestoneDeclFilePart", "milestoneDefDirectorySource", "milestoneDefFILEInfo", "milestoneDeffilename", "milestoneDefFileIn", "milestoneDeclfileFile", "milestoneDefLineSize", "milestoneDefinitionFileName", "milestoneDefLinePath", "milestoneDefStreamFile", "milestoneDefFILEName", "milestoneDefClassPath", "milestoneInfFILEShare", "milestoneDefDirectoryDesc"], "sqlDirectoryName": ["solDirectoryKey", "sqlModuleKey", "sqlDirName", "SQLDirAddress", "databaseDirectoryFile", "sqldirectoryPath", "sqlModulename", "sqlDirectoryKey", "SQLDirPath", "sqlFilePath", "sqlFolderName", "solDirectoryPart", "sqlFileFile", "solDirName", "sqlFolderPath", "SQLDirName", "sqlDirAddress", "sqlLocationName", "sqlDirPart", "sqldirectorySize", "sqlDirectoryAddress", "sqlFileAddress", "sqlDocumentPath", "sqlDirKey", "sqlDocumentName", "sqlFolderUrl", "sqlLocationUrl", "sqlDirectorySize", "SQLFolderKey", "databaseDirectoryPath", "sqldirectoryAddress", "SQLDirectoryKey", "sqlFilePart", "sqlDirectoryPart", "SQLFolderName", "SQLDirectorySize", "solDirectoryPath", "sqlFileKey", "sqlDirPath", "sqlFolderPart", "sqlDirectoryPath", "SQLDirectoryPath", "SQLFolderUrl", "sqlFileSize", "solDirKey", "sqlFileName", "sqlFileUrl", "sqlLocationPath", "solDirectoryName", "sqlLocationKey", "sqlDirectoryname", "sqlDocumentFile", "sqlDirSize", "SQLDirectoryName", "SQLFoldername", "SQLFolderPath", "sqlDirectoryUrl", "SQLDirectoryAddress", "sqlModuleName", "SQLDirSize", "databaseDirectoryName", "SQLDirectoryname", "sqlFoldername", "sqlDirectoryFile", "sqlFolderKey", "solDirPart", "SQLDirectoryUrl", "solDirPath", "sqldirectoryName"], "fromMilestone": ["withMilathon", "withLegaxy", "fromGalathon", "fromMilathon", "fromGalaxy", "withLegestone", "withMilaxy", "fromLegaxy", "fromSilaxy", "withMilework", "withLegathon", "fromSilathon", "fromLegathon", "fromGalestone", "fromLegestone", "withLegework", "fromGalework", "fromLegework", "fromSilework", "withMilestone", "fromSilestone", "fromMilaxy", "fromMilework"], "destMilestone": ["DestMilename", "DestMilestones", "destDigenge", "destDigename", "destMilename", "destMilenge", "destMillenge", "DestMilestone", "destMillestone", "destDigestone", "destDigestones", "destMillestones", "destMilestones", "destMillename", "DestMilenge"], "destFileName": ["destPageLine", "sourceFileLine", "DestDirectoryPath", "deleteFileAlias", "destFileLine", "destSourceFilePath", "destFileOption", "destfilePart", "sourceDirectoryname", "sourceFileName", "DestDirectoryPart", "destStreamName", "DestDirectoryName", "sourceDirectoryLocation", "destPagename", "destFilePath", "DestFilePath", "DestFilePart", "destDirectoryPath", "destDirectoryname", "destFilePart", "deleteFilenameOption", "destFilenameLine", "DestFileName", "destSourceFileSize", "deleteFileOption", "destStreamOption", "destFILEAlias", "destPageName", "destFileSize", "destDirectoryLine", "destStreamAlias", "destFILEName", "destDirectoryPart", "destFilenameAlias", "destFilenamename", "destFilenameOption", "sourceDirectoryName", "DestFileSize", "sourceFilename", "destFilenameLocation", "sourceDirectoryLine", "destFileLocation", "destSourceFilePart", "destFILEOption", "destFileAlias", "sourceFileLocation", "destDirectoryLocation", "destPageLocation", "destDirectoryName", "destDirectorySize", "destSourceFileName", "deleteFileName", "deleteFilenameName", "destFilenameName", "destfilePath", "DestDirectorySize", "destFilename", "destfileSize", "destfileName", "deleteFilenameAlias"], "milestoneDefFile": ["milestoneDefFolder", "milelineDEFfile", "milestoneDefPlace", "milestoneDefinitionFile", "milestoneDefinitionfile", "milestonedeffile", "milestonesDefinitionfile", "milestoneDefinitionFolder", "milestonesDefFile", "milestoneConfLine", "milestoneDiffDirectory", "milestoneDiffStream", "milelineDEFFile", "milestonDefDirectory", "milestoneConfFiles", "milestoneConfSourceFile", "milestoneDEFFiles", "milelineDefSourceFile", "milestonDefFolder", "milestoneConfPlace", "milestonDefFile", "milestoneDefDirectory", "milestonDefinitionfile", "milelineDefFile", "milestoneRefDirectory", "milestonesDefStream", "milwallDefFiles", "milestonedefSourceFile", "milwallDefLine", "milestoneDEFStream", "milestonDefinitionFolder", "milestoneConfigFile", "milestoneDEFSourceFile", "milestoneDefSourceFile", "milestoneDEFfile", "milestonDefinitionFile", "milestoneDiffFolder", "milestoneConfigFiles", "milwallDefinitionFile", "milestoneRefPlace", "milestoneDefStream", "milelineDEFFiles", "milestonesDefinitionFile", "milestonesDeffile", "milestoneConffile", "milestonesConfFile", "milestoneDiffFiles", "milestoneDefFiles", "milestoneConfigDirectory", "milestonedefFiles", "milestoneConfFile", "milestoneDiffFile", "milwallDefinitionfile", "milestoneDefinitionDirectory", "milelineDefFiles", "milestonesDefinitionFiles", "milwallDefinitionLine", "milestoneDEFFile", "milestoneDefLine", "milestoneConfDirectory", "milestoneRefFiles", "milestonesDefinitionStream", "milelineDEFSourceFile", "milestoneDefinitionLine", "milestonedefLine", "milestonesDefFiles", "milestoneRefFile", "milestonesDefDirectory", "milestoneDefinitionStream", "milestonDeffile", "milestonesConfPlace", "milwallDeffile", "milestonesConfDirectory", "milwallDefinitionFiles", "milestonDefinitionDirectory", "milestoneDifffile", "milestonesDefPlace", "milestoneConfigPlace", "milelineDeffile", "milestonedefFile", "milwallDefFile", "milestoneDefinitionFiles", "milestoneDeffile", "milestonesConfFiles"], "sqlDirectory": ["SQLDirector", "dsFolder", "qlDirector", "sqlCollection", "SQLDir", "sqCollection", "sqDirectory", "dbDir", "sqDirector", "dsLibrary", "dbFolder", "dsDirectory", "SQLDirectory", "sslDirectory", "sqlFile", "socialDir", "sqlFolder", "SQLFolder", " sqlFolder", "qlFolder", "sqFolder", " sqlCollection", "SQLLibrary", "qlDir", "sslFolder", "qlDirectory", "dbDirectory", "qlCollection", "qlLibrary", "socialFile", "sqlDirector", "sslLibrary", "socialFolder", "dsCollection", "dbFile", "SQLCollection", "sqlLibrary", "socialDirectory", " sqlLibrary", "sqlDir", "qlFile", "sslDir"], "destFile": ["DestFiles", "DestFile", "srcFolder", "destFiles", "targetPage", " destFilename", " destFiles", "DestPage", "destDirectory", "destfile", "DestFilename", " destfile", "Destfile", "srcDirectory", " destFolder", "transFilename", "targetFiles", "DestDirectory", " destPage", "DestFolder", "destDir", "srcDir", " destDirectory", "targetFile", "transFile", "srcFile", "targetDir", "transDirectory", " destDir", "destPage", "DestDir", "destFilename", "destFolder", "transfile"], "parser": ["lp", "parent", "aws", "reader", "general", "processor", "pe", "xml", "plugin", "pd", "l", "arser", "in", "b", "layer", "loader", "jack", "data", "worker", "auto", "system", "handler", "server", "writer", "er", "php", "per", "json", "instance", "se", "up", "document", "node", "sp", "parse", "builder", "manager", "s", "Parser", "fork", "p"], "milestoneDefFIS": ["milestoneDefBISS", "milestoneDefinitionVIs", "milestonedefLIs", "milestoneDEFLIR", "milestoneDefDISS", "milestoneDefDIS", "milestonedefFIS", "milestoneDEFFIs", "milestoneDefEFIS", "milestoneDefFISS", "milestoneDefHIT", "milestoneDEFLINS", "milestonedefLAS", "milestoneDefVIs", "milestoneDefinitionVIT", "milestoneDefFIT", "milestoneDefEISS", "milestoneDefFis", "milestoneDefLAS", "milestoneDefVIT", "milestoneDefLis", "milestoneDivFIs", "milestoneDefVISS", "milestoneDefPFIS", "milestoneDefBIs", "milestoneDefDAS", "milestoneDefLIR", "milestoneDefLISS", "milestoneDefEFINS", "milestoneDefEFIR", "milestoneDefFIR", "milestoneDefHISS", "milestonedefLISS", "milestoneDefBIR", "milestoneDefPFIs", "milestoneDefEIS", "milestoneDefFAS", "milestoneDeffIS", "milestonedefLIS", "milestoneDeffIs", "milestoneDefEIs", "milestoneDEFLIs", "milestoneDEFFIR", "milestoneDefinitionFIS", "milestoneDefinitionFISS", "milestoneDefinitionFIs", "milestoneDEFFINS", "milestoneDefHIs", "milestoneDefEFIs", "milestonedefFAS", "milestoneDefBINS", "milestoneDefLIS", "milestoneDefBIS", "milestonedefFISS", "milestoneDivfIs", "milestoneDivFIS", "milestoneDefinitionFIT", "milestoneDefPFISS", "milestoneDefHIS", "milestoneDefLIT", "milestoneDefinitionVis", "milestoneDivFis", "milestoneDefEAS", "milestoneDefDIT", "milestoneDefinitionVIS", "milestonedefFIs", "milestoneDivfis", "milestoneDEFFIS", "milestoneDefinitionFis", "milestoneDeffIT", "milestoneDefinitionVISS", "milestoneDeffis", "milestoneDefVIS", "milestoneDefBis", "milestoneDEFLIS", "milestoneDefDIs", "milestoneDivFIT", "milestoneDivfIS", "milestoneDivfIT", "milestoneDefLIs", "milestoneDefVis", "milestoneDefFINS", "milestoneDefLINS", "milestoneDefPFis", "milestoneDefFIs"]}}
{"id1": "3928959", "id2": "19846242", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            out = new FileOutputStream(to);\n            byte[] bytes = new byte[1024 * 4];\n            int len = 0;\n            while ((len = in.read(bytes)) >= 0) out.write(bytes, 0, len);\n        } finally {\n            Streams.closeQuietly(in);\n            Streams.closeQuietly(out);\n        }\n    }\n", "code2": "    public I18N(JApplet applet) {\n        if (prop != null) return;\n        String lang = \"en\";\n        try {\n            Properties userProperties = new Properties();\n            if (applet != null) {\n                URL url = new URL(applet.getCodeBase() + \"logicsim.cfg\");\n                userProperties.load(url.openStream());\n            } else {\n                userProperties.load(new FileInputStream(\"logicsim.cfg\"));\n            }\n            if (userProperties.containsKey(\"language\")) lang = userProperties.getProperty(\"language\");\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        prop = new Properties();\n        try {\n            if (applet != null) {\n                URL url = new URL(applet.getCodeBase() + \"languages/\" + lang + \".txt\");\n                prop.load(url.openStream());\n            } else {\n                prop.load(new FileInputStream(\"languages/\" + lang + \".txt\"));\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            try {\n                if (applet != null) {\n                    URL url = new URL(applet.getCodeBase() + \"languages/en.txt\");\n                    prop.load(url.openStream());\n                } else {\n                    prop.load(new FileInputStream(\"languages/en.txt\"));\n                }\n            } catch (Exception ex2) {\n                JOptionPane.showMessageDialog(null, \"Language file languages/en.txt not found.\\nPlease run the program from its directory.\");\n                System.exit(5);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"from": ["source", "left", "url", "user", "connection", "with", "io", "src", "con", "client", "of", "part", "base", "f", "as", "From", "by", "data", "into", "os", "address", "name", "o", "old", "a", "back", "up", "se", "path", "cache", "c", "file", "or", "ce", "form", "add"], "to": ["source", "url", "token", "office", "top", "tto", "output", "TO", "b", "toc", "To", "f", "base", "po", "by", "os", "eto", "dest", "until", "name", "o", "target", "copy", "temp", "path", "socket", "file", "database", "at", "two", "so", "tom"], "in": ["source", "read", "reader", "id", "url", "input", "inc", "din", "token", "win", "pull", "min", "nin", "con", "b", "this", "diff", "login", "f", "as", "base", "data", "In", "pin", "again", "n", "r", "isin", "inner", "pc", "init", "ins", "gin", "ini", "a", "m", "up", "cin", "image", "lock", "socket", "i", "IN", "err", "inside", "or", "inn", "is", "bin", "s", "pass"], "out": ["source", "size", "url", "user", "inc", "write", "net", "io", "output", "outer", "conn", "nin", "one", "client", "object", "this", "ou", "part", "as", "data", "by", "OUT", "Out", "n", "outs", "again", "no", "os", "server", "writer", "off", "exec", "sync", "name", "o", "aos", "log", "ex", "timeout", "up", "image", "pool", "cache", "obj", "file", "socket", "err", "bin", "copy", "exit", "ext"], "bytes": ["cells", "size", "binary", "ies", "Bytes", "pieces", "lines", "items", "bps", "data", "blocks", "zip", "elt", "objects", "outs", "es", "gets", "vs", "ins", "pages", "length", "values", "lists", "seq", "ls", "buf", "words", "units", "rows", "les", "vals", "its", "limits", "ips", "files", "parts", "bits", "s", "reads"], "len": ["size", "en", "url", "ln", "lf", "iter", "min", "limit", "lim", "l", "pre", "val", "f", "base", "Len", "data", "no", "n", "elt", "el", "nt", "length", "seq", "fl", "lc", "li", "le", "offset", "count", "i", "err", "pos", "led", "start", "lin", "fin", "bin", "line", "ie"]}}
{"id1": "7811549", "id2": "15383485", "code1": "    public AudioInputStream getAudioInputStream(URL url) throws UnsupportedAudioFileException, IOException {\n        if (TDebug.TraceAudioFileReader) {\n            TDebug.out(\"TAudioFileReader.getAudioInputStream(URL): begin\");\n        }\n        long lFileLengthInBytes = AudioSystem.NOT_SPECIFIED;\n        InputStream inputStream = url.openStream();\n        AudioInputStream audioInputStream = null;\n        try {\n            audioInputStream = getAudioInputStream(inputStream, lFileLengthInBytes);\n        } catch (UnsupportedAudioFileException e) {\n            inputStream.close();\n            throw e;\n        } catch (IOException e) {\n            inputStream.close();\n            throw e;\n        }\n        if (TDebug.TraceAudioFileReader) {\n            TDebug.out(\"TAudioFileReader.getAudioInputStream(URL): end\");\n        }\n        return audioInputStream;\n    }\n", "code2": "    protected byte[] getTSAResponse(byte[] requestBytes) throws Exception {\n        URL url = new URL(tsaURL);\n        URLConnection tsaConnection;\n        tsaConnection = (URLConnection) url.openConnection();\n        tsaConnection.setDoInput(true);\n        tsaConnection.setDoOutput(true);\n        tsaConnection.setUseCaches(false);\n        tsaConnection.setRequestProperty(\"Content-Type\", \"application/timestamp-query\");\n        tsaConnection.setRequestProperty(\"Content-Transfer-Encoding\", \"binary\");\n        if ((tsaUsername != null) && !tsaUsername.equals(\"\")) {\n            String userPassword = tsaUsername + \":\" + tsaPassword;\n            tsaConnection.setRequestProperty(\"Authorization\", \"Basic \" + Base64.encodeBytes(userPassword.getBytes()));\n        }\n        OutputStream out = tsaConnection.getOutputStream();\n        out.write(requestBytes);\n        out.close();\n        InputStream inp = tsaConnection.getInputStream();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead = 0;\n        while ((bytesRead = inp.read(buffer, 0, buffer.length)) >= 0) {\n            baos.write(buffer, 0, bytesRead);\n        }\n        byte[] respBytes = baos.toByteArray();\n        String encoding = tsaConnection.getContentEncoding();\n        if (encoding != null && encoding.equalsIgnoreCase(\"base64\")) {\n            respBytes = Base64.decode(new String(respBytes));\n        }\n        return respBytes;\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "user", "buffer", "download", "ll", "l", "http", "lr", "base", "loader", "f", "loc", "channel", "stream", "resource", "server", "address", "config", " URL", "el", "name", "ur", "dir", "location", "string", "path", "image", "file", "uri", "ssl", "URL", "Url", "str", "jar", "sl"], "lFileLengthInBytes": ["lFileSizeINMB", "lFileSizeINBytes", "lFileLenINbytes", "lFileLenINBytes", "lFileLengthinBytes", "lFileSizeInByte", "lFileLengthInByte", "lFileLengthedInByte", "lFileLengthedInBytes", "lFileLengthINBytes", "lFileLenInByte", "lFileLengthINByte", "lFileSizeInbytes", "lFileSizeINbytes", "lFileSizeInMB", "lFileLengthinByte", "lFileSizeInBytes", "lFileLengthInbytes", "lFileLengthinMB", "lFileLenInBytes", "lFileLengthinbytes", "lFileLengthedInMB", "lFileLengthINbytes", "lFileLengthedInbytes", "lFileLenInMB", "lFileLenInbytes", "lFileLenINMB", "lFileSizeINByte", "lFileLengthInMB", "lFileLengthINMB", "lFileLenINByte"], "inputStream": ["outputSteam", "inputPath", "outputStream", "inputSteam", "parentSteam", "audioView", " inputFeed", "audioStreamer", "errorStream", "installStreamer", "audioThread", "InputThread", "errorstream", "inputstream", "parentFeed", "inputFeed", " inputView", "InputStream", "installSteam", " inputSteam", "InputPath", " inputPath", "inputStreamer", "audioSteam", "installStream", "parentStream", "InputView", "inputView", "outputstream", "initSteam", "errorStreamer", "errorSteam", "audioStream", "audioFeed", " inputStreamer", "Inputstream", "parentStreamer", "InputStreamer", "installstream", "audioPath", "audiostream", "InputSteam", "initStream", "outputStreamer", "initstream", " inputThread", "initStreamer", "inputThread"], "audioInputStream": ["videoOutputStreamer", "videoAudioPath", "audioOutputPath", " audioInputSteam", "audioInputPath", " audioInputThread", "videoAudioStream", "audioAudioFile", "audioByteStreamer", "audioInputThread", "audioAudioSteam", "audioAudioPath", "audioOutputStreamer", "videoAudioThread", "videoInputFile", "audioAudioStream", "audioUploadThread", "audioAudioThread", "videoOutputStream", "audioUploadPath", " audioAudioFile", "videoInputStreamer", "audioOutputSteam", "videoOutputFile", "videoInputStream", "audioUploadStream", " audioAudioStream", "videoInputPath", "audioByteStream", "audioOutputFile", "audioInputSteam", "videoInputSteam", "audioAudioStreamer", " audioAudioSteam", "videoInputThread", "audioOutputThread", "audioInputFile", "audioByteSteam", "audioInputStreamer", "audioUploadFile", " audioAudioThread", "audioOutputStream", "videoAudioSteam", "audioByteFile", "videoOutputSteam", " audioInputFile", "audioUploadSteam"]}}
{"id1": "10450245", "id2": "3765287", "code1": "    public Map<String, String> getMetadata(WebFileObject fo) throws IOException {\n        if (!fo.wfs.getRootURL().getProtocol().equals(\"ftp\")) {\n            String realName = fo.pathname;\n            boolean exists;\n            URL ur = new URL(fo.wfs.getRootURL(), realName);\n            HttpURLConnection connect = (HttpURLConnection) ur.openConnection();\n            connect.setRequestMethod(\"HEAD\");\n            HttpURLConnection.setFollowRedirects(false);\n            connect.connect();\n            HttpURLConnection.setFollowRedirects(true);\n            if (connect.getResponseCode() == 303) {\n                String surl = connect.getHeaderField(\"Location\");\n                if (surl.startsWith(fo.wfs.root.toString())) {\n                    realName = surl.substring(fo.wfs.root.toString().length());\n                }\n                connect.disconnect();\n                ur = new URL(fo.wfs.getRootURL(), realName);\n                connect = (HttpURLConnection) ur.openConnection();\n                connect.setRequestMethod(\"HEAD\");\n                connect.connect();\n            }\n            exists = connect.getResponseCode() != 404;\n            Map<String, String> result = new HashMap<String, String>();\n            Map<String, List<String>> fields = connect.getHeaderFields();\n            for (Entry<String, List<String>> e : fields.entrySet()) {\n                String key = e.getKey();\n                List<String> value = e.getValue();\n                result.put(key, value.get(0));\n            }\n            result.put(META_EXIST, String.valueOf(exists));\n            connect.disconnect();\n            return result;\n        } else {\n            Map<String, String> result = new HashMap<String, String>();\n            URL url = new URL(fo.wfs.getRootURL(), fo.pathname);\n            URLConnection urlc = url.openConnection();\n            try {\n                urlc.connect();\n                urlc.getInputStream().close();\n                result.put(META_EXIST, \"true\");\n            } catch (IOException ex) {\n                result.put(META_EXIST, \"false\");\n            }\n            return result;\n        }\n    }\n", "code2": "    private void initializeSecretKey() {\n        String baseKey = \"\" + SystemClock.currentThreadTimeMillis() + new Random().nextInt();\n        MessageDigest digest;\n        String secretKey;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(baseKey.getBytes());\n            byte messageDigest[] = digest.digest();\n            int len = messageDigest.length;\n            StringBuilder sb = new StringBuilder(len << 1);\n            for (int i = 0; i < len; i++) {\n                sb.append(Character.forDigit((messageDigest[i] & 0xf0) >> 4, 16));\n                sb.append(Character.forDigit(messageDigest[i] & 0x0f, 16));\n            }\n            secretKey = sb.substring(0, 32);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        this.setSecretKey(secretKey);\n    }\n", "label": 0, "substitutes": {"fo": ["af", "su", "rf", "ao", "txt", "la", "xml", "prof", "za", "cf", "so", "tto", "ws", "io", "ma", "aco", "olo", "fs", "tw", "ico", " info", "fp", "inf", "sf", "jo", "FO", "ho", "umo", "tra", "f", "tf", "po", "data", "mo", "fe", "fw", "wh", "os", "hello", "auto", "oo", "bo", "abo", "tu", "info", "hea", "vo", "off", "yahoo", " Fo", "lo", "zo", "tp", " FO", "o", "ph", "fn", "shi", "F", "ko", "uf", "no", "ft", "co", "obj", "flo", "ato", "fi", "fa", "wo", "wt"], "realName": ["shortName", "specialNames", "shortResource", "fullFile", "complexName", "complexURL", " realNAME", "RealFile", "realResource", "realNames", "Realname", " realname", "realMessage", "releasename", "RealResource", "realAddress", " realMessage", "reMessage", "realURL", " realNames", "releaseMessage", " realFile", "RealAddress", "specialURL", "rename", "complexNames", "releaseName", "specialname", "realname", "fullAddress", "shortname", "reName", "fullName", "releaseNAME", " realResource", "specialName", "RealName", "realNAME", "complexname", " realURL", "realFile", "fullname", "reNAME", " realAddress"], "exists": ["Existant", "existant", "nexistant", "xists", "expist", " existence", "Expects", "nexists", "exits", "nexits", "Exits", "exist", " exist", "Exists", "existence", "suist", "exests", "Exests", "expects", "expils", "Exist", " expects", "xist", "expits", "nexests", "Existence", "xpects", "Exils", " expistant", "exils", " expests", " expits", "xistence", "suits", "expists", "suils", " expists", "suists"], "ur": ["ure", "attr", "su", "ru", "gr", "util", "UR", "br", "urt", "conn", "ul", "uu", "urs", "ou", "fr", "loc", " cur", "eur", "tur", "sur", "ud", "r", "aur", "org", "air", "ocr", "ub", "ir", "cur", "bor", "ui", "u", "rc", "au", "uj", "enter", "ch", "dr", "Ur", "adr", "tr", "up", "il", "rl", "ut", "utils", "uri", "rt", "uv", "ract", "ol", "raf", "rr", "ar", " su"], "connect": ["contract", "input", "sign", "control", "con", "connected", " disconnect", "r", "contact", "call", "info", "stop", "sync", "cont", "log", "Connect", "syn", "timeout", "release", "quit", "ssl", "support", "construct", "create", "exit", "read", "feed", "build", "destruct", "conn", "join", "object", "find", "remote", "update", "ssh", "event", "patch", "act", "collect", "index", "load", "c", "fail", "nat", "start", "add", "get", "respond", "en", "open", "util", "complete", "core", "http", "request", "client", "login", "sc", "exec", "send", "access", "shut", "text", "ch", "close", "run", "don", "j", "reg", "struct", "reset", "process", "ct", "use", "select", "connection", "uc", "pull", "download", "success", "bind", "output", "out", "config", "condition", "init", "graph", "socket", "un", "follow", "accept", "on", "put"], "surl": ["nsurl", "suri", "sesstring", "nsuri", "nstring", " sstring", "sesuri", "setsuri", "nuri", "setsurl", "srule", "buri", "lstring", "nslocation", "slocation", " sloc", " slocation", "setsrule", "sloc", " srule", "setsstring", "lloc", "sesrule", "sesurl", "bstring", "burl", "nurl", "lurl", "bloc", " suri", "luri", "nloc", "sstring", "nsloc"], "result": ["source", "resources", "page", "attr", "continue", "compl", "test", "default", "user", "success", "buffer", "Result", "dict", "complete", "function", "product", "message", "output", "params", "fr", "part", "table", "summary", "data", "include", "response", "master", "sum", "ret", "match", "repl", "changes", "resource", "section", "results", "report", "json", "instance", "found", "comment", "df", "list", "cache", "record", "err", "search", "map", "details", "manager", "date", "array", "current", "total", "order", "follow", "group", "detail", "res", "filter", "coll", "use"], "fields": ["comments", "ums", "relations", "cells", "strings", "events", "errors", "lines", "keys", "fs", "properties", "items", "types", "f", "data", "objects", "posts", "forms", "groups", "plugins", "results", "pages", "members", "lists", "values", "names", "rules", "rows", "headers", "features", "details", "files", "ids", "tags", "services", "field", "dates", "s"], "e": ["ea", "h", "en", "pe", "d", "be", "edge", "ee", "l", "ev", "end", "ue", "E", "fe", "ec", "r", "es", "esi", "element", "er", "ge", "ne", "de", "ae", "ve", "oe", "enter", "je", "se", "le", "ze", "g", "ele", "eu", "ce", "me", "te", "entry", "p", "ie"], "key": ["source", "id", "link", "keys", "k", "ry", "object", "val", "op", "by", "data", "Key", "version", "match", "prefix", "pair", "ie", "feature", "server", "KEY", "element", "section", "name", "query", "ge", "text", "v", "index", "string", "change", "list", "code", "search", "property", "service", "secret", "item", "type", "field", "option", "ip", "entry"], "value": ["default", "alt", "range", "function", "message", "one", "object", "val", "description", "ue", "part", "data", "VALUE", "response", "pair", "feature", "info", "element", "section", "name", "ge", "member", "flow", "ve", "values", "sv", "area", "v", "all", "string", "media", "image", "list", "Value", "vi", "video", "field", "collection", "entry", "va", "type"], "url": ["host", "feed", "connection", "download", "pull", "ll", "conn", "l", "http", "control", "client", "b", "f", "base", "loc", "stream", "r", "resource", "server", "config", "tool", "cur", "gl", "cl", "t", "bel", "sl", "ch", "fl", "ls", "orb", "c", "ssl", "uri", "g", "URL", "service", "Url", "www", "web", "p"], "urlc": [" urlfc", "URLcon", "urln", "libcon", "urlcon", " urldc", "urldc", "URLf", "Urlh", "URLp", " urlh", "belfc", "llf", "llp", "urlenc", " urlenc", "belc", "URLdc", " urlcache", "slc", "sln", "URLc", " urln", "urlp", "urlfc", "slenc", "urlh", "libc", "urlcache", "llcon", "URLh", "slfc", "Urlc", "URLcache", "beln", "libp", "belenc", "Urlcache", "urlf", "libf", "Urldc", "llc"]}}
{"id1": "15034107", "id2": "7993946", "code1": "    private static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public void unsplit(String newFilename, File[] files) throws Exception {\n        FileOutputStream stream = new FileOutputStream(new File(newFilename));\n        for (int i = 0; i < files.length; i++) {\n            FileInputStream fin = new FileInputStream(files[i].getAbsolutePath());\n            DataInputStream din = new DataInputStream(fin);\n            while (din.available() > 0) {\n                stream.write(din.read());\n            }\n            din.close();\n            fin.close();\n        }\n        stream.close();\n    }\n", "label": 1, "substitutes": {"in": ["source", "reader", "id", "url", "input", "inc", "connection", "buffer", "min", "io", "b", "diff", "part", "login", "base", "data", "In", "again", "work", "config", "inner", "name", "ins", "ini", "a", "m", "ex", "image", "c", "file", "i", "IN", "or", "inn", "at", "bin", "copy", "ac"], "out": ["source", "user", "connection", "io", "output", "conn", "w", "object", "b", "client", "part", "base", "data", "n", "Out", "OUT", "outs", "server", "call", "external", "writer", "dest", "exec", "x", "name", "o", "target", "ex", "v", "up", "string", "point", "image", "cache", "c", "file", "at", "copy", "p"], "sourceChannel": ["sourceConnection", " sourceStream", "targetStream", "SourceSocket", " sourceChan", "sourceChan", " sourceMessage", "sourceContext", "SourceCh", "Sourcechannel", "sourceSocket", " sourceConnection", "ourceCh", "SourceStream", " sourceSocket", " sourceCh", "ourceContext", "inputChannel", " sourceContext", "targetChan", "targetConnection", "targetchannel", "inputchannel", "ourceChannel", "SourceConnection", "inputChan", "SourceContext", "SourceMessage", "SourceChan", "ourceSocket", "sourceCh", "sourceMessage", "sourcechannel", "inputMessage", "sourceStream", "SourceChannel", " sourcechannel", "targetChannel"], "destinationChannel": ["destinatorChannel", "destructionChannel", "destationConnection", "destationChannel", "destinationchannel", "destinationConnection", " destinationChan", "destinatingStream", "destinationsChannel", "DestinatorChan", "destructionChan", " destributionChannel", "destinatorStream", "destributionConnection", "destinationStream", "destructionchannel", "DestinationChan", "DestinatorChannel", " destributionchannel", "destinateStream", " destinationchannel", "destributionchannel", "destinatorchannel", "destinateChannel", " destinationConnection", "destationStream", "DestinationChannel", "destinatorChan", "Destinationchannel", "destinationsChan", "DestinationStream", "DestinationConnection", "destinationschannel", "destinateConnection", "DestinatorStream", "destributionChan", "destinateChan", "destinatorConnection", "destributionChannel", "destructionStream", "destinatingChan", " destributionConnection", "destationChan", " destributionChan", "DestinatorConnection", "destinatingchannel", "destinatingChannel", "destinationsConnection", "destinationChan", "Destinatorchannel"]}}
{"id1": "12577306", "id2": "12798566", "code1": "    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String url = \"http://jdkcn.com/checkUpdateNew.jsp?ver=\" + blogFacade.getDatabaseSiteConfig().getAppVersion();\n        response.setCharacterEncoding(\"UTF-8\");\n        URLConnection connection = new URL(url).openConnection();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        StringBuilder sb = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            sb.append(line).append(\"\\r\\n\");\n            line = reader.readLine();\n        }\n        response.getWriter().println(sb.toString());\n        return null;\n    }\n", "code2": "    private static void process(String urlstring) {\n        try {\n            URL url = new URL(urlstring);\n            System.out.println(\"Connecting to \" + url);\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            for (String line; (line = in.readLine()) != null; ) if (line.startsWith(MARKER)) {\n                System.out.println(TAG.matcher(line).replaceAll(\"\"));\n            }\n            in.close();\n        } catch (IOException ioe) {\n            System.err.println(\"\" + ioe);\n        }\n    }\n", "label": 0, "substitutes": {"request": ["page", "user", "req", "xml", "reply", "result", "message", "view", "client", "object", "model", "application", "version", "resource", "server", "config", "writer", "Request", "name", "method", "report", "json", "instance", "session", "string", "document", "service"], "response": ["next", "page", "parent", "respond", "site", "write", "feed", "reference", "buffer", "reply", "result", "message", "output", "view", "out", "object", "client", "model", "application", "onse", "stream", "resource", "server", "esi", "writer", "method", "full", "report", "json", "api", "wave", "status", "session", "Response", "index", "document", "respons", "image", "html", "file", "error", "resp", "service", "position", "res"], "url": ["language", "host", "page", "source", "feed", "download", "plugin", "l", "http", "base", "f", "channel", "data", "version", "r", "resource", "server", "config", "address", " URL", "name", "ls", "job", "string", "path", "secure", "file", "context", "callback", "error", "ssl", "uri", "URL", "Url", "www", "account", "proxy", "str", "location"], "connection": ["open", "director", "io", "conn", "communication", "http", "con", "control", "client", "driver", "connected", "normal", "channel", "application", "directory", "stream", "resource", "handler", "server", "config", "writer", "creator", "bec", "relation", "session", "string", "connect", "socket", "uri", "file", "context", "builder", "service", "character", "database", "Connection", "ctor"], "reader": ["read", "input", "rar", "rx", "Reader", "linger", "buffer", "feed", "iter", "result", "ser", "ro", "io", "keeper", "ler", "driver", "in", "row", "f", "loader", "worker", "stream", "re", "r", "handler", "server", "editor", "writer", "inner", "er", "rer", "reading", "report", "per", "parser", "ri", "slice", "readable", "i", "builder", "rr", "ner"], "sb": ["sa", "cb", "binary", "si", "bh", "bf", "mb", "buffer", "sth", "lines", "ss", "sg", "sm", "pb", "bg", "src", "b", "sf", "bc", "lr", "kb", "bm", "bd", "storage", "bs", "obb", "sc", "ub", "bj", "bb", "SB", "api", "sr", "sv", "zb", "ls", "gb", "xb", "eb", "sk", "sp", "bsp", "ab", "db", "bt", "wb", "fb", "sq", "lab", "nb", "lb", "s", "rb", "bp"], "line": ["page", "none", "link", "user", "pe", "feed", "lf", "buffer", "range", "lines", "iter", "message", "l", "letter", "hide", "one", "stroke", "definition", "end", "LINE", "cell", "Line", "row", "base", "part", "data", "no", "inline", "style", "r", "auto", "strip", "lo", "sync", "word", "liner", "unit", "log", "cl", "non", "text", "lc", "job", "le", "key", "string", "frame", "rule", "parse", "error", "err", "block", "lin", "look", "str", "sl", "entry"]}}
{"id1": "12289756", "id2": "15078689", "code1": "    public String loadURL(URL url) {\n        String retVal = \"\";\n        try {\n            InputStream inputStream = url.openStream();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            String line = bufferedReader.readLine();\n            retVal += line + \"\\n\";\n            while (line != null) {\n                System.out.println(line);\n                line = bufferedReader.readLine();\n                if (line != null) retVal += line + \"\\n\";\n            }\n            bufferedReader.close();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        } catch (IOException e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        } catch (Exception e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        }\n        return retVal;\n    }\n", "code2": "    protected void fetchDicomSopInstance(File result) throws Exception {\n        try {\n            URL url = new URL(this.config.getUrl(\"wadoserver.url\").toString() + \"?requestType=WADO&contentType=text/xml\" + \"&studyUID=\" + publicationProperties.getProperty(\"studyUID\") + \"&seriesUID=\" + publicationProperties.getProperty(\"seriesUID\") + \"&objectUID=\" + publicationProperties.getProperty(\"objectUID\"));\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            OutputStream ostream;\n            InputStream istream;\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"accept\", \"text/xml\");\n            connection.connect();\n            if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                throw new Exception(\"Error fetching DICOM SOP instance (\" + connection.getResponseCode() + \" \" + connection.getResponseMessage() + \")\");\n            }\n            ostream = new BufferedOutputStream(new FileOutputStream(result));\n            try {\n                istream = connection.getInputStream();\n                Utilities.copyStream(istream, ostream);\n            } finally {\n                ostream.close();\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Error fetching DICOM SOP instance.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "user", "connection", "buffer", "xml", "l", "http", "object", "request", "b", "lr", "base", "loader", "f", "r", "resource", "server", "address", "el", "ur", "e", "sl", "job", "string", "path", "image", "rule", "file", "uri", "ssl", "err", "URL", "service", "Url", "www", "proxy", "str", "location"], "inputStream": ["outputStream", "inBuffer", " inputstream", "InputBuffer", "inputstream", "InputStream", "accessStream", "accessStreamer", "inWriter", "inputStreamer", "inputReader", " inputWriter", "outputstream", "outputReader", "Inputstream", "inStream", "InputStreamer", " inputBuffer", "instream", "inputWriter", "InputWriter", "accessstream", "inputBuffer", "InputReader", "accessReader", "outputStreamer"], "bufferedReader": ["bufflatedLine", "buffinedLine", "bufferredWriter", "buffaredStream", "BufferedRunner", "bufferingRunner", "bufferedRunner", "buffaredreader", "BuffedWriter", "muteredWriter", "mutmentedreader", "buffiedWriter", "buffiedreader", "bufferedWriter", "buffedWriter", "muteredReader", "buffmentedreader", "buffedLine", "buffiedReader", "BufferedReader", "BuffledWriter", "buffaredWriter", "buffiedLine", "bufferedStream", "buffinedWriter", "bufferedLine", "mutmentedReader", "muteredStream", "BuffedRunner", "mutmentedStream", "bufferedreader", "mutmentedWriter", "bufferingReader", "BufferedWriter", "BufferedLine", "bufflatedReader", "bufferingWriter", "bufflatedWriter", "buffledStream", " bufferingStream", " bufferingWriter", " bufferedLine", "buffmentedStream", "buffaredReader", "buffedReader", "buffedStream", " bufferedStream", "BuffedReader", "buffmentedReader", "bufflatedreader", "BuffedStream", "bufferredReader", "muteredreader", "buffledreader", "bufferingStream", "buffledWriter", "BuffledReader", " bufferingReader", "Bufferedreader", "buffmentedWriter", "buffedRunner", "BuffledLine", "buffinedStream", "Buffledreader", "bufferredRunner", "bufferingLine", "bufferredStream", "buffledReader", "buffledLine", "buffinedReader", "BufferedStream", " bufferingLine", " bufferedWriter"], "line": ["lines", "l", "definition", "val", "Line", "model", "number", "style", "zip", "email", "strip", "sync", "cl", "log", "sl", "le", "file", "err", "ip", "pass", "continue", "lf", "one", "object", "cell", "row", "inline", "liner", "job", "lin", "str", "page", "none", "link", "write", "pe", "user", "LINE", "column", "base", "no", "raw", "el", "section", "element", "word", "e", "text", "comment", "string", "error", "i", " Line", "entry", "next", "message", "letter", "out", "char", "layer", "data", "response", "non", "content", "lc", "frame", "code", "character", "block", "item", "shell", "unit"], "retVal": ["ftEl", "rtValue", "RetVAL", "replyValue", "altval", "returnValue", "retValid", "replyBu", "returnval", "RETBu", "RETArg", "replyval", "retVAL", "ftVal", "rtBu", "rtValid", "refBu", "refVAL", "replyVal", "RetValue", "altValue", "refVal", "rtVal", "altVal", "retEl", " retval", "RetValid", "retval", "returnVal", " retValue", "retBu", "RetBu", "rtArg", "altBu", "RETVal", " retBu", "retValue", "rtval", "rtEl", "ftValid", "Retval", "replyValid", "rtVAL", "RetVal", "refValue", "retArg", "returnBu", " retArg", " retEl", " retValid", "ftval"]}}
{"id1": "15464715", "id2": "2885691", "code1": "    private String sendQuery(String query) {\n        File xmlServerResponse = null;\n        String serverResponse = \"\";\n        try {\n            long start = Calendar.getInstance().getTimeInMillis();\n            System.out.println(\"\\n\\n++++++++++++++++++++++++++++++++++++++++++++++++++++\");\n            System.out.println(\"    consulta de busqueda -> \" + query);\n            URL url = new URL(query);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            while ((line = in.readLine()) != null) {\n                serverResponse += line;\n            }\n            long ahora = (Calendar.getInstance().getTimeInMillis() - start);\n            System.out.println(\" Tiempo transcurrido en la consulta (en milesimas) -> \" + ahora);\n            System.out.println(\"++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return serverResponse;\n    }\n", "code2": "    public static boolean sendInformation(String reportType, HashMap<String, String> data) {\n        if (Activator.getDefault().getPreferenceStore().getBoolean(PreferenceConstants.P_UDC)) {\n            logger.debug(\"Report usage information to devs...\");\n            String transferData = \"reportType=\" + reportType;\n            transferData += \"&build=\" + Platform.getBundle(\"de.uni_mannheim.swt.codeconjurer\").getHeaders().get(\"Bundle-Version\");\n            transferData += \"&Suppl-Server=\" + Activator.getDefault().getPreferenceStore().getString(PreferenceConstants.P_SERVER);\n            for (String key : data.keySet()) {\n                transferData += \"&Suppl-\" + key + \"=\" + data.get(key);\n            }\n            try {\n                URL url = new URL(\"http://www.merobase.com:7777/org.code_conjurer.udc/UsageReport\");\n                URLConnection conn = url.openConnection();\n                conn.setDoOutput(true);\n                OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n                writer.write(transferData);\n                writer.flush();\n                StringBuffer answer = new StringBuffer();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    answer.append(line + \"\\r\\n\");\n                }\n                writer.close();\n                reader.close();\n                logger.debug(\"UDC Server answer: \" + answer.toString());\n            } catch (Exception e) {\n                CrashReporter.reportException(e);\n                logger.debug(\"Could not report usage data: \" + e.toString());\n                return false;\n            }\n            return true;\n        } else {\n            logger.debug(\"Reporting not wished!\");\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"query": ["source", "select", "sql", "term", "xml", "reply", "range", "result", "message", "format", "request", "description", "data", "resource", "info", "qs", "module", "script", "name", "body", "qu", "report", "json", "password", "text", "comment", "content", "timeout", "time", "string", "answer", "uri", "error", "expression", "command", "Query", "search", "code", "parse", "q", "database", "question", "str", "filter", "series", "type"], "xmlServerResponse": ["xmlServerResult", "xmlServerResp", " xmlServerresponse", "xmlserverResp", " xmlServerResult", " xmlServerResp", "xmlserverResult", "xmlserverresponse", "xmlServerresponse", "xmlserverResponse"], "start": ["next", "get", "Start", "size", "id", "first", "last", "len", "range", "min", "now", "grade", "from", "end", "diff", "st", "part", "base", "set", "stop", "info", "ime", "started", "init", "ize", "step", "enter", "max", "offset", "run", "time", "art", "count", "load", "parse", "since", "check", "ish", "date", "starting", "create", "entry"], "url": ["source", "page", "reader", "input", "link", "user", "connection", "open", "buffer", "feed", "build", "io", "conn", "l", "http", "out", "b", "client", "f", "base", "channel", "stream", "zip", "resource", "org", "server", "log", "bel", "string", "image", "socket", "uri", "file", "ssl", "URL", "hub", "Url", "web", "sl"], "in": ["source", "read", "reader", "h", "id", "input", "inc", "din", "token", "io", "nin", "l", "out", "b", "client", "login", "f", "as", "data", "In", "stream", "again", "r", "server", "inner", "er", "body", "ins", "e", "container", "ini", "kin", "image", "c", "file", "socket", "i", "IN", "ssl", "inn", "ilo", "bin", "s"], "line": ["source", "page", "id", "link", "user", "write", "connection", "lf", "range", "lines", "message", "l", "letter", "definition", "char", "end", "LINE", "cell", "Line", "row", "f", "base", "data", "inline", "response", "r", "server", "word", "sync", "name", "ge", "unit", "log", "cl", "text", "comment", "lc", "key", "le", "string", "frame", "point", "pass", "file", "error", "code", "i", "header", "block", "character", "lin", "str", "ip", "sl", "entry"], "serverResponse": [" serverResp", "systemResp", "erverResponse", " serverRequest", "erverLine", "ServerResp", " serverresponse", "systemLine", "serverReply", "erverResp", " serverReply", "systemResponse", "erverReply", "ServerRequest", "systemReply", "serverLine", " serverLine", "serverResp", "serverRequest", "serverresponse", "erverresponse", "Serverresponse", "ServerResponse", "erverRequest"], "ahora": ["ohora", "ahacia", "jahoras", "amora", "yahoras", "jahora", "amta", "lahora", "yahora", "lahoras", " ahacia", "ohta", "ahta", "ahoras", "ohoras", "lahila", "yahila", "ahoria", "ahila", "jahoria", "jahila", "ohacia", "amacia", "yahoria", "amoras", "lahoria", " ahta", " ahoras"]}}
{"id1": "15634393", "id2": "6102140", "code1": "    public boolean copyStoredTileTo(File targetFileName, int x, int y, int zoom, MapSource tileSource) throws IOException {\n        File sourceFile = getTileFile(x, y, zoom, tileSource);\n        if (!sourceFile.exists()) return false;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        long sourceBytes = 0;\n        long writtenBytes = 0;\n        try {\n            fis = new FileInputStream(sourceFile);\n            fos = new FileOutputStream(targetFileName);\n            FileChannel source = fis.getChannel();\n            FileChannel destination = fos.getChannel();\n            sourceBytes = source.size();\n            writtenBytes = destination.transferFrom(source, 0, sourceBytes);\n        } finally {\n            Utilities.closeStream(fis);\n            Utilities.closeStream(fos);\n        }\n        if (writtenBytes != sourceBytes) throw new IOException(\"Target file's size is not equal to the source file's size!\");\n        return true;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"targetFileName": [" targetfilePath", " targetfileNAME", "TargetfilePath", "targetTablePath", "TargetfileUrl", "TargetFilePath", "targetfilePath", "TargetfileName", "targetfileUrl", "targetfileAddress", "targetFilenameNAME", "targetTableName", "targetFileAddress", "TargetFileName", " targetfileName", "targetFileUrl", "targetRoutePath", " targetfileAddress", "targetRouteName", " targetFilePath", "targetFilenameAddress", "targetLogAddress", "targetFilenamePath", "targetTableUrl", "targetFilenameName", " targetFileNAME", "targetFileNAME", "TargetFileUrl", "targetLogPath", "targetfileNAME", "targetfileName", " targetFileAddress", "targetRouteUrl", "targetLogName", "targetFilePath", "targetLogNAME"], "x": ["px", "host", "en", "d", "rx", "l", "w", "in", "b", "xy", "f", "X", "tx", "name", "xs", "ix", "a", "ex", "xi", "v", "time", "col", "index", "image", "c", "dx", "i", "width", "pos", "z", "on", "p", "lat"], "y": ["Y", "h", "py", "d", "cy", "yt", "ry", "l", "yi", "w", "b", "zy", "xy", "yy", "ny", "f", "o", "yd", "ch", "m", "yl", "ey", "time", "col", "dy", "c", "i", "ye", "type", "vy", "sy", "oy", "z", "ya", "ip", "p", "ie"], "zoom": ["tzom", "zhooming", "gzoom", " zdepth", "tzooming", "gzow", "zow", "zooming", "zhom", " zooming", "tzoom", "gzom", "zom", "gzdepth", "gzooming", "zhoom", "zdepth", "tzow", "tzdepth", "zhow"], "tileSource": ["TileSource", "TileService", "themeSourceFile", "multiSources", "tileSources", "themeSOURCE", "tileFile", "tileSourceFile", "mapFile", "mapSource", "mapService", " tileService", " tileSourceFile", "mapSources", " tileSources", "TileFile", "tileSOURCE", "multiSOURCE", "themeSources", " tileSOURCE", " tileFile", "tileService", "TileSources", "themeSource", "multiSource", "multiSourceFile"], "sourceFile": ["sourceDir", "ourceDirectory", "parentFile", "parentPlace", "srcF", "srcfile", "parentFiles", "ourcefile", " sourceFiles", "ourceFile", " sourcePath", "targetPlace", "sourceF", " sourceDirectory", "sourcefile", "switchF", "sourcePlace", "targetFiles", "parentfile", "targetfile", "switchPath", "sourceFiles", "sourcePath", " sourcePlace", " sourceF", "targetFile", "srcFile", " sourcefile", "targetDirectory", "targetDir", " sourceDir", "switchFile", "sourceDirectory", "switchfile", "ourceDir", "srcPath"], "fis": ["sfos", "Fics", " fs", "tos", "fs", "Fos", "Fiss", "FIS", "fiss", "fIS", "sfs", "infics", "fsos", " fists", "fsisa", "infos", "fios", "fists", "sfis", "fsis", "infisa", " fios", "fics", "infists", "infiss", "Fis", "tis", "infIS", "Fs", " fas", "infis", " fIS", "Fisa", "sfios", "fsics", "Fios", "infas", "fisa", "tists", "tas", " fiss", "fas"], "fos": ["sfos", " fot", "infoss", " fo", " foes", "flaos", "feios", "flos", "foss", "sfot", "fo", " fOS", "sfaos", "Fos", "Foss", "fols", "feOS", "Fot", "infos", "Fo", "fios", "feos", "dosi", "dos", " fios", "info", "dis", "sfols", " fosi", "feot", "fot", "poes", "infols", "FOS", "Fis", "fosi", "pis", "fOS", "infis", "faos", "Fios", "pos", "infaos", "posi", "flols", " foss", "foes", "flot", "infot", "does"], "sourceBytes": ["siteBytes", " sourceSize", "targetPages", " sourcePages", "SourceSize", "SourceByte", "sourceSize", "sourceByte", "ourceByte", "sourceCharacters", "writtenSize", "ourcebytes", " sourcebytes", "targetBytes", "SourceBytes", "ourceSize", "sourcebytes", "ourceBytes", " sourceByte", "targetSize", "Sourcebytes", "ourcePages", " sourceCharacters", "targetCharacters", "sourcePages", "sitebytes", "siteCharacters", "writtenbytes", "targetbytes"], "writtenBytes": ["writeBytes", " writtenByte", " writtenCount", " writtenCode", "writtenByte", "rittenCode", "writerBytes", "rittenCount", " writtenZip", "rittenBytes", "wroteBytes", "writtenBlocks", "writtenPages", "rittenPages", "wroteZip", "writtenCode", "writerPages", "rittenZip", "rittenByte", "rittenBlocks", "writtenbytes", "sourcebytes", " writtenbytes", "writtenZip", "sourceBlocks", "wrotebytes", "rittenbytes", "writerBlocks", "writerbytes", "writeCode", "sourcePages", "writeByte", "writtenCount", "writebytes", "wroteCount"], "source": ["plus", "parent", "route", "size", "reader", "site", "id", "input", "si", "connection", "reference", "core", "result", "origin", "output", "src", "from", "original", "out", "in", "client", "Source", "this", "channel", "base", "data", "stream", "storage", "single", "remote", "resource", "slave", "master", "config", "info", "ources", "dest", "Target", "ui", "scope", "target", "unit", "ource", " sources", "temp", "status", "sin", "SOURCE", "slice", "string", "index", "secure", "file", "uri", "search", "service", "current", "type", "scene", "local", "start", "proxy", "use", "ie"], "destination": ["descinations", " destinator", " destinations", "Destining", "continion", " destining", "contininator", "continining", "describution", " destion", "Destion", "Destinator", "continination", "destinations", " destation", "Destinations", " destribution", "Destation", "destion", "destribution", "destinator", "descation", "descination", "destation", "destining", "Destination", "Destribution"]}}
{"id1": "16422406", "id2": "18741904", "code1": "    private URLConnection getServletConnection(String strServlet_name) throws MalformedURLException, IOException {\n        URL urlServlet = null;\n        if (strServlet_name == null) {\n            urlServlet = m_Url;\n        } else {\n            urlServlet = new URL(m_Url, strServlet_name);\n        }\n        URLConnection connection = urlServlet.openConnection();\n        connection.setConnectTimeout(180000);\n        connection.setDoInput(true);\n        connection.setDoOutput(true);\n        connection.setUseCaches(false);\n        connection.setRequestProperty(\"Content-Type\", \"application/x-java-serialized-object\");\n        if (m_strJsessionid != null) {\n            connection.setRequestProperty(\"Cookie\", m_strJsessionid);\n        }\n        return connection;\n    }\n", "code2": "    protected void cboTemplateIndexSelectionChanged() {\n        int idx = WizardPage1.this.cboTemplateIndex.getSelectionIndex();\n        IPreferenceStore store = Activator.getDefault().getPreferenceStore();\n        String prefnamePrefix = PreferenceConstants.TEMPLATE_PREFIX + idx;\n        String baseUrl = store.getString(prefnamePrefix + PreferenceConstants.BASEURL_POSTFIX);\n        String descfile = store.getString(prefnamePrefix + PreferenceConstants.DESCFILE_POSTFIX);\n        try {\n            URL url = new URL(baseUrl + descfile);\n            URLConnection con = url.openConnection();\n            WizardPage1.this.setTemplContainer(new TemplateContainer(con.getInputStream(), baseUrl));\n            fillListboxFromTemplateContainer();\n        } catch (MalformedURLException e1) {\n            getTxaTemplateDescription().setText(e1.getMessage());\n            e1.printStackTrace();\n        } catch (IOException e2) {\n            getTxaTemplateDescription().setText(e2.getMessage());\n            e2.printStackTrace();\n        } catch (XPathExpressionException e3) {\n            getTxaTemplateDescription().setText(e3.getMessage());\n            e3.printStackTrace();\n        } catch (ParserConfigurationException e4) {\n            getTxaTemplateDescription().setText(e4.getMessage());\n            e4.printStackTrace();\n        } catch (SAXException e5) {\n            getTxaTemplateDescription().setText(e5.getMessage());\n            e5.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"strServlet_name": ["strServet_type", "strServet_name", "strServlet_no", "strServletPathdata", "strServlet_data", "strServletPathName", "strServlets_no", "strServlets_Name", "strServlet_id", "strServlet_Name", "strServletNamepath", "strServletNamename", "strServlets_name", "strServet_Name", "strServletPathname", "strServlets_data", "strServlets_path", "strServet_id", "strServlet_type", "strServletNameName", "strServletNameno", "strServlet_path"], "urlServlet": ["urlservlex", "URLServicelet", " urlServjet", "URLServle", "pageBootL", "URLServicelex", " urlServet", " urlAngjet", "URLServlete", "urlServicele", "urlServerlet", "urlWeblex", "urlServle", "URLServlex", "urlservile", "URLServlet", "urlservlete", "urlServet", "urlSele", "pageServlet", "urlAnget", "urlAngle", "pageBootle", "urlWebile", "urlAnglet", " urlServle", "pageBootlete", "urlServerlex", "pageServlete", "urlServicelet", "allowServlet", "urlServlete", "urlBootlet", "urlWeble", "urlWebet", "urlServile", "urlServicelex", "urlservle", "allowservle", "urlAngjet", " urlAnget", "urlSelet", "urlBootle", "pageServL", "urlBootlete", "urlServerle", "urlWeblete", "allowServle", "urlWebL", "urlSejet", "urlWebjet", "pageBootlet", "urlServicelete", "urlServerile", "urlservL", "URLServicele", "urlServlex", "urlSeet", "allowservlet", "URLServicelete", "urlBootL", "urlWeblet", " urlAnglet", "allowservile", " urlAngle", "urlServL", "pageServle", "urlservlet", "allowServlex", "urlServjet", "allowservlex", "allowServile"], "connection": ["source", "translation", "general", "url", "wrapper", "link", "reference", "open", "cf", "result", "function", "message", "conn", "communication", "http", "con", "client", "object", "union", "bc", "driver", "connected", "common", "channel", "application", "part", "data", "directory", "version", "remote", "response", "resource", "handler", "server", "config", "info", "condition", "creator", "section", "query", "event", "container", "password", "ion", "api", "text", "instance", "relation", "session", "key", "document", "node", "connect", "cache", "c", "j", "context", "socket", "command", "image", "builder", "service", "database", "position", "Connection", "proxy", "collection", "use", "entry"]}}
{"id1": "6778337", "id2": "7678253", "code1": "    private void copy(File from, File to) throws FileNotFoundException, IOException {\n        FileReader in;\n        in = new FileReader(from);\n        FileWriter out = new FileWriter(to);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    protected void copyFile(File sourceFile, File targetFile) throws FileNotFoundException, IOException {\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        try {\n            inChannel = new FileInputStream(sourceFile).getChannel();\n            outChannel = new FileOutputStream(targetFile).getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            try {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"from": ["source", "left", "url", "link", "about", "d", "user", "connection", "with", "range", "origin", "part", "base", "f", "From", "by", "resource", "address", "x", "name", "o", "e", "old", "a", "back", "path", "image", "file", "or", "vol", "front", "at", "form", "add"], "to": ["source", "size", "url", "about", "token", "office", "with", "tab", "top", "output", "TO", "tz", "client", "b", "toc", "To", "f", "base", "as", "by", "prefix", "eto", "address", "x", "until", "name", "o", "target", "t", "temp", "obj", "file", "at", "copy", "so", "p"], "in": ["source", "get", "read", "reader", "id", "input", "inc", "ln", "din", "win", "min", "nin", "conn", "l", "con", "login", "f", "as", "In", "pin", "again", "n", "r", "isin", "inner", "pc", "exec", "init", "ins", "e", "ax", "gin", "ini", "kin", "before", "image", "cin", "i", "IN", "inside", "inn", "rin", "is", "lin", "bin", "pass"], "out": ["plus", "parent", "plain", "inc", "write", "net", "outer", "io", "output", "conn", "w", "b", "client", "as", "data", "n", "Out", "OUT", "outs", "again", "writer", "off", "exec", "x", "sync", "o", "s", "ex", "temp", "v", "up", "obj", "cache", "file", "i", "err", "socket", "at", "outside", "bin", "copy", "line"], "c": ["dc", "cd", "d", "uc", "cy", "cu", "cm", "cf", "k", "fc", "l", "char", "bc", "f", "p", "oc", "ec", "cp", "n", "r", "xc", "enc", "sc", "pc", "ci", "rc", "u", "e", "esc", "o", "cl", "arc", "t", "ch", "m", "lc", "content", "v", "col", "cr", "pointer", "i", "code", "character", "ce", "cc", "ct", "nc", "ac", "C"]}}
{"id1": "288695", "id2": "2009328", "code1": "    public void CopyFile(File source, File destination) throws Exception {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(source);\n            fos = new FileOutputStream(destination);\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                fos.write(buffer, 0, read);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private String storeProxy(String proxyPath, String userName) throws IOException {\n        File inputFile = new File(proxyPath);\n        String outfile = slcsFactory.getStoreDirectory() + File.separator + userName + File.separator + PROXYFILENAME;\n        File outputFile = new File(outfile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n        Process p = Runtime.getRuntime().exec(\"/bin/chmod 600 \" + outfile);\n        try {\n            p.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return outfile;\n    }\n", "label": 1, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "io", "src", "from", "in", "this", "Source", "base", "table", "directory", "stream", "remote", "resource", "ie", "server", "address", "info", "ources", "filename", "name", "e", "target", "ource", "sin", "SOURCE", "slice", "string", "image", "file", "uri", "i", "service", "scene", "proxy", "use", "unit"], "destination": ["deadinated", "deadination", "Desturation", "destiner", "combinated", "deaduration", "Destinated", "desturation", "Destiner", "destinated", "dinations", "combination", "diination", "diinations", "Destinator", "deadiner", "diinated", "dinated", "destinations", "dinator", "Destinations", "dination", "combiner", "diinator", "comburation", "destinator", "Destination"], "fis": ["los", "fris", "infris", "fois", "Fos", "Fiss", "las", "fiss", "bos", "infos", "lois", "fios", "Fas", " fois", "biss", " fios", "bris", "Fris", "hos", "Fis", "his", "hiss", " fas", "infis", " fris", "hris", "Fois", "lis", "infios", "Fios", "lris", "bis", " fiss", "fas"], "fos": ["Foes", "los", " fros", " foses", "fose", "fus", " foes", " fou", "ufou", "ufos", "baos", "ufros", "pose", "bros", "fros", "Fos", "bos", "infos", "fios", "infus", " fios", " faos", " fus", "Faos", "poes", "lios", "bou", "Fis", "infis", "Fose", "loses", "faos", "lis", "ufis", "infios", "foses", "bus", "Fios", "bios", "pos", "Foses", "poses", "bis", "fou", "foes", " fose"], "buffer": ["reader", "url", "queue", "memory", "binary", "input", "write", "feed", "reference", "buff", "repeat", "iter", "result", "Buffer", "limit", "request", "b", "channel", "number", "layer", "data", "available", "resource", "address", "uffer", "shape", "transfer", "null", "batch", "flush", "length", "wave", "buf", "slice", "count", "document", "border", "seed", "cache", "header", "block", "total", "position", "bin"], "read": ["play", "get", "next", "reader", "en", "size", "id", "write", "d", "input", "feed", "len", "Read", "ind", "open", "iter", "READ", "io", "in", "b", "end", "f", "data", "rate", "find", "n", "work", "raw", "exec", "x", "send", "e", "reading", "_", "length", "allow", "text", "max", "se", "key", "run", "index", "close", "count", "pass", "load", "connect", "parse", "readable", "i", "check", "seek", "current", "type", "wait", "start", " count", "add", "ed", " Read", "use", " ride", "reads"]}}
{"id1": "11647643", "id2": "6226250", "code1": "        public void actionPerformed(ActionEvent e) {\n            try {\n                URL url = new URL(\"http://mailsomething.sf.net/helppages.xml\");\n                try {\n                    File file = File.createTempFile(\"temp\", \"xml\");\n                    InputStream in = new BufferedInputStream(url.openStream());\n                    OutputStream out = new FileOutputStream(file);\n                    byte[] buf = new byte[1024];\n                    int n;\n                    while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n                    out.flush();\n                    out.close();\n                    module.merge(file);\n                } catch (IOException f) {\n                }\n            } catch (MalformedURLException f) {\n            }\n        }\n", "code2": "    public static String MD5(String plainTxt) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(plainTxt.getBytes());\n            byte[] b = md.digest();\n            int i = 0;\n            StringBuffer buffer = new StringBuffer();\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) {\n                    i += 256;\n                }\n                if (i < 16) {\n                    buffer.append(\"0\");\n                }\n                buffer.append(Integer.toHexString(i));\n            }\n            return buffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return \"ERROR\";\n        }\n    }\n", "label": 0, "substitutes": {"e": ["events", "pe", "ception", "ee", "vent", "end", " Event", "f", "E", "exc", "fe", "ec", "ctx", "es", "x", "name", "event", "ae", "t", "a", "v", "Event", "j", "c", "et", "ing", "te", "type"], "url": ["source", "page", "ball", "queue", "user", "feed", "connection", "download", "pull", "open", "ll", "l", "http", "base", "f", "stream", "zip", "resource", "email", "server", "org", "ur", "ls", "up", "string", "path", "image", "socket", "uri", "ssl", "URL", "service", "Url", "www", "blog", "web", "sl"], "file": ["source", "page", "folder", "queue", "pe", "place", "feed", "connection", "buffer", "xml", "plugin", "File", "io", "output", "l", "letter", "http", "fp", "b", "part", "model", "f", "base", "data", "fe", "table", "zip", "module", "filename", "name", "dir", "full", "flow", "per", "log", "job", "temp", "up", "book", "rule", "path", "pool", "cache", "lock", "db", "files", "FILE", "web", "line", "use"], "in": ["source", "reader", "h", "input", "inc", "din", "win", "io", "nin", "conn", "lib", "con", "b", "login", "f", "data", "In", "stream", "r", "inner", "init", "ins", "gin", "ini", "a", "image", "lock", "socket", "c", "i", "IN", "inn", "lin", "bin", "s"], "out": ["parent", "inc", "write", "buffer", "plugin", "io", "output", "outer", "conn", "lib", "one", "b", "client", "part", "f", "base", "data", "Out", "OUT", "outs", "again", "zip", "writer", "inner", "off", "exec", "sync", "name", "o", "s", "flow", "log", "flush", "ex", "cli", "temp", "up", "pool", "image", "cache", "socket", "lock", "err", "bin", "copy", "line", "ext"], "buf": ["bp", "cb", "num", "queue", "bf", "la", "uc", "len", "buffer", "buff", "cf", "br", "Buffer", "cas", "b", "bc", "f", "cv", "loc", "data", "bd", "bytes", "ctx", "box", "pad", "off", "cur", "batch", "grab", "bb", "feat", "rc", "cl", "seq", "uf", "cap", "bag", "temp", "pool", "ab", "c", "comb", "vec", "wb", "fb", "ff", "bin", "auc", "rb", "p"], "n": ["size", "an", "en", "num", "none", "d", "nn", "net", "len", "min", "k", "nin", "l", "b", "ns", "f", "number", "no", "rn", "dn", "x", "ne", "na", "u", "o", "nt", "length", "t", "m", "nu", "v", "N", "j", "c", "i", "g", "un", "nb", "ng", "sn", "z", "nc", "p"]}}
{"id1": "13551188", "id2": "272355", "code1": "    public static InputStream getResourceAsStream(String resName, Class<?> clazz) {\n        URL url = getResource(resName, clazz);\n        try {\n            return (url != null) ? url.openStream() : null;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"resName": ["ResUrl", "ResClass", "resUrl", "relname", "resPath", "resname", "relName", "Resname", "reqUrl", "resourcename", "rePath", "rename", "resNames", "reNames", "reName", "resourceName", "resClass", "reqName", "reqClass", "resourcePath", "ResPath", "reqname", "relClass", "resourceNames", "ResNames", "relUrl", "ResName"], "clazz": ["Claz", " claz", "clclass", " clone", " cllass", "Clazz", "claz", "CLlass", "Cllass", " clclass", "CLclass", "CLaz", "CLazz", "Clclass", "clone", "Clone", "cllass", "CLone"], "url": ["page", "id", "browser", "feed", "connection", "xml", "rel", "pull", "plug", "ll", "download", "l", "lib", "http", "control", "this", "b", "object", "lr", "f", "loader", "base", "data", "loc", "class", "r", "zip", "resource", "server", "el", "name", "gl", "rc", "ob", "api", "bel", "fl", "ls", "location", "path", "orb", "image", "rl", "obj", "impl", "file", "ssl", "uri", "err", "fb", "URL", "service", "Url", "www", "blog", "web", "coll", "sl"]}}
{"id1": "10067028", "id2": "9307757", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            long size = in.size();\n            MappedByteBuffer buffer = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buffer);\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            clearTables(stmt);\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Minimal Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 0, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "src", "from", "object", "Source", "client", "base", "table", "stream", "remote", "resource", "server", "inner", "ources", "sync", "filename", "name", "ins", "target", "ource", "sin", "SOURCE", "internal", "slice", "path", "image", "string", "cache", "file", "service", "proxy", "use"], "destination": [" Destination", " Destinations", "destitution", "declinator", "declination", "Destinated", "distinated", "distination", "distitution", "declinations", "destinated", "declinated", "Destinator", "constinator", "constitution", "destinations", "Destinations", " Destinator", "constination", "destinator", "constinated", "distinator", " Destinated", "Destination", "Destitution"], "in": ["get", "reader", "id", "url", "input", "inc", "din", "token", "win", "pull", "min", "nin", "conn", "src", "con", "b", "this", "diff", "login", "base", "as", "data", "In", "pin", "again", "n", "r", "include", "thin", "stream", "server", "work", "isin", "inner", "info", "pc", "name", "init", "ins", "gin", "ini", "m", "issue", "up", "slice", "index", "cin", "image", "socket", "c", "file", "i", "IN", "err", "inside", "inn", "is", "bin", "pass"], "out": ["parent", "id", "plain", "write", "line", "net", "connection", "extra", "io", "output", "outer", "conn", "one", "w", "client", "ou", "part", "channel", "to", "no", "version", "OUT", "Out", "again", "n", "prefix", "outs", "server", "external", "writer", "inner", "off", "exec", "dest", "sync", "init", "o", "other", "target", "flush", "ex", "timeout", "up", "image", "pool", "vert", "cache", "obj", "file", "socket", "err", "at", "outside", "bin", "copy", "null", "ext"], "size": ["page", "export", "en", "write", "si", "len", "range", "scale", "weight", "limit", "sized", "end", "mode", "Size", "number", "loc", "SIZE", "bytes", "n", "sum", "address", "shape", "send", "depth", "name", "transfer", "sync", "e", "ize", "length", "flush", "capacity", "max", "content", "offset", "time", "count", "code", "seek", "width", "speed", "type", "order", "empty", "small", "clear", "unit"], "buffer": ["reader", "value", "url", "input", "queue", "feed", "buff", "iter", "Buffer", "output", "BB", "channel", "base", "layer", "data", "resource", "address", "info", "writer", "uffer", "null", "batch", "bb", "flow", "length", "wave", "FFER", "buf", "offset", "document", "cache", "map", "header", "texture", "bin", "copy"]}}
{"id1": "813913", "id2": "9769234", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    void downloadImage(String filename, File imageFile) throws Exception {\n        String URL = Constants.IMAGE_URL + \"/\" + filename;\n        SiteResponse response = stratSite.getResponse(URL);\n        InputStream inputStream = response.getInputStream();\n        OutputStream outputStream = new FileOutputStream(imageFile);\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "label": 1, "substitutes": {"inFile": ["inputfile", "inPlace", "InFiles", "oldfile", "inputFiles", "incPlace", " inPath", "outFilename", "outfile", "inFilename", "outPlace", "outPath", "oldFiles", "inputFilename", "infile", "InFile", "oldFilename", "incfile", "oldFile", "outFiles", "inPath", "incFile", "inFiles", " inFiles", "incFiles", "InPlace", " infile", "inputFile", "Infile", "InPath"], "outFile": [" outTable", "zipFile", " outPlace", "inputFolder", "outTable", "zipString", "newfile", " outString", "newPlace", "OutFile", " outfile", "outputFILE", "outputFilename", "outDir", "zipFilename", "outputFile", "outputFolder", "outFILE", "outFilename", "outputString", " outFolder", " outDir", "outfile", "newDir", "inputPlace", "outPlace", "OutPlace", "Outfile", " outFilename", "outFolder", "OutDir", "newFile", "inputTable", " outFILE", "outString", "inputFile", "outputPlace", "outputTable", "zipFILE"], "iis": [" iIS", " iiss", "Iisc", " iIs", "iniais", "ciis", "iois", "iiIS", "ioIs", "IIs", "iIS", "iniIS", "iiIs", "iid", "iisc", "ioiss", " iais", "Iiss", "ciid", "iiss", "iniIs", "iils", "ciais", "Iis", " iils", "iiils", " iid", "ioisc", "iniis", "iniisc", "iiis", "iniiss", "iniid", "iIs", "ciiss", "iniils", "iais"], "dcmParser": ["dcpJar", " dpmarser", "dcpReader", "dcmLoader", "pdymJar", "dpmarser", "dpmLoader", "dcyJar", "pdcmparser", "dcyReader", "Dcmarser", " dpmPlugin", "dsemPlugin", "dmcarser", "dcmparser", "dsemStreamer", "dcrarser", "dpmStreamer", "dcrParser", "dmoduleParser", "dymReader", "dcrparser", "dsemParser", " dcmStreamer", "dtermStreamer", "dpmparser", "dtermParser", "ddcReader", "dcmBuilder", "dmmWriter", "dymparser", "dmmParser", " dcmPlugin", "dmoduleBuilder", "dcmWriter", "ddcParser", " dpmJar", "dmcParser", "dmodulePlugin", "dpmJar", "pdcmReader", "dpmParser", " dcmReader", " dpmLoader", "DcmReader", "dcyParser", "ddcLoader", "dymParser", "dcyarser", " dpmReader", "pdymparser", "pdymReader", "dpmPlugin", " dcmJar", " dcmPar", "DcmJar", "dtermPlugin", "dcpParser", "dcpparser", " dpmPar", " dcmLoader", "pdcmParser", "dpmPar", " dpmBuilder", "dmcJar", "dmoduleReader", " dpmStreamer", "dpmBuilder", " dcmBuilder", " dcmarser", "dymJar", "dcmStreamer", "dmmReader", "dcrWriter", "dcmPlugin", "dmcPar", "dcmJar", "ddcPlugin", " dpmParser", "Dcmparser", "DcmParser", "dsemReader", "dcmarser", "dcmPar", "dcrPar", "DcmWriter", "pdymParser", "dmmarser", "dcmReader", "dtermReader", "dcrReader", "dpmReader", "pdcmJar", "dcrJar"], "ds": ["ys", "ks", "dc", "ipes", "Ds", "des", "d", "points", "dd", "ils", "ld", "ss", "ws", "gd", "src", "pd", "conn", "cdn", "gs", "client", "ns", "ads", "fd", "ros", "Db", "asi", "data", "iss", "di", "os", "bs", "DS", "tx", "drivers", "sys", "js", "vs", "eps", "sync", "dt", "xs", "plugins", "ins", "dds", "da", "rs", "cs", "Ts", "amps", "dr", "ls", "df", "Os", "ays", "session", "docs", "utils", "db", "details", "parts", "services", "is", "tes", "ts", "nas", "ps", "s", "dat", "uds"], "pdReader": ["wdRead", "pcParser", "dsreader", "pbParser", "pcLoader", "pdreader", "pbReader", "xdreader", "xdWriter", "hdreader", "pdRead", "pcReader", "dsRead", "pdLoader", "hdRead", "pidParser", "pbLoader", "hdWriter", "wdReader", "pdParser", "pidScan", "pcScan", "dsLoader", "pbScan", "pcRead", "pcWriter", "wdLoader", "hdReader", "pidReader", "wdWriter", "pidLoader", "xdReader", "dsWriter", "dsReader", "pdScan", "xdRead"], "out": ["default", "later", "d", "net", "with", "result", "down", "now", "doc", "model", "over", "Out", "call", "writer", "sys", "sync", "name", "dot", "log", "flush", "cli", "temp", "image", "list", "obj", "file", "ssl", "err", "array", "img", "group", "store", "line", "pass", "co", "outer", "io", "conn", "lib", "object", "gen", "to", "OUT", "auto", "class", "child", "exp", "ex", "key", "point", "pool", "cache", "at", "copy", "ext", "page", "parent", "url", "user", "write", "inc", "term", "in", "client", "login", "base", "oder", "sum", "external", "exec", "word", "full", "o", "builder", "manager", "order", "s", "null", "connection", "output", "w", "as", "data", "again", "outs", "inner", "flow", "password", "session", "up", "lock", "db", "code", "device"], "dcmEncParam": ["dcmElParameter", "dcmDecParam", "dpmDecParam", "dcmEngType", "dcmDecParameter", "dcmEnVar", "dcmDecPar", "dcmElVar", "dcmEncType", "dcmElType", "dcmencParam", "dpmEncParam", "dcmEnPar", "dcmEncSm", "dcmEngParam", "dcmEnParam", "dcmElParam", "dcmAccParameter", "dcmDecSm", "dpmEncSm", "dcmencParameter", "dpmDecParameter", "dcmEngVar", "dcmAccParam", "dcmencSm", "dpmEncParameter", "dcmAccSm", "dpmDecSm", "dcmEnParameter", "dcmEncPar", "dcmEncVar", "dcmEncParameter", "dcmEnType", "dcmEngParameter"], "pdWriter": ["hdOutput", "pdContent", "pxContent", "PDOutput", "pxReader", "PDReader", "PDWriter", "PDContent", "pxWriter", "tdReader", "ddWR", "dsWrite", "hdWriter", "pxOutput", "ddWrite", "ddOutput", "hdWrite", "pdOutput", "pdWrite", "hdWR", "pdWR", "tdWriter", "dsOutput", "tdContent", "dsWriter", "tdOutput", "ddWriter", "dsWR"]}}
{"id1": "2640244", "id2": "22328844", "code1": "    public DocumentDialog(Frame frame, String title, String document) {\n        setTitle(title);\n        textArea = new JTextArea();\n        textPane = new StdScrollPane(textArea, StdScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, StdScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n        textArea.setEditable(false);\n        getContentPane().add(textPane);\n        URL url = DocumentDialog.class.getClassLoader().getResource(document);\n        try {\n            StringBuilder sb = new StringBuilder();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            String buildNumber = MessageBundle.getBuildNumber();\n            String releaseNumber = MessageBundle.getReleaseNumber();\n            String tmp;\n            while ((tmp = in.readLine()) != null) {\n                tmp = tmp.replace(\"${build_number}\", buildNumber);\n                tmp = tmp.replace(\"${release_number}\", releaseNumber);\n                sb.append(tmp + \"\\n\");\n            }\n            textArea.setText(sb.toString());\n            textArea.setCaretPosition(0);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    protected void doBackupOrganize() throws Exception {\n        Connection con = null;\n        PreparedStatement ps = null;\n        ResultSet result = null;\n        String strSelQuery = \"SELECT organize_id,organize_type_id,organize_name,organize_manager,\" + \"organize_describe,work_type,show_order,position_x,position_y \" + \"FROM \" + Common.ORGANIZE_TABLE;\n        String strInsQuery = \"INSERT INTO \" + Common.ORGANIZE_B_TABLE + \" \" + \"(version_no,organize_id,organize_type_id,organize_name,organize_manager,\" + \"organize_describe,work_type,show_order,position_x,position_y) \" + \"VALUES (?,?,?,?,?,?,?,?,?,?)\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            try {\n                con = dbo.getConnection();\n                con.setAutoCommit(false);\n                ps = con.prepareStatement(strSelQuery);\n                result = ps.executeQuery();\n                ps = con.prepareStatement(strInsQuery);\n                while (result.next()) {\n                    ps.setInt(1, this.versionNO);\n                    ps.setString(2, result.getString(\"organize_id\"));\n                    ps.setString(3, result.getString(\"organize_type_id\"));\n                    ps.setString(4, result.getString(\"organize_name\"));\n                    ps.setString(5, result.getString(\"organize_manager\"));\n                    ps.setString(6, result.getString(\"organize_describe\"));\n                    ps.setString(7, result.getString(\"work_type\"));\n                    ps.setInt(8, result.getInt(\"show_order\"));\n                    ps.setInt(9, result.getInt(\"position_x\"));\n                    ps.setInt(10, result.getInt(\"position_y\"));\n                    int resultCount = ps.executeUpdate();\n                    if (resultCount != 1) {\n                        con.rollback();\n                        throw new CesSystemException(\"Organize_backup.doBackupOrganize(): ERROR Inserting data \" + \"in T_SYS_ORGANIZE_B INSERT !! resultCount = \" + resultCount);\n                    }\n                }\n                con.commit();\n            } catch (SQLException se) {\n                con.rollback();\n                throw new CesSystemException(\"Organize_backup.doBackupOrganize(): SQLException:  \" + se);\n            } finally {\n                con.setAutoCommit(true);\n                close(dbo, ps, result);\n            }\n        } catch (SQLException se) {\n            throw new CesSystemException(\"Organize_backup.doBackupOrganize(): SQLException while committing or rollback\");\n        }\n    }\n", "label": 0, "substitutes": {"frame": ["movie", "frames", " Frame", "panel", "message", "thread", "object", "state", "f", "loader", "base", "config", "component", "framework", "flow", "screen", "Frame", "window", "media", "image", "file", "code", "fb", "scene", "process", "video", "figure"], "title": ["page", "display", "term", "theme", "message", "doc", "format", "license", "article", "description", "part", "application", "summary", "prefix", "heading", "filename", "name", " Title", "text", "content", "media", "company", "html", "setup", "details", "label", "itle", "header", "Title", "subject", "metadata", "project", "notes", "chapter", "type"], "document": ["language", "source", "page", "host", "parent", "program", "office", "Document", "download", "message", "doc", "output", "object", "description", "application", "directory", "resource", "address", "filename", "name", "body", "target", "content", " documentation", "docs", "string", "media", "image", "uri", "context", "ocument", "database", "video", "subject", "position", "location"], "textArea": ["fontArea", "formCenter", "extBar", "TextBook", "textarea", "textPa", "Textarea", "textCenter", "textBook", " textBook", " textarea", "extArea", "eventarea", "contentarea", "formarea", "contentCenter", "fontarea", " textPa", "textBox", "eventBar", "formBar", " textBox", "TextBox", "fontBook", "eventArea", "fontPa", "contentBar", "extarea", "formArea", "textPanel", "extBox", "eventPanel", " textBar", "TextPa", "contentArea", "textBar", "TextBar", "formPanel", "TextCenter", "TextArea", " textPanel"], "textPane": ["scrollpace", "textPoANE", "scrollPane", "textpair", "textPoane", "scrollpane", "scrollPace", "textpanes", "textPoanes", "scrollPanes", "textPale", "textChale", "textpace", "textPanes", "textChanes", "scrollPale", "contentpane", "contentpanes", "contentPANE", "contentpair", "textGane", "textGanes", "textPace", "textpane", "textGale", "contentPanes", "scrollpanes", "textPoair", "contentPane", "contentPair", "textChane", "textpANE", "textpale", "contentpANE", "textChace", "scrollpale", "textPair", "textPANE", "textGace"], "url": ["source", "page", "ball", "user", "connection", "buffer", "io", "src", "l", "http", "client", "base", "loader", "data", "r", "resource", "org", "server", "address", "ur", "gl", "api", "bel", "ls", "job", "up", "string", "path", "image", "rule", "rl", "impl", "socket", "file", "uri", "ssl", "err", "URL", "hub", "Url", "web", "coll", "sl"], "sb": ["bp", "cb", "sa", "bf", "si", "txt", "bh", "mb", "buffer", "usb", "sg", "pb", "BB", "src", "fp", "b", "sf", "bc", "storage", "abb", "bs", "erb", "ub", "sup", "bj", "SB", " SB", "bb", "zb", "buf", "ls", "gb", "xb", "eb", "sp", "bsp", "bt", "db", "wb", "fb", "sq", "lab", "nb", "lb", "rb", "ib", "bl"], "in": ["source", "reader", "input", "inc", "din", "buffer", "io", "nin", "con", "out", "b", "login", "f", "fe", "In", "pin", "stream", "again", "r", "resource", "isin", "inner", "ins", "e", "gin", "ini", "m", "image", "c", "file", "ssl", "i", "IN", "socket", "inn", "is", "ilo", "lin", "bin", "s", "line"], "buildNumber": ["lockNo", "BuildNumber", "locknumber", "lockNum", "lockNumber", "BuildUnit", "Buildnumber", "buildString", "BuildNo", "buildnumber", " buildUnit", " buildString", " buildNum", "releaseString", "BuildNum", "releaseUnit", "buildUnit", "releaseNum", "buildNum", " buildnumber", "buildNo", " buildNo", "BuildString"], "releaseNumber": ["releaseVersion", "installnumber", "leasenumber", "installCode", " releaseCode", "installVersion", "installString", "installNum", " releasenumber", "ReleaseString", "installUnit", " releaseUnit", "releaseString", "installNumber", "releaseUnit", "leaseNum", "releasenumber", " releaseString", "ReleaseNumber", " releaseNum", "ReleaseCode", " releaseVersion", "leaseVersion", "releaseNum", "releaseCode", "ReleaseUnit", "leaseNumber"], "tmp": ["attr", "appy", "str", "py", "su", "cb", "bf", "txt", "append", "proc", "term", "tab", "result", "pb", "mm", "src", "kk", "stuff", "wx", "pre", "mmm", "fp", "app", "diff", "st", "const", "part", "tf", "cpp", "data", "mo", "cp", "storage", "zip", "pad", "dest", "sup", "ppa", "body", "mp", "bb", "amp", "tc", "api", "tt", "nm", "buf", "temp", "job", "own", "string", "sp", "obj", "cache", "bt", "vm", "wb", "np", "fb", "vt", "nb", "md", "img", "test", "copy", "rb", "cmp", "pkg"]}}
{"id1": "323592", "id2": "6644160", "code1": "    public void elimina(Pedido pe) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorPedido.elimina()\");\n        int id = pe.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM pedido WHERE id=\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorPedido.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorPedido.elimina(): \" + e);\n        }\n    }\n", "code2": "    public void saveHiddenNames(HashSet names) throws SQLException {\n        Connection conn = AppLayerDatabase.getInstance().getPooledConnection();\n        PreparedStatement ps = null;\n        try {\n            conn.setAutoCommit(false);\n            Statement stmt = conn.createStatement();\n            stmt.executeUpdate(\"DELETE FROM HIDDENBOARDNAMES\");\n            stmt.close();\n            stmt = null;\n            ps = conn.prepareStatement(\"INSERT INTO HIDDENBOARDNAMES (boardname) VALUES (?)\");\n            for (Iterator i = names.iterator(); i.hasNext(); ) {\n                String bName = (String) i.next();\n                ps.setString(1, bName);\n                ps.executeUpdate();\n            }\n            ps.close();\n            conn.commit();\n            conn.setAutoCommit(true);\n        } catch (Throwable t) {\n            logger.log(Level.SEVERE, \"Exception during save\", t);\n            try {\n                conn.rollback();\n            } catch (Throwable t1) {\n                logger.log(Level.SEVERE, \"Exception during rollback\", t1);\n            }\n            try {\n                conn.setAutoCommit(true);\n            } catch (Throwable t1) {\n            }\n        } finally {\n            AppLayerDatabase.getInstance().givePooledConnection(conn);\n            try {\n                if (ps != null) ps.close();\n            } catch (Throwable t1) {\n            }\n            ;\n        }\n    }\n", "label": 1, "substitutes": {"pe": ["PE", "ppe", "py", "ipe", "Pe", "pee", "pes", "pet", "ee", "pd", "xe", "pie", "po", "fe", "pex", "ffe", "ppa", "ge", "pa", "ne", "e", "ace", "de", "oe", "ple", "se", "le", "pse", "ape", "ke", "plate", "file", "pp", "spe", "ope", "pei", "ce", "ps", "me", "p"], "id": ["head", "url", "num", "en", "d", "oid", "mid", "in", "part", "aid", "f", "Id", "style", "zip", "ident", "info", "ql", "name", "pid", "patch", "key", "index", "string", "path", "db", "code", "rid", "i", "like", "vid", "q", "ids", "ip", "kid", "ID", "sid", "entry", "uid", "p", "type"], "sql": ["dl", "select", "su", "sb", "url", "nl", "msg", "util", "xml", "result", "ss", "statement", "join", "http", "params", "pg", "cmd", "sf", "delete", "data", "summary", "zip", "repl", "ql", "sys", "update", "generic", "shell", "eps", "section", "plan", "query", "s", "printf", "json", "log", "bool", "text", "comment", "sv", "SQL", "ls", "cli", "status", "mail", "string", "seed", "ssl", "db", "error", "err", "lua", "sol", "sq", " SQL", "reason", "str", "null", "sl", "type"], "stmt": ["estmt", "tmp", " stmr", "strpt", "strmd", "tmt", "ctmr", "ctm", "strnt", "ostmt", "Stmb", " stmd", "ctmd", " stm", "stnt", "Stt", "stmp", " stbl", "STpt", "stmd", "stm", "ostmr", "stpt", "stmr", "estt", "stmb", "STmd", "ctmt", " stnt", "stbl", "strmt", " stmp", "tbl", " stpt", "ostmd", " stt", "STnt", "Stm", "STmp", "stt", "estmb", "tmd", "STbl", " stmb", "Stmt", "ostm", "STmt", "estm"]}}
{"id1": "16302957", "id2": "12482760", "code1": "    private void parse(URL url, String description, boolean qualifiersOnTarget) throws org.xml.sax.SAXException, java.io.IOException {\n        this.qualifiersOnTarget = qualifiersOnTarget;\n        model = new Model(description);\n        if (roughMode) model.setRoughMode(true);\n        DOMParser parser = new DOMParser();\n        parser.setFeature(\"http://xml.org/sax/features/validation\", false);\n        parser.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        parser.parse(new InputSource(url.openStream()));\n        Document doc = parser.getDocument();\n        Element documentEl = doc.getDocumentElement();\n        Element contentEl = demandChildElement(documentEl, \"XMI.content\");\n        adapter = Adapter.getAdapter(documentEl);\n        parsePackage(contentEl);\n        if (!packagePath.isEmpty()) throw new IllegalArgumentException();\n        packagePath = null;\n        for (Iterator i = generalizations.iterator(); i.hasNext(); ) parseGeneralization((Element) i.next());\n        generalizations = null;\n        for (Iterator i = associations.keySet().iterator(); i.hasNext(); ) {\n            Element assoel = (Element) i.next();\n            parseAssociation(assoel, (ModelClass) (associations.get(assoel)));\n        }\n        associations = null;\n        for (Iterator i = classElements.keySet().iterator(); i.hasNext(); ) elaborate((ModelClass) (i.next()));\n        classElements = null;\n        if (roughMode) model.determineAllSupertypes(); else model.flatten();\n        url = null;\n    }\n", "code2": "    public synchronized void connect() throws FTPConnectionException {\n        checkLocked();\n        try {\n            int reply;\n            this.disconnect();\n            if (isSecured()) {\n                this.client = new FTPSClient(protocol, protection, impliciteSec, null, null);\n            } else {\n                this.client = new FTPClient();\n            }\n            if (this.controlEncoding != null) {\n                this.client.setControlEncoding(this.controlEncoding);\n                debug(\"control encoding : \", controlEncoding);\n            }\n            Logger.defaultLogger().info(\"Trying to connect to server : \" + this.remoteServer + \" ...\");\n            debug(\"connect : connect\", remoteServer);\n            client.connect(remoteServer, this.remotePort);\n            Logger.defaultLogger().info(\"Received FTP server response : \" + formatFTPReplyString(client.getReplyString()));\n            this.connectionId = Util.getRndLong();\n            reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                String msg = formatFTPReplyString(client.getReplyString());\n                this.disconnect();\n                throw new FTPConnectionException(\"Unable to communicate with remote FTP server. Got message : \" + msg);\n            } else {\n                Logger.defaultLogger().info(\"Trying to log in with user : \" + this.login + \" ...\");\n                debug(\"connect : login\", login + \"/\" + password);\n                if (!client.login(this.login, this.password)) {\n                    String msg = formatFTPReplyString(client.getReplyString());\n                    this.disconnect();\n                    throw new FTPConnectionException(\"Unable to login on FTP server (\" + login + \"/\" + password + \"). Received response : \" + msg);\n                } else {\n                    Logger.defaultLogger().info(\"Logged in with user : \" + this.login + \". Received response : \" + formatFTPReplyString(client.getReplyString()));\n                    if (this.passivMode) {\n                        Logger.defaultLogger().info(\"Switching to passive mode ...\");\n                        debug(\"connect : pasv\");\n                        client.enterLocalPassiveMode();\n                        reply = client.getReplyCode();\n                        if (!FTPReply.isPositiveCompletion(reply)) {\n                            String msg = formatFTPReplyString(client.getReplyString());\n                            this.disconnect();\n                            throw new FTPConnectionException(\"Unable to switch to passiv mode. Received response : \" + msg);\n                        } else {\n                            this.updateOpTime();\n                        }\n                    } else {\n                        this.updateOpTime();\n                    }\n                    debug(\"connect : bin\");\n                    client.setFileType(FTP.BINARY_FILE_TYPE);\n                    Logger.defaultLogger().info(\"Connected to server : \" + this.remoteServer);\n                }\n            }\n        } catch (UnknownHostException e) {\n            resetClient(e);\n            throw new FTPConnectionException(\"Unknown FTP server : \" + this.remoteServer);\n        } catch (SocketException e) {\n            resetClient(e);\n            throw new FTPConnectionException(\"Error during FTP connection : \" + e.getMessage());\n        } catch (IOException e) {\n            resetClient(e);\n            throw new FTPConnectionException(\"Error during FTP connection : \" + e.getMessage());\n        } finally {\n            clearCache();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "language", "host", "page", "route", "user", "link", "connection", "xml", "download", "buffer", "username", "l", "view", "http", "object", "base", "channel", "loader", "data", "layer", "stream", "remote", "class", "resource", "server", "address", "config", "element", "name", "log", "text", "string", "path", "document", "image", "file", "uri", "URL", "database", "date", "service", "Url", "blog", "location", "entry"], "description": ["language", "source", "translation", "about", "xml", "message", "definition", "summary", "phrase", "version", "resource", "address", "name", "desc", "filename", "report", "json", "text", "comment", "string", "path", "document", "uri", "title", "expression", "attribute", "details", "label", "code", "secret", "Description", "reason", "value", "author", "escription", "type"], "qualifiersOnTarget": ["qualifierOnSource", "qualifieronHost", "qualificationsontarget", "qualifiersForSource", "qualifiersOffTarget", "qualifiersUponTarget", "qualifiersOntarget", "qualificationsonSource", "qualifiersOffHost", "qualificationsOnTarget", "qualifiersAttarget", "qualifyOntarget", "qualifiersonSource", "qualifiersONSource", "qualifyONtarget", "qualifiersForTarget", "qualifieronTarget", "qualifiersUponSource", "qualifiersOffSource", "qualifierOnTarget", "qualifiersAtSource", "qualifiersUpontarget", "qualifiersAtTarget", "qualifiersontarget", "qualifiersONTarget", "qualifiersonHost", "qualifiersOnSource", "qualifyONTarget", "qualificationsonTarget", "qualifyONSource", "qualificationsOntarget", "qualifiersOfftarget", "qualifieronSource", "qualifiersForHost", "qualifiersonTarget", "qualifyOnTarget", "qualifiersOnHost", "qualifyOnSource", "qualifierOnHost", "qualificationsOnSource", "qualifiersONtarget"], "model": ["source", "language", "page", "parent", "reader", "link", "user", "cm", "xml", "build", "Model", "ma", "man", "view", "client", "layer", "base", "loader", "data", "system", "resource", "handler", "server", "config", "models", "module", "pattern", "container", "json", "instance", "m", "media", "image", "document", "graph", "ml", "file", "db", "code", "command", "record", "builder", "manager", "process", "self", "form", "store", "type"], "parser": ["aws", "reader", "default", "pkg", "upload", "util", "xml", "dd", "plugin", "ger", "audio", "http", "arser", "this", "driver", "client", "root", "part", "layer", "loader", "worker", "auto", "system", "slave", "handler", "server", "editor", "info", "writer", "doctor", "wp", "pc", "er", "monkey", "query", "au", "container", "json", "api", "tt", "instance", "se", "up", "book", "document", "node", "library", "cache", "utils", "parse", "uri", "builder", "manager", "pp", "Parser", "p"], "doc": ["source", "div", "parent", "page", "h", "dc", "Document", "xml", "open", "http", "f", "po", "data", "editor", "tx", "mc", "module", "js", "body", "dir", "ax", "container", "exp", "Doc", "m", "df", "pm", "docs", "document", "html", "file", "db", "parse", "vm", "pos", "cam", "cms"], "documentEl": ["documentEL", "xmlE", "contentEll", "contentel", "DocumentElement", "containerElement", "containerel", "xmlElement", "Documentel", "containerEll", "metadataE", "DocumentEl", "xmlEll", "metadataEL", "metadataEl", "documentEle", "contentEL", "DocumentEle", "contentE", "metadataElement", "xmlEL", "xmlEl", "documentEll", "documentE", "documentel", "DocumentEll", "documentElement", "contentElement", "contentEle", "containerEl", "xmlel", "xmlEle"], "contentEl": ["resourceElement", "resourceEl", "codeEl", "codeEle", "ContentEL", "contentEll", "resourceEL", "codeEll", "xmlElement", "ContentEl", "contentEL", "documentEle", " contentImpl", "contentImpl", "documentImpl", " contentEll", "xmlEL", " contentEle", "xmlEl", "ContentElement", "documentEll", "codeImpl", "resourceEle", "contentElement", "ContentEle", "contentEle", "xmlEle"], "adapter": ["AdAdapter", "alAdapter", "alporter", "adler", "Adapter", "adporter", "alapter", "Adler", "Adporter", "acapter", "aller", "acler", "adAdapter", "acAdapter", "acporter"], "packagePath": ["packageData", "componentpath", "sourceContainer", " packagepath", " packageName", "classContainer", "sourceName", "classPath", "featurePath", "packageOrder", "classpath", "packageContainer", "featureOrder", "featurepath", "componentData", "featureData", "componentPath", "sourcePath", " packageContainer", "sourcepath", "className", "packageName", " packageOrder", "packagepath", "componentOrder", " packageData"], "i": ["id", "h", "multi", "si", "d", "abi", "qi", "uli", "iter", "iu", "phi", "hi", "io", "ati", "l", "y", "in", "you", "f", "di", "bi", "mu", "I", "ti", "oi", "ai", "info", "gi", "inner", "esi", "init", "it", "ui", "ci", "o", "u", "e", "eni", "api", "ini", "ali", "cli", "xi", "li", "iri", "anti", "ri", "slice", "index", "wei", "j", "ori", "uri", "ii", "err", "vi", "q", "pi", "is", "idi", "chi", "me", "ed", "ip", "ic", "ie"], "generalizations": ["organization", "normalifications", "organizers", "generalizes", "generalifications", "normalizes", "Generalizers", "Generalifications", "organizations", " generalizes", "Generalizations", "organifications", "generalization", " generalization", "normalizers", "organizes", "normalizations", "Generalization", " generalizers", "generalizers", "Generalizes"], "assoel": [" caEl", "ancel", "asseil", "acoe", "assobel", "assoEl", "asabel", "assoell", "assoelle", "asae", "acobel", "assoe", "ancell", "acoell", "aroelle", "arobel", "acoelle", "asaell", "assoele", "ancele", " sone", "assoil", "asael", "asaele", "acoel", " cae", "assee", " cael", "asaelle", "asseel", "aroel", " sonel", "ance", "aroell", " sonil", " cail", " sonEl", "acoele", "asseEl"], "associations": ["assaboration", "associions", " associions", "Associions", "assigATIONS", " assigations", "associationations", "associances", "associationments", "associons", "associationATIONS", "assignations", "asspirations", "Association", "association", "asspirions", "assigations", " assigments", "assocATIONS", "assciation", "assaborations", "Associations", "attaborations", "associments", " assigions", "asspiration", "attociances", "assignions", " associATIONS", "Associateativity", "associateation", "assciances", "associationions", "associateions", "assocments", "attociation", "attociators", " assigATIONS", "assigions", "assigators", "assciations", "associateations", " associments", "Associativity", "assciators", "attaboration", "attaborators", "Associateions", "Associateations", "Associateation", "assignation", "attaborances", "assaborators", "assigances", "assocations", "associators", "assigments", "assigation", "associativity", "attociations", "associateativity", "assaborances", "asspirativity", "assignativity", "associATIONS"], "classElements": ["Classelers", "classIayers", "classEleles", "classElementles", " classEndlements", "classEodes", "classEonents", " classEndodes", "classElementlements", "classEndayers", " classEayers", "classeles", "ClassElements", "classIodes", "ClassEles", "classElers", "Classeles", " classEndayers", "classEayers", "Classelements", " classEonents", "classElelers", "classelements", "classIlements", " classEodes", "classElayers", "classElodes", "classElonents", "classElementlers", "classEllements", "ClassElers", "classelers", "classEndlements", "classIonents", "classElelements", "classEndonents", "classEles", " classEndonents", "classEndodes"]}}
{"id1": "20215222", "id2": "1332258", "code1": "    public static void main(String[] args) {\n        String in = \"/Users/laemmel/svn/shared-svn/projects/120multiDestPeds/floor_plan/boundaries.shp\";\n        String out = \"/Users/laemmel/svn/shared-svn/projects/120multiDestPeds/floor_plan/boundaries_closed.shp\";\n        ShapeFileReader reader = new ShapeFileReader();\n        reader.readFileAndInitialize(in);\n        QuadTree<Coordinate> quad = new QuadTree<Coordinate>(reader.getBounds().getMinX(), reader.getBounds().getMinY(), reader.getBounds().getMaxX(), reader.getBounds().getMaxY());\n        for (Feature ft : reader.getFeatureSet()) {\n            MultiLineString ml = (MultiLineString) ft.getDefaultGeometry();\n            for (int i = 0; i < ml.getNumGeometries(); i++) {\n                LineString ls = (LineString) ml.getGeometryN(i);\n                Point start = ls.getStartPoint();\n                checkIt(start, quad);\n                Point end = ls.getEndPoint();\n                checkIt(end, quad);\n            }\n        }\n        ShapeFileWriter.writeGeometries(reader.getFeatureSet(), out);\n    }\n", "code2": "    public void writeTo(OutputStream out) throws IOException {\n        if (!closed) {\n            throw new IOException(\"Stream not closed\");\n        }\n        if (isInMemory()) {\n            memoryOutputStream.writeTo(out);\n        } else {\n            FileInputStream fis = new FileInputStream(outputFile);\n            try {\n                IOUtils.copy(fis, out);\n            } finally {\n                IOUtils.close(fis);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["source", "id", "url", "input", "inc", "din", "xml", "min", "diff", "login", "f", "base", "include", "In", "data", "inas", "n", "resource", "work", "config", "info", "name", "init", "ins", "ini", "slice", "string", "path", "image", "c", "file", "IN", "lin", "bin", "s"], "out": ["page", "id", "url", "msg", "user", "result", "extra", "png", "output", "io", "outer", "letter", "this", "diff", "ou", "gen", "OUT", "Out", "again", "outs", "external", "template", "writer", "config", "inner", "conf", "filename", "name", "query", "target", "dot", "password", "comment", "key", "string", "point", "cfg", "list", "image", "file", "error", "err", "group", "bin", "res", "line"], "reader": ["pdf", "input", "dd", "audio", "over", "r", "system", "resource", "writer", "info", "rc", "report", "reading", "ri", "image", "file", "rr", "project", "actor", "read", "Reader", "feed", "buffer", "xml", "iter", "io", "rator", "bug", "worker", "riter", "handler", "editor", "er", "rer", "parse", "or", "source", "user", "http", "ler", "this", "client", "f", "loader", "oder", "server", "per", "book", "context", "builder", "manager", "ner", "h", "rar", "director", "vd", "w", "driver", "layer", "data", "feature", "config", "inner", "der", "parser", "former", "enter", "dr", "seed", "author", "entry"], "quad": [" Quad", "dq", "ad", "id", "split", "quarter", "pixel", "phase", "multi", "layout", "phi", "cgi", "qua", "gd", "bc", "diff", "bug", "loop", "poly", "circ", "zip", "round", "qq", "angle", "config", "pad", "shape", "cur", "tick", "sync", "query", "tri", "direction", "dir", "dog", "dot", "quant", "pattern", "step", "three", "patch", "bit", "chart", "post", "gb", "trap", "slice", "point", "rect", "coord", "sq", "q", "dollar", "circle", "grad", "quart", "square"], "ft": ["af", "fts", "ant", "bf", "txt", "fort", "ht", "cf", "fs", "xt", "wd", "fp", "sf", "fd", "fr", "Fact", "f", "part", "fw", "feature", "feat", "gt", "oft", "F", "fl", "aft", "pt", "TF", " FT", "bt", "rt", "font", "att", "fact", "Feature", "vt", "FT", "ff", "th", "et", "ct", "kt", "wt"], "ml": ["dl", "lp", "sel", "nl", "ln", "la", "LM", "cm", "lf", "xml", "ll", "mm", "lim", "l", "las", "lv", "lr", "fr", "wm", "kl", "vel", "ql", "gm", "cel", "ML", "cl", "wl", "bel", "fl", "li", "lc", "kel", "pm", "il", "mr", "vm", "jl", "fm", "lin", "pl", "line", "sl", "bl", "wt"], "i": ["id", "si", "qi", "iu", "hi", "io", "l", "b", "f", "di", "n", "zi", "mu", "I", "bi", "ti", "oi", "ai", "ni", "gi", "ji", "x", "ix", "ui", "ci", "u", "o", "e", "t", "ini", "m", "li", "v", "xi", "index", "ri", "j", "c", "uri", "ii", "pi", "is", "fi", "chi", "z", "mi", "s", "ip", "p"], "ls": ["ums", "lp", "los", "als", "ples", "ks", "dl", "ln", "la", "lf", "ils", "lines", "ss", "l", "las", "ns", "ms", "lv", "lr", "lins", "lt", "bs", "LS", "qs", "vs", "ins", "els", "pps", "cs", "lists", "sl", "sels", "lc", "li", "lis", " lines", "les", "rl", "ails", "its", "ii", "ols", "ds", "ts", "ps", "s", "coll", "ll"], "start": ["next", "Start", "id", "first", "last", "mid", "range", "min", "origin", "from", "l", "st", "part", "base", "loc", "skip", "set", "stop", "use", "name", "init", "patch", "step", "length", "cost", "offset", "art", "index", "point", "pos", "starting", "add", "line", "p", "type"], "end": ["End", "id", "url", "en", "append", "ends", "open", "complete", "edge", "eff", "object", "b", "begin", "base", "est", "ending", "set", "END", "stop", "off", "use", "patch", "length", "api", "max", "post", "offset", "point", "vert", "c", "pos", "position", "nd", "ended", "ad", "p"]}}
{"id1": "3046105", "id2": "19687459", "code1": "    public GGLicenses getLicensesInfo() throws IllegalStateException, GGException, Exception {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"method\", \"gg.photos.licenses.getInfo\"));\n        qparams.add(new BasicNameValuePair(\"key\", this.key));\n        String url = REST_URL + \"?\" + URLEncodedUtils.format(qparams, \"UTF-8\");\n        URI uri = new URI(url);\n        HttpGet httpget = new HttpGet(uri);\n        HttpResponse response = httpClient.execute(httpget);\n        int status = response.getStatusLine().getStatusCode();\n        errorCheck(response, status);\n        InputStream content = response.getEntity().getContent();\n        GGLicenses licenses = JAXB.unmarshal(content, GGLicenses.class);\n        return licenses;\n    }\n", "code2": "    @SuppressWarnings(\"deprecation\")\n    public void testMemberIterator() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(allfour_gz));\n        Iterator<GZIPMembersInputStream> iter = gzin.memberIterator();\n        assertTrue(iter.hasNext());\n        GZIPMembersInputStream gzMember0 = iter.next();\n        int count0 = IOUtils.copy(gzMember0, new NullOutputStream());\n        assertEquals(\"wrong 1k member count\", 1024, count0);\n        assertEquals(\"wrong member number\", 0, gzin.getMemberNumber());\n        assertEquals(\"wrong member0 start\", 0, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member0 end\", noise1k_gz.length, gzin.getCurrentMemberEnd());\n        assertTrue(iter.hasNext());\n        GZIPMembersInputStream gzMember1 = iter.next();\n        int count1 = IOUtils.copy(gzMember1, new NullOutputStream());\n        assertEquals(\"wrong 32k member count\", (32 * 1024), count1);\n        assertEquals(\"wrong member number\", 1, gzin.getMemberNumber());\n        assertEquals(\"wrong member1 start\", noise1k_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member1 end\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberEnd());\n        assertTrue(iter.hasNext());\n        GZIPMembersInputStream gzMember2 = iter.next();\n        int count2 = IOUtils.copy(gzMember2, new NullOutputStream());\n        assertEquals(\"wrong 1-byte member count\", 1, count2);\n        assertEquals(\"wrong member number\", 2, gzin.getMemberNumber());\n        assertEquals(\"wrong member2 start\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member2 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberEnd());\n        assertTrue(iter.hasNext());\n        GZIPMembersInputStream gzMember3 = iter.next();\n        int count3 = IOUtils.copy(gzMember3, new NullOutputStream());\n        assertEquals(\"wrong 5-byte member count\", 5, count3);\n        assertEquals(\"wrong member number\", 3, gzin.getMemberNumber());\n        assertEquals(\"wrong member3 start\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member3 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length + hello_gz.length, gzin.getCurrentMemberEnd());\n        assertFalse(iter.hasNext());\n    }\n", "label": 0, "substitutes": {"qparams": ["kparam", "iqparams", "qincludes", "questparam", "qresult", "iqsettings", "qapi", "kapi", "kparts", "qvals", "Qams", "Qapi", "Qincludes", "qargs", " qresult", "questparams", "quargs", "qsettings", "quvals", " qincludes", " qvals", "quparams", "koptions", " qargs", " qapi", "kparams", "queryoptions", " qoptions", " qams", "qparts", "Qparams", "questresult", "iqresult", "queryams", " qsettings", "Qparts", "qoptions", "quincludes", "kams", "Qargs", "queryparams", "qparam", "queryparam", "Qvals", " qparam", " qparts", "iqparam", "qams", "questsettings"], "url": ["host", "route", "feed", "connection", "build", "result", "l", "http", "request", "f", "base", "loc", "href", "data", "resource", "email", "server", "address", "name", "method", "ur", "u", "json", "sl", "ri", "string", "path", "rule", "file", "i", "ssl", "URL", "q", "Url", "www", "web", "str", "location"], "uri": ["source", "route", "id", "connection", "io", "http", "client", "request", "environment", "base", "version", "resource", "prefix", "server", "handler", "gi", "address", "info", "query", "ui", "api", "cli", "iri", "ri", "string", "path", "i", "service", "database", "pi", "URI", "mi", "uni", "ip", "location"], "httpget": ["httpsend", "HttpGet", " httpdo", "Httpclient", "httpclient", "httpGet", "Httpdo", "ttpclient", "ttpget", "servergot", "ttpsend", "ttpGet", "ttpgot", "httpdo", "httpgot", " httpGet", " httpgot", "ttpdo", "serverget", " httpsend", "Httpget", "serversend", "serverGet", " httpclient"], "response": ["next", "get", "page", "successful", "respond", "default", "connection", "success", "feed", "xml", "reply", "result", "message", "output", "http", "request", "client", "object", "application", "data", "version", "resource", "handler", "server", "serv", "body", "full", "results", "e", "report", "json", "api", "wave", "found", "relation", "Response", "image", "document", "error", "resp", "code", "received"], "status": ["source", "reason", "msg", "warning", "success", "reply", "result", "message", "grade", "security", "ity", "score", "state", "Status", "ess", "resource", "server", "stats", "stage", "method", "json", "stat", "sr", "index", "error", "code", "resp", "speed", "level", "received", "rate", "str", "uses", "type"], "content": ["source", "resources", "page", "reader", "input", "xml", "Content", "result", "message", "output", "object", "channel", "application", "data", "stream", "bytes", "enc", "resource", "handler", "server", "activity", "body", "results", "esc", "json", "cont", "act", "text", "string", "image", "entity", "document", "load", "code", "struct", "value"], "licenses": ["icences", " licencies", "icenses", "lices", "compences", "licents", "Licences", "licencies", "Licencies", "Licenses", "licentials", "Lices", "expenses", "compentials", "icencies", " licents", "icents", "compes", "Licentials", "compenses", " licences", "expences", "expes", "expentials", "licences", "Licents"]}}
{"id1": "1218380", "id2": "22261730", "code1": "    public static void main(String[] args) {\n        try {\n            Object o = Naming.lookup(\"Server\");\n            IServer serverStub = (IServer) o;\n            File srcDir = new File(args[0]);\n            File dstDir = new File(args[1]);\n            File[] srcFiles = srcDir.listFiles();\n            long position = 0;\n            for (File f : srcFiles) {\n                if (f.isDirectory()) continue;\n                try {\n                    FileChannel srcChannel = new FileInputStream(f).getChannel();\n                    String fileName = dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName();\n                    FileChannel dstChannel = new FileOutputStream(fileName).getChannel();\n                    System.out.println(\"Coping \" + fileName);\n                    ByteBuffer buffer = ByteBuffer.allocate(65536);\n                    int nr = 0;\n                    srcChannel.position(nr);\n                    nr = srcChannel.read(buffer);\n                    while (nr > -1) {\n                        buffer.flip();\n                        byte[] bytes = new byte[buffer.limit()];\n                        buffer.get(bytes);\n                        position = serverStub.write(bytes, position);\n                        buffer.clear();\n                        nr = srcChannel.read(buffer);\n                    }\n                    System.out.println(\"Done \");\n                    srcChannel.close();\n                    dstChannel.close();\n                } catch (IOException e) {\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        } catch (NotBoundException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static boolean fileCopy(String sFileSrc, String sFileDst) {\n        boolean ok = true;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            File fSrc = new File(sFileSrc);\n            int len = 32768;\n            byte[] buff = new byte[(int) Math.min(len, fSrc.length())];\n            fis = new FileInputStream(fSrc);\n            boolean append = false;\n            fos = new FileOutputStream(sFileDst, append);\n            while (0 < (len = fis.read(buff))) fos.write(buff, 0, len);\n            fos.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n            ok = false;\n        } finally {\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException ex) {\n                    ex.printStackTrace();\n                    JdxLog.logError(ex);\n                }\n            }\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException ex) {\n                    ex.printStackTrace();\n                    JdxLog.logError(ex);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"o": ["d", "oid", "io", "k", "l", "out", "object", "b", "op", "po", "no", "n", "os", "oa", "r", "oo", "oi", "bo", "vo", "er", "e", "ob", "ingo", "uto", "t", "oe", "ko", "m", "OO", "od", "O", "Obj", "obj", "c", "i", "or", "ando", "s", "so", "p"], "serverStub": ["serverStubs", "serverStob", "ServerTubs", "serverFubs", "serverBubs", "serverStrob", "serverstob", "erverStrob", "serverBub", "erverStrub", "serverTob", "ServerStub", "ServerTub", "serverTab", "serverTUB", "serverstub", "serverStrubs", "erverStrubs", "serverFUB", "serverstubs", "serverBUB", "ServerTUB", "serverBab", "serverTub", "ServerTab", "ServerStab", "serverFub", "serverStUB", "erverStUB", "serverStrub", "serverStab", "serverStrUB", "serverstUB", "erverStubs", "erverStob", "serverTubs", "erverStub", "ServerStUB", "serverFab", "erverStrUB", "ServerStubs"], "srcDir": ["sourceDir", "srcFile", " srcDirectory", "rcFile", " srcFolder", "rcFolder", "sourceFolder", "srcDirectory", "srcFolder", "rcDir", " srcFile", "sourceFile", "rcDirectory", "sourceDirectory"], "dstDir": ["destDIR", "drcDirectory", "dostDir", "dstDirectory", "dostDirectory", "drcDir", "dostDIR", "DrcDir", "DrcFile", "destDirectory", "DrcDIR", "dstFile", "dostFile", "dstFolder", "dstsFolder", "dndDir", "dstDIR", "dstsDIR", "DstFile", "DstDirectory", "dstsDir", "drcDIR", "DstDir", "destDir", "DrcFolder", "drcFile", "DstDIR", "DrcDirectory", "dndFile", "dndDirectory", "DstFolder", "destFolder", "dndDIR", "dstsDirectory", "drcFolder"], "srcFiles": ["sourceDir", "sourcefiles", "rcDir", "rcFiles", "sourceNames", "rcfiles", "sourceFile", "srcNames", " srcfiles", "srcfiles", "sourceFiles", " srcNames", " srcFile", "srcFile", "rcFile", "rcNames"], "position": ["next", "adjust", "head", "select", "parent", "size", "operation", "page", "nl", "open", "range", "iter", "pose", "result", "limit", "object", "request", "move", "loc", "number", "resolution", "response", "r", "resource", "address", "sequence", "Position", "random", "transfer", "patch", "length", "capacity", "job", "area", "offset", "release", "index", "string", "count", "point", "insert", "pointer", "sort", "image", "numbered", "i", "seek", "coord", "speed", "pos", "reset", "item", "type", "manager", "block", "osition", "order", "location", "duration", "unit"], "f": ["folder", "h", "rf", "bf", "d", "feed", "lf", "cf", " F", "function", "l", "fs", "fc", "fp", "b", "sf", "fd", "fr", "part", "tf", "fe", "directory", "n", "r", "info", "name", "filename", "dir", "u", "e", "fn", "t", "F", "m", "v", "j", "c", "file", "i", "fb", "files", "fen", " df", "s", "fa", "p", "fx"], "srcChannel": ["sbchannel", "remotechannel", "srcchannel", "srcBuffer", "sslchannel", "srcClient", "rcChan", " srcChan", "sbChannel", "remoteClient", "inputConsole", " srcConsole", " srcConnection", " srcCh", "rcchannel", "srcChan", "rcChannel", "inputChannel", "sbConnection", "rcConsole", "sslBuffer", "rcCh", "inputchannel", "srcCh", "inputChan", "sbCh", " srcBuffer", "syncConnection", "remoteChannel", "syncChannel", "rcClient", "rcConnection", "srcConsole", " srcchannel", " srcClient", "rcBuffer", "sslChannel", "syncchannel", "sslChan", "syncBuffer", "srcConnection"], "fileName": ["FileInfo", " fileUrl", " fileNum", "fName", "FilePath", "fileUrl", "fPath", "Filename", " filePath", "filename", " filename", "fname", "fileInfo", "fileNum", " fileInfo", "filePath", "FileName", "FILEname", "FileNum", "FILENum", "FileUrl", "FILEName", "FILEInfo", "fUrl"], "dstChannel": [" dndChannel", "drcManager", "ddestchannel", " dndSocket", "ddestChannel", " dstClient", "drcChannel", "drdChannel", "dndchannel", "dstsClient", "dsrcManager", "dsrcchannel", "dstsManager", " drcClient", "ddestConnection", "drdchannel", " drcChannel", "drdConnection", "ddestSocket", "dstSocket", "drcchannel", "dstschannel", "dsrcChannel", " dstSocket", " drcManager", "dstClient", "dndSocket", "dndChannel", " dndConnection", "dsrcClient", "dstManager", "drcClient", " dstConnection", "dstchannel", " dstchannel", " drcchannel", "dstConnection", "drdSocket", " dstManager", " dndchannel", "dndConnection", "dstsChannel"], "buffer": ["reader", "size", "processor", "queue", "memory", "binary", "counter", "reference", "buff", "repeat", "iter", "result", "player", "Buffer", "extra", "limit", "audio", "this", "b", "base", "layer", "data", "loader", "number", "channel", "r", "cover", "resource", "handler", "server", "address", "writer", "uffer", "sequence", "er", "transfer", "null", "batch", "flush", "wave", "comment", "FFER", "buf", "bar", "offset", "slice", "border", "seed", "cache", "file", "builder", "array", "header", "block", "rate", "copy", "pause"], "nr": ["next", "size", "ru", "nl", "num", "rf", "gr", "rx", "uni", "len", "counter", "range", "iter", "eno", "arity", "radius", "lr", "loc", "number", "rn", "no", "n", "r", "nor", "sequence", "inter", "usr", "NR", "nt", "length", "sr", "hr", "nu", "adr", "offset", "nos", "index", "pointer", "rl", "mr", "err", "i", "coord", "pos", "rr", "nb", "order", "ng", "sn", "nil", "inv", "nm", "nc", "rb", "ner", "umber"], "bytes": ["resources", "classes", "cells", "size", "strings", "binary", "Bytes", "pieces", "runs", "lines", "packs", "items", "bps", "b", "bc", "data", "fe", "blocks", "zip", "bs", "objects", "outs", "es", "address", "gets", "vs", "body", "pages", "values", "buf", "rules", "units", "rows", "les", "vals", "its", "limits", "features", "files", "pos", "bits", "tes", "seconds", "reads"]}}
{"id1": "5229696", "id2": "18519247", "code1": "    public static HttpsURLConnection createRequest(String feedUrl, String httpMethod, Map<String, String> headers) throws BuzzIOException {\n        HttpsURLConnection con;\n        try {\n            URL url = new URL(feedUrl);\n            con = (HttpsURLConnection) url.openConnection();\n            con.setRequestMethod(httpMethod);\n            if (headers != null && !headers.isEmpty()) {\n                for (String key : headers.keySet()) {\n                    con.setRequestProperty(key, headers.get(key));\n                }\n            }\n        } catch (IOException e) {\n            throw new BuzzIOException(e);\n        }\n        return con;\n    }\n", "code2": "    public List<PathObject> fetchPath(PathObject parent) throws NetworkException {\n        if (parent.isFetched()) {\n            return parent.getChildren();\n        } else if (!\"d\".equals(parent.getType())) {\n            return null;\n        }\n        HttpClient client = HttpConfig.newInstance();\n        HttpGet get = new HttpGet(HttpConfig.bbsURL() + HttpConfig.BBS_0AN + parent.getPath());\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            Document doc = XmlOperator.readDocument(entity.getContent());\n            BBSBodyParseHelper.parsePathList(doc, parent);\n            return parent.getChildren();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"feedUrl": ["readerUr", "httpAddress", "formAddress", "readerurl", "formUrl", "feedFile", "FeedUrl", "readerFeed", " feedURL", "Feedurl", " feedAddress", "rssUrl", "feedUr", "httpUrl", "feedURL", " feedFile", "readerUrl", "FeedUr", "httpFile", "rssFeed", "rssurl", "formURL", "FeedFeed", "formFile", "httpURL", "feedurl", "feedFeed", "feedAddress", "rssUr"], "httpMethod": [" httpStr", "httpStr", " httpName", "requestMethods", " httpMETHOD", "phpMethod", "phpName", "phpmethod", " httpMethods", "phpMETHOD", "httpMethods", " httpmethod", "requestmethod", "internalStr", "businessmethod", "httpmethod", "requestStr", "internalmethod", "internalMethod", "businessName", "businessMETHOD", "httpName", "httpMETHOD", "requestMethod", "businessMethod", "internalMethods"], "headers": ["resources", "head", "relations", "host", "strings", "events", "breaks", "dict", "frames", "authors", "lines", "keys", "properties", "http", "params", "types", "writers", "builders", "hers", "stats", "heads", "models", "drivers", "rooms", "groups", "users", "plugins", "results", "members", "ppers", "rs", "values", "names", "rules", "fields", "rows", "docs", "ers", "cache", "features", "limits", "details", "files", "header", "workers", "ids", "parts", "metadata", "terms"], "con": ["an", "en", "connection", "uc", "cm", "open", "cf", "core", "co", "conn", "fc", "cas", "http", "request", "client", "bc", "login", "channel", "ctrl", "cp", "cover", "xc", "ctx", "can", "el", "cn", "pc", "cons", "conf", "cur", "init", "func", "rc", "CON", "fn", "ocon", "syn", "fl", "lc", "session", "run", "close", "com", "cr", "connect", "cache", "c", "don", "ran", "un", "conv", "create", "cc", "ca", "on", "fa", "coll", "ac", "Con"], "url": ["feed", "rel", "connection", "uc", "plug", "build", "ll", " curl", "conn", "l", "http", "client", "b", "base", "loc", "f", "ctrl", "channel", "resource", "server", "config", "el", "ur", "gl", "rc", "log", "cl", "bel", "fl", "ls", "lc", "rl", "obj", "file", "ssl", "context", "uri", "URL", "Url", "www", "blog", "web", "sl"], "key": ["str", "id", "link", "pe", "net", "keys", "k", "sign", "in", "object", "val", "op", "part", "row", "ver", "data", "by", "Key", "class", "r", "match", "pair", "ie", "feature", "child", "info", "KEY", "element", "x", "section", "name", "ace", "other", "exp", "act", "cookie", "step", "ax", "col", "index", "string", "rule", "change", "list", "code", "service", "type", "field", "value", "any", "ip", "entry"]}}
{"id1": "18354823", "id2": "14647876", "code1": "    private String storeEditionFile(InputStream in) throws IOException {\n        String datadir = getCqPropertiesBeanSpring().getDatadir() + File.separator + \"attachments\" + File.separator;\n        File attachmentsDir = new File(datadir);\n        attachmentsDir.mkdirs();\n        File storedEditionFile = File.createTempFile(\"edition_import_\", \".tmp\", attachmentsDir);\n        FileOutputStream out = new FileOutputStream(storedEditionFile);\n        IOUtils.copyLarge(in, out);\n        IOUtils.closeQuietly(out);\n        IOUtils.closeQuietly(in);\n        return storedEditionFile.getAbsolutePath();\n    }\n", "code2": "    public static void copyFile(IPath fromFileName, IPath toFileName) throws IOException {\n        File fromFile = fromFileName.toFile();\n        File toFile = toFileName.toFile();\n        if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFileName);\n        if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n        if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) throw new IOException(\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n        }\n        InputStream from = null;\n        OutputStream to = null;\n        try {\n            from = new BufferedInputStream(new FileInputStream(fromFile));\n            to = new BufferedOutputStream(new FileOutputStream(toFile));\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["source", "plus", "read", "reader", "id", "url", "input", "inc", "din", "token", "connection", "io", "doc", "con", "b", "request", "this", "part", "login", "as", "loader", "data", "In", "version", "stream", "inas", "r", "again", "resource", "work", "config", "inner", "init", "ins", "ini", "m", "ex", "up", "image", "cache", "c", "file", "record", "i", "IN", "err", "is", "bin", "pass"], "datadir": [" datasdir", "datADirs", "Datadire", "datendir", " datadIR", "datADire", "dataddir", "datacirs", "datadadir", "datacire", " datasIR", "Datadirs", "datacIR", "datasirs", "datadaire", " dataddir", "Datadir", " datadirs", "Datacir", "Datacirs", " datasir", "datadire", "Datacdir", "datenddir", " datasirs", "datadIR", "datasdir", "datendirs", "Datacire", "datasIR", "datADir", "datadairs", "datadair", "datADdir", "datacdir", "datendIR", "datadirs", "datacir", "Dataddir", "datasir"], "attachmentsDir": ["attachmentDir", "achmentDirectory", "attachmentsDirectory", "partmentDirectory", "attachitionsDir", "achmentArea", "attachachmentdir", "achmentdir", "partmentsFile", "partmentsDirectory", "achachmentFolder", "achachmentFile", "achmentDir", "attachmentdir", "achmentsArea", "attachmentDirectory", "achmentsdir", "attachementsDirectory", "attachachmentDir", "attachmentsFile", "partmentsdir", "achmentsFolder", "attachmentsdir", "attachementsdir", "attachitionsDirectory", "attachachmentDirectory", "achachmentDir", "attachementsDir", "partmentsDir", "attacheesDir", "attachmentFile", "achmentsFile", "achmentsDir", "attachmentsArea", "attachachmentFile", "attachmentArea", "attachementsArea", "attachmentFolder", "attachachmentFolder", "attachmentsFolder", "attachachmentArea", "attachitionsFolder", "achachmentDirectory", "partmentdir", "attachitionsdir", "attacheesFile", "partmentDir", "achmentsDirectory", "partmentFile", "attacheesDirectory", "attachitionsFile", "attacheesdir"], "storedEditionFile": ["storedEditionUnit", "storedEditionsfile", "storedEditionsDirectory", "storedConditionF", "storedEdmissionFolder", "storedEdignmentF", "storedEditionsDir", "storedEditionalUnit", "storedCondignmentFile", "storedEditionF", "storedAdditionsUnit", "storedAdditionfile", "storedEditionStream", "storedEditionFiles", "storedEdmissionFile", "storedConditionFolder", "storedAdditionsFile", "storedAdditionsfile", "storedAdditionUnit", "storedEdortionFile", "storedEdmissionFiles", "storedAdditionsStream", "storedEdignmentFiles", "storedEdititionDir", "storedEdititionFile", "storedEditionDirectory", "storedEdmissionF", "storedEdachmentUnit", "storedEditionalStream", "storedEdititionDirectory", "storedConditionDir", "storedEdignmentDirectory", "storedEditionalfile", "storedEditionalFile", "storedEdortionFolder", "storedEditionsUnit", "storedEdortionDir", "storedAdditionFile", "storedEditionfile", "storedEdachmentFile", "storedEdignmentFolder", "storedCondignmentFolder", "storedEdachmentfile", "storedCondignmentDir", "storedEdachmentStream", "storedEditionFolder", "storedConditionFile", "storedEdmissionDir", "storedEditionsFile", "storedEditionsStream", "storedEditignmentDirectory", "storedEdignmentDir", "storedEdignmentFile", "storedEditionDir", "storedEditignmentFile", "storedEdititionFiles", "storedCondignmentF", "storedEditignmentDir", "storedEditignmentFiles", "storedEdortionF", "storedEditionsFiles", "storedAdditionStream", "storedEdmissionDirectory"], "out": ["page", "parent", "plain", "url", "default", "write", "connection", "io", "output", "outer", "conn", "object", "this", "client", "base", "f", "data", "OUT", "Out", "again", "outs", "resource", "server", "external", "writer", "inner", "exec", "sync", "null", "init", "full", "o", "password", "a", "ex", "temp", "v", "up", "image", "obj", "cache", "file", "error", "i", "err", "bin", "copy", "line", "ext"]}}
{"id1": "12039035", "id2": "23299412", "code1": "    public static ArrayList<Principal> importPrincipals(String urlString) {\n        ArrayList<Principal> results = new ArrayList<Principal>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</Principal>\")) {\n                    Principal principal = ProfileParser.parsePrincipal(buff.toString());\n                    results.add(principal);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "code2": "    public List<String> getLinks(String url) {\n        List<String> links = new ArrayList<String>();\n        try {\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n            String s;\n            StringBuilder builder = new StringBuilder();\n            while ((s = bufferedReader.readLine()) != null) {\n                builder.append(s);\n            }\n            Matcher tagmatch = htmltag.matcher(builder.toString());\n            while (tagmatch.find()) {\n                Matcher matcher = link.matcher(tagmatch.group());\n                matcher.find();\n                String link = matcher.group().replaceFirst(\"href=\\\"\", \"\").replaceFirst(\"\\\">\", \"\");\n                if (valid(link)) {\n                    links.add(makeAbsolute(url, link));\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "label": 1, "substitutes": {"urlString": ["urlstring", "urlUrl", "fileFile", " urlUrl", " urlLine", "fileUrl", "httpLine", "webUrl", "httpUrl", "filestring", "urlFile", "webFile", "webString", "URLLine", "fileString", "URLString", " urlstring", "httpFile", "urlLine", "URLUrl", "httpString", "webstring", "httpstring", "URLstring"], "results": ["resources", "tests", "relations", "works", "successful", "ings", "reports", "errors", "authors", "runs", "result", "lines", "items", "properties", "params", "styles", "prints", "data", "response", "objects", "changes", "es", "raw", "models", "gets", "grades", "groups", "boxes", "users", "owners", "members", "values", "locks", "rules", "roots", "rows", "RESULTS", "list", "features", "vals", "tops", "Results", "helps", "details", "vers", "ids", "services", "ps", "res", " Results", "reads"], "url": ["source", "page", "ball", "reader", "browser", "feed", "connection", "buffer", "plug", "open", "io", "conn", "l", "http", "b", "base", "f", "loader", "stream", "r", "zip", "resource", "server", "address", "el", "ur", "e", "log", "api", "bel", "ls", "string", "path", "socket", "file", "uri", "ssl", "URL", "service", "Url", "www", "sl"], "in": ["source", "read", "reader", "h", "input", "inc", "din", "buffer", "io", "doc", "l", "out", "b", "login", "f", "as", "fe", "In", "data", "stream", "again", "r", "ref", "resource", "inner", "ins", "e", "gin", "ini", "socket", "file", "ssl", "i", "IN", "inn", "lin", "bin", "s"], "buff": ["utf", "cb", "sb", "h", "tmp", "bf", "append", "txt", "mb", "feed", "buffer", "tab", "bind", "Buffer", "bg", "pb", "app", "b", "bug", "f", "base", "cpp", "bm", "ref", "fw", "obb", "work", "ctx", "raw", "info", "off", "fam", "Buff", "bb", "flow", "ob", "amp", "ph", "text", "uf", "bound", "buf", "bag", "gb", "eb", "load", "ab", "wb", "fb", "raf", "pp", "front", "lab", "uff", "nb", "boot", "ff", "nd", "bin", "rb", "null"], "line": ["source", "page", "entry", "value", "split", "nl", "link", "pe", "buffer", "lf", "lines", "message", "l", "letter", "object", "char", "end", "LINE", "cell", "Line", "row", "profile", "f", "base", "data", "part", "inline", "style", "response", "email", "name", "e", "unit", "log", "cl", "text", "comment", "content", "lc", "le", "key", "string", "rule", "file", "parse", "code", "character", "item", "header", "valid", "block", "lin", "look", "str", "sl", "pass"], "principal": ["prindential", "princature", "pripipal", "peincipal", "prominchip", "prificipal", "peindipal", "pripature", "promincipal", "peindential", "prithip", "priphip", "prindhip", "promincature", "prindiple", "pritipal", "prominciple", "prassipal", "promennhip", "prifichip", "princential", "pritiple", "princhip", "prennature", "prasship", "promennipal", "prassature", "promennature", "promenniple", "peindiple", "pritential", "prificiple", "pripiple", "peindhip", "prassiple", "prennhip", "prennipal", "peinciple", "peinchip", "principle", "prenniple", "prificential", "prindipal", "peincential"]}}
{"id1": "16870482", "id2": "23213941", "code1": "    private void populateSessionId() throws IOException, java.net.MalformedURLException {\n        String general_search_url = \"http://agricola.nal.usda.gov/cgi-bin/Pwebrecon.cgi?\" + \"DB=local&CNT=1&Search_Arg=RNAi&Search_Code=GKEY&STARTDB=AGRIDB\";\n        String sidString = \"\", inputLine;\n        BufferedReader in = new BufferedReader(new InputStreamReader((new URL(general_search_url)).openStream()));\n        while ((inputLine = in.readLine()) != null) {\n            if (inputLine.startsWith(\"<INPUT TYPE=HIDDEN NAME=PID VALUE=\")) {\n                sidString = (inputLine.substring(inputLine.indexOf(\"PID VALUE=\") + 11, inputLine.indexOf(\">\") - 1));\n            }\n        }\n        sessionId = Integer.parseInt(sidString.trim());\n    }\n", "code2": "    @Override\n    protected void writeSnapshot(final String message, final String details) {\n        try {\n            final URL url = proxyAddress == null ? new URL(url_spec) : new URL(\"http\", proxyAddress, proxyPort, url_spec);\n            LOG.info(\"connect to \" + url);\n            final URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            final HttpQueryWriter out = new HttpQueryWriter(connection.getOutputStream());\n            out.addParameter(\"error\", message);\n            out.addParameter(\"trace\", details);\n            out.close();\n            final InputStream in = connection.getInputStream();\n            int c;\n            final StringBuffer result = new StringBuffer();\n            while ((c = in.read()) != -1) {\n                result.append((char) c);\n            }\n            LOG.info(result);\n            in.close();\n        } catch (final UnknownHostException e) {\n            LOG.info(\"could not find host (unknown host) to submit log to\");\n        } catch (final IOException e) {\n            LOG.debug(\"i/o problem submitting log\", e);\n        }\n    }\n", "label": 0, "substitutes": {"general_search_url": ["general_searchlibURL", "general_searchurlstr", "general_search_config", "general_searchurlurl", "general_Search_url", "general_Search_URL", "general_searchlibconfig", "general_searchurlfield", "general_search_URL", "general_Search_str", "general_Search_field", "general_Search_config", "general_searchliburl", "general_search_field", "general_search_str"], "inputLine": ["sourcePass", "outputStream", "InputPass", "InputLine", "inLine", " inputBlock", "sourceBlock", "rawName", " inputPass", "InputName", "requestStream", " inputName", "sourceLine", "outputline", "inputline", "outputFile", "outputLine", "inputName", " inputFile", " inputL", "inputPass", "inline", "InputLook", "outputString", "rawLine", "inputString", "InputL", "inBlock", " inputline", "requestLine", "Inputline", "rawPass", "InputFile", "rawline", "requestString", " inputStream", "inputL", "sourceL", "requestline", "InputString", "outputL", "InputBlock", "inLook", "inputLook", "inputFile", "inputBlock", "inputStream", " inputLook", " inputString", "inString"], "in": ["source", "read", "reader", "h", "id", "url", "input", "inc", "din", "connection", "buffer", "min", "nin", "l", "con", "out", "b", "fr", "login", "f", "data", "In", "version", "stream", "again", "r", "resource", "server", "inner", "ins", "container", "t", "ini", "m", "ex", "kin", "c", "socket", "ssl", "i", "IN", "g", "inn", "rin", "bin", "s", "line"], "sidString": ["sessionService", "sidStr", "silString", " sidBlock", "sidLine", "silLine", " sidLine", "idString", "sidData", "idService", "sidstring", "sidValue", "idLine", "sessionLine", "sessionstring", " sidData", "sessionStr", "silValue", "sidService", "identstring", " sidstring", "identLine", "sidBlock", "idData", "sessionString", "sessionData", "idValue", " sidService", "sessionValue", "silStr", "sessionBlock", "identString", "identBlock", "idStr"], "sessionId": [" sessionInfo", "sessionUrl", "siteName", "sessionInfo", "sessionName", "essionName", "siteInfo", "essionInfo", "essionId", "siteUrl", " sessionUrl", "siteId", " sessionName", "essionUrl"]}}
{"id1": "8006559", "id2": "11066054", "code1": "    private final void findSubclasses(URL location, String packageName, Class superClass, Set setOfClasses) {\n        synchronized (results) {\n            String fqcn = searchClass.getName();\n            List knownLocations = new ArrayList();\n            knownLocations.add(location);\n            for (int loc = 0; loc < knownLocations.size(); loc++) {\n                URL url = (URL) knownLocations.get(loc);\n                File directory = new File(url.getFile());\n                if (directory.exists()) {\n                    File[] files = directory.listFiles(CLASSES_ONLY);\n                    for (int i = 0; i < files.length; i++) {\n                        String filename = files[i].getName();\n                        String classname = filename.substring(0, filename.length() - 6);\n                        try {\n                            if (!fqcn.equals(packageName + \".\" + classname)) {\n                                Class c = callClassForName(packageName + \".\" + classname);\n                                manageClass(setOfClasses, superClass, c, url);\n                            }\n                        } catch (Throwable t) {\n                            errors.add(t);\n                        }\n                    }\n                } else {\n                    try {\n                        JarURLConnection conn = (JarURLConnection) url.openConnection();\n                        JarFile jarFile = conn.getJarFile();\n                        Enumeration e = jarFile.entries();\n                        while (e.hasMoreElements()) {\n                            JarEntry entry = (JarEntry) e.nextElement();\n                            String entryname = entry.getName();\n                            if (!entry.isDirectory() && entryname.endsWith(\".class\")) {\n                                String classname = entryname.substring(0, entryname.length() - 6);\n                                if (classname.startsWith(\"/\")) classname = classname.substring(1);\n                                classname = classname.replace('/', '.');\n                                try {\n                                    if (!fqcn.equals(classname)) {\n                                        Class c = callClassForName(classname);\n                                        manageClass(setOfClasses, superClass, c, url);\n                                    }\n                                } catch (Throwable t) {\n                                    errors.add(t);\n                                }\n                            }\n                        }\n                    } catch (IOException ioex) {\n                        errors.add(ioex);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"location": ["language", "source", "folder", "parent", "route", "site", "link", "connection", "reference", "l", "LOC", "object", "home", " Location", "root", "base", "layer", "region", "remote", "resource", "handler", "server", "address", "Location", "module", "selection", "area", "localhost", "string", "path", "node", "image", "library", "document", "uri", "command", "database", "position", "ocation"], "packageName": ["folderName", "directoryName", "directorySize", "folderString", "pkgname", "pluginNames", "containerName", "directoryname", "packagePath", "documentPath", "PackagePath", "documentShare", "packagename", "packageNames", "packageShare", "pluginName", "packageString", "environmentname", "documentName", "containerSize", " packageShare", "pluginname", "directoryNames", "foldername", "environmentString", " packagename", "Packagename", "containerNames", "pkgString", "packageSize", "pluginSize", "containername", "pkgName", "PackageName", "environmentName", " packagePath", "PackageShare", "documentname"], "superClass": ["specialClass", "superPackage", " superclass", "superUser", "superCode", "superMethod", "Superclass", "specialMethod", "SuperMethod", " superMethod", "specialPackage", "SuperPackage", "subCode", "specialUser", "SuperCode", "SuperClass", "specialPass", " superUser", " superPackage", "SuperUser", "SuperPass", "superclass", " superCode", "subClass", "subclass", " superPass", "superPass"], "setOfClasses": ["setofProcessES", "setOfclasses", "setOfclasss", "setOfCLASSions", "setofclassceptions", "setOfCLets", "setOfCLASSes", "setOfCLES", "setofClassets", "setOfClassions", "setofClassES", "setOfCLASSclasses", "setOfClassets", "setOfNamesES", "setOfTextets", "setOfClassES", "setOfProjectES", "setOfUsclasses", "setOfNameses", "setOfProjectceptions", "setOfTextes", "setOfUsions", "setOfProcessions", "setofclassES", "setOfProcesses", "setOfClassclasses", "setofclasses", "setofProcesses", "setOfClassceptions", "setOfCLes", "setOfCLs", "setofProcessions", "setOfProcessES", "setOfProcessclasses", "setofProcessclasses", "setOfNamess", "setofClassclasses", "setOfclassES", "setOfclassceptions", "setofclassets", "setOfNamesets", "setOfUses", "setOfProjectes", "setOfProjectets", "setofClasses", "setOfUsES", "setOfClasss", "setOfTextES", "setOfCLASSES", "setofClassions", "setOfclassets", "setofClassceptions", "setOfTextceptions"], "fqcn": ["fqDN", "fqudn", "FQct", "fqgn", "FQhn", "fkgDN", "fqns", "fQnc", "Fqdn", "Fqgn", "fQct", "fQgn", "fqualnc", "favhn", "fqugn", "FQdn", "FQns", "fqdn", "fqhn", "fkgct", "fqualdn", "fquns", "Fqcn", "fqualct", "Fqns", "fqnc", "fqualDN", "fwgn", "FqDN", "FQnc", "FQgn", "favcn", "fqualhn", "fwns", "Fqhn", "fkgdn", "fwcn", "fQhn", "fQns", "FQDN", "fqucn", "fQdn", "favnc", "fwdn", "fqualcn", "fQcn", "fkgcn", "favdn", "Fqnc", "fQDN", "FQcn", "Fqct", "fqct"], "knownLocations": [" knownLocation", "knownlocation", "knownCloci", " knownLibraries", "knownAllayers", "knowLocations", "knownLayers", " knownLoocations", "knownLoayers", "knownLuoci", "knownLococations", "knownBlayers", "unknownLocation", "knownClocations", "knownAllocations", "knownLocate", "knowBlayers", "knownLusters", "knownClusters", "knownAllanguages", "knownloci", " knownBlocation", "knownLocayers", "knownLocusters", "unknownCloci", "knownClocate", " knownBlayers", "knowLayers", "knownGlocations", " knownLusters", "knownLoanguages", "knownBlocation", " knownBlocations", "unknownLoci", "knownLoocations", "knownLuocate", "knownClibraries", "knownLibraries", "knownLoci", "knownLoibraries", "unknownLocate", "knowLocation", "knownGlocation", "knowBlocation", "unknownClocations", "knownLocation", "knownAllocation", "knownLoocation", "knownlocate", "knownBlocations", "knownClocation", "knownLuocation", "knownLococation", "knownBlations", "knownGlayers", "knownLuocations", "knowLanguages", " knownLousters", "knownBlanguages", " knownBlations", "unknownClocation", " knownLoibraries", "unknownClocate", "knowBlocations", "knownLations", "unknownLocations", "knowBlanguages", " knownLoocation", "knownlocations", "knownGlations", " knownLayers", "knownLousters", "knownLanguages", "knownLocibraries", " knownLations"], "loc": ["num", "la", "uc", "lang", "lit", "ld", "iter", "co", "hi", "lim", "fc", "src", "l", "LOC", "val", "bc", "lr", "oc", "ec", "ref", "zip", "ctx", "sc", "tx", "Loc", "Location", "lo", "rc", "ci", "other", "LC", "ok", "exp", "cl", "length", "lc", "col", "rl", "oci", "pos", "local", "lb", "pl", "coll", "bl"], "url": ["source", "host", "page", "id", "user", "link", "connection", "feed", "download", "plug", "xml", "ll", "result", "l", "view", "http", "object", "client", "bc", "base", "f", "channel", "layer", "loader", "zip", "resource", "org", "server", "config", "address", "el", "name", "ur", "dir", "gl", "event", "log", "cl", "api", "fl", "job", "ls", "string", "path", "image", "rl", "obj", "html", "file", "uri", "ssl", "socket", "cloud", "URL", "q", "service", "manager", "Url", "www", "web", "sl"], "directory": ["folder", "journal", "d", "connection", "download", "director", "Directory", "l", "out", "home", "description", "f", "layer", "application", "data", "class", "system", "resource", "prefix", "archive", "server", "config", "editor", "creator", "Location", "machine", "name", "volume", "dir", "direction", "direct", "container", "whatever", "path", "document", "image", "library", "uri", "file", "URL", "manager", "database", "s", "collection"], "files": ["balls", "resources", "classes", "Files", "split", "errors", "sections", "lines", "keys", "l", "fs", "items", "http", "books", "lib", "types", "sf", "sheets", "bugs", "f", "ions", "facts", "data", "blocks", "bytes", "bs", "objects", "es", "ports", "boxes", "users", "ins", "results", "pages", "locks", "names", "ls", "fields", "words", "rows", "all", "headers", "thumbnails", "ips", "file", "iles", "fires", "s"], "i": ["id", "si", "d", "multi", "iu", "hi", "io", "phi", "yi", "l", "y", "b", "f", "data", "di", "bi", "I", "ti", "ni", "gi", "ai", "oi", "info", "ji", "ix", "ui", "ci", "u", "ini", "lc", "li", "v", "xi", "key", "ri", "index", "j", "uri", "ii", "vi", "pi", "fi", "mi", "ip", "p", "ie"], "filename": ["source", "folder", "attr", "route", "bf", "txt", "connection", "download", "username", "l", "fp", "sf", "f", "loader", "phrase", "version", "class", "n", "resource", "Filename", "prefix", "word", "name", "fn", "length", "sl", "lc", "ls", "string", "path", "document", "il", "file", "uri", "subject", "nil", "s", "fil"], "classname": ["longpart", "classkey", "locknamed", " classnamed", "classword", "lassname", " classsource", "objectkey", "bookName", "lockname", "filesize", " classbase", "CLASSname", "fullname", "fileword", "fileurl", "nameName", " classurl", "filebase", "objectname", "booknamed", " classsize", "entryName", "stringname", "filepath", "CLASSnamed", "backn", "filen", "stringName", "structname", "booklayer", "nameword", "classlayer", "lockbase", "stringnamed", "ClassName", "fullName", "filekey", "namename", "capName", "classbase", "classnamed", "classn", "bookname", "backword", "backName", " classkey", "lasslayer", "CLASSlayer", "entrysize", "structpart", "capurl", " classpath", "filelayer", "classurl", "classsource", "fileName", "classpath", "backname", "structNAME", " classn", " classword", "fullnamed", "className", "filesource", "lockName", "Classname", "Classnamed", "lassName", "cappath", "classsize", "fullsize", "capname", "Classsize", "classpart", "CLASSName", " classlayer", "namesource", " classpart", "locksize", " className", "objectName", " classNAME", "stringsize", "classNAME", "longNAME", "entrynamed", "longname"], "c": ["h", "d", "ic", "uc", "cu", "cf", "co", "cat", "k", "fc", "ct", "l", "y", "con", "object", "b", "out", "f", "ctrl", "ec", "cp", "n", "r", "class", "sc", "ac", "config", "pc", "cn", "u", "ci", "o", "cl", "cs", "t", "ch", "m", "lc", "content", "v", "z", "col", "cr", "code", "g", "ce", "cc", "ca", "s", "collection", "coll", "p", "C"], "conn": ["h", "connection", "open", "uc", "cf", "io", "l", "ct", "con", "client", "b", "fr", "ca", "ctrl", "cp", "n", "enc", "ctx", "config", "cn", "conf", "sync", "ci", "rc", "nt", "act", "ch", "cli", "col", "connect", "j", "ssl", "db", "lock", "conv", "Connection", "Conn", "nc", "coll", "p"], "jarFile": ["Jarfile", "entryLine", "jsonFiles", " jarFiles", "jsonFile", " jarfile", " jarDir", "entryFiles", "jarfile", "JarFile", "JarDir", "entryfile", "entryFile", "jarDir", "jsonfile", "jarLine", " jarLine", "JarLine", "jarFiles", "jsonDir", "JarFiles"], "e": ["ea", "h", "en", "d", "pe", "ente", "be", "edge", " te", "ee", " pe", "l", "que", "ev", "b", "end", "ue", "f", "E", "fe", "ec", "n", "r", " E", "ie", "es", "esi", "he", "el", "element", "er", "ne", " r", "ge", "s", "de", "o", "ae", "oe", "m", "je", "se", "le", "eb", "ze", "g", "eu", "me", "te", "ed", "ele"], "entry": ["next", "page", "route", "reader", "term", "d", "pe", "line", "ent", "connection", "si", "be", "cat", "ry", "l", "in", "object", "cell", "part", "row", "f", "data", "class", "r", "zip", "archive", "info", "inner", "element", "section", "name", "ge", "it", "de", "exp", "nt", "enter", "je", "v", "key", "se", "image", "obj", "file", "record", "parse", "or", "Entry", "service", "field", "ie"], "entryname": [" entryName", "entryno", "Entryfull", "entrydata", "classinfo", "elementpath", "entername", "entryfull", "elementdata", "elementname", "elementnumber", "cellName", "Entrydata", "entryName", "entrynumber", "elementinfo", "Entrynumber", "systemno", "enterdata", "classpath", " entryinfo", "Entryname", "cellname", " entryobject", "enternumber", " entryno", "systemobject", "cellno", "enterfull", " entryfull", "cellobject", "entrypath", "className", "elementfull", " entrypath", "systemname", "entryobject", "enterName", "entryinfo", " entrydata", "elementName", "systemName"]}}
{"id1": "7902699", "id2": "15605423", "code1": "    public static List<String> getLevelIndex(URL fetchUrl) {\n        List<String> levelNames = new ArrayList<String>();\n        BufferedReader bufferedreader;\n        try {\n            URLConnection urlconnection = fetchUrl.openConnection();\n            urlconnection.setConnectTimeout(30000);\n            if (urlconnection.getContentEncoding() != null) {\n                bufferedreader = new BufferedReader(new InputStreamReader(urlconnection.getInputStream(), urlconnection.getContentEncoding()));\n            } else {\n                bufferedreader = new BufferedReader(new InputStreamReader(urlconnection.getInputStream(), \"utf-8\"));\n            }\n        } catch (IOException _ex) {\n            System.err.println(\"HexTD::readFile:: Can't read from \" + fetchUrl);\n            return levelNames;\n        }\n        String sLine1;\n        try {\n            while ((sLine1 = bufferedreader.readLine()) != null) {\n                if (sLine1.trim().length() != 0) {\n                    levelNames.add(sLine1);\n                }\n            }\n        } catch (IOException ex) {\n            Logger.getLogger(MapLoaderClient.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return levelNames;\n    }\n", "code2": "    private static void generateGIF(Connection con, String category, String area_code, String topic_code, String timeseries, String diff_timeseries, Calendar time, String area_label, String raster_label, String image_label, String note, Rectangle2D bounds, Rectangle2D raster_bounds, String source_filename, String diff_filename, String legend_filename, String output_filename, int output_maximum_size) throws SQLException, IOException {\n        System.out.println(\"ImageCropper.generateGIF begin\");\n        MapContext map_context = new MapContext(\"test\", new Configuration());\n        try {\n            Map map = new Map(map_context, area_label, new Configuration());\n            map.setCoordSys(ProjectionCategories.default_coordinate_system);\n            map.setPatternOutline(new XPatternOutline(new XPatternPaint(Color.white)));\n            String type = null;\n            RasterLayer rlayer = getRasterLayer(map, raster_label, getLinuxPathEquivalent(source_filename), getLinuxPathEquivalent(diff_filename), type, getLinuxPathEquivalent(legend_filename));\n            map.addLayer(rlayer, true);\n            map.setBounds2DImage(bounds, true);\n            Dimension image_dim = null;\n            image_dim = new Dimension((int) rlayer.raster.getDeviceBounds().getWidth() + 1, (int) rlayer.raster.getDeviceBounds().getHeight() + 1);\n            if (output_maximum_size > 0) {\n                double width_factor = image_dim.getWidth() / output_maximum_size;\n                double height_factor = image_dim.getHeight() / output_maximum_size;\n                double factor = Math.max(width_factor, height_factor);\n                if (factor > 1.0) {\n                    image_dim.setSize(image_dim.getWidth() / factor, image_dim.getHeight() / factor);\n                }\n            }\n            map.setImageDimension(image_dim);\n            map.scale();\n            image_dim = new Dimension((int) map.getBounds2DImage().getWidth(), (int) map.getBounds2DImage().getHeight());\n            Image image = null;\n            Graphics gr = null;\n            image = ImageCreator.getImage(image_dim);\n            gr = image.getGraphics();\n            try {\n                map.paint(gr);\n            } catch (Exception e) {\n                Debug.println(\"map.paint error: \" + e.getMessage());\n            }\n            String gif_filename = \"\";\n            try {\n                gif_filename = formatPath(category, timeseries, output_filename);\n                new File(new_filename).mkdirs();\n                new GifEncoder(image, new FileOutputStream(gif_filename)).encode();\n            } catch (IOException e) {\n                Debug.println(\"ImageCropper.generateGIF e: \" + e.getMessage());\n                throw new IOException(\"GenerateGIF.IOException: \" + e);\n            }\n            PreparedStatement pstmt = null;\n            try {\n                String delete_raster = \"delete raster_layer where \" + \"label='\" + gif_name.trim() + \"' and category='\" + category.trim() + \"' and area_code=' \" + area_code.trim() + \"'\";\n                pstmt = con.prepareStatement(delete_raster);\n                boolean del = pstmt.execute();\n                pstmt.close();\n                String insert_raster = \"insert into RASTER_LAYER \" + \"values(RASTER_LAYER_ID.nextval, ?, ?, ?, \" + \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \" + \"SYSDATE, ?)\";\n                pstmt = con.prepareStatement(insert_raster);\n                pstmt.setString(1, gif_name);\n                pstmt.setString(2, category);\n                pstmt.setString(3, area_code);\n                pstmt.setString(4, topic_code);\n                if (time == null) {\n                    pstmt.setNull(5, java.sql.Types.DATE);\n                } else {\n                    pstmt.setDate(5, new java.sql.Date(time.getTimeInMillis()));\n                }\n                pstmt.setString(6, timeseries);\n                pstmt.setString(7, gif_filename);\n                pstmt.setNull(8, java.sql.Types.INTEGER);\n                pstmt.setNull(9, java.sql.Types.INTEGER);\n                pstmt.setDouble(10, raster_bounds.getX());\n                pstmt.setDouble(11, raster_bounds.getY());\n                pstmt.setDouble(12, raster_bounds.getWidth());\n                pstmt.setDouble(13, raster_bounds.getHeight());\n                pstmt.setString(14, note);\n                int sequence = 0;\n                if (gif_name.endsWith(\"DP\")) {\n                    sequence = 1;\n                } else if (gif_name.endsWith(\"DY\")) {\n                    sequence = 2;\n                } else if (gif_name.endsWith(\"DA\")) {\n                    sequence = 3;\n                }\n                pstmt.setInt(15, sequence);\n                pstmt.executeUpdate();\n            } catch (SQLException e) {\n                Debug.println(\"SQLException occurred e: \" + e.getMessage());\n                con.rollback();\n                throw new SQLException(\"GenerateGIF.SQLException: \" + e);\n            } finally {\n                pstmt.close();\n            }\n        } catch (Exception e) {\n            Debug.println(\"ImageCropper.generateGIF e: \" + e.getMessage());\n        }\n        System.out.println(\"ImageCropper.generateGIF end\");\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["bachUrl", "refetchUr", "faitURL", "FetchUrl", "fachUr", "refachUrl", "forkUrl", "fractURL", "betchUrl", "betchURL", "Fetchurl", "FetchFile", "fetchFile", "betchurl", "fachUrl", "fractUrl", "FetchURL", "fachURL", "refetchURL", "refetchurl", "faitUr", "refachUr", "forkurl", "faiturl", "bachURL", "fetchurl", "forkURL", "refachurl", "faitUrl", "fractFile", "refetchUrl", "bachurl", "betchUr", "bachUr", "fetchUr", "fetchURL", "fracturl", "forkUr", "faitFile", "fachurl", "refachURL"], "levelNames": [" levelFeatures", "levelWords", " levelMembers", "levelnames", " levelnames", " levelWords", "levelInfo", "indexNames", "entrynames", "indexWords", "logFiles", "LevelNames", "indexKeys", "lognames", "levelsNames", "listNames", "fileMembers", "levelsFeatures", " levelList", " levelNs", "levelFiles", " levelKeys", "levelsTags", "entryNames", "LevelList", "LevelNs", "levelKeys", " levelFiles", "fileWords", "logStars", "lineNames", "levelList", "levelFeatures", " levelStars", "levelNs", "indexMembers", "levelsnames", "listList", "LevelInfo", " levelInfo", "levelMembers", "listInfo", "levelTags", "logNames", "levelStars", "entryTags", "lineFiles", " levelTags", "linenames", "entryFeatures", "listNs", "lineStars", "fileNames", "fileKeys"], "bufferedreader": ["Buffereder", "buffendedwriter", " buffererreader", " buffererReader", " buffenedstream", "buffererstream", "Buffenedreader", " buffenedwriter", "bufferingreader", "bufforedreader", "bufferredauthor", " bufferedstream", "buffendedReader", "Bufferedstream", "BufferedReader", "buffererReader", "buffenedauthor", " buffererwriter", "bufferredreader", "buffredReader", "bufferingReader", "buffleder", "buffenedwriter", "buffendedreader", "bufferedauthor", "bufferingwriter", "Buffenedwriter", "buffenedstream", "buffeneder", "buffendeder", "bufferredwriter", "bufferedstream", " buffererauthor", " bufferedReader", "Buffeneder", "buffenedreader", "bufferedwriter", "buffererauthor", "Buffenedstream", "bufferredReader", "buffredwriter", "buffledreader", "buffledwriter", " bufferedauthor", "buffredreader", "buffererreader", "Bufferedreader", "buffererwriter", " buffenedReader", " bufferedwriter", "buffenedReader", "buffledReader", "bufforedstream", "bufforedwriter", "BuffenedReader", " buffenedreader", "Bufferedwriter", "buffredstream", "buffereder", "bufferingstream", "bufforedReader", "bufferedReader"], "urlconnection": ["urlservice", "httpcommunication", "httpcontext", "urlconfig", "urlcontext", "lConnection", "webconn", "webconnect", "URLconn", "urlconnect", "httpConnection", "llconfig", "urlcommunication", "collconnection", " urlcontext", "URLConnection", "lconnection", " urlservice", "httpconfig", " urlconfig", "collConnection", " urlConnection", "webConnection", " urlconnect", "httpconnection", "lconnect", "httpconn", " urlconn", "httpconnect", "urlConnection", "llconnect", "collconnect", "URLconnection", "urlconn", "llConnection", "URLcommunication", "webcommunication", "elcontext", "URLservice", "collconfig", "lservice", "webconnection", "lconn", "elconn", "webconfig", "elconnection", "llconnection", "elconnect"], "sLine1": ["sL2", "sBlock2", "pLine6", "sLine2", " sBlock1", "sline1", "sBlock0", "sBlockOne", "sUnit1", "sLWeb", " sLU", " sBlockOne", "sLineWeb", "pLin6", " sLineOnce", " sLOne", "sline2", "sByte6", "pLine1", "sPass1", "sLookOne", "sBlock1", "sLin1", "pLin1", "sLineOnce", "sBlockOnce", "sL1", " sL2", "slineWeb", "sLin6", "sL0", " sLine0", "sLookOnce", "sLinOne", " sL1", " sBlockOnce", "sPassOne", "sUnitOne", "sUnit6", "sLook0", "sLU", "sLineU", "sByte0", "sLine0", "sLin2", "sByteOnce", " sLine2", " sBlock0", "sline0", "sByte1", "sByteOne", "sLineOne", " sLineU", "sPass2", "sPassU", "sBlockWeb", "sLine6", " sLineOne", "sLinU", "pLineOne", "pLinOne", "sLook1", "sLOne"]}}
{"id1": "21750197", "id2": "1274215", "code1": "    public static byte[] getBytesFromURL(URL url) throws IOException {\n        byte[] b;\n        URLConnection con = url.openConnection();\n        int size = con.getContentLength();\n        InputStream s = con.getInputStream();\n        try {\n            if (size <= 0) b = IOUtil.getBytesFromStream(s); else {\n                b = new byte[size];\n                int len = 0;\n                do {\n                    int n = s.read(b, len, size - len);\n                    if (n < 0) throw new IOException(\"the stream was closed: \" + url.toString());\n                    len += n;\n                } while (len < size);\n            }\n        } finally {\n            s.close();\n        }\n        return b;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            if (args.length < 2) {\n                System.err.println(\"usage: test [src] [dest]\");\n                return;\n            }\n            FileInputStream in = new FileInputStream(args[0]);\n            FileOutputStream out = new FileOutputStream(args[1]);\n            FileChannel src = in.getChannel();\n            FileChannel channel = out.getChannel();\n            long pos = 0, len = src.size(), ret;\n            while (len > 0) {\n                if ((ret = channel.transferFrom(src, pos, len)) < 0) break;\n                len -= ret;\n                pos += ret;\n            }\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "user", "connection", "open", "ll", "conn", "l", "src", "http", "this", "lr", "loc", "base", "f", "stream", "r", "resource", "server", "address", "el", "ur", "u", "e", "log", "bel", "m", "string", "path", "image", "il", "rl", "secure", "c", "file", "uri", "ssl", "socket", "impl", "g", "URL", "Url", "gl", "str", "sl"], "b": ["sb", "h", "cb", "bf", "mb", "binary", "d", "buffer", "buff", "br", "k", "pb", "l", "bc", "part", "f", "base", "bd", "abb", "bs", "r", "bytes", "bi", "x", "u", "e", "bb", "ob", "a", "bar", "buf", "ba", "gb", "v", "xb", "eb", "B", "emb", "ib", "obj", "ab", "c", "db", "wb", "fb", "g", "block", "nb", "boot", "lb", "bin", "z", "rb", "p"], "con": ["plain", "en", "connection", "open", "uc", "cf", "co", "conn", "fc", "l", "http", "out", "in", "src", "w", "client", "common", "f", "ctrl", "r", "re", "enc", "ctx", "can", "cn", "x", "cons", "cur", "rc", "CON", "cl", "bel", "syn", "ch", "m", "ls", "lc", "com", "close", "sin", "cr", "connect", "c", "ssl", "ran", "socket", "un", "conv", "cc", "Conn", "coll", "Con"], "size": ["page", "div", "left", "en", "si", "cm", "fee", "min", "scale", "limit", "sized", "iz", "Size", "loc", "data", "SIZE", "enc", "sum", "address", "shape", "sync", "six", "name", "body", "ui", "big", "ci", "ize", "length", "max", "capacity", "content", "lc", "se", "time", "sec", "close", "string", "count", "c", "code", "i", "g", "eng", "start", "form", "sn", "empty", "small", "use"], "s": ["opens", "aws", "ks", "sb", "strings", "d", "si", "lines", "ss", "ws", "src", "l", "fs", "http", "gs", "ns", "sf", "in", "f", "ions", "stream", "os", "bs", "es", "serv", "js", "sym", "ins", "o", "e", "rs", "cs", "sl", "a", "m", "ls", "abs", "session", "sin", "socket", "ssl", "c", "g", "ses", "is", "ds", "services", "bis", "sn", "ps", "p"], "len": ["dl", "left", "en", "ln", "d", "nn", "lf", "ld", "ll", "iter", "min", "limit", "conn", "l", "ler", "val", "lon", "part", "L", "f", "Len", "lan", "no", "elt", "el", "lo", "nt", "length", "fn", "syn", "fl", "lc", "li", "kn", "le", "il", "N", "count", "j", "i", "pos", "un", "led", "lin", "bn", "fin", "z", "line", "sl", "hl", "ie"], "n": ["an", "en", "num", "nl", "ln", "d", "nn", "net", "yn", "nr", "l", "ns", "f", "number", "rn", "no", "r", "ni", "dn", "el", "cn", "ne", "na", "u", "o", "e", "nt", "non", "fn", "t", "length", "m", "nu", "N", "j", "c", "i", "nat", "un", "pn", "nb", "ng", "sn", "nc", "p"]}}
{"id1": "11444436", "id2": "20292404", "code1": "    public void run() {\n        try {\n            FTPClient c = new FTPClient();\n            c.configure(ftpConfig);\n            logger.debug(\"Trying to connect\");\n            c.connect(\"127.0.0.1\", 21211);\n            logger.debug(\"Connected\");\n            c.setSoTimeout(5000);\n            if (!FTPReply.isPositiveCompletion(c.getReplyCode())) {\n                logger.debug(\"Houston, we have a problem. D/C\");\n                c.disconnect();\n                throw new Exception();\n            }\n            if (c.login(\"drftpd\", \"drftpd\")) {\n                logger.debug(\"Logged-in, now waiting 5 secs and kill the thread.\");\n                _sc.addSuccess();\n                Thread.sleep(5000);\n                c.disconnect();\n            } else {\n                logger.debug(\"Login failed, D/C!\");\n                throw new Exception();\n            }\n        } catch (Exception e) {\n            logger.debug(e, e);\n            _sc.addFailure();\n        }\n        logger.debug(\"exiting\");\n    }\n", "code2": "    protected void convertInternal(InputStream inputStream, DocumentFormat inputFormat, OutputStream outputStream, DocumentFormat outputFormat) {\n        File inputFile = null;\n        File outputFile = null;\n        try {\n            inputFile = File.createTempFile(\"document\", \".\" + inputFormat.getFileExtension());\n            OutputStream inputFileStream = null;\n            try {\n                inputFileStream = new FileOutputStream(inputFile);\n                IOUtils.copy(inputStream, inputFileStream);\n            } finally {\n                IOUtils.closeQuietly(inputFileStream);\n            }\n            outputFile = File.createTempFile(\"document\", \".\" + outputFormat.getFileExtension());\n            convert(inputFile, inputFormat, outputFile, outputFormat);\n            InputStream outputFileStream = null;\n            try {\n                outputFileStream = new FileInputStream(outputFile);\n                IOUtils.copy(outputFileStream, outputStream);\n            } finally {\n                IOUtils.closeQuietly(outputFileStream);\n            }\n        } catch (IOException ioException) {\n            throw new OpenOfficeException(\"conversion failed\", ioException);\n        } finally {\n            if (inputFile != null) {\n                inputFile.delete();\n            }\n            if (outputFile != null) {\n                outputFile.delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"c": ["dc", "cd", "d", "connection", "cy", "cu", "cm", "cf", "co", "vc", "conn", "fc", "l", "ct", "con", "w", "client", "b", "bc", "f", "ctrl", "ec", "cp", "n", "xc", "ctx", "sc", "enc", "config", "ac", "mc", "pc", "cn", "cur", "exec", "ci", "e", "u", "cl", "tc", "t", "cs", "ch", "m", "lc", "cr", "g", "ce", "cc", "ca", "coll", "p", "C"]}}
{"id1": "6925921", "id2": "7993946", "code1": "    public static void bubbleSort(int[] polje) {\n        boolean swapped;\n        int temp;\n        int n = polje.length;\n        do {\n            swapped = false;\n            n--;\n            for (int i = 0; i < n - 1; i++) {\n                if (polje[i] > polje[i + 1]) {\n                    temp = polje[i];\n                    polje[i] = polje[i + 1];\n                    polje[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n    }\n", "code2": "    public void unsplit(String newFilename, File[] files) throws Exception {\n        FileOutputStream stream = new FileOutputStream(new File(newFilename));\n        for (int i = 0; i < files.length; i++) {\n            FileInputStream fin = new FileInputStream(files[i].getAbsolutePath());\n            DataInputStream din = new DataInputStream(fin);\n            while (din.available() > 0) {\n                stream.write(din.read());\n            }\n            din.close();\n            fin.close();\n        }\n        stream.close();\n    }\n", "label": 0, "substitutes": {"polje": [" polja", "polpe", "poljo", "antje", "holja", " poljo", "prja", "Polja", "polji", "palji", " polae", "Poljp", "poljp", "parji", "polte", "antji", " polkee", "polze", "prkee", "holji", "holjo", "Polje", "polae", "prje", "prpe", "palja", "pje", "prjo", "parjo", "parja", "promji", "promje", "pjo", " poljp", "palze", "pze", " polze", "prji", "Poljo", "Polji", "antae", " polji", "palte", "polja", " polte", "palae", "paljo", " polpe", "promja", "promjp", "pja", "antjo", "polkee", "promjo", "Polpe", "parte", "palje", "Polkee", "holje", "parje"], "swapped": ["wap", "rewapping", "snapped", "rewaped", "swoped", "snapping", "swap", "rewagged", "wapping", "Swapping", "flapped", "wapped", " swagged", "rewapped", "woped", "flaped", " swaped", " swapping", "waped", "Swap", "swapping", " swap", "Swaped", "swagged", "rewap", "flapping", " swoped", "snagged", "Swapped", "snaped", "floped", "swaped"], "temp": ["source", "parent", "tmp", "default", "num", "iter", "result", "extra", "flat", "tw", "w", "fake", "wa", "diff", "stable", "f", "base", "data", "tem", "clean", "prefix", "Temp", "adj", "x", "e", "cel", "tc", "length", "t", "api", "partial", "v", "offset", "index", "count", "cache", "c", "emp", "j", "modified", "current", "pi", "local", "level", "empty", "z", "test", "alpha", "null", "p"], "n": ["nl", "en", "ln", "d", "nn", "net", "len", "nw", "k", "nin", "conn", "l", "ns", "f", "ni", "adj", "cn", "nor", "na", "ne", "o", "e", "nt", "nan", "fn", "t", "m", "nu", "span", "v", "N", "don", "j", "c", "np", "g", "un", "pn", "nb", "sn", "z", "nm", "nc", "ot", "ner", "mn", "p"], "i": ["id", "si", "qi", "multi", "abi", "iu", "hi", "io", "phi", "l", "y", "b", "f", "di", "bi", "mu", "I", "oi", "ni", "ai", "info", "ti", "gi", "adi", "x", "ix", "init", "ui", "u", "ci", "e", "o", "eni", "it", "api", "ini", "a", "cli", "lc", "li", "v", "xi", "index", "anti", "slice", "ri", "j", "c", "uri", "ori", "ii", "pi", "fi", "z", "mi", "mini", "ip", "p", "ie"]}}
{"id1": "2940068", "id2": "2525895", "code1": "    public void run() {\n        checkupdates.BetaST.setText(\"\");\n        checkupdates.stableST.setText(\"\");\n        \n        String[] s = new String[7];\n       int i=0;\n        try {\n            \n            URL url = new URL(\"http://memorize-words.sourceforge.net/latest.txt\");\n            \n            BufferedReader in = new BufferedReader(new\n                    InputStreamReader(url.openStream()));\n            String str;\n           \n            while (((str = in.readLine()) != null)&&(i<7)) {\n                \n                s[i]=str;\n                i++;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n       if (i<5) \n       { checkupdates.CheckBT.setEnabled(true);\n           return;\n       }\n       //S[0]=latest Beta version\n       //S[1]=latest Stable version\n       //s[2]=Beta version download path\n       //s[3]=Stable version download path\n       //s[4]= Beta name\n       //s[5]=Stable name\n       boolean updated=false;\n       if ((MF.CurVersion<Integer.parseInt(s[0]))&&(checkupdates.BetaCHK.isSelected()))\n       {\n       checkupdates.BetaST.setText(\"<HTML>A newer BETA version (<b>\"+s[4]+\"</b>) is available at<BR> <a href=''>\"+s[2]+\"</a></HTML>\");\n       updated=true;\n       checkupdates.hasBeta=true;\n       checkupdates.BetaURL=s[2];\n       }else\n           checkupdates.BetaST.setText(\"\");\n           \n       if ((MF.CurVersion<Integer.parseInt(s[1]))&&(checkupdates.StableCHK.isSelected()))\n       {\n       checkupdates.stableST.setText(\"<HTML>A newer STABLE version (<b>\"+s[5]+\"</b>) is available at<BR> <a href=''>\"+s[3]+\"</a></HTML>\");\n       updated=true;\n       checkupdates.hasStable=true;\n       checkupdates.StableURL=s[3];\n       }\n       else\n           checkupdates.stableST.setText(\"\");\n       \n       if (updated)\n           checkupdates.setVisible(true);\n       checkupdates.CheckBT.setEnabled(true);\n       // \"A newer stable version (memorize-words 1-2-2) is available at http://\"\n       //   MF.CurVersion;\n    }\n", "code2": "    public static byte[] encode(String cryptPassword, byte[] credentials, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] cipherOut = cipher.doFinal(credentials);\n            byte[] ret = new byte[salt.length + cipherOut.length];\n            System.arraycopy(salt, 0, ret, 0, salt.length);\n            System.arraycopy(cipherOut, 0, ret, salt.length, cipherOut.length);\n            return ret;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 0, "substitutes": {"s": ["states", "su", "d", "lines", "l", "ns", "es", "groups", "u", "ls", "ssl", "ts", "ys", "ves", "comments", "strings", "site", "b", "os", "sites", "posts", "sets", "ins", "t", "a", "abs", "c", "ses", "is", "ids", "services", "ps", "plus", "aws", "si", "submit", "ss", "fs", "params", "gs", "f", "n", "qs", "js", "x", "e", "rs", "v", "string", "ments", "ans", "g", "ds", "S", "p", "tests", "bes", "ks", "ws", "steps", "y", "w", "ms", "as", "uns", "xs", "m", "its", "times", "parts", "z"], "i": ["id", "si", "qi", "multi", "iu", "hi", "io", "phi", "l", "f", "di", "bi", "zi", "I", "ti", "ni", "gi", "ai", "oi", "x", "ix", "it", "ui", "ci", "u", "e", "t", "ini", "a", "m", "lc", "li", "xi", "v", "cli", "ri", "index", "count", "j", "c", "uri", "ori", "ii", "pi", "fi", "z", "p"], "url": ["source", "user", "link", "browser", "feed", "connection", "download", "buffer", "open", "l", "http", "out", "b", "client", "f", "base", "channel", "stream", "r", "resource", "org", "server", "address", "gl", "e", "api", "bel", "ls", "up", "string", "image", "socket", "uri", "file", "ssl", "URL", "Url", "www", "web", "sl"], "in": ["source", "reader", "h", "input", "inc", "din", "min", "io", "l", "con", "out", "b", "client", "fr", "login", "f", "loader", "data", "In", "stream", "again", "r", "re", "server", "serv", "isin", "inner", "er", "ins", "e", "gin", "ini", "image", "c", "ssl", "IN", "err", "inn", "is", "ilo", "lin", "bin", "line"], "str": ["read", "reader", "strings", "STR", "input", "txt", "arr", "br", "result", "out", "char", "b", "st", "fr", "f", "data", "n", "r", "enc", "x", "cur", "inst", "e", "cl", "spec", "Str", "text", "t", "sl", "pr", "dr", "sr", "tr", "lc", "string", "sp", "obj", "c", "j", "err", "stri", "sn", "strike", "line", "p"], "checkupdates": ["checkuptchanges", "checkappdating", "checkinstalldates", "checkUpdates", "checkupdatestates", "checkoutports", "checkupsstates", "checkuppstates", " checkupdategrades", "crossupdates", "compupstates", "checkinstallgrades", "checkareadate", "checkbackdates", "checkupdateencies", "checkUpalls", "checkaroundports", "checkupchanges", "syncupsforms", "crossupsdating", " checkupjobs", "setupsstates", "checkUpdate", "checkupdocs", "checkprencies", "viewuplines", "checkopdates", "updateupdategrades", "checkuptlines", "compupsdating", " checkUpdate", "checkprflows", "checkupdatealls", "checkappstates", "checkupworks", "crossupdating", "viewUpgrades", "checkupschanges", "checkinworks", "checkupslines", "checkuppdates", " checkupdetails", "checkupsports", "updateuplishes", "checkuptdocs", "checkupdateflows", "updateupdatechanges", "compupdating", "checkUpstates", "syncupflows", "crossupsstates", "setupsdates", "crossupsdates", " checkupchanges", " checkupvals", "updateupdates", " checkoutalls", "checkuppplugins", "checkopdetails", "pullupgrades", "setupsgrades", "setupgrades", "checkupdate", "checkareagrades", "checkupsjobs", " checkupplugins", " checkUpdates", "checkupjobs", " checkoutgrades", "checkuptgrades", "pullupencies", "checkUpjobs", "viewupgrades", "checkareachanges", "checkuppflows", "checkupstates", "checkUpports", "viewupdocs", " checkUpgrades", "updateupchanges", "checkUpplugins", "checkuppges", "checkupsworks", "checkupdatelishes", "checkoffdates", "checkupsfeatures", " checkUpjobs", " checkupfeatures", "checkprogrades", "checkupdategrades", "updateupgrades", "checkinencies", "checkinstallstates", "crossupschanges", "checkappworks", "checkupsges", "checkprodating", "syncupforms", "checkupsforms", "checkingrades", " checkoutvals", "checkprodates", "checkbackgrades", "updateupstates", "checkupsvals", "checkupgrades", "checkupsflows", "pullupdateflows", "checkUpdating", "checkuptdates", "checkualls", "checkuppforms", "crossupstates", "checkoutstates", "compupsworks", "updateupdatedates", "checkuplishes", "checkuptstates", "checkoffalls", "compupworks", "checkupdatedetails", "checkUpgrades", "syncupsflows", "checkprgrades", "checkoffgrades", "checkareadetails", "viewUplines", "checkUpchanges", " checkoutfeatures", "checkupsdating", "checkareadates", "checkupforms", "checkupplugins", "checkprdates", "checkoutalls", "setupdates", "compupdates", "updateupdatealls", "pullupdategrades", "checkbackdating", "checkupsgrades", "checkindates", " checkupdating", "checkupsdates", "checkupfeatures", "checkupges", "checkupdetails", "updateUpdates", "checkupdatedating", "checkprochanges", "checkupencies", "checkuppdate", "checkaroundjobs", "syncupworks", " checkUpdating", "updateUpstates", "checkupdateworks", "checkupdatedates", "updateupdatelishes", "checkproforms", "checkupsalls", "checkoutfeatures", "checkudates", "checkofflishes", "checkarounddates", "viewUpdocs", " checkupalls", "checkUpfeatures", "checkindating", " checkupdatechanges", "syncupdates", "checkupsdocs", "pullupdates", "checkupflows", "compupsstates", "checkuplines", "checkUplines", "pullupdatedates", " checkupports", "checkupdating", "syncupsdates", " checkoutports", "checkuports", "checkuppgrades", "pullupdateencies", "checkUpdocs", " checkupdate", "viewupdates", "setupges", "checkoutgrades", "updateupalls", "checkupvals", "checkbackchanges", " checkupgrades", "checkupalls", "checkuvals", "compupsdates", " checkUpchanges", "checkupdateforms", "checkuppworks", "crossupchanges", "checkaroundgrades", "checkopchanges", "checkupports", "checkopgrades", " checkupdatedates", "pullupflows", "checkupdatechanges", "viewUpdates", "updateUpgrades", "checkuptdating", "checkinstallalls", "updateupforms", " checkUpports", "checkappdates", "syncupsworks", "updateupdateforms", "checkinflows", "checkoutges", " checkUpplugins", "checkoutdates", "checkoutvals", "checkareaplugins", " checkupdatedetails", "setupstates", " checkoutdates", "updateUpalls", "checkUplishes", "setupsges", "checkinstates"], "BetaURL": ["BetaVERSION", " BetaVERSION", "BetaURI", "betaURI", " betaURI", "betaURL", "betaVERSION", " BetaURI", " betaVERSION", " betaURL"], "StableURL": [" StableUrl", "StorableUrl", "StaleUrl", "StabledURL", "StableUrl", "StabledURI", "StorableURL", " StorableUrl", " StorableURI", "StaleURI", "StableURI", " StorableURL", "StaleURL", "StabledUrl", "StorableURI", " StableURI"], "updated": ["successful", "left", "rendered", "added", " changed", "ified", "released", "edited", "expected", "filled", "result", "Update", "interrupted", "actual", "bug", "connected", "used", "data", "loaded", "style", " modified", "provided", "update", "started", "event", "other", "json", "failed", "checked", "found", "needed", "done", " update", "confirmed", "PDATED", "dated", " updates", "error", "installed", "modified", "raised", "created", "posted", "initialized", "fixed", "changed", "dates", "locked", "received", "Updated", "handled", "made", "established"]}}
{"id1": "2525895", "id2": "14356579", "code1": "    public static byte[] encode(String cryptPassword, byte[] credentials, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] cipherOut = cipher.doFinal(credentials);\n            byte[] ret = new byte[salt.length + cipherOut.length];\n            System.arraycopy(salt, 0, ret, 0, salt.length);\n            System.arraycopy(cipherOut, 0, ret, salt.length, cipherOut.length);\n            return ret;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "code2": "    public String getRandomGUID() {\n        MessageDigest md5 = null;\n        String valueBeforeMD5 = \"\";\n        String retValue = \"\";\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            InetAddress id = InetAddress.getLocalHost();\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            rand = random.nextLong();\n            sbValueBeforeMD5.append(id.toString());\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            retValue = sb.toString();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error:\" + e);\n        }\n        return retValue;\n    }\n", "label": 1, "substitutes": {"cryptPassword": ["passwordPass", "passwordPassword", " cryptPass", "ryptPassword", " cryptpassword", "cryptpassword", "passwordSalt", " cryptString", " cryptSalt", "cryptString", "cryptPass", "ryptpassword", "passwordpassword", "ryptString", "passwordString", "cryptSalt", "ryptPass", "ryptSalt"], "credentials": ["scryptitors", "caboritors", "credeters", "scredentials", "scryptentials", "caborpassword", "cedentials", "credential", "screditors", "caborential", "Chedential", "criptpassword", "cedential", "Chedentials", "cipential", "caborentials", "Credentials", "cryptentials", "Credential", "cryptpassword", "ceduments", "scryptpassword", "Creduments", "criptitors", "credpassword", "chedentials", "cryptential", "chedential", "Credeters", "chedeters", "Cheduments", "creditors", "cedeters", "cryptitors", "scredential", "cipuments", "cheduments", "creduments", "scredpassword", "scryptential", "Chedeters", "cipeters", "criptentials", "cipentials", "criptential"], "salt": ["scipher", "essecret", "sodium", "psodium", "secalt", "seipher", "esALT", "ssecret", "esodium", "Sodium", " sodium", "palt", "Ssecret", "sesALT", "cunt", "sessecret", "sunt", "secALT", "seALT", "scALT", "scalt", "sesalt", "codium", "sipher", "pault", "secodium", "cALT", "seodium", "psulator", "sault", " sunt", "sulator", "ssault", " sALT", "Salt", "calt", " sault", "ssalt", "pALT", "psALT", "seculator", "sert", "scault", "sart", "psalt", "Sret", "seault", "SALT", " sret", "sret", "cert", "ssart", "cart", "pipher", "esalt", "sesodium", "ssALT", " sulator", " sart", "cault", "Sunt", "seert", "cret", "sealt", "sALT"], "digester": [" digitter", "Diger", " digcher", "signester", "diger", "genercher", "generest", "Digester", "generested", "Digested", "signitter", "Digitter", "digitter", "digest", "generester", " digest", "Digcher", "signer", "signest", "digested", "digcher", " diger", " digested", "Digest"], "random": ["reader", "general", "default", "rand", "user", "rar", "token", "network", "range", "chain", "nr", "gener", "ro", "right", "unique", "extra", "io", "regular", "out", "winner", "root", "gen", "normal", "worker", "serial", "r", "re", "remote", "clean", "auto", "server", "config", "resource", "inner", "creator", "reverse", "monkey", "init", "password", "exclusive", "seed", "reg", "or", "manager", "database", "crypt", "order", "ng", "inv", "author"], "i": ["id", "h", "si", "multi", "qi", "ind", "iu", "hi", "k", "io", "phi", "b", "f", "di", "n", "bi", "mu", "I", "ti", "oi", "ai", "gi", "ni", "x", "init", "it", "ui", "u", "e", "ci", "o", "ski", "ini", "m", "li", "v", "xi", "index", "ri", "count", "j", "c", "uri", "ii", "pi", "start", "chi", "z", "mi", "mini", "ip", "p"], "hash": ["host", "ash", "h", "id", "url", "memory", "msg", "input", "auth", "ha", "result", "message", "base", "data", "hex", "mac", "version", "phrase", "enc", "sum", "master", "her", "address", "sha", "kh", "password", "image", "seed", "cache", "check", "array", "secret", "header", "block", "Hash", "crypt", "value", "pass"], "maxKeySize": ["maxKeysize", "maxSecretLen", "maxHashLength", " maxCharLength", "maxBlockLength", "maxBlocksize", " maxKeyLength", "maxCharLength", "maxkeyLength", " maxSecretLen", "maxCharLen", "maxHashsize", "maxHashSIZE", " maxKeysize", "maxkeysize", " maxSecretSize", " maxSecretLength", "maxkeySIZE", " maxKeySIZE", "maxBlockLen", "maxSecretSize", "maxkeySize", "maxBlockSize", "maxCharsize", "maxKeyLen", "maxKeyLength", " maxKeyLen", "maxCharSize", " maxCharSize", " maxCharSIZE", " maxSecretsize", "maxSecretsize", "maxCharSIZE", "maxSecretLength", "maxKeySIZE", " maxCharsize", "maxHashSize"], "generator": ["generate", "genator", "Generater", "gener", "grinator", "ger", "Generator", "generinator", "Generate", "gate", "generater", "gator", "grer", "grate", " generate", "Generer", "grator", " generater", "genater", "Generating", " generer", "generer", "gating", "genating", "generating", "geninator", "genate", "Generinator"], "key": ["source", "id", " secret", "user", "net", "connection", "core", "keys", "k", "message", "sign", " seed", "client", "driver", " object", "mode", "row", "phrase", "Key", "enc", "pair", "server", "raw", "KEY", "name", "cer", "temp", " password", "seed", "cache", "pass", "file", "lock", "ssl", "code", "service", "secret", "ce", "crypt", "kid", "store", "ip", "type"], "cipher": ["scipher", " cryption", "conrypted", "cryption", "encrypt", "Crypted", " coder", "conryption", "encipher", "scoder", "Cairo", "encoder", "Cryption", "cairo", "conrypt", "coder", "crypted", "scryption", "encairo", "conipher", " crypt", "scairo", "scrypt", "Cipher", "encrypted", "Crypt", "crypt", "encryption"], "cipherOut": ["cipherIn", "cipOUT", "acipherOutput", "rcipherInt", "cipherInt", "cipherNew", "cipOutput", "Cipherout", "cipout", "cipherOUT", "Cipout", "rcengeInt", "rcipherout", "CipherOut", "rcipherOUT", "cipIn", "cursorIn", "cairoInt", "cursorOUT", "CipOut", "rcengeout", "rcengeOUT", "cipNew", "cengeInt", "rcipherOut", "acryptOutput", "cipherOutput", "cryptInt", "cengeout", "rcengeOut", "cairoout", "acryptIn", "acipherOut", "CipherNew", "cpherOut", "acipherout", "cpherNew", "cursorOut", "cipOut", "cryptIn", "CipherOUT", "CipNew", "cpherout", "cipherout", "cairoOut", "cpherIn", "cryptout", "acipherIn", "cairoNew", "cairoOutput", "acryptout", "cairoIn", "cengeOUT", "cairoOUT", "cryptOut", "acryptOut", "cryptOUT", "CipIn", "CipherIn", "cengeOut", "CipOUT", "cryptOutput"], "ret": ["value", "py", "tmp", "default", "memory", "bf", "rf", "alt", "continue", "success", "buffer", "rets", "len", "reply", "result", "output", "mem", "out", "val", "def", "base", "data", "phrase", "ref", "re", "response", "match", "repl", "info", "fun", "target", "bit", "temp", "back", "pass", "reg", "replace", "db", "rev", "arg", "secret", "Ret", "res", "exit", "RET", "ext"]}}
{"id1": "545112", "id2": "6102140", "code1": "    public static void main(String[] args) throws Exception {\n        String uri = args[0];\n        Configuration conf = new Configuration();\n        FileSystem fs = FileSystem.get(URI.create(uri), conf);\n        Path inputPath = new Path(uri);\n        CompressionCodecFactory factory = new CompressionCodecFactory(conf);\n        CompressionCodec codec = factory.getCodec(inputPath);\n        if (codec == null) {\n            System.err.println(\"No codec found for \" + uri);\n            System.exit(1);\n        }\n        String outputUri = CompressionCodecFactory.removeSuffix(uri, codec.getDefaultExtension());\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = codec.createInputStream(fs.open(inputPath));\n            out = fs.create(new Path(outputUri));\n            IOUtils.copyBytes(in, out, conf);\n        } finally {\n            IOUtils.closeStream(in);\n            IOUtils.closeStream(out);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"uri": ["source", "route", "id", "ki", "url", "qi", "si", "abi", "username", "io", "origin", "format", "http", " URI", "f", "base", "href", "directory", "afi", "resource", "prefix", "ris", "server", "config", "gi", "address", "umi", "filename", "name", "query", "ui", "dir", "ci", "prot", "ini", "cli", "iri", "ri", "string", "path", "ori", "file", "i", "code", "attribute", "database", "pi", "URI", "domain", "mi", "uni", "location"], "conf": ["af", "Config", "cb", "url", "req", "cm", "Conf", "cf", "co", "conn", "fc", "Configuration", "con", "cas", "http", "client", "bc", "fr", "f", "def", "prop", "ref", "cp", "ctx", "config", "info", "cn", "fam", "aff", "init", "cl", "spec", "cs", "password", "ch", "cli", "timeout", "cr", "cfg", "cache", "c", "file", "raf", "conv", "cc", " Conf", "fi", "cms", "ca", "cor"], "fs": ["host", "cb", "bf", "cf", "ws", "io", "conn", "fc", "http", "fp", "sf", "bc", "fd", "f", "base", "fe", "fw", "os", "bs", "ctx", "es", "server", "sys", "fn", "cs", "Fs", "FS", "df", "ls", "utils", "cache", "file", "fb", "raf", "files", "ds", "services", "ps", "s"], "inputPath": ["sourceUrl", "outputStream", "sourcePoint", " inputP", "inputPoint", "imageStream", "outputpath", "InputP", " inputUrl", "InputStream", "imageP", "InputPath", "inputUrl", "outputLocation", " inputLocation", " inputPoint", "sourcePath", "imagePath", " inputStream", "sourcepath", "Inputpath", "imagepath", "sourceLocation", "inputP", "inputLocation", "inputpath", "outputPoint", "outputPath", " inputpath", "inputStream", "outputUrl", "sourceStream"], "factory": [" fct", "compct", "compolver", "cfact", "colver", "compfact", "bffact", "fsFactory", "fault", "bfault", "fsault", "bfactory", " folver", "folver", "bfFactory", "fsactory", "fsfact", "fct", " ffact", "cct", "cactory", "compactory", "Fault", "Factory", "fFactory", "Ffact", "FFactory", "ffact"], "codec": ["odEC", "codesEC", "Codocol", "defEC", "Codec", "codoc", "defoc", "codenc", "codEc", "defef", " codoc", "odep", "codesenc", "codesec", "Codoc", " codEC", "codef", "compocol", "compEc", "CodEC", "oderer", "codEC", "odec", "Codenc", " coderer", "compec", " codocol", " codef", "codesep", "defec", "Codef", "codep", "compef", "Codep", "CodEc", "coderer", "odef", " codEc", "Coderer", "odenc", "compEC", "codocol"], "outputUri": ["outputFri", "OutputUpi", " outputFRI", "outputFileri", "OutputUri", "outputUris", "outputUio", "OutputUris", "outputFilepi", "outputUpi", "outputUsri", "outputFuri", "outputFris", " outputURI", "outputFRI", " outputFri", "outputIpi", "OutputIio", "OutputUio", "outputIuri", "outputFileuri", " outputFuri", "OutputIris", " outputUris", "outputFileris", "outputURI", "outputIri", "outputUsio", "outputIio", "outputUsris", "outputUspi", "outputIris", "outputUuri", "OutputIpi", "outputFileRI", "OutputIri", "outputFileio", "outputIRI", " outputFris", " outputUuri"], "in": ["source", "reader", "id", "input", "inc", "din", "anc", "token", "win", "asin", "min", "nin", "b", "login", "f", "base", "as", "data", "In", "pin", "again", "n", "r", "inas", "work", "thin", "ac", "isin", "inner", "x", "init", "ins", "ax", "vin", "ini", "a", "m", "kin", "up", "path", "cin", "image", "socket", "i", "IN", "err", "inn", "rin", "is", "bin", "s", "p"], "out": ["plain", "inc", "write", "user", "net", "io", "output", "conn", "lib", "b", "client", "object", "base", "data", "to", "In", "again", "OUT", "Out", "n", "outs", "prefix", "thin", "serv", "writer", "off", "exec", "sync", "action", "null", "version", "o", "dot", "exp", "flow", "password", "gin", "ext", "ex", "up", "path", "point", "image", "obj", "socket", "file", "err", "img", "bin", "copy", "qa", "line", "pass"]}}
{"id1": "13339653", "id2": "11540200", "code1": "    public void write(String resource, String destinationPath) throws IOException, CoreException {\n        OutputStream output = null;\n        InputStream contentStream = null;\n        try {\n            contentStream = new BufferedInputStream(new FileInputStream(resource));\n            output = new BufferedOutputStream(new FileOutputStream(destinationPath));\n            int available = contentStream.available();\n            available = available <= 0 ? DEFAULT_BUFFER_SIZE : available;\n            int chunkSize = Math.min(DEFAULT_BUFFER_SIZE, available);\n            byte[] readBuffer = new byte[chunkSize];\n            int n = contentStream.read(readBuffer);\n            while (n > 0) {\n                output.write(readBuffer, 0, n);\n                n = contentStream.read(readBuffer);\n            }\n        } finally {\n            if (contentStream != null) {\n                try {\n                    contentStream.close();\n                } catch (IOException e) {\n                    IDEWorkbenchPlugin.log(\"Error closing input stream for file: \" + resource, e);\n                }\n            }\n            if (output != null) {\n                output.close();\n            }\n        }\n    }\n", "code2": "    public File uploadImage(InputStream inputStream, String fileName, String sessionId) {\n        File file = new File(PathConfig.getInstance().sessionFolder(sessionId) + File.separator + fileName);\n        FileOutputStream fileOutputStream = null;\n        try {\n            FileUtils.touch(file);\n            fileOutputStream = new FileOutputStream(file);\n            IOUtils.copy(inputStream, fileOutputStream);\n        } catch (IOException e) {\n            logger.error(\"Save uploaded image to file occur IOException.\", e);\n            throw new FileOperationException(\"Save uploaded image to file occur IOException.\", e);\n        } finally {\n            try {\n                if (fileOutputStream != null) {\n                    fileOutputStream.close();\n                }\n            } catch (IOException e) {\n                logger.error(\"Close FileOutputStream Occur IOException while save a uploaded image.\", e);\n            }\n        }\n        return file;\n    }\n", "label": 1, "substitutes": {"resource": ["source", "resources", "route", "reader", "id", "url", "input", "queue", "memory", "connection", "reference", "buffer", "range", "Resource", "src", "base", "data", "directory", "ruby", "stream", "remote", "address", "filename", "name", "target", "text", "ource", "content", "string", "path", "image", "media", "rule", "cache", "pointer", "file", "uri", "context", "attribute", "property", "database", "project", "rice"], "destinationPath": ["Destributionpath", "destativePath", "destificatePATH", "destativePATH", "destificatePath", "DestinationFile", "destinationPATH", "destributionStream", "destensionDirectory", "DestributionPATH", "destinationFile", "DestributionFile", "destativepath", "destinationStream", "destributionDirectory", "destinateStream", "destativeFile", "destensionpath", "destinateDirectory", "destributionPath", "destensionPath", "destributionFile", "destificatepath", "DestinationDirectory", "DestinationStream", "DestinationPATH", "destificateFile", "destinationDirectory", "DestributionPath", "destensionStream", "destributionpath", "Destinationpath", "DestributionDirectory", "DestinationPath", "destributionPATH", "DestributionStream", "destinatepath", "destinatePath", "destinationpath"], "output": ["next", "source", "page", "left", "export", "operation", "continue", "input", "display", "write", "pot", "oper", "office", "connection", "network", "reference", "hidden", "complete", "download", "result", "exit", "outer", "fore", "lib", "control", "out", "this", "object", "ou", "console", "environment", "application", "progress", "version", "remote", "response", "config", "external", "writer", "stop", "address", "module", "production", "Output", "full", "other", "target", "log", "content", "temp", "offset", "sort", "four", "image", "OU", "document", "cut", "file", "error", "current", "generation", "ilo", "web", "put", "null", "unit"], "contentStream": ["Contentstream", "outputSteam", "outputStream", "contentSt", "inputSteam", "ContentSteam", "ContentCh", "ContentStream", "parentSteam", "coreSteam", "contentstream", "readableHalf", "readableStreamer", "parentstream", "ContentReader", "resourceStream", "mediaSteam", "resourceSteam", "resourceHalf", " contentstream", " contentStreamer", "mediaStreamer", "ContentStreamer", "inputSt", "contentReader", "resourcestream", "inputStreamer", "coreStreamer", "childStreamer", "mediaStream", "parentStream", "resourceSt", "outputstream", " contentCh", "outputReader", "readableSteam", "eventSteam", "currentReader", "currentStream", "contentBuffer", "currentSteam", "parentStreamer", " contentSteam", "mediaBuffer", "corestream", "currentStreamer", "eventStreamer", "readableStream", "resourceBuffer", "eventStream", "mediaHalf", "contentSteam", "contentHalf", " contentSt", "childStream", "resourceStreamer", "coreStream", "eventBuffer", "contentStreamer", "childCh", "outputStreamer", "inputStream", "contentCh", "childstream"], "available": ["read", "size", "active", "default", "input", "released", "open", "buffer", "complete", "availability", "allowed", "limited", "used", "connected", "stable", "data", " unavailable", "version", "supported", "loaded", "always", "auto", "provided", "raw", "archive", "latest", "can", "Available", "exec", "api", "volume", "full", "opened", "aw", "allow", "length", "accessible", "instance", "initial", "capacity", "running", "bound", "cap", "usable", "exclusive", "missing", "release", "all", "unknown", "free", "enough", "connect", "readable", "cache", "load", "visible", "installed", "av", "current", "valid", "array", "block", "initialized", "total", "unsigned", "position", "empty", "enabled", "ended", "null", "able"], "chunkSize": ["bunkSize", "chunksSize", "shardsize", "shunkize", "bulkOrder", "chunkerInfo", "chardsize", "chunkssize", "chunkInfo", "shunkSize", "bunkOrder", "chardize", "bulkSize", "chulkInfo", "chunkerSize", "chacketSize", "chardSize", "chulkOrder", "chunkOrder", "chunkerOrder", "chacketInfo", "chulkize", "chunksize", "chunkize", "shardSize", "bulkInfo", "shardize", "chulksize", "chulkSize", "shunksize", "chacketOrder", "bunkInfo"], "readBuffer": ["loadCount", "bitbuffer", "loadBuffer", " readSize", " readLine", "loadBuff", " readBuff", "playCount", " readLimit", "readableLine", "writeBuff", " readCount", "readablebuffer", "readChannel", "bitBuff", "loadChannel", " readChannel", "writeSize", "readLimit", "writeBuffer", "playBuffer", "bitBuffer", "loadLimit", "readLine", "readableBuff", "loadbuffer", " readbuffer", "readSize", "bitChannel", "playLine", "readableBuffer", "loadSize", "loadLine", "readCount", "playBuff", "writeLimit", "readbuffer", "readBuff"], "n": ["size", "an", "nl", "num", "en", "ln", "d", "none", "nn", "net", "network", "write", "k", "nin", "conn", "l", "b", "ns", "f", "number", "rn", "r", "dn", "nor", "ne", "na", "u", "e", "o", "length", "m", "v", "index", "N", "j", "c", "i", "g", "un", "nb", "position", "ng", "sn", "z", "nc", "p"]}}
{"id1": "10895680", "id2": "120730", "code1": "    private DefaultMutableTreeNode parseTree() {\n        try {\n            DefaultMutableTreeNode root;\n            URL url = RebusHelp.class.getResource(\"/org/olga/rebus/gui/help/html/content.xml\");\n            InputStream is = url.openStream();\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(true);\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            Document document = parser.parse(is);\n            NodeList elements = document.getElementsByTagName(\"help\");\n            Element element = (Element) elements.item(0);\n            root = createTreeContent(element);\n            is.close();\n            return root;\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            return null;\n        } catch (ParserConfigurationException e1) {\n            System.out.println(e1.getMessage());\n            return null;\n        } catch (org.xml.sax.SAXException e2) {\n            System.out.println(e2.getMessage());\n            return null;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"root": ["page", "parent", "div", "default", "xml", "result", "output", "doc", "rss", "Root", "article", "out", "this", "object", "bc", "row", "ver", "loc", "data", "cover", "n", "tree", "child", "config", "writer", "section", "report", "container", "instance", "ow", "content", "ree", "rec", "node", "help", "leaf", "html", "obj", "record", "builder", "array", "null"], "url": ["source", "host", "page", "id", "user", "browser", "feed", "connection", "open", "xml", "l", "http", "out", "b", "f", "base", "loader", "channel", "stream", "r", "resource", "server", "address", "config", "name", "e", "api", "location", "ls", "string", "path", "image", "uri", "file", "ssl", "i", "URL", "service", "Url", "blog", "web", "sl"], "is": ["ic", "ils", "isa", "io", "src", "fs", "http", "isl", "out", "in", "app", "as", "p", "was", "iss", "stream", "os", "resource", "ris", "serv", "ai", "info", "es", "address", "ir", "has", "iv", "isi", "it", "ui", "iris", "IS", "abs", "ri", "il", "ios", "its", "uri", "i", "im", "or", "us", "Is", "iso", "ps", "s", "ip", "ib"], "factory": ["canta", "infFactory", "formactory", "formixture", " filler", " fault", "filler", "fixture", "fault", "pactory", "formoo", "fanta", "foo", "fuild", "panta", "pault", " fixture", "Filler", "mFactory", " fFactory", " fictionary", "formiller", " fanta", "Ffact", "refuild", " foo", "mactory", "inffact", "mfact", "infoo", " fuild", "pixture", "infactory", "Fictionary", "fictionary", "refictionary", "miller", "cactory", "cixture", "cault", "Fuild", "infixture", "Factory", "fFactory", "refFactory", "infiller", "FFactory", "refactory", "ffact"], "parser": ["paragraph", "reader", "wrapper", "xml", "util", "plugin", "man", "http", "arser", "law", "driver", "base", "as", "jack", "data", "worker", "class", "handler", "server", "config", "writer", "creator", "er", "angler", "php", "per", "container", "instance", "api", "list", "library", "parse", "file", "command", "builder", "Parser", "p", "type"], "document": ["language", "paragraph", "page", "parent", "host", "reader", "layout", "connection", "Document", "xml", "director", "message", "doc", "l", "base", "number", "git", "data", "directory", "response", "tree", " documents", "full", "content", " documentation", "docs", "media", "node", "list", "ml", "parse", "file", "ocument", "builder", "project", "copy", "port", "author"], "elements": ["neboxes", "Elements", "elem", "enlements", "Eboxes", "nelements", "nelem", "belem", "enlem", "elelem", "beodes", "Eodes", "belements", "eboxes", "eleodes", "eodes", "nelement", "enlement", "Elem", "belement", "Element", "enboxes", "elelement", "elelements"], "element": ["page", "parent", "input", "office", "lement", "xml", "lements", "plugin", "ee", "effect", "article", "object", "model", "environment", "layer", "data", "style", "tree", "editor", "address", "el", "section", "tag", "name", "component", "event", "e", "container", "text", "instance", "content", "entity", "node", "Element", "item", "type", "line", "entry"]}}
{"id1": "272355", "id2": "13339653", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void write(String resource, String destinationPath) throws IOException, CoreException {\n        OutputStream output = null;\n        InputStream contentStream = null;\n        try {\n            contentStream = new BufferedInputStream(new FileInputStream(resource));\n            output = new BufferedOutputStream(new FileOutputStream(destinationPath));\n            int available = contentStream.available();\n            available = available <= 0 ? DEFAULT_BUFFER_SIZE : available;\n            int chunkSize = Math.min(DEFAULT_BUFFER_SIZE, available);\n            byte[] readBuffer = new byte[chunkSize];\n            int n = contentStream.read(readBuffer);\n            while (n > 0) {\n                output.write(readBuffer, 0, n);\n                n = contentStream.read(readBuffer);\n            }\n        } finally {\n            if (contentStream != null) {\n                try {\n                    contentStream.close();\n                } catch (IOException e) {\n                    IDEWorkbenchPlugin.log(\"Error closing input stream for file: \" + resource, e);\n                }\n            }\n            if (output != null) {\n                output.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "RC", "reader", "sb", "tmp", "url", "input", "proc", "cb", "req", "upload", "SourceFile", "dep", "download", "sth", "sit", "username", "fp", "Source", "supp", "st", "loc", "cpp", "href", "ref", "stream", "storage", "resource", "sc", "ctx", "config", "filename", "name", "component", "rc", "inst", "prot", "feat", "gn", "spec", "fn", "ource", "Dest", "buf", "back", "sin", "gb", "slice", "sec", "path", "gz", "string", "rl", "obj", "load", "uri", "ssl", "file", "secure", "code", "impl", "vr", "dist", "img", "sn", "s", "rb", "cmp", "sl"], "dest": ["source", "tmp", "dc", "txt", "disk", "lib", "home", " destination", "std", "di", "class", "dir", "target", "cont", "fn", "Dest", "temp", "orig", "path", "obj", "wb", "dist", " dst", "img", "bin", "dat", "null"], "in": ["source", "reader", "input", "inc", "din", "d", "win", "io", "doc", "inf", "val", "login", "f", "as", "data", "In", "pin", "stream", "n", "r", "inas", "isin", "ins", "t", "ini", "a", "ex", "up", "file", "i", "IN", "err", "inn", "is", "bin", "ps", "pass"], "p": ["lp", "cop", "bp", "py", "h", "P", "d", "pe", "jp", "pb", "pd", "l", "pre", "fp", "pg", "b", "part", "f", "po", "cp", "wp", "pc", "tp", "pa", "o", "s", "e", "per", "t", "parser", "pr", "m", "v", "pm", "sp", "c", "j", "i", "np", "pp", "g", "pi", "ps", "op"], "ds": ["hs", "d", "dd", "ils", "ld", "lines", "tools", "ns", "bs", "DS", "dp", "sys", "vs", "eps", "sync", "dt", "da", "cs", "ls", "ays", "dist", "ts", "ys", " DS", "pd", " ps", "os", "posts", "models", "cons", "ins", "dm", "els", "scripts", "sts", "dates", "nas", "ps", "dl", "dc", "Ds", "points", "ss", "gs", "styles", "ups", "dos", "qs", "js", " props", "rs", "df", "words", "docs", "utils", "vals", "ans", " sd", "s", "lp", "tests", "ks", " db", "des", "ded", "ws", "gd", "cdn", "ads", "data", "di", "xs", "plugins", "dds", "icks", " dd", "amps", "ants", "db", "parts", "obs", "dat", "uds"], "format": ["source", "language", "host", "url", "ant", "Format", "layout", "xml", "plugin", "function", "scale", "letter", "fp", "object", "fd", "model", "part", "f", "magic", "data", "table", "version", "class", "style", "match", "handler", "prefix", "config", "template", "tag", "filename", "name", "pattern", "feat", "unit", "spec", "fn", "parser", "t", "atter", "api", "act", "frame", "string", "path", "file", "record", "struct", "nat", "sche", "at", "form", "filter", "type"], "hasPixelData": ["haspixelStyle", "hasPicturedata", "hasByteSize", "hasPicOps", " hasPixelStyle", "hasPixelStyle", "hasBytedata", "hasPictureDATA", "hasPicStyle", "hasPicData", "haspixelOps", "hasByteData", " hasPixelSize", "hasPictureData", " hasPixeldata", " hasPixelDATA", "haspixeldata", "haspixelDATA", "haspixelData", " hasPixelOps", "hasPixelSize", "hasPixelOps", "hasPixeldata", "hasPixelDATA", "haspixelSize"], "inflate": ["inflocate", " informate", " inflase", "infolate", "uninfloute", "inFlate", "infloase", "incollute", "incollocate", "infloation", "infloame", "incollame", "inFlation", "uninflate", " informase", "inFlATE", "inflATE", " inflation", "uninfloame", " informATE", "informase", "inflase", "infolocate", "incollate", "inflame", "uninfloocate", "information", "infolute", " inflATE", "inflation", " information", "infloATE", "uninflocate", "informate", "infloate", "infolame", "uninflute", "infloute", "uninfloate", "uninflame", "influte", "informATE", "infloocate", "inFlase"], "pxlen": ["pxlength", "xpval", "pxval", "cpl", "pnglen", "fxlength", "pyln", "xylen", "xplen", "cplen", "pglen", "ppln", "pglength", "pylen", "npfin", "pxden", "pgval", "nplin", "rxlen", "cpden", "pxlin", "pglf", "xplf", "pxfin", "cpln", "rxfin", "npden", "rxden", "pxln", "xplength", "pxl", "xyden", "pyden", "pngLen", "fxval", "ppLen", "ppden", "pplen", "pxlf", "xylin", "pyl", "nplen", "pngln", "rxlin", "fxl", "pngden", "fxlf", "fxden", "pxLen", "xyfin", "fxlen", "xyln", "fxln", "xyLen"], "out": ["page", "parent", "user", "io", "output", "conn", "lib", "dump", "gen", "base", "again", "OUT", "Out", "outs", "work", "server", "print", "re", "prefix", "sys", "inter", "step", "log", "cli", "post", "v", "up", "session", "point", "list", "obj", "lock", "cache", "error", "code", "err", "group", "store", "copy", "line"]}}
{"id1": "7687037", "id2": "9830267", "code1": "    public synchronized int insertMessage(FrostMessageObject mo) {\n        AttachmentList files = mo.getAttachmentsOfType(Attachment.FILE);\n        AttachmentList boards = mo.getAttachmentsOfType(Attachment.BOARD);\n        Connection conn = AppLayerDatabase.getInstance().getPooledConnection();\n        try {\n            conn.setAutoCommit(false);\n            PreparedStatement ps = conn.prepareStatement(\"INSERT INTO \" + getMessageTableName() + \" (\" + \"primkey,messageid,inreplyto,isvalid,invalidreason,msgdatetime,msgindex,board,fromname,subject,recipient,signature,\" + \"signaturestatus,publickey,isdeleted,isnew,isreplied,isjunk,isflagged,isstarred,hasfileattachment,hasboardattachment,idlinepos,idlinelen\" + \") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\");\n            Long identity = null;\n            Statement stmt = AppLayerDatabase.getInstance().createStatement();\n            ResultSet rs = stmt.executeQuery(\"select UNIQUEKEY('\" + getMessageTableName() + \"')\");\n            if (rs.next()) {\n                identity = new Long(rs.getLong(1));\n            } else {\n                logger.log(Level.SEVERE, \"Could not retrieve a new unique key!\");\n            }\n            rs.close();\n            stmt.close();\n            int i = 1;\n            ps.setLong(i++, identity.longValue());\n            ps.setString(i++, mo.getMessageId());\n            ps.setString(i++, mo.getInReplyTo());\n            ps.setBoolean(i++, mo.isValid());\n            ps.setString(i++, mo.getInvalidReason());\n            ps.setLong(i++, mo.getDateAndTime().getMillis());\n            ps.setInt(i++, mo.getIndex());\n            ps.setInt(i++, mo.getBoard().getPrimaryKey().intValue());\n            ps.setString(i++, mo.getFromName());\n            ps.setString(i++, mo.getSubject());\n            ps.setString(i++, ((mo.getRecipientName() != null && mo.getRecipientName().length() == 0) ? null : mo.getRecipientName()));\n            if (mo.getSignatureV2() == null || mo.getSignatureV2().length() == 0) {\n                ps.setString(i++, mo.getSignatureV1());\n            } else {\n                ps.setString(i++, mo.getSignatureV2());\n            }\n            ps.setInt(i++, mo.getSignatureStatus());\n            ps.setString(i++, mo.getPublicKey());\n            ps.setBoolean(i++, mo.isDeleted());\n            ps.setBoolean(i++, mo.isNew());\n            ps.setBoolean(i++, mo.isReplied());\n            ps.setBoolean(i++, mo.isJunk());\n            ps.setBoolean(i++, mo.isFlagged());\n            ps.setBoolean(i++, mo.isStarred());\n            ps.setBoolean(i++, (files.size() > 0));\n            ps.setBoolean(i++, (boards.size() > 0));\n            ps.setInt(i++, mo.getIdLinePos());\n            ps.setInt(i++, mo.getIdLineLen());\n            int inserted;\n            try {\n                inserted = ps.executeUpdate();\n            } finally {\n                ps.close();\n            }\n            if (inserted == 0) {\n                logger.log(Level.SEVERE, \"message insert returned 0 !!!\");\n                throw new Exception(\"message insert returned 0 !!!\");\n            }\n            mo.setMsgIdentity(identity.longValue());\n            PreparedStatement pc = conn.prepareStatement(\"INSERT INTO \" + getContentTableName() + \" (msgref,msgcontent) VALUES (?,?)\");\n            pc.setLong(1, mo.getMsgIdentity());\n            pc.setString(2, mo.getContent());\n            try {\n                inserted = pc.executeUpdate();\n            } finally {\n                pc.close();\n            }\n            if (inserted == 0) {\n                logger.log(Level.SEVERE, \"message content insert returned 0 !!!\");\n                throw new Exception(\"message content insert returned 0 !!!\");\n            }\n            if (files.size() > 0) {\n                PreparedStatement p = conn.prepareStatement(\"INSERT INTO \" + getFileAttachmentsTableName() + \" (msgref,filename,filesize,filekey)\" + \" VALUES (?,?,?,?)\");\n                try {\n                    for (Iterator it = files.iterator(); it.hasNext(); ) {\n                        FileAttachment fa = (FileAttachment) it.next();\n                        int ix = 1;\n                        p.setLong(ix++, mo.getMsgIdentity());\n                        p.setString(ix++, fa.getFilename());\n                        p.setLong(ix++, fa.getFileSize());\n                        p.setString(ix++, fa.getKey());\n                        int ins = p.executeUpdate();\n                        if (ins == 0) {\n                            logger.log(Level.SEVERE, \"fileattachment insert returned 0 !!!\");\n                            throw new Exception(\"fileattachment insert returned 0 !!!\");\n                        }\n                    }\n                } finally {\n                    p.close();\n                }\n            }\n            if (boards.size() > 0) {\n                PreparedStatement p = conn.prepareStatement(\"INSERT INTO \" + getBoardAttachmentsTableName() + \" (msgref,boardname,boardpublickey,boardprivatekey,boarddescription)\" + \" VALUES (?,?,?,?,?)\");\n                try {\n                    for (Iterator it = boards.iterator(); it.hasNext(); ) {\n                        BoardAttachment ba = (BoardAttachment) it.next();\n                        Board b = ba.getBoardObj();\n                        int ix = 1;\n                        p.setLong(ix++, mo.getMsgIdentity());\n                        p.setString(ix++, b.getNameLowerCase());\n                        p.setString(ix++, b.getPublicKey());\n                        p.setString(ix++, b.getPrivateKey());\n                        p.setString(ix++, b.getDescription());\n                        int ins = p.executeUpdate();\n                        if (ins == 0) {\n                            logger.log(Level.SEVERE, \"boardattachment insert returned 0 !!!\");\n                            throw new Exception(\"boardattachment insert returned 0 !!!\");\n                        }\n                    }\n                } finally {\n                    p.close();\n                }\n            }\n            conn.commit();\n            conn.setAutoCommit(true);\n            return INSERT_OK;\n        } catch (Throwable t) {\n            boolean isDuplicate;\n            if (t.getMessage().indexOf(\"constraint violation\") > 0 && t.getMessage().indexOf(\"MSG_ID_UNIQUE_ONLY\") > 0) {\n                isDuplicate = true;\n                logger.warning(\"Duplicate message id, not added to database table: msgid='\" + mo.getMessageId() + \"', board=\" + mo.getBoard().getName() + \", date='\" + mo.getDateAndTimeString() + \"', index=\" + mo.getIndex());\n            } else if (t.getMessage().indexOf(\"constraint violation\") > 0 && t.getMessage().indexOf(\"MSG_UNIQUE_ONLY\") > 0) {\n                isDuplicate = true;\n                logger.warning(\"Duplicate msgdatetime,index,board, not added to database table: msgid='\" + mo.getMessageId() + \"', board=\" + mo.getBoard().getName() + \", date='\" + mo.getDateAndTimeString() + \"', index=\" + mo.getIndex());\n            } else {\n                isDuplicate = false;\n                logger.log(Level.SEVERE, \"Exception during insert of message: msgid='\" + mo.getMessageId() + \"', board=\" + mo.getBoard().getName() + \", date='\" + mo.getDateAndTimeString() + \"', index=\" + mo.getIndex(), t);\n                try {\n                    conn.rollback();\n                } catch (Throwable t1) {\n                    logger.log(Level.SEVERE, \"Exception during rollback\", t1);\n                }\n            }\n            try {\n                conn.setAutoCommit(true);\n            } catch (Throwable t1) {\n            }\n            if (isDuplicate) {\n                return INSERT_DUPLICATE;\n            } else {\n                return INSERT_ERROR;\n            }\n        } finally {\n            AppLayerDatabase.getInstance().givePooledConnection(conn);\n        }\n    }\n", "code2": "            public void run() {\n                final SimpleMessageListener listener = new SimpleMessageListener() {\n\n                    public final boolean accept(final String from, final String recipient) {\n                        return true;\n                    }\n\n                    public final void deliver(final String from, final String recipient, final InputStream data) throws TooMuchDataException, IOException {\n                        System.out.println(\"FROM: \" + from);\n                        System.out.println(\"TO: \" + recipient);\n                        final File tmpDir = new File(System.getProperty(\"java.io.tmpdir\"));\n                        final File file = new File(tmpDir, recipient);\n                        final FileWriter fw = new FileWriter(file);\n                        try {\n                            IOUtils.copy(data, fw);\n                        } finally {\n                            fw.close();\n                        }\n                    }\n                };\n                final SMTPServer smtpServer = new SMTPServer(new SimpleMessageListenerAdapter(listener));\n                smtpServer.start();\n                System.out.println(\"Started SMTP Server\");\n            }\n", "label": 0, "substitutes": {"mo": ["mobi", "ao", "mor", "go", " fo", " o", "yo", "la", "so", " MO", "co", "message", "ma", "fo", " Mo", "gro", "jo", "object", "ms", "umo", "ho", "ou", "loc", "MO", "po", "oa", "mu", "oo", "bo", "mi", "oco", "vo", "emo", "module", "lo", "wo", "ako", "o", "ob", "ME", "omo", "mod", "mol", " wo", "mos", "oe", "ko", "m", "M", "OO", "mail", "oda", "media", "O", "gone", "flo", "obo", "ilo", " lo", "gor", "md", "me", "mob", "Mo", " om"], "files": ["ums", "Files", "classes", "frames", "mails", "fs", "items", "data", "photos", "objects", "ages", "ources", "models", "filename", "boxes", "phones", "images", "members", "text", "names", "fl", "mail", "fields", "media", "file", "iles", "igs", "fil"], "boards": ["ones", "actions", "tracks", "links", "frames", "lines", "acks", "cards", "mails", "bars", "books", "ups", "objects", "flows", "rooms", "boxes", "Board", " buttons", "members", "ways", "backs", "orders", " board", "banks", "ids", "views", "ards", "board"], "conn": ["h", "sb", "en", "sa", "sql", "connection", "util", "cf", "ws", "ct", "con", "pg", "fp", "client", "ns", "Conn", "fr", "cp", "n", "enc", "ctx", "dn", "mc", "cn", "conf", "ci", "nt", "act", "dh", "cs", "pr", "ch", "ann", "cr", "pool", "connect", "c", "db", "rt", "oci", "ds", "Connection", "ca", "nc"], "ps": [" mp", "Rs", "hs", "ys", "cop", "ks", "ples", "pes", "ils", "lines", "ss", " mc", "TS", "jp", "RS", "pl", "ws", "properties", "pg", " comp", "gs", "ms", "ns", "css", "part", "fs", " pub", "os", "bs", "changes", "es", " fr", "posts", "qs", "js", "vs", "eps", "xs", "res", "pa", " ops", "pps", "cs", "PS", "pr", "ls", "Ps", "pse", " repl", "ops", "ips", "its", "ans", "details", "pp", "pos", "pi", "ds", " scr", " RS", " pg", "pers", "ts", "proxy", "s"], "identity": ["authorace", "authentonymous", "identITY", "authorentity", "stringITY", "equence", " idententity", "stringentity", "stringity", "authententity", "authorifier", "idITY", "identifier", "idifier", "idace", "equonymous", "authentence", "authorence", "equentity", "authority", "stringifier", "authentity", "identonymous", "identence", "authoronymous", "authorITY", " identace", " identifier", "idententity", "equity", "idity", "identace"], "stmt": ["Sttr", " stql", "estmt", " stgr", "Stmp", "stmn", "stgr", "sttr", " stmd", " stm", "stmp", "Stgr", "stmd", "stm", "estql", "STm", "rtr", "estgr", "Stmn", "STmd", "STmn", "rmp", " stmn", "Str", "rmt", " stmp", " str", "Stm", "Stql", "rr", "stql", "str", "Stmt", "Stmd", "STmt", " sttr", "estm"], "rs": ["Rs", "hs", "ys", "ks", "rys", "ows", "ra", "ges", "runs", "rep", "lines", "acks", "RS", "rss", " results", "ars", "ros", "r", "ubs", "rg", "ris", "qs", " rows", "xs", " res", "rc", "icks", "s", "results", "cs", "sr", "hr", "pr", "ls", " Rs", "rows", "ri", "maps", " sr", "rl", " rc", "rt", "rd", "mr", "vers", " ret", "rr", "ras", " RS", "ds", "ts", "kr", "res", "rb"], "i": ["ei", "id", "si", "multi", "qi", "abi", "d", "counter", "iu", "phi", "io", "l", "yi", "f", "data", "di", "bi", "n", "I", "ti", "oi", "gi", "ai", "info", "ji", "esi", "x", "ui", "ci", "o", "u", "e", "eni", "init", "t", "ini", "a", "m", "li", "xi", "v", "slice", "ri", "index", "j", "c", "uri", "ii", "g", "pi", "idi", "fi", "z", "ip", "ie"]}}
{"id1": "7082101", "id2": "16324555", "code1": "    public byte[] computeMD5(String plainText) throws GException {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException ex) {\n            throw new GException(\"The MD5 hash algorithm is not available.\", ex);\n        }\n        try {\n            md.update(plainText.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException ex) {\n            throw new GException(\"The UTF-8 encoding is not supported.\", ex);\n        }\n        return md.digest();\n    }\n", "code2": "    public static String gerarDigest(String mensagem) {\n        String mensagemCriptografada = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            System.out.println(\"Mensagem original: \" + mensagem);\n            md.update(mensagem.getBytes());\n            byte[] digest = md.digest();\n            mensagemCriptografada = converterBytesEmHexa(digest);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return mensagemCriptografada;\n    }\n", "label": 1, "substitutes": {"plainText": ["plainName", " plainTEXT", "fileTEXT", "plainTEXT", "filetext", "binaryText", " plainString", "fileContent", "singleText", "binarytext", " plainName", "binaryContent", "plaintext", " plainContent", "binaryString", "binaryName", "plainCode", "plainString", "singleString", "fileText", " plaintext", "binaryCode", "singleName", "binaryTEXT", " plainCode", "singleCode", "plainContent"], "md": ["dc", "hash", "cd", "msg", "d", "mb", "cm", "alg", "dd", "ld", "hd", " MD", "mm", "doc", "ma", "mem", "mk", "sm", "pd", "pg", "cmd", "ms", "f", "data", "mac", "mo", "bd", "hm", "mu", "mand", "mag", "meta", "mc", "sha", "mp", "dm", "mod", "ph", "MD", "mt", "m", "df", "od", "pm", "mg", "metadata", "amd", "em", "nm", "dig", "ad", "pkg"]}}
{"id1": "2897046", "id2": "6707620", "code1": "    public boolean execute_check() {\n        FTPClient ftp = new FTPClient();\n        File filename = null;\n        FileChannel channel;\n        InputStream is;\n        OutputStream os;\n        int reply;\n        if (super.verbose > 0) verbose = true;\n        ftp.setDefaultPort(port);\n        ftp.setDefaultTimeout(timeout);\n        if (verbose) {\n            System.out.println(\"Using FTP Server: \" + hostname);\n            System.out.println(\"Using FTP Port: \" + port);\n            System.out.println(\"Using Timeout of: \" + timeout);\n        }\n        if (passive) {\n            ftp.enterLocalPassiveMode();\n            if (verbose) System.out.println(\"Using Passive Mode\");\n        }\n        try {\n            filename = new File(file);\n            channel = new RandomAccessFile(filename, \"rw\").getChannel();\n            if (verbose) System.out.println(\"Attempting FTP Connection to \" + hostname);\n            ftp.connect(hostname);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                if (verbose) System.out.println(\"FTP Connection to \" + hostname + \" failed\");\n                check_state = common_h.STATE_CRITICAL;\n                check_message = ftp.getReplyString();\n                filename.delete();\n                ftp.disconnect();\n                return true;\n            }\n            if (username != null && password != null) {\n                if (verbose) System.out.println(\"Attempting to log in into FTP Server \" + hostname);\n                if (!ftp.login(username, password)) {\n                    if (verbose) System.out.println(\"Unable to log in to FTP Server \" + hostname);\n                    check_state = common_h.STATE_CRITICAL;\n                    check_message = ftp.getReplyString();\n                    ftp.disconnect();\n                    filename.delete();\n                    return true;\n                }\n            }\n            if (verbose) System.out.println(\"Attempting to change to required directory\");\n            if (!ftp.changeWorkingDirectory(directory)) {\n                if (verbose) System.out.println(\"Required directory cannot be found!\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            if (verbose) System.out.println(\"Attempting to retrieve specified file!\");\n            is = ftp.retrieveFileStream(file);\n            if (is == null) {\n                if (verbose) System.out.println(\"Unable to locate required file.\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            os = Channels.newOutputStream(channel);\n            byte[] buf = new byte[4096];\n            if (verbose) System.out.println(\"Beginning File transfer...\");\n            for (int len = -1; (len = is.read(buf)) != -1; ) os.write(buf, 0, len);\n            if (verbose) {\n                System.out.println(\"...transfer complete.\");\n                System.out.println(\"Attempting to finalise Command\");\n            }\n            if (!ftp.completePendingCommand()) {\n                if (verbose) System.out.println(\"Unable to finalise command\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            if (verbose) System.out.println(\"Check Completed.\");\n            check_state = common_h.STATE_OK;\n            check_message = ftp.getReplyString();\n            is.close();\n            os.close();\n            channel.close();\n            filename.delete();\n        } catch (IOException e) {\n            check_state = common_h.STATE_CRITICAL;\n            check_message = e.getMessage();\n            if (filename != null) filename.delete();\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (Exception e) {\n                }\n            }\n        }\n        return true;\n    }\n", "code2": "    private static String getHash(String hash, String clear) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(hash);\n            md.update(clear.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            String str = new String();\n            for (int i = 0; i < bytes.length; ++i) str += Integer.toHexString(0xF0 & bytes[i]).charAt(0) + Integer.toHexString(0x0F & bytes[i]);\n            return str;\n        } catch (NoSuchAlgorithmException exc) {\n        } catch (UnsupportedEncodingException exc) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"ftp": ["ufuser", " ftplug", "aftpc", "cfw", "xfb", "rtsp", "webtp", "rtpc", " fttp", "fc", " ftw", "xfp", " ftpc", " ftcp", "afi", "ctw", "ctpc", "ctcp", "uftp", " ftsp", "lfp", "FTplug", "aftm", "afc", "fb", "ctp", " ftc", "lfpi", "cfcp", "fdc", "aftcp", " ftP", "fspc", "xfc", " fti", "cftp", "ctpb", "ftm", "ctP", "fsm", "ftpre", "rtm", "ufpre", "ftjp", "webpart", "lfc", "aftpb", " ftpart", "fttp", "ftl", "webp", "fdp", "ftplug", "webjp", "ufp", "cfuser", "ctb", "fP", "ufpc", "fdcp", "fi", "ctpre", "aftp", "ctport", "xfplug", "ftuser", "aftjp", "rtp", "cttp", "aftsp", "FTc", "fp", "ufport", "ftw", "FTb", "afp", "ftpart", "ufcp", "afl", "fti", "ftc", "ftpb", "ftP", "lftp", "fdl", "fsp", " ftuser", "ftport", "cfp", "ftpc", "aftpart", "ftsp", " ftpi", " ftb", "cfpc", "fpi", "ftcp", "fcp", "fstp", "ftb", "fdpc", " ftm", "ftpi", "ufpb", "afcp", "fl", "aftpre", "FTp", " ftjp", "fdport", "afttp"], "filename": ["source", "via", "folder", "journal", "url", "processor", "queue", "binary", "txt", "memory", "SourceFile", "connection", "download", "jet", "fax", "dll", "username", "message", "output", "audio", "l", "fp", "sf", "fd", "f", "loader", "application", "directory", "phrase", "profile", "resource", "Filename", "prefix", "archive", "config", "ppa", "name", "tp", "password", "fn", "json", "picture", "session", "slice", "string", "il", "document", "socket", "ssl", "file", "uri", "lua", "files", "manager", "database", "sudo", "FILE", "metadata", "nil", "location", "fil"], "channel": ["source", "page", "url", "queue", "connection", "buffer", "username", "chan", "io", "message", "conn", "Channel", "client", "out", "directory", "stream", "resource", "handler", "server", "slave", "config", "writer", "can", "name", "transfer", "target", "password", "log", "ch", "session", "path", "pool", "socket", "file", "command", "self", "entry"], "is": ["id", "rx", "abi", "ais", "fs", "was", "isu", "irc", "ai", "ir", "iv", "isi", "it", "ins", "ci", "tis", "IS", "ri", "il", "image", "ios", "uri", "iii", "ii", "bis", "Is", "ip", "ib"], "os": ["options", "oper", " o", "ws", "io", "ou", "root", "OS", "outs", "oss", "res", "o", "aos", "ok", "log", "flush", "Os", "O", "ios", "ops", "obj", "or", "pos", "opt", "et", " bos", "op"], "reply": ["next", "respond", "continue", "notice", "queue", "link", "write", "msg", " replies", "connection", "buffer", "result", "message", "request", "mode", "ply", "ise", "enable", "response", "repl", "ret", "address", "info", "send", "Reply", "sync", "transfer", "force", "query", "ix", "rc", "report", "flush", "length", "comment", "status", "back", "ping", "dy", "install", "lock", "answer", "delay", "replace", "code", "callback", "resp", "error", "err", "attribute", "wait", "service", "i", "rr", "reason"], "verbose": ["verbore", "mutosed", "combosity", "quosed", "prettyose", "fosity", "combose", "buffosity", "logisy", " verbressed", "logosed", "verbressed", "verbsade", "logoise", "comblier", "logore", "labote", " verbote", "verbitive", "mutosity", "logout", "buffout", "silose", "verbosity", "silative", "fOSE", "verbade", "verbsosed", "prettyressive", "logosity", " verbisy", "vvote", "verbressive", "logose", "labOSE", "verbOSE", "mutout", "verbative", "labosity", "labose", " verbosed", "fose", "quose", "buffoise", "vvose", "vvisy", "logressive", "buffressive", "laboise", "prettyosity", "labressed", "verblier", "logade", "verbout", "buffosed", "querosity", "buffote", "verbisy", "logressed", " verbative", "loglier", "verbsose", "logOSE", "verbote", "silitive", "verbosed", "querose", "quore", "verboise", "quade", " verbitive", "silosity", "buffOSE", "verbsore", "prettyote", "logitive", "logative", "mutose", " verbOSE", " verbout", "buffose", "querlier", "fote", " verbosity", "logote", "vvosity"], "check_state": ["info64state", "check_source", "check64manager", "checkvalmedia", "check_cause", "block_media", "info64source", "check_manager", "info_source", "checkpremanager", "info64manager", "checkvalState", "blockxstate", "checkprestate", "check64source", "info64output", "check64output", "blockxcause", "checkpresource", "checkxstate", "checkxcause", "checkpreoutput", "block_cause", "check_output", "check64state", "block_state", "checkxState", "info_output", "check_media", "check_State", "checkxmedia", "checkvalcause", "info_state", "info_manager", "blockxState", "blockxmedia", "checkvalstate", "block_State"], "check_message": ["comment_message", "comment64member", "block_code", "block___code", "comment_mail", "block___output", "comment_address", "comment64mail", "block_language", "check_address", "check___output", "block_message", "check64language", "check___language", "block___language", "check_member", "checkJoutput", "check64output", "check64mail", "block___message", "block_output", "checkJmessage", "comment_member", "check64member", "check_output", "check___code", "checkJlanguage", "check_code", "checkJcode", "check___message", "check_mail", "check64code", "check64address", "check64message", "comment64address", "comment64message", "check_language"]}}
{"id1": "15136801", "id2": "518901", "code1": "    public static String readUrl(String urlString) {\n        try {\n            java.net.URL url = new java.net.URL(urlString);\n            BufferedReader br = null;\n            if (url != null) {\n                br = new BufferedReader(new InputStreamReader(url.openStream()));\n            }\n            StringBuffer fileString = new StringBuffer();\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                fileString.append(line + \"\\n\");\n            }\n            return fileString.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public void fetchFile(String ID) {\n        String url = \"http://www.nal.usda.gov/cgi-bin/agricola-ind?bib=\" + ID + \"&conf=010000++++++++++++++&screen=MA\";\n        System.out.println(url);\n        try {\n            PrintWriter pw = new PrintWriter(new FileWriter(\"MARC\" + ID + \".txt\"));\n            if (!id.contains(\"MARC\" + ID + \".txt\")) {\n                id.add(\"MARC\" + ID + \".txt\");\n            }\n            in = new BufferedReader(new InputStreamReader((new URL(url)).openStream()));\n            in.readLine();\n            String inputLine, stx = \"\";\n            StringBuffer sb = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.startsWith(\"<TR><TD><B>\")) {\n                    String sts = (inputLine.substring(inputLine.indexOf(\"B>\") + 2, inputLine.indexOf(\"</\")));\n                    int i = 0;\n                    try {\n                        i = Integer.parseInt(sts);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    if (i > 0) {\n                        stx = stx + \"\\n\" + sts + \" - \";\n                    } else {\n                        stx += sts;\n                    }\n                }\n                if (!(inputLine.startsWith(\"<\") || inputLine.startsWith(\" <\") || inputLine.startsWith(\">\"))) {\n                    String tx = inputLine.trim();\n                    stx += tx;\n                }\n            }\n            pw.println(stx);\n            pw.close();\n        } catch (Exception e) {\n            System.out.println(\"Couldn't open stream\");\n            System.out.println(e);\n        }\n    }\n", "label": 0, "substitutes": {"urlString": ["urlstring", "fileStream", "httpStream", "resourcestring", "resourceSection", " urlSection", "fileSection", "urlStr", "filestring", "fileSource", " urlStream", " urlstring", "httpSource", "urlSection", " urlSource", "fileStr", "urlStream", "urlSource", "httpString", "resourceStr", "resourceString", "httpstring", " urlStr"], "url": ["user", "browser", "feed", "plug", "buffer", "connection", "open", "l", "lib", "http", "object", "b", "fr", "f", "base", "loc", "ref", "stream", "r", "resource", "org", "server", "address", "ur", "gl", "bb", "ob", "log", "bel", "fl", "string", "image", "rl", "impl", "html", "file", "uri", "ssl", "socket", "db", "URL", "service", "Url", "blog", "web", "str", "jar", "sl", "bl", "entry"], "br": ["ber", "brush", "reader", "cb", "gr", "bf", "browser", "bh", "arr", "result", "Br", "b", "ler", "bc", "fr", "BR", "ref", "r", "abb", "er", "ur", "bur", "bb", "bridge", "sr", "pr", "hr", "bar", "buf", "dr", "tr", "cr", "obj", "rt", "mr", "err", "yr", "bed", "fb", "bro", "img", "str", "rb", "jar", "bl"], "fileString": ["feedString", "fileInt", "feedStr", "FileBuffer", "fileFile", "resourceFile", "FileText", "feedFile", "baseBytes", "ruleBuffer", "baseLine", "FileBytes", "fileBytes", "ruleLine", " fileFile", "fileLine", "ruleString", "FileStr", "feedInt", "baseBuffer", "fileText", "FileInt", "ruleBytes", "FileFile", " fileText", "FileString", "resourceText", " fileStr", "resourceLine", " fileInt", "fileStr", "baseString", "fileBuffer", "resourceString", " fileLine", "FileLine"], "line": ["next", "source", "page", "entry", "reader", "link", "write", "pe", "feed", "buffer", "lf", "lines", "result", "output", "l", "letter", "out", "object", "char", "end", "LINE", "cell", "column", "Line", "row", "f", "data", "no", "inline", "style", "response", "e", "log", "cl", "text", "content", "lc", "le", "string", "frame", "file", "parse", "code", "character", "valid", "lin", "str", "sl", "pass"]}}
{"id1": "15037259", "id2": "14282702", "code1": "    public void testJob() {\n        try {\n            URL url = new URL(\"http://rickysql.gotoip3.com/mapp/admin/admin.do\");\n            url.openConnection();\n            url.getContent();\n            System.out.print(\"00\");\n        } catch (Exception e) {\n            System.out.print(\"Daily data update exception:\" + e);\n        }\n    }\n", "code2": "    @Override\n    public void runTask(HashMap jobStack) throws Exception {\n        String lstrFilter = (String) getResources().get(\"filter\");\n        String lstrTarget = (String) getResources().get(\"target\");\n        String lstrSource = (String) getResources().get(\"source\");\n        String[] lstrFilesFound = null;\n        lstrFilesFound = searchForFiles(lstrSource, lstrFilter);\n        if (lstrFilesFound != null) {\n            for (int i = 0; i < lstrFilesFound.length; i++) {\n                getLog().debug(\"Found match [\" + lstrSource + File.separator + lstrFilesFound[i] + \"]\");\n                File lfileSource = new File(lstrSource + File.separator + lstrFilesFound[i]);\n                File lfileTarget = new File(lstrTarget + File.separator + lstrFilesFound[i]);\n                FileChannel lfisInput = null;\n                FileChannel lfosOutput = null;\n                try {\n                    lfisInput = new FileInputStream(lfileSource).getChannel();\n                    lfosOutput = new FileOutputStream(lfileTarget).getChannel();\n                    int maxCount = (32 * 1024 * 1024) - (32 * 1024);\n                    long size = lfisInput.size();\n                    long position = 0;\n                    while (position < size) {\n                        position += lfisInput.transferTo(position, maxCount, lfosOutput);\n                    }\n                } finally {\n                    if (lfisInput != null) {\n                        lfisInput.close();\n                    }\n                    if (lfosOutput != null) {\n                        lfosOutput.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["host", "page", "user", "browser", "feed", "connection", "pull", "buffer", "build", "ll", "l", "http", "out", "object", "client", "b", "app", "f", "channel", "data", "resource", "org", "server", "address", "update", "e", "bb", "ob", "json", "log", "api", "bel", "job", "location", "string", "path", "image", "file", "ssl", "fb", "URL", "service", "Url", "www", "web", "sl"]}}
{"id1": "20852768", "id2": "2766456", "code1": "    private final Vector<Class<?>> findSubclasses(URL location, String packageName, Class<?> superClass) {\n        synchronized (results) {\n            Map<Class<?>, URL> thisResult = new TreeMap<Class<?>, URL>(CLASS_COMPARATOR);\n            Vector<Class<?>> v = new Vector<Class<?>>();\n            String fqcn = searchClass.getName();\n            List<URL> knownLocations = new ArrayList<URL>();\n            knownLocations.add(location);\n            for (int loc = 0; loc < knownLocations.size(); loc++) {\n                URL url = knownLocations.get(loc);\n                File directory = new File(url.getFile());\n                if (directory.exists()) {\n                    String[] files = directory.list();\n                    for (int i = 0; i < files.length; i++) {\n                        if (files[i].endsWith(\".class\")) {\n                            String classname = files[i].substring(0, files[i].length() - 6);\n                            try {\n                                Class<?> c = Class.forName(packageName + \".\" + classname);\n                                if (superClass.isAssignableFrom(c) && !fqcn.equals(packageName + \".\" + classname)) {\n                                    thisResult.put(c, url);\n                                }\n                            } catch (ClassNotFoundException cnfex) {\n                                errors.add(cnfex);\n                            } catch (Exception ex) {\n                                errors.add(ex);\n                            }\n                        }\n                    }\n                } else {\n                    try {\n                        JarURLConnection conn = (JarURLConnection) url.openConnection();\n                        JarFile jarFile = conn.getJarFile();\n                        Enumeration<JarEntry> e = jarFile.entries();\n                        while (e.hasMoreElements()) {\n                            JarEntry entry = e.nextElement();\n                            String entryname = entry.getName();\n                            if (!entry.isDirectory() && entryname.endsWith(\".class\")) {\n                                String classname = entryname.substring(0, entryname.length() - 6);\n                                if (classname.startsWith(\"/\")) classname = classname.substring(1);\n                                classname = classname.replace('/', '.');\n                                try {\n                                    Class c = Class.forName(classname);\n                                    if (superClass.isAssignableFrom(c) && !fqcn.equals(classname)) {\n                                        thisResult.put(c, url);\n                                    }\n                                } catch (ClassNotFoundException cnfex) {\n                                    errors.add(cnfex);\n                                } catch (NoClassDefFoundError ncdfe) {\n                                    errors.add(ncdfe);\n                                } catch (UnsatisfiedLinkError ule) {\n                                    errors.add(ule);\n                                } catch (Exception exception) {\n                                    errors.add(exception);\n                                } catch (Error error) {\n                                    errors.add(error);\n                                }\n                            }\n                        }\n                    } catch (IOException ioex) {\n                        errors.add(ioex);\n                    }\n                }\n            }\n            results.putAll(thisResult);\n            Iterator<Class<?>> it = thisResult.keySet().iterator();\n            while (it.hasNext()) {\n                v.add(it.next());\n            }\n            return v;\n        }\n    }\n", "code2": "    private void renderScript(PhaseEvent event) {\n        URL url = AjaxPhaseListener.class.getResource(SCRIPT_RESOURCE_NAME);\n        URLConnection conn = null;\n        InputStream stream = null;\n        BufferedReader bufReader = null;\n        HttpServletResponse response = (HttpServletResponse) event.getFacesContext().getExternalContext().getResponse();\n        OutputStreamWriter outWriter = null;\n        String curLine = null;\n        try {\n            outWriter = new OutputStreamWriter(response.getOutputStream(), response.getCharacterEncoding());\n            conn = url.openConnection();\n            conn.setUseCaches(false);\n            stream = conn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(stream));\n            response.setContentType(\"text/javascript\");\n            response.setStatus(200);\n            while (null != (curLine = bufReader.readLine())) {\n                outWriter.write(curLine + \"\\n\");\n            }\n            outWriter.flush();\n            outWriter.close();\n            event.getFacesContext().responseComplete();\n        } catch (Exception e) {\n            String message = null;\n            message = \"Can't load script file:\" + url.toExternalForm();\n        }\n    }\n", "label": 0, "substitutes": {"location": ["language", "source", "folder", "site", "connection", "xml", "LOC", "home", " Location", "base", "layer", "region", "class", "remote", "resource", "server", "address", "config", "Location", "module", "filename", "direction", "area", "string", "path", "node", "document", "image", "library", "uri", "command", "URL", "database", "collection"], "packageName": ["folderName", " packageSize", "componentCode", "componentFamily", " packageSummary", "componentname", "packageCode", "packagePath", "PackagePath", "packagename", "folderType", " packageCode", "componentName", "folderCode", "databaseName", "folderSize", "databaseFamily", " packagename", "databaseSummary", "Packagename", "pkgSize", "pkgType", "packageFamily", " packageType", "packageSize", "pkgName", "PackageName", "pkgCode", "packageSummary", "PackageSummary", " packagePath", "databasename", "databaseCode", "packageType", "databasePath", " packageFamily"], "superClass": [" superclass", "superCode", "Superclass", "perCode", "perclass", "SuperClass", "SuperCode", "superType", " superType", "perType", "subType", "superclass", " superCode", "SuperType", "perClass", "subClass", "subclass"], "thisResult": ["theseRes", "ThisReturn", "theseReturn", "thisRes", "ThisResult", " thisRes", "theseArray", "theseResult", "theseResults", "theseMap", "ThisMessage", "thisResults", "thisReturn", " thisResults", "thisMap", "thisArray", "theseMessage", " thisReturn", " thisArray", " thisMessage", "ThisResults", "ThisRes", "ThisArray", " thisMap", "thisMessage", "ThisMap"], "v": ["d", "br", "l", "ev", "V", "b", "f", "cv", "r", "var", "vs", "vp", "u", "m", "vals", "uv", "rev", "ii", "g", "ov", "vi", "array", "conv", "s", "p"], "fqcn": ["fixhn", "bqsdn", "bqhn", "fqns", "fqsdn", "Fqdn", "fetcn", "fqsns", "FQn", "bqsns", "fQn", "fvdn", "FQdn", "fqdn", "fvCN", "fqhn", "bqns", "Fqn", "fetdn", "bqshn", "Fqcn", "fetCN", "bqscn", "fixcn", "bqdn", "fqCN", "fqscn", "fQCN", "fixdn", "FQCN", "fetn", "fqshn", "fvn", "fQhn", "fQns", "fQdn", "bqcn", "fvcn", "fQcn", "FqCN", "fqn", "FQcn", "fixns"], "knownLocations": ["knowLanguages", "knownBlanguages", " knownLocation", "knownSlocation", "unknownBlanguages", "knownFlayers", "knowBlocation", " knownLoanguages", "knownLolutions", "knownClanguages", "knownLocation", " knownLoibraries", "knownlolutions", "unknownLolutions", "knownLoanguages", "unknownBlocation", " knownLibraries", "knownAllayers", "knownAllocation", "knownBlibraries", "knownSlibraries", "knownLoocation", "knowLocations", "unknownBlolutions", "knownLayers", " knownLoocations", "knownAllolutions", "knownBlocation", "knownlayers", "knownFlocation", "knowBlocations", "knownSlocations", "knownBlocations", "knownLoocations", "knownLococations", " knownLanguages", "knownBlayers", "knownFlanguages", "unknownLocation", "unknownLocations", "knowBlanguages", "knownClocations", "knownAllocations", "knownClibraries", " knownLoocation", "knownlocations", "knownLibraries", "knownClocation", "knowLibraries", "knownFlocations", "knownAllanguages", "knownlanguages", "knownBlolutions", "unknownLayers", "knownLococation", "unknownLanguages", "knownLanguages", "unknownBlayers", "knownLoibraries", "knownSlanguages", "knownLocibraries", "knowBlibraries", "knowLocation", "unknownBlocations", "knownLocanguages"], "loc": ["inc", "go", "lang", "uc", "ld", "ll", "iter", "co", "hi", "src", "fc", "l", "LOC", "lim", "val", "bc", "lr", "fe", "oc", "zip", "ctx", "sc", "tx", "Loc", "Location", "lo", "cur", "dir", "rc", "other", "ok", "exp", "cl", "length", "lc", "col", "sec", "il", "rl", "coord", "oci", "pos", "local", "lb", "coll", "pl"], "url": ["source", "host", "page", "route", "user", "link", "connection", "download", "director", "ll", "result", "io", "l", "ul", "http", "client", "lr", "channel", "base", "layer", "ref", "loader", "class", "r", "resource", "email", "archive", "server", "address", "config", "org", " URL", "filename", "name", "ur", "dir", "log", "fl", "ls", "li", "string", "path", "image", "uri", "file", "ssl", "URL", "database", "service", "Url", "www", "jar", "sl"], "directory": ["source", "folder", "d", "connection", "director", "result", "output", "Directory", "l", "out", "home", "description", "f", "loader", "layer", "data", "class", "tree", "resource", "archive", "server", "creator", "module", "machine", "filename", "name", "volume", "dir", "direction", "direct", "container", "category", "session", "path", "document", "library", "uri", "file", "record", "URL", "database", "manager", "service", "project", "collection"], "files": ["balls", "resources", "classes", "Files", "tests", "strings", "actions", "links", "events", "sections", "lines", "packs", "keys", "tools", "lib", "fs", "items", "books", "bugs", "sheets", "f", "facts", "data", "blocks", "bytes", "bs", "objects", "sites", "models", "children", "ports", "filename", "users", "boxes", "dir", "phones", "plugins", "ins", "images", "pages", "members", "locks", "names", "ls", "fields", "words", "rules", "docs", "headers", "thumbnails", "features", "ips", "file", "apps", "projects", "ids", "obs", "views"], "i": ["id", "h", "si", "multi", "qi", "ind", "iu", "hi", "io", "phi", "k", "y", "b", "diff", "f", "ij", "di", "I", "ti", "ni", "ai", "gi", "info", "oi", "inner", "ji", "iv", "ix", "ui", "ci", "u", "ini", "lc", "li", "xi", "col", "index", "ri", "j", "uri", "ori", "ii", "vi", "pi", "fi", "mi", "uni", "ip", "p", "ie"], "classname": ["catchname", "entryno", "entrysource", "stringtype", " classkey", "entrykey", "classkey", "functionname", "CLASSName", "stringno", "entryName", "stringname", "catchnamed", "filepath", " classpath", "classsource", "fileName", "classpath", "stringName", "stringfull", "typename", "classtype", "classimage", " classnamed", " classimage", "catchName", " classsource", "filename", "stringpath", "stringnamed", " className", "catchimage", "ClassName", "classfull", "typeimage", "typeName", "className", "entrypath", "filesource", "Classname", " classtype", " classfull", "typepath", "functionName", "fileno", "typenamed", "functionpath", "typekey", "Classnamed", "classnamed", "classno", "CLASSname", "functionnamed", "CLASSfull", "typetype", "Classpath"], "c": ["h", "dc", "cd", "d", "chain", "co", "cat", "k", "l", "con", "b", "css", "f", "ctrl", "cp", "n", "class", "r", "sc", "ac", "mc", "cn", "name", "ci", "cross", "u", "o", "esc", "cl", "t", "cs", "ch", "m", "lc", "com", "col", "abc", "or", "g", "ce", "cc", "ca", "cod", "s", "coll", "p", "C"], "conn": ["net", "connection", "open", "cf", "jp", "io", "ct", "http", "con", "fp", "client", "b", "Conn", "ctrl", "cp", "n", "enc", "ctx", "serv", "config", "ai", "cn", "conf", "init", "rc", "nt", "act", "ch", "cli", "apt", "col", "connect", "lock", "reg", "db", "rt", "j", "conv", "cc", "Connection", "ca", "coll"], "jarFile": ["zipFile", "searchfile", "javaFile", "Jarfile", " jarF", "JarF", "jarBlock", "zipDir", " jarfile", "searchBlock", " jarDir", "searchDir", "javaBlock", "zipfile", "jarfile", "javafile", "JarDir", "JarFile", "zipF", "jarDir", "searchFile", " jarBlock", "jarF", "javaDir"], "e": ["ea", "h", "en", "pe", "d", "ente", "ent", "be", "edge", "iter", "ee", "ed", "l", "ev", "que", "driver", "end", "f", "E", "p", "fe", "ec", "r", "her", "es", "esi", "he", "el", "element", "er", "ge", "event", "o", "de", "ae", "oe", "enter", "je", "se", "le", "eb", "ze", "err", "eu", "ce", "ele", "ie"], "entry": ["next", "page", "reader", "term", "d", "ent", "connection", "result", "cat", "ry", "l", "object", "cell", "part", "row", "f", "add", "data", "class", "r", "auto", "match", "ie", "archive", "ident", "info", "element", "section", "name", "component", "event", "country", "nt", "enter", "comment", "lc", "key", "index", "string", "image", "entity", "obj", "file", "record", "parse", "error", "or", "Entry", "service", "field", " Entry"], "entryname": [" entryName", "importsize", "entryno", "classsize", "importmin", "importinfo", " entrymin", "zipname", "Entrypart", "entersize", "elementpath", "entername", "zipName", "classpart", "entrysize", "servicename", "elementname", "zipnam", "zipimage", "entryName", "importname", "stringname", "Entryno", "serviceName", "serviceimage", " entrysize", "classpath", "stringName", " entryinfo", "Entryname", "elementpart", "elementsize", "stringimage", "elementno", "entryimage", "stringnam", "enterinfo", "className", "entrypath", "entrymin", "entrypart", " entrypath", "entrynam", "servicenam", "entermin", "entryinfo", "EntryName", "classno", "elementName"]}}
{"id1": "16324741", "id2": "23413733", "code1": "    public static void copyFiles(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws Exception {\n        if (!from.exists()) return;\n        FileInputStream in = new FileInputStream(from);\n        FileOutputStream out = new FileOutputStream(to);\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int bytes_read;\n        while (true) {\n            bytes_read = in.read(buffer);\n            if (bytes_read == -1) break;\n            out.write(buffer, 0, bytes_read);\n        }\n        out.flush();\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"source": ["parent", "route", "reader", "site", "id", "input", "connection", "iter", "down", "origin", "src", "from", "Source", "base", "stream", "remote", "resource", "server", "inner", "ources", "sync", "name", "ins", "target", "unit", "ource", "copy", "up", "SOURCE", "sin", "slice", "path", "image", "file", "start", "s", "null", "use", "ie"], "dest": ["folder", "route", "die", "dc", "later", "default", "result", "down", "flat", "src", "home", " destination", "delete", "thin", " Dest", "desc", "target", "de", "Dest", "temp", "done", "orig", "obj", "comb", "wb", "coord", "dist", "img", "destroy", "bin", "test", "exit"], "in": ["plus", "reader", "id", "url", "input", "inc", "din", "win", "download", "plugin", "min", "nin", "src", "conn", "con", "client", "b", "this", "login", "as", "data", "In", "pin", "again", "re", "r", "include", "thin", "resource", "work", "isin", "inner", "name", "init", "it", "ins", "gin", "ini", "m", "issue", "session", "up", "cin", "image", "socket", "c", "file", "i", "IN", "err", "inside", "inn", "rin", "bin", "s", "ac", "ie"], "out": ["parent", "plain", "id", "write", "our", "net", "connection", "not", "buffer", "with", "extra", "down", "cat", "io", "output", "outer", "conn", "lib", "one", "w", "client", "this", "ou", "part", "channel", "no", "OUT", "Out", "n", "outs", "again", "trial", "call", "server", "writer", "inner", "off", "exec", "sync", "name", "o", "other", "password", "ex", "up", "pool", "vert", "obj", "socket", "file", "err", "at", "outside", "bin", "option", "copy", "ext"], "size": ["ice", "export", "en", "id", "write", "si", "len", "open", "scale", "now", "sized", "iz", "end", "age", "mode", "Size", "loc", "number", "SIZE", "bytes", "n", "sum", "address", "shape", "send", "depth", "name", "transfer", "ize", "length", "flush", "capacity", "izes", "content", "max", "offset", "close", "time", "count", "seek", "width", "map", "speed", "type", "start", "empty", "small", "clear", "any", "unit"], "buf": ["dec", "cb", "ra", "bf", "la", "uc", "len", "buffer", "ha", "buff", "cmp", "br", "Buffer", "src", "cas", "b", "val", "bc", "fd", "cv", "data", "bd", "bytes", "ctx", "box", "fam", "feat", "seq", "uf", "bag", "ba", "vec", "map", "BU", "fb", "ff", "bn", "rb", "coll", "pkg"]}}
{"id1": "4710943", "id2": "691789", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        long t0 = System.currentTimeMillis();\n        String id = request.getRequestURI().split(\"/\")[3];\n        Song song = manager.find(id);\n        if (song != null) {\n            if (song.getArtwork()) {\n                if (log.isDebugEnabled()) log.debug(\"song has embedded artwork\");\n                try {\n                    AudioFile af = AudioFileIO.read(new File(song.getFile()));\n                    Tag tag = af.getTag();\n                    Artwork aw = tag.getFirstArtwork();\n                    byte[] bytes = aw.getBinaryData();\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    response.setContentType(aw.getMimeType());\n                    response.getOutputStream().write(bytes);\n                } catch (Exception e) {\n                    log.warn(e.getMessage());\n                }\n            } else {\n                if (log.isDebugEnabled()) log.debug(\"search in directory\");\n                File directory = new File(song.getFile()).getParentFile();\n                File[] files = directory.listFiles(filter);\n                if (files != null && files.length > 0) {\n                    File file = files[0];\n                    String type = FilenameUtils.getExtension(file.getName()).toLowerCase();\n                    if (type.startsWith(\"jp\")) type = \"jpeg\";\n                    String mime = \"image/\" + type;\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    response.setContentType(mime);\n                    FileInputStream stream = new FileInputStream(file);\n                    try {\n                        IOUtils.copy(stream, response.getOutputStream());\n                    } catch (IOException e) {\n                        log.warn(e.getMessage());\n                    } finally {\n                        IOUtils.closeQuietly(stream);\n                    }\n                } else {\n                    if (log.isDebugEnabled()) log.debug(\"image not found: \" + id + \", sending redirect: \" + redirect);\n                    response.sendRedirect(redirect);\n                }\n            }\n        } else {\n            log.info(\"song not found: \" + id);\n            response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n        }\n        long t1 = System.currentTimeMillis();\n        log.info(\"request: \" + id + \" duration: \" + (t1 - t0) + \"ms\");\n    }\n", "code2": "    public void bubbleSort(int[] arr) {\n        BasicProcessor.getInstance().getStartBlock();\n        BasicProcessor.getInstance().getVarDeclaration();\n        boolean swapped = true;\n        BasicProcessor.getInstance().getVarDeclaration();\n        int j = 0;\n        BasicProcessor.getInstance().getVarDeclaration();\n        int tmp;\n        {\n            BasicProcessor.getInstance().getWhileStatement();\n            while (swapped) {\n                BasicProcessor.getInstance().getStartBlock();\n                swapped = false;\n                j++;\n                {\n                    BasicProcessor.getInstance().getForStatement();\n                    for (int i = 0; i < arr.length - j; i++) {\n                        BasicProcessor.getInstance().getStartBlock();\n                        {\n                            BasicProcessor.getInstance().getIfStatement();\n                            if (arr[i] > arr[i + 1]) {\n                                BasicProcessor.getInstance().getStartBlock();\n                                tmp = arr[i];\n                                arr[i] = arr[i + 1];\n                                arr[i + 1] = tmp;\n                                swapped = true;\n                                BasicProcessor.getInstance().getEndBlock();\n                            }\n                        }\n                        BasicProcessor.getInstance().getEndBlock();\n                    }\n                }\n                BasicProcessor.getInstance().getEndBlock();\n            }\n        }\n        BasicProcessor.getInstance().getEndBlock();\n    }\n", "label": 0, "substitutes": {"request": ["reader", "url", "input", "queue", "req", "connection", "xml", "pull", "complete", "result", "message", "view", "http", "client", "application", "data", "resource", "server", "call", "child", "Request", "info", "writer", "er", "method", "query", "event", "e", "report", "instance", "session", "image", "uri", "i", "manager", "current", "position", "use", "QUEST"], "response": ["su", "default", "result", "model", "onse", "resource", "writer", "HTTP", "other", "report", "status", "received", "location", "site", "feed", "xml", "reply", "object", "application", "future", "results", " Response", "Response", "index", "more", "all", "pool", "parse", "URL", "video", "Url", "res", "collection", "page", "respond", "queue", "http", "client", "this", "description", "version", "server", "_", "error", "Resp", "manager", "s", "next", "connection", "success", "download", "message", "output", "view", "format", "out", "data", "re", "tree", "serv", "body", "json", "api", "wave", "session", "document", "resp", "entry"], "t0": ["t00", " t00", "tt00", "dt00", "dt5", " t5", "tt1", "t5", "dt1", "tt5", "tt0", "dt0"], "id": ["source", "url", "did", "link", "mid", "view", "in", "aid", "part", "f", "Id", "data", "work", "resource", "ident", "address", "info", "name", "bid", "uid", "query", "pid", "key", "side", "index", "string", "path", "image", "uri", "code", "i", "error", "vid", "ids", "iden", "create", "kid", "ID", "sid", "ip"], "song": ["source", "play", "hop", "vision", "site", "sample", "user", "si", "nn", "plugin", "band", "game", "audio", "ship", "voice", "jo", "album", "Song", "model", "channel", "layer", "part", "seed", "pin", "ding", "style", "single", "work", "feature", "trial", "match", "learning", "ong", "photo", "sync", "name", "station", "room", "spec", "dj", "student", "syn", "wave", "job", "session", "sin", "string", "image", "artist", "sk", "library", "live", "record", "son", " songs", "search", "sound", "note", "service", "music", "item", "ip", "bot", "project", "sid", "track"], "af": [" ab", "sa", "ant", "la", "ap", "audio", "aux", "AF", " ac", "aj", "as", "aph", "afi", " fa", "ai", "al", "aff", "au", "amp", "ax", "ae", "Af", "a", "apt", "ba", "ape", "art", "aft", "alog", "ab", "aba", "raf", "av", "aa", "AFP", "ag", "ca", "fa", "ad", "ac"], "tag": ["parent", "attr", "ban", "TAG", "ra", "ang", "pe", "band", "ee", "cat", "ro", "bug", "root", "loc", "data", "ref", "r", "oo", "ac", "name", "Tag", "ack", "event", "ay", "au", "feat", "log", "bag", "ann", "own", "art", "string", "image", "reg", "raf", "manager", "cro", "av", "tags", "ar", "ag", "ad", "p"], "aw": ["aws", " ape", "haw", " array", "la", " av", "wal", "hw", "saw", " ap", " assembly", "ah", " archive", "awi", "asha", "ew", "am", "ga", " instance", "sw", "wa", "aux", " all", "rew", " fa", "ai", "al", "ema", "Aw", " api", "au", "ay", "ax", "ae", " aid", "asu", "ow", " acc", " access", "a", "AW", " au", "ave", "asa", "iw", " am", "array", "aa", "awa", " app", " attachment", " ma", " award", "fa", " arg", "va", " ad"], "bytes": ["resources", "strings", "ings", "ipes", "binary", "Bytes", "pieces", "lines", "items", "bps", "ions", "data", "blocks", "elt", "bs", "objects", "outs", "es", "gets", "vs", "body", "pages", "values", "ls", "bles", "units", "gb", "string", "les", "vals", "its", "details", "articles", "parts", "boot", "bits", "tes", "videos", "seconds"], "directory": ["source", "resources", "folder", "parent", "d", "upload", "disk", "connection", "download", "director", "io", "Directory", "audio", "out", "object", "sf", "root", "f", "application", "channel", "zip", "tree", "system", "handler", "archive", "server", "minute", "module", "yard", "machine", "filename", "name", "volume", "dir", "itory", "direction", "direct", "container", "category", "media", "path", "image", "document", "library", "node", "manager", "database", "video", "project", "collection", "location"], "files": ["balls", "resources", "Files", "classes", "tests", "states", "reports", "events", "sections", "lines", "fs", "items", "books", "types", "bugs", "sheets", "f", "ions", "blocks", "issues", "objects", "flows", "sites", "models", "archives", "children", "stars", "groups", "ports", "users", "boxes", "plugins", "phones", "results", "rooms", "images", "pages", "members", "values", "locks", "requires", "names", "ls", "fields", "words", "rows", "docs", "features", "ips", "iles", "apps", "projects", "ids", "fires", "videos", "seconds", "s", "uploads"], "file": ["source", "page", "parent", "folder", "ile", "url", "pe", "place", "File", "message", "l", "letter", "object", "b", "fp", "model", "part", "f", "base", "data", "future", "auto", "single", "style", "resource", "handler", "child", "info", "module", "force", "filename", "name", "dir", "full", "it", "e", "per", "log", "show", "path", "image", "document", "load", "lock", "record", "live", "local", "FILE", "use"], "type": ["language", "page", "size", "none", "py", "split", "pe", "rel", "year", "ype", "TYPE", "view", "format", "y", "one", "object", "types", "Type", "part", "f", "base", "data", "version", "class", "style", "single", "resource", "role", "ty", "info", "template", "shape", "name", "action", "dir", "kind", "large", "o", "t", "ext", "copy", "key", "col", "icon", "string", "index", "image", "day", "title", "like", "block", "field", "domain", "op"], "mime": ["menge", "smIME", "mIME", "smime", " mag", " menge", "mmag", "Menge", "mimes", "mag", " mIME", "mpe", "smpe", "mmenge", "Mimes", "smimes", "Mpe", "MIME", " mimes", "Mag", "mmime", "Mime", "mmIME", " mpe"], "stream": ["source", "host", "reader", "draft", "url", "input", "user", "oper", "trans", "wrapper", "upload", "feed", "Stream", "open", "result", "sign", "output", "message", "view", "control", "flash", "sw", "object", "driver", "channel", "f", "data", "serial", "clean", "resource", "handler", "writer", "transfer", "body", "ack", "per", "transform", "temp", "path", "image", "pool", "document", "cache", "context", "or", "speed", "video", "form", "platform", "coll", "sl"]}}
{"id1": "19631892", "id2": "14647876", "code1": "    public static void copyFiles(File src, File dest) throws IOException {\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            for (String f : src.list()) {\n                String df = dest.getPath() + File.separator + f;\n                String sf = src.getPath() + File.separator + f;\n                copyFiles(new File(sf), new File(df));\n            }\n        } else {\n            FileInputStream fin = new FileInputStream(src);\n            FileOutputStream fout = new FileOutputStream(dest);\n            int c;\n            while ((c = fin.read()) >= 0) fout.write(c);\n            fin.close();\n            fout.close();\n        }\n    }\n", "code2": "    public static void copyFile(IPath fromFileName, IPath toFileName) throws IOException {\n        File fromFile = fromFileName.toFile();\n        File toFile = toFileName.toFile();\n        if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFileName);\n        if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n        if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) throw new IOException(\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n        }\n        InputStream from = null;\n        OutputStream to = null;\n        try {\n            from = new BufferedInputStream(new FileInputStream(fromFile));\n            to = new BufferedOutputStream(new FileOutputStream(toFile));\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "resources", "sel", "RC", "sb", "tmp", "url", "input", "req", "txt", "upload", "sit", "origin", "http", "in", "inf", "b", "Source", "st", "supp", "loc", "ruby", "stream", "storage", "resource", "sc", "rob", "archive", "config", "ources", "sub", "cur", "sup", "filename", "init", "ins", "rc", "inst", "spec", "sr", "ource", "sin", "SOURCE", "slice", "scripts", "thumbnails", "obj", "secure", "ssl", "seed", "support", "files", "sq", "dist", "start", "img", "project", "s", "rb", "rest", "sl"], "dest": ["source", "folder", "parent", "route", "die", "dc", "tmp", "export", "trans", "later", "d", "txt", "upload", "dep", "result", "flat", "wd", "cdn", "out", "both", "home", "st", " destination", "delete", "loc", "thin", " Dest", "du", "sup", "desc", "transfer", "dir", "target", "de", "cont", "transform", "Dest", "temp", "done", "orig", "file", "comb", "wb", "front", "dist", "destroy", "project", "store", "rest"], "f": ["xf", "h", "rf", "d", "feed", "cf", "l", "fs", "fp", "b", "fd", "fr", "tf", "fe", "ref", "n", "x", "fun", "name", "e", "fn", "t", "F", "m", "fold", "v", "string", "file", "i", "fen", "field", "s", "fa", "p", "fx"], "df": ["dl", "dq", "xf", "isf", "dc", "rf", "cd", "bf", "d", "lf", "dd", "cf", "fore", "fs", "out", "fp", "elf", "fd", "fr", "tf", "def", "fe", "di", "dn", "der", "du", "dir", "dm", "deb", "uf", "dr", "dim", "file", "db", "raf", "dist", "ds", "ff", "sd", "fa", "DF", "fx"], "sf": ["dl", "xf", "isf", "su", "sb", "rf", "suff", "bf", "si", "ulp", "feed", "lf", "cf", "ss", "fs", "fp", "inf", "fd", "elf", "tf", "fe", "tif", "sh", "sup", "vp", "fn", "SF", "sv", "sp", "file", "db", "fb", "sq", "dist", "ds", "fm", "ff", "sd", "s", "sl", "fx"], "fin": ["su", "die", "rf", "cb", "trans", "Fin", "fine", "conn", "fs", "fp", "in", "fd", "fr", "pin", "thin", "fat", "off", "init", "rc", "per", "FIN", "non", "fn", "spec", "rb", "ini", "nir", "kin", "done", "close", "fit", "before", "ori", "prev", "raf", "fb", "inn", "fen", "rin", "fi", "lin", "inv", "fa"], "fout": ["FOut", "fsync", "fOUT", "fdsync", "ufOUT", " fagain", "fOut", "fenoff", " fOut", "ffOUT", "fdOut", "ffoff", "ffout", "ufout", " foff", "fdinit", "Fsync", "Finit", " finit", "fileoff", "fileout", " fsync", " fwrite", "fenout", "fagain", "filenet", " fOUT", " fnet", "ufwrite", "fenagain", "fennet", "foff", "fdout", "fileagain", "ufoff", "fwrite", "finit", "Fout", "ffwrite", "fnet"], "c": ["dec", "dc", "cb", "cd", "d", "uc", "cy", "cu", "cf", "k", "fc", "l", "char", "bc", "p", "ec", "oc", "n", "r", "enc", "xc", "ac", "pc", "x", "exec", "ci", "rc", "e", "u", "o", "esc", "cl", "arc", "t", "ch", "m", "lc", "abc", "col", "cr", "pointer", "i", "character", "ce", "cc", "ct", "nc", "ic", "C"]}}
{"id1": "9049568", "id2": "8109022", "code1": "    public void reset(String componentName, int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \" + \"AND component_name = ?\");\n            psta.setInt(1, currentPilot);\n            psta.setString(2, componentName);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    public static void main(String args[]) throws Exception {\n        currTime = getCurrentTimestamp();\n        String sqlDoc = \"\";\n        String sqlVersion = \"\";\n        String sqlDocVersion = \"\";\n        String sqlContent = \"\";\n        String sqlDocDetail = \"\";\n        String sqlRoot = \"\";\n        java.util.Properties props = new java.util.Properties();\n        String path = new LoadDocumentData().getClass().getProtectionDomain().getCodeSource().getLocation().toString().substring(6);\n        if (!path.endsWith(\"/\")) {\n            path += \"/\";\n        }\n        path += \"generate.properties\";\n        if (!path.startsWith(\"/\")) {\n            path = \"/\" + path;\n        }\n        java.io.FileInputStream fis = new java.io.FileInputStream(new java.io.File(path));\n        props.load(fis);\n        author = props.getProperty(\"author\");\n        srcPath = props.getProperty(\"srcPath\");\n        driverStr = props.getProperty(\"driverStr\");\n        dbConnStr = props.getProperty(\"dbConnStr\");\n        dbUsername = props.getProperty(\"dbUsername\");\n        dbPassword = props.getProperty(\"dbPassword\");\n        openDBConn();\n        stat = conn.createStatement();\n        Hashtable htTableKey = new Hashtable();\n        htTableKey = getTableKey(conn);\n        genUserDefinedIndex(conn, htTableKey);\n        Integer ownerID = new Integer(0);\n        Integer nDocID = new Integer(1);\n        Integer nDocDetailID = new Integer(1);\n        Integer nVersionID = new Integer(1);\n        Integer nContentID = new Integer(1);\n        Integer nDmsRootID = new Integer(1);\n        Integer nMtmDocVersionID = new Integer(1);\n        Integer nParentID = null;\n        Integer nRootID = null;\n        String sName = \"1000000001.txt\";\n        String sConvertedName = \"1000000001\";\n        if (htTableKey.containsKey(\"DMS_DOCUMENT\")) {\n            nDocID = new Integer(((Integer) htTableKey.get(\"DMS_DOCUMENT\")).intValue() + 1);\n        }\n        if (htTableKey.containsKey(\"DMS_DOCUMENT_DETAIL\")) {\n            nDocDetailID = new Integer(((Integer) htTableKey.get(\"DMS_DOCUMENT_DETAIL\")).intValue() + 1);\n        }\n        if (htTableKey.containsKey(\"DMS_VERSION\")) {\n            nVersionID = new Integer(((Integer) htTableKey.get(\"DMS_VERSION\")).intValue() + 1);\n        }\n        if (htTableKey.containsKey(\"DMS_CONTENT\")) {\n            nContentID = new Integer(((Integer) htTableKey.get(\"DMS_CONTENT\")).intValue() + 1);\n        }\n        if (htTableKey.containsKey(\"DMS_ROOT\")) {\n            nDmsRootID = new Integer(((Integer) htTableKey.get(\"DMS_ROOT\")).intValue() + 1);\n        }\n        if (htTableKey.containsKey(\"MTM_DOCUMENT_VERSION\")) {\n            nMtmDocVersionID = new Integer(((Integer) htTableKey.get(\"MTM_DOCUMENT_VERSION\")).intValue() + 1);\n        }\n        int nStart = (new Integer(args[0])).intValue();\n        int nEnd = (new Integer(args[1])).intValue();\n        nParentID = new Integer(args[2]);\n        Integer nRootParentID = new Integer(args[2]);\n        nRootID = new Integer(args[3]);\n        String sPhysicalLoc = new String(args[4]);\n        indexPath = new String(args[5]);\n        System.out.println(\"rootID : \" + nRootID + \"  ParentID \" + nParentID + \" physical Loc = \" + sPhysicalLoc);\n        String sFieldValue = \"\";\n        PreparedStatement preStat = null;\n        String sDocName = \"\";\n        int count = 0;\n        int total = 0;\n        FileInputStream infile = new FileInputStream(new File(sPhysicalLoc + sName));\n        byte[] buffer = new byte[infile.available()];\n        infile.read(buffer);\n        String inFileData = new String(buffer);\n        for (int i = nStart; i <= nEnd; i++) {\n            try {\n                sFieldValue = \"REF\" + i;\n                sDocName = Calendar.getInstance().getTimeInMillis() + \".tif\";\n                dmsDocument.setID(nDocID);\n                dmsDocument.setDocumentType(\"D\");\n                dmsDocument.setParentID(nParentID);\n                dmsDocument.setRootID(nRootID);\n                dmsDocument.setCreateType(\"S\");\n                dmsDocument.setReferenceNo(\"Ref Num\");\n                dmsDocument.setDescription(\"desc\");\n                dmsDocument.setUdfDetailList(new ArrayList());\n                dmsDocument.setEffectiveStartDate(currTime);\n                dmsDocument.setItemSize(new Integer(20480));\n                dmsDocument.setItemStatus(\"A\");\n                dmsDocument.setOwnerID(new Integer(0));\n                dmsDocument.setUpdateCount(new Integer(0));\n                dmsDocument.setCreatorID(new Integer(0));\n                dmsDocument.setCreateDate(currTime);\n                dmsDocument.setUpdaterID(new Integer(0));\n                dmsDocument.setUpdateDate(currTime);\n                dmsDocument.setRecordStatus(\"A\");\n                if (count % 500 == 0) {\n                    sDocName = \"TestDocument\" + i;\n                    dmsDocument.setDocumentName(sDocName);\n                    dmsDocument.setDocumentType(\"F\");\n                    sqlDoc = \"INSERT INTO DMS_DOCUMENT VALUES(\" + nDocID.toString() + \",'\" + sDocName + \"','F',\" + nRootParentID + \",\" + nRootID.toString() + \", 'S', '\" + dmsDocument.getCreateDate().toString() + \"', NULL, '\" + ownerID + \"','Ref Num', 'desc', 0, 'A', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,'A',0,0,'\" + dmsDocument.getCreateDate().toString() + \"',0,'\" + dmsDocument.getCreateDate().toString() + \"')\";\n                    preStat = conn.prepareStatement(sqlDoc);\n                    preStat.executeUpdate();\n                    nParentID = nDocID;\n                    nDocID = new Integer(nDocID.intValue() + 1);\n                }\n                total = count + nStart;\n                System.out.println(\"xxx Count: \" + total + \" docID = \" + nDocID);\n                sDocName = \"TestFullText\" + i + \".txt\";\n                dmsDocument.setDocumentName(sDocName);\n                sqlDoc = \"INSERT INTO DMS_DOCUMENT VALUES(\" + nDocID.toString() + \",'\" + sDocName + \"','D',\" + nParentID.toString() + \",\" + nRootID.toString() + \", 'S','\" + dmsDocument.getCreateDate().toString() + \"', NULL, '\" + ownerID + \"','Ref Num', 'desc', 20480, 'A', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'A',0,0,'\" + dmsDocument.getCreateDate().toString() + \"',0,'\" + dmsDocument.getCreateDate().toString() + \"')\";\n                preStat = conn.prepareStatement(sqlDoc);\n                preStat.executeUpdate();\n                sqlDocDetail = \"INSERT INTO DMS_DOCUMENT_DETAIL VALUES(\" + nDocDetailID.toString() + \",\" + nDocID.toString() + \",\" + sUdfID + \",\" + sUdfDetailID + \",'\" + sFieldValue + \"', null, null, 'A',0,0,'\" + dmsDocument.getCreateDate().toString() + \"',0,'\" + dmsDocument.getCreateDate().toString() + \"')\";\n                preStat = conn.prepareStatement(sqlDocDetail);\n                preStat.executeUpdate();\n                dmsDocument.setUserDefinedFieldID(new Integer(sUdfID));\n                sqlContent = \" INSERT INTO DMS_CONTENT VALUES (\" + nContentID.toString() + \",\" + sConvertedName + \", 'IMAGE', null, 'TIF', 'A', 0,0,'\" + dmsDocument.getCreateDate().toString() + \"',0,'\" + dmsDocument.getCreateDate().toString() + \"')\";\n                preStat = conn.prepareStatement(sqlContent);\n                preStat.executeUpdate();\n                dmsDocument.setContentID(nContentID);\n                sqlVersion = \"INSERT INTO DMS_VERSION VALUES(\" + nVersionID.toString() + \", \" + nDocID.toString() + \", 1,'ROOT',0,\" + nContentID.toString() + \",0, 'Ref Num', 'desc', 20480, 'A', null, 'A',0,0,'\" + dmsDocument.getCreateDate().toString() + \"',0,'\" + dmsDocument.getCreateDate().toString() + \"')\";\n                preStat = conn.prepareStatement(sqlVersion);\n                preStat.executeUpdate();\n                dmsDocument.setVersionID(nVersionID);\n                dmsDocument.setVersionID(new Integer(1));\n                dmsDocument.setVersionLabel(\"ROOT\");\n                sqlDocVersion = \"INSERT INTO MTM_DOCUMENT_VERSION VALUES(\" + nMtmDocVersionID.toString() + \",\" + nDocID.toString() + \",\" + nVersionID.toString() + \",'A', 0, 0,'\" + dmsDocument.getCreateDate().toString() + \"',0,'\" + dmsDocument.getCreateDate().toString() + \"')\";\n                preStat = conn.prepareStatement(sqlDocVersion);\n                preStat.executeUpdate();\n                nDocID = new Integer(nDocID.intValue() + 1);\n                nDocDetailID = new Integer(nDocDetailID.intValue() + 1);\n                nVersionID = new Integer(nVersionID.intValue() + 1);\n                nContentID = new Integer(nContentID.intValue() + 1);\n                nDmsRootID = new Integer(nDmsRootID.intValue() + 1);\n                nMtmDocVersionID = new Integer(nMtmDocVersionID.intValue() + 1);\n                SessionContainer sessionContainer = new SessionContainer();\n                if (\"D\".equals(dmsDocument.getDocumentType())) {\n                    File outFile = new File(sPhysicalLoc + \"temp.txt\");\n                    PrintStream out = new PrintStream(new FileOutputStream(outFile, false), true);\n                    out.println(formatNumber(i));\n                    out.print(inFileData);\n                    try {\n                        out.close();\n                    } catch (Exception ignore) {\n                        out = null;\n                    }\n                    FileInputStream data = new FileInputStream(outFile);\n                    indexDocument(dmsDocument, data, GlobalConstant.OP_MODE_INSERT);\n                    try {\n                        data.close();\n                    } catch (Exception ignore) {\n                        data = null;\n                    }\n                }\n                count++;\n            } catch (Exception ee) {\n                log.error(ee, ee);\n                conn.rollback();\n            } finally {\n                try {\n                    preStat.close();\n                    conn.rollback();\n                } catch (Exception ep) {\n                }\n            }\n        }\n        try {\n            infile.close();\n        } catch (Exception ignore) {\n            infile = null;\n        }\n        PreparedStatement statment = null;\n        if (htTableKey.containsKey(\"DMS_DOCUMENT\")) {\n            statment = conn.prepareStatement(\"UPDATE SYS_TABLE_KEY SET TABLE_KEY_MAX=\" + nDocID.toString() + \" WHERE TABLE_NAME='DMS_DOCUMENT'\");\n            statment.executeUpdate();\n        } else {\n            statment = conn.prepareStatement(\"INSERT INTO SYS_TABLE_KEY VALUES('DMS_DOCUMENT', \" + nDocID.toString() + \")\");\n            statment.executeUpdate();\n        }\n        if (htTableKey.containsKey(\"DMS_DOCUMENT_DETAIL\")) {\n            statment = conn.prepareStatement(\"UPDATE SYS_TABLE_KEY SET TABLE_KEY_MAX=\" + nDocDetailID.toString() + \" WHERE TABLE_NAME='DMS_DOCUMENT_DETAIL'\");\n            statment.executeUpdate();\n        } else {\n            statment = conn.prepareStatement(\"INSERT INTO SYS_TABLE_KEY VALUES('DMS_DOCUMENT_DETAIL', \" + nDocDetailID.toString() + \")\");\n            statment.executeUpdate();\n        }\n        if (htTableKey.containsKey(\"DMS_VERSION\")) {\n            statment = conn.prepareStatement(\"UPDATE SYS_TABLE_KEY SET TABLE_KEY_MAX=\" + nVersionID.toString() + \" WHERE TABLE_NAME='DMS_VERSION'\");\n            statment.executeUpdate();\n        } else {\n            statment = conn.prepareStatement(\"INSERT INTO SYS_TABLE_KEY VALUES('DMS_VERSION', \" + nVersionID.toString() + \")\");\n            statment.executeUpdate();\n        }\n        if (htTableKey.containsKey(\"DMS_CONTENT\")) {\n            statment = conn.prepareStatement(\"UPDATE SYS_TABLE_KEY SET TABLE_KEY_MAX=\" + nContentID.toString() + \" WHERE TABLE_NAME='DMS_CONTENT'\");\n            statment.executeUpdate();\n        } else {\n            statment = conn.prepareStatement(\"INSERT INTO SYS_TABLE_KEY VALUES('DMS_CONTENT', \" + nContentID.toString() + \")\");\n            statment.executeUpdate();\n        }\n        if (htTableKey.containsKey(\"MTM_DOCUMENT_VERSION\")) {\n            statment = conn.prepareStatement(\"UPDATE SYS_TABLE_KEY SET TABLE_KEY_MAX=\" + nMtmDocVersionID.toString() + \" WHERE TABLE_NAME='MTM_DOCUMENT_VERSION'\");\n            statment.executeUpdate();\n        } else {\n            statment = conn.prepareStatement(\"INSERT INTO SYS_TABLE_KEY VALUES('MTM_DOCUMENT_VERSION', \" + nMtmDocVersionID.toString() + \")\");\n            statment.executeUpdate();\n        }\n        statment.close();\n        System.out.println(\"final value: \" + \" DocumentID \" + nDocID + \" DocDetailID \" + nDocDetailID + \" DocVersion \" + nVersionID + \" DocContent \" + nContentID + \" nMtmDocVersionID \" + nMtmDocVersionID);\n        closeDBConn();\n    }\n", "label": 1, "substitutes": {"componentName": ["projectNames", "componentNames", " componentNames", "systemString", " componentString", "compType", "compName", "compPath", "componentString", " componentPath", "projectType", "moduleName", "projectPath", "componentPath", "componentType", " componentType", "moduleString", "projectName", "moduleNames", "moduleType", "systemType", "compNames", "systemNames", "systemName"], "currentPilot": ["currentPortotor", "currentPacket", "currentPolar", "currentComposter", "currentPortoster", "reportedPoster", "currentpilot", "reportedPortilot", "reportedPortolar", "reportedPilot", "currentCompotor", "reportedPortotor", "currentCompolar", "currentPoster", " currentPacket", "currentPector", "currentPortilot", "currentpolar", "currentPortacket", " currentPolar", "currentPowerector", "currentPowerilot", " currentPector", "reportedPotor", "currentpotor", "reportedPolar", "currentposter", "currentPortector", "currentPotor", "reportedPortoster", "currentPoweracket", "currentCompilot", "currentPortolar", "currentPowerolar"], "psta": ["apstra", "npsta", " pasa", "psesta", "pasa", "ppsta", "papa", "ppesta", " papa", "pssta", " pta", " pesta", "ppasa", "napa", "nasi", "pasi", "psa", "apta", "npasi", "pstra", "apsta", "npapa", "pta", "Pasa", "nsa", " pasi", "Psta", "Pta", "Pstra", "npsa", "Pesta", " pstra", "pssa", "pesta", " psa", "apsa", "Psa", "ppsa", "nsta"]}}
{"id1": "19886663", "id2": "21273053", "code1": "    public boolean retrieveByPMID(String pmid) {\n        try {\n            URL url = new URL(baseURL + \"&id=\" + pmid.trim());\n            BufferedReader xml = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuffer title_sb = new StringBuffer();\n            while ((line = xml.readLine()) != null) {\n                if (line.indexOf(\"<ArticleTitle>\") != -1) {\n                    title_sb.delete(0, title_sb.length());\n                    title_sb.append(line.substring(line.indexOf(\"<ArticleTitle>\") + 14, line.length() - 15));\n                } else if (line.indexOf(\"<AbstractText>\") != -1) {\n                    PrintWriter article = new PrintWriter(new FileWriter(new File(outputDir.getPath() + File.separatorChar + pmid + \".txt\")));\n                    article.println(title_sb);\n                    article.println(line.substring(line.indexOf(\"<AbstractText>\") + 14, line.length() - 15));\n                    article.close();\n                    break;\n                }\n            }\n            xml.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public RobotList<Enemy> sort_incr_Enemy(RobotList<Enemy> list, String field) {\n        int length = list.size();\n        Index_value[] enemy_dist = new Index_value[length];\n        if (field.equals(\"\") || field.equals(\"location\")) {\n            Location cur_loc = this.getLocation();\n            for (int i = 0; i < length; i++) {\n                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));\n            }\n        } else if (field.equals(\"health\")) {\n            for (int i = 0; i < length; i++) {\n                enemy_dist[i] = new Index_value(i, list.get(i).health);\n            }\n        } else {\n            say(\"impossible to sort list - nothing modified\");\n            return list;\n        }\n        boolean permut;\n        do {\n            permut = false;\n            for (int i = 0; i < length - 1; i++) {\n                if (enemy_dist[i].value > enemy_dist[i + 1].value) {\n                    Index_value a = enemy_dist[i];\n                    enemy_dist[i] = enemy_dist[i + 1];\n                    enemy_dist[i + 1] = a;\n                    permut = true;\n                }\n            }\n        } while (permut);\n        RobotList<Enemy> new_enemy_list = new RobotList<Enemy>(Enemy.class);\n        for (int i = 0; i < length; i++) {\n            new_enemy_list.addLast(list.get(enemy_dist[i].index));\n        }\n        return new_enemy_list;\n    }\n", "label": 0, "substitutes": {"pmid": ["pxID", " pmname", "amID", "PMids", "amId", " pmID", "cmbid", "mmID", "PMid", "pmname", "mmids", " pmId", "pxid", "PMID", "pmbid", "pmId", "pxbid", "cmid", "mmname", "PMname", "amid", "pmID", "amname", "PMId", "pmids", "pxname", "mmid", "cmID", "PMbid", " pmids", "cmname"], "url": ["source", "reader", "id", "user", "feed", "open", "buffer", "download", "connection", "l", "http", "b", "base", "channel", "stream", "zip", "r", "resource", "email", "server", "address", "ur", "log", "ls", "string", "path", "socket", "file", "uri", "ssl", "db", "URL", "service", "hub", "Url", "www", "web", "sl"], "xml": ["source", "page", "reader", "input", "reports", "txt", "feed", "ws", "output", "rss", "audio", "http", "owl", "apache", "layer", "data", "stream", "print", "zip", "response", "email", "writer", "element", "x", "body", "php", "event", "e", "report", "json", "log", "atom", "wl", "parser", "enter", "content", "image", "document", "html", "file", "ml", "ssl", "parse", "www", "form", "sheet"], "line": ["split", "nl", "lines", "l", "definition", "end", "Line", "style", "email", "info", "strip", "name", "log", "cl", "status", "le", "side", "day", "file", "header", "id", "site", "lf", "plugin", "range", "one", "object", "cell", "part", "row", "inline", "auto", "lo", "key", "col", "load", "note", "parse", "title", "or", "lin", "str", "page", "left", "route", "none", "link", "user", "write", "license", "LINE", "column", "base", "no", "el", "section", "word", "text", "comment", "string", "error", "entry", "message", "letter", "data", "ne", "non", "content", "lc", "frame", "rule", "code", "block", "look", "unit"], "title_sb": ["title_SB", "title_buff", "titleLbf", "title_bf", "titleLsplit", "titleLsa", "title_sa", "title_split", "titleLabb", "title_stab", "url_bf", "title_bh", " title_buff", " title_nb", "url_sb", "titleLsb", " title_stab", "titleJabb", "titleLbb", " title_abb", " title_bb", "title_pb", "titleJbh", " title_bh", "url_sa", "url_split", "title_abb", "titleJbb", " title_SB", " title_pb", "title_bb", "titleLbh", "titleJsb", "title_nb"], "article": ["paragraph", "page", "reader", "operation", "site", "our", "office", "atomic", "reply", "analysis", "function", "output", "io", "optional", "iterator", "out", "internet", "part", "application", "inline", "auto", "print", "system", "editor", "archive", "air", "writer", "ocr", "author", "external", "section", "element", "riot", "module", "action", "event", "other", "report", "atom", "text", "course", "job", "adr", "art", "image", "orb", "Article", "html", "service", "articles", "figure", "blog", "option", "news", "journal"]}}
{"id1": "13902980", "id2": "11840745", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public final void close() throws IOException {\n        if (dataStream == null) throw new NullPointerException(\"Write stream is null.\");\n        dataStream.flush();\n        dataStream.close();\n        dataStream = null;\n        File tmpFile = new File(packPath + \".tmp\");\n        FileOutputStream packStream = new FileOutputStream(packPath);\n        try {\n            String nbFiles = Long.toString(currentNbFiles) + \"\\0\";\n            packStream.write(FLAT_PACK_HEADER.getBytes(Charsets.ISO_8859_1));\n            structBufferWriter.flush();\n            structBufferWriter.close();\n            int headerSize = structBuffer.size() + nbFiles.length();\n            packStream.write(Integer.toString(headerSize).getBytes(Charsets.ISO_8859_1));\n            packStream.write('\\0');\n            packStream.write(nbFiles.getBytes(Charsets.ISO_8859_1));\n            structBuffer.writeTo(packStream);\n            structBufferWriter = null;\n            structBuffer = null;\n            FileInputStream in = new FileInputStream(tmpFile);\n            try {\n                byte[] buffer = new byte[FILE_COPY_BUFFER_LEN];\n                int read;\n                while ((read = in.read(buffer)) > 0) packStream.write(buffer, 0, read);\n                packStream.flush();\n                packStream.close();\n            } finally {\n                Utilities.closeStream(in);\n            }\n        } finally {\n            Utilities.closeStream(packStream);\n        }\n        if (tmpFile.isFile()) Utilities.deleteFile(tmpFile);\n        packPath = null;\n        structBuffer = null;\n    }\n", "label": 1, "substitutes": {"infile": ["inputfile", "infilename", "outFile", "infiles", "inFile", "inputfiles", "inputfilename", "outfiles", " infilename", "infp", " infp", "inputfp", "outfilename", "Infiles", " infiles", "InFile", "outfp", "Infilename", "inputFile", "Infile"], "outfile": ["outputfp", "outFile", "infilename", "Outname", "newfile", "OutFile", "outputfilename", " outFile", "newname", "infp", "newfolder", "outfilename", "Outfile", " outfolder", "newFile", " outname", "outfolder", " outfp", "outputfolder", "outfp", "Outfolder", "infolder", "outname", " outfilename", "outputfile"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "min", "nin", "conn", "con", "b", "login", "as", "base", "data", "In", "pin", "into", "re", "r", "inas", "thin", "again", "ac", "isin", "inner", "init", "ins", "vin", "gin", "ini", "a", "m", "sin", "cin", "image", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "bin", "s", "ic", "pass"], "out": ["source", "parent", "inc", "write", "net", "co", "io", "output", "outer", "conn", "lib", "one", "client", "home", "ou", "base", "on", "to", "no", "In", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "ex", "post", "timeout", "session", "up", "job", "point", "image", "cache", "socket", "file", "obj", "error", "err", "or", "bin", "copy", "exit", "line"], "buffer": ["source", "size", "reader", "split", "url", "queue", "input", "write", "binary", "feed", "len", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "base", "layer", "data", "bytes", "server", "raw", "address", "uffer", "transfer", "null", "padding", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "count", "border", "seed", "cache", "fb", "value", "type"], "read": ["play", "select", "next", " write", "size", "reader", "ad", "input", "get", "write", "inc", "id", "feed", "len", "Read", "ind", "iter", " skip", "fill", "READ", "ride", "io", "limit", "end", "tell", "f", "sleep", "find", "n", "work", "raw", "exec", "x", "sync", "send", "reading", "_", "length", "allow", "run", "close", "se", "slice", "count", "pass", "load", "connect", "parse", "i", "seek", "check", "wait", "lex", "current", " copy", "start", " count", "ip", "add", "copy", " Read", "use", "reads"], "success": ["successful", "continue", "roll", "default", "warning", "first", "better", "successfully", "open", " succeed", "complete", "growth", "result", "right", "message", "Success", "true", "flash", "winner", " succ", "model", " successful", "cess", "data", "fast", "again", "response", "primary", "xx", "rolled", " Success", "method", "func", "results", "failed", "initial", "comment", "danger", "content", "status", "done", "path", "respons", "error", "fail", "modified", "valid", "construct", "ccess", "rolling", "follow", "ceed", "good", "value", "null", "pass"]}}
{"id1": "6217412", "id2": "8364554", "code1": "    protected void EncodeRoute() throws EncodeFailedException, IOException {\n        File storefile = getNode().getCodec().PackStore(null, ReturnStore);\n        DownRoute.EncodeData(storefile);\n        File data = getNode().getCodec().PackRemoteDownload(this);\n        data = PigData.EncodeData(data);\n        FileOutputStream fos = new FileOutputStream(PiggybackRouteFile, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(data);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        UpRoute.EncodeData(PiggybackRouteFile);\n    }\n", "code2": "    @Override\n    public void executeInterruptible() {\n        EncodeFilesDialog dialog = (EncodeFilesDialog) this.dialog;\n        File encoderFile = null;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            if (Platform.isWindows()) {\n                encoderFile = new File(\".\", \"lame.exe\");\n                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"lame/lame.exe\");\n            } else if (Platform.isLinux()) {\n                encoderFile = new File(\".\", \"lame\");\n                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"lame/lame\");\n            } else {\n                MainWindowInterface.showError(new Exception(Messages.getString(\"operations.file.encode.dialog.notsupported\")));\n                return;\n            }\n            os = new FileOutputStream(encoderFile);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            LOG.error(\"Cannot extract encoder executable\", e);\n            MainWindowInterface.showError(e);\n            return;\n        } finally {\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n        encoderFile.setExecutable(true, true);\n        try {\n            long totalSize = 0l;\n            for (int i = 0, l = filesModel.getSize(); i < l; i++) {\n                if (isInterrupted()) return;\n                IconAndFileListElement element = (IconAndFileListElement) filesModel.get(i);\n                File origFile = element.getFile();\n                totalSize += origFile.length();\n            }\n            rangeModel = dialog.getProgressBar().getModel();\n            rangeModel.setMinimum(0);\n            rangeModel.setMaximum((int) totalSize);\n            int parallelProcesses = dialog.getParallelProcesses();\n            List<Thread> encodingThreads = new ArrayList<Thread>();\n            encodingRunnables = new ArrayList<EncoderLauncherRunnable>(parallelProcesses);\n            for (int i = 0; i < parallelProcesses; i++) {\n                EncoderLauncherRunnable encoderLauncherRunnable = new EncoderLauncherRunnable(i, dialog, encoderFile);\n                Thread thread = new Thread(encoderLauncherRunnable);\n                encodingRunnables.add(encoderLauncherRunnable);\n                encodingThreads.add(thread);\n                thread.start();\n            }\n            for (Thread thread : encodingThreads) {\n                thread.join();\n            }\n            if (!isInterrupted()) MainWindowInterface.showMessage(Messages.getString(\"operations.file.encode.execute.done.title\"), Messages.getString(\"operations.file.encode.execute.done.message\").replace(\"${number}\", \"\" + filesModel.getSize()));\n        } catch (Exception e) {\n            LOG.error(\"Cannot encode files\", e);\n            MainWindowInterface.showError(e);\n        } finally {\n            if (encoderFile != null) encoderFile.delete();\n            dialog.setVisible(false);\n        }\n    }\n", "label": 1, "substitutes": {"storefile": ["Storepart", "StoreFile", "transferFile", "fileFile", "transferhttp", "storeaction", "fileaction", "transferaction", "storehttp", "storepart", "Storepage", " storehttp", "gatepart", "transferfile", "storepage", "gatefile", "Storefile", "gateFile", " storeaction", "filehttp", " storepart", " storepage", "filefile", "storeFile", " storeFile", "gatepage"], "data": ["next", "parent", "reader", "default", "input", "memory", "queue", "d", "feed", "download", "buffer", "result", "message", "output", "dump", "object", "part", "base", "loader", "ata", "bytes", "response", "zip", "resource", "raw", "address", "config", "body", "DATA", "results", "json", "content", "missing", "session", "done", "buf", "media", "image", "change", "cache", "load", "file", "error", "record", "map", "array", "current", "database", "block", "video", "empty", "store", "value", "dat", "p"], "fos": ["infOS", "eos", " fo", "dOS", " foes", "infoes", " fOS", "fo", "Fos", "Foc", "infos", "Fo", "dos", "info", "eoc", "FOS", "fOS", "eo", "eOS", "foes", "does"], "foc": [" foca", "eos", "Fic", " fisc", "tos", "foca", "Focl", "Fos", "Foc", "Focol", "toc", "infos", "focol", "eoc", "fisc", "infoc", " focol", "focl", "tocol", "tocl", "Foca", "eoca", "eocl", " focl", "Fisc", "infisc", "infic"], "fis": ["Fics", "bisc", "Fic", " fisc", "ofos", "Fos", "bos", "ofics", "fics", "Fis", "ofis", "fisc", "ofic", " fics", "bics", "bis", "Fisc"], "fic": ["cfci", "Fics", "Fic", "fci", "dfic", "cfoc", " fci", "Foc", "fico", "infics", "fice", "Fci", "fics", "Fice", "poc", "dfics", "Fico", "Fis", " fico", "infoc", "pic", "pics", "infis", "dfice", " fics", "dfoc", "cfic", "pico", " fice", "cfis", "infic"]}}
{"id1": "12306298", "id2": "9970377", "code1": "    public static void renameFileMultiFallback(File sourceFile, File destFile) throws FileHandlingException {\n        if (destFile.exists()) {\n            throw new FileHandlingException(FileHandlingException.FILE_ALREADY_EXISTS);\n        }\n        if (!sourceFile.exists()) {\n            return;\n        }\n        boolean succ = sourceFile.renameTo(destFile);\n        if (succ) {\n            NLogger.warn(FileUtils.class, \"First renameTo operation worked!\");\n            return;\n        }\n        NLogger.warn(FileUtils.class, \"First renameTo operation failed.\");\n        System.gc();\n        Thread.yield();\n        succ = sourceFile.renameTo(destFile);\n        if (succ) {\n            return;\n        }\n        NLogger.warn(FileUtils.class, \"Second renameTo operation failed.\");\n        FileInputStream input = null;\n        FileOutputStream output = null;\n        try {\n            input = new FileInputStream(sourceFile);\n            output = new FileOutputStream(destFile);\n            long lengthLeft = sourceFile.length();\n            byte[] buffer = new byte[(int) Math.min(BUFFER_LENGTH, lengthLeft + 1)];\n            int read;\n            while (lengthLeft > 0) {\n                read = input.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                lengthLeft -= read;\n                output.write(buffer, 0, read);\n            }\n        } catch (IOException exp) {\n            NLogger.warn(FileUtils.class, \"Third renameTo operation failed.\");\n            throw new FileHandlingException(FileHandlingException.RENAME_FAILED, exp);\n        } finally {\n            IOUtil.closeQuietly(input);\n            IOUtil.closeQuietly(output);\n        }\n        destFile.setLastModified(sourceFile.lastModified());\n        FileUtils.deleteFileMultiFallback(sourceFile);\n    }\n", "code2": "    public void doWrite() {\n        System.out.print(\"\\nSerializing...\");\n        try {\n            IFile ifile = null;\n            File file = null;\n            if (null != method.getResource()) {\n                ifile = method.getJavaProject().getResource().getProject().getFile(Statics.CFG_DIR + Statics.SEPARATOR + path.substring(path.lastIndexOf(Statics.SEPARATOR)));\n            }\n            file = new File(path);\n            if (file.exists()) {\n                boolean ans = MessageDialog.openQuestion(wb.getSite().getShell(), \"Flow Plug-in\", \"File already exists. Do you want to overwrite it?\");\n                if (ans) {\n                    file.delete();\n                }\n            }\n            if (!file.exists()) {\n                FileOutputStream fos = new FileOutputStream(path);\n                ObjectOutputStream oos = new ObjectOutputStream(fos);\n                BufferedOutputStream bo = new BufferedOutputStream(oos);\n                oos.writeObject(anode);\n                oos.flush();\n                oos.close();\n                InputStream is = new FileInputStream(path);\n                if (null != ifile) {\n                    if (ifile.exists()) ifile.delete(true, null);\n                    ifile.create(is, IResource.NONE, null);\n                }\n                Path fullpath = new Path(path);\n                IDE.openEditorOnFileStore(wb.getSite().getPage(), EFS.getLocalFileSystem().getStore(fullpath));\n                method.getResource().refreshLocal(10, null);\n                System.out.println(\"Serializing ...Done!\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (CoreException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"sourceFile": ["sourceDir", " sourceFilename", "loadFILE", "srcfile", "thisFilename", "SourceFile", "targetPage", "sourceFILE", "ourcefile", " sourceFILE", "sourceSourceFile", "destfile", " sourceFiles", "ourceFile", "createFile", " sourcePath", "thisfile", "createFILE", "sourcefile", "loadfile", "targetPath", "SourceSourceFile", "ourceSourceFile", "SourcePath", "unitfile", "targetFiles", "ourcePage", "createDir", "loadFile", "targetfile", "sourceFilename", "sourceFiles", "destDir", "sourcePath", "unitFILE", " sourcePage", "loadDir", "srcFILE", "SourceDir", " sourceSourceFile", "targetFile", "Sourcefile", "srcFile", " sourcefile", "destFILE", "targetDir", " sourceDir", "ourcePath", "SourceFiles", "sourcePage", "createfile", "unitFile", "thisFile", "unitFilename", "thisFILE", "srcDir", "ourceDir", "srcPath"], "destFile": ["sourceDir", "srcFiles", "DestFiles", "srcfile", "destFiles", " destFiles", "srcLine", " destinationPath", "sourceLine", "destDirectory", "destfile", "destPath", "sourceSourceFile", " destfile", "defaultDir", "destSourceFile", "Destfile", "srcDirectory", "defaultFile", "sourcefile", "targetPath", "srcSourceFile", "routeDir", "routefile", "DestDirectory", "targetfile", " destinationFile", "sourceFilename", "sourceFiles", "destDir", "sourcePath", "defaultFiles", " destinationDir", " destDirectory", "srcDir", "routeFilename", "targetFile", "srcFilename", "routeFile", " destinationDirectory", "destLine", "srcFile", "targetDirectory", "targetDir", "defaultfile", " destLine", "DestDir", "targetLine", " destinationfile", " destinationLine", "destFilename", "DestFile", " destinationSourceFile"], "succ": ["rucf", "Suce", "suce", "Succ", "asuck", "Sucf", "rucc", "luucc", "SUcc", "sscc", " suucc", "Suec", "SuCC", "suec", "SUck", "ssacc", "lucc", "secc", "suucc", "seucc", "suCC", "ssce", "SUec", "ruck", "asucc", "luacc", " unsuCC", "luce", "ssck", "ruCC", " suacc", " suck", "Suacc", " unsucc", "Suck", "asucf", "suacc", "sucf", " suce", "suck", " unsuck", "asuCC", "seacc", "sece", "SUCC", " unsuec"], "input": ["source", "get", "select", "reader", "active", "url", "inc", "binary", "connection", "pull", "io", "audio", "conn", "http", "control", "out", "in", "request", "client", "driver", "state", "ou", "inf", "data", "include", "stream", "storage", "resource", "child", "address", "inner", "exec", "Input", "Output", "volume", "acl", "length", "api", "keep", "session", "media", "image", "connect", "cache", "socket", "context", "i", "error", "service", "form", "ip", "ie"], "output": ["source", "page", "parent", "operation", "queue", "write", "memory", "oper", "office", "connection", "reference", "core", "exit", "outer", "io", "audio", "letter", "control", "out", "object", "ou", "console", "environment", "application", "response", "resource", "external", "writer", "config", "module", "update", "Output", "o", "other", "target", "flow", "log", "oe", "job", "image", "OU", "entity", "socket", "file", "error", "ilo", "web", "op", "put", "unit"], "lengthLeft": ["LengthLeft", "durationRight", "LengthRight", "durationleft", "lengthL", "numberLimit", " lengthLo", "numberRight", " lengthFirst", "LengthLimit", "lenL", "lengthLo", "Lengthleft", " lengthL", "lenFirst", "lengthLimit", "sizeFirst", "lengthRight", "lengthleft", " lengthleft", "numberLeft", "positionLeft", "sizeLo", " lengthLimit", "lengthFirst", "lenLo", "sizeL", " lengthRight", "sizeLeft", "durationLeft", "positionRight", "lenLeft", "positionleft", "numberleft"], "buffer": ["source", "size", "reader", "url", "queue", "write", "memory", "binary", "feed", "reference", "buff", "result", "iter", "Buffer", "message", "request", "row", "layer", "number", "base", "data", "bytes", "available", "resource", "raw", "address", "writer", "pad", "uffer", "batch", "length", "wave", "FFER", "buf", "offset", "variable", "slice", "count", "cache", "block", "position", "value"], "read": ["READ", "end", "sleep", "r", "sync", " load", "reading", "ok", "count", "connect", "readable", "rw", " count", "line", "pass", "id", "feed", "Read", "build", "find", "child", "length", "se", "key", "load", "parse", "lex", "start", "add", "copy", "reads", "get", "size", "en", "write", "pe", "ind", "fill", "in", "skip", "work", "raw", "exec", "x", "send", "e", " use", "_", "text", "show", "run", "i", "g", "wait", " Read", " ride", "select", "play", " pass", " write", "reader", " get", "need", " skip", "k", "w", "data", " length", " r", "check", "seek", "block", " copy", "ed"]}}
{"id1": "7495800", "id2": "6541774", "code1": "    public static void copyFile(File fromFile, File toFile) throws IOException {\n        FileReader from = new FileReader(fromFile);\n        FileWriter to = new FileWriter(toFile);\n        char[] buffer = new char[4096];\n        int bytes_read;\n        while ((bytes_read = from.read(buffer)) != -1) {\n            to.write(buffer, 0, bytes_read);\n        }\n        to.flush();\n        to.close();\n        from.close();\n    }\n", "code2": "    private static String digest(String val) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(val.trim().getBytes());\n            byte[] digest = md.digest();\n            StringBuffer buf = new StringBuffer();\n            for (byte b : digest) {\n                String hexString = Integer.toHexString(b);\n                int length = hexString.length();\n                if (length > 2) {\n                    hexString = hexString.substring(length - 2, length);\n                } else if (length < 2) {\n                    hexString = \"0\" + hexString;\n                }\n                buf.append(hexString);\n            }\n            return buf.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new EnerjyException(\"Could not create digest: MD5\", e);\n        }\n    }\n", "label": 0, "substitutes": {"fromFile": ["orfile", "toDirectory", "fromSourceFile", " fromDirectory", "FromFile", "FromSourceFile", "fromfile", "orSourceFile", " fromFiles", "FromFiles", " fromSourceFile", " fromfile", "FromDirectory", "Fromfile", "fromDirectory", "fromFiles", "tofile", "orFile", "orDirectory", "toFiles"], "toFile": ["ToFile", "Tofile", "toDirectory", "toFolder", " toFolder", " toFilename", " tofile", " toPath", " toDir", "etoFilename", "ToFolder", "toFilename", "etofile", "ToFilename", "ToDirectory", "etoPath", "ToPath", "toDir", "targetFolder", "targetFile", "ToDir", "targetDirectory", "targetDir", "toPath", "etoFile", "tofile", " toDirectory"], "from": ["source", "get", "left", "read", "parent", "url", "link", "with", "range", "after", "io", "one", "original", "out", "this", "client", "end", "of", "in", "part", "normal", "f", "base", "From", "fe", "by", "data", "r", "u", "o", "old", "per", "a", "se", "up", "c", "parse", "file", "or", "ce", "start", "self", "form", "who", "so"], "to": ["via", "size", "write", "token", "with", "after", "co", "io", "TO", "one", "http", "thro", "out", "client", "b", "To", "f", "as", "po", "by", "into", "no", "auto", "data", "storage", "writer", "sync", "o", "target", "per", "api", "copy", "temp", "too", "socket", "file", "flo", "or", "who", "two", "so"], "buffer": ["source", "read", "reader", "url", "queue", "memory", "input", "binary", "feed", "reference", "buff", "repeat", "iter", "result", "Buffer", "limit", "layer", "number", "channel", "data", "base", "bytes", "available", "resource", "server", "raw", "address", "pad", "uffer", "transfer", "null", "batch", "flush", "length", "buf", "timeout", "slice", "count", "document", "border", "seed", "cache", "character", "position", "ip", "duration"], "bytes_read": [" bytes_valid", "bytes_load", " bytes_pass", "bytesIDvalid", "bytesIDload", "bytes_valid", " bytes_write", "bytes_pass", "bytes_length", " bytes_set", " bytes_length", "bytes_set", "bytes_in", " bytes_in", " bytes_load", "bytes_write", "bytesIDpass", "bytesIDread"]}}
{"id1": "7687037", "id2": "15826301", "code1": "    public synchronized int insertMessage(FrostMessageObject mo) {\n        AttachmentList files = mo.getAttachmentsOfType(Attachment.FILE);\n        AttachmentList boards = mo.getAttachmentsOfType(Attachment.BOARD);\n        Connection conn = AppLayerDatabase.getInstance().getPooledConnection();\n        try {\n            conn.setAutoCommit(false);\n            PreparedStatement ps = conn.prepareStatement(\"INSERT INTO \" + getMessageTableName() + \" (\" + \"primkey,messageid,inreplyto,isvalid,invalidreason,msgdatetime,msgindex,board,fromname,subject,recipient,signature,\" + \"signaturestatus,publickey,isdeleted,isnew,isreplied,isjunk,isflagged,isstarred,hasfileattachment,hasboardattachment,idlinepos,idlinelen\" + \") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\");\n            Long identity = null;\n            Statement stmt = AppLayerDatabase.getInstance().createStatement();\n            ResultSet rs = stmt.executeQuery(\"select UNIQUEKEY('\" + getMessageTableName() + \"')\");\n            if (rs.next()) {\n                identity = new Long(rs.getLong(1));\n            } else {\n                logger.log(Level.SEVERE, \"Could not retrieve a new unique key!\");\n            }\n            rs.close();\n            stmt.close();\n            int i = 1;\n            ps.setLong(i++, identity.longValue());\n            ps.setString(i++, mo.getMessageId());\n            ps.setString(i++, mo.getInReplyTo());\n            ps.setBoolean(i++, mo.isValid());\n            ps.setString(i++, mo.getInvalidReason());\n            ps.setLong(i++, mo.getDateAndTime().getMillis());\n            ps.setInt(i++, mo.getIndex());\n            ps.setInt(i++, mo.getBoard().getPrimaryKey().intValue());\n            ps.setString(i++, mo.getFromName());\n            ps.setString(i++, mo.getSubject());\n            ps.setString(i++, ((mo.getRecipientName() != null && mo.getRecipientName().length() == 0) ? null : mo.getRecipientName()));\n            if (mo.getSignatureV2() == null || mo.getSignatureV2().length() == 0) {\n                ps.setString(i++, mo.getSignatureV1());\n            } else {\n                ps.setString(i++, mo.getSignatureV2());\n            }\n            ps.setInt(i++, mo.getSignatureStatus());\n            ps.setString(i++, mo.getPublicKey());\n            ps.setBoolean(i++, mo.isDeleted());\n            ps.setBoolean(i++, mo.isNew());\n            ps.setBoolean(i++, mo.isReplied());\n            ps.setBoolean(i++, mo.isJunk());\n            ps.setBoolean(i++, mo.isFlagged());\n            ps.setBoolean(i++, mo.isStarred());\n            ps.setBoolean(i++, (files.size() > 0));\n            ps.setBoolean(i++, (boards.size() > 0));\n            ps.setInt(i++, mo.getIdLinePos());\n            ps.setInt(i++, mo.getIdLineLen());\n            int inserted;\n            try {\n                inserted = ps.executeUpdate();\n            } finally {\n                ps.close();\n            }\n            if (inserted == 0) {\n                logger.log(Level.SEVERE, \"message insert returned 0 !!!\");\n                throw new Exception(\"message insert returned 0 !!!\");\n            }\n            mo.setMsgIdentity(identity.longValue());\n            PreparedStatement pc = conn.prepareStatement(\"INSERT INTO \" + getContentTableName() + \" (msgref,msgcontent) VALUES (?,?)\");\n            pc.setLong(1, mo.getMsgIdentity());\n            pc.setString(2, mo.getContent());\n            try {\n                inserted = pc.executeUpdate();\n            } finally {\n                pc.close();\n            }\n            if (inserted == 0) {\n                logger.log(Level.SEVERE, \"message content insert returned 0 !!!\");\n                throw new Exception(\"message content insert returned 0 !!!\");\n            }\n            if (files.size() > 0) {\n                PreparedStatement p = conn.prepareStatement(\"INSERT INTO \" + getFileAttachmentsTableName() + \" (msgref,filename,filesize,filekey)\" + \" VALUES (?,?,?,?)\");\n                try {\n                    for (Iterator it = files.iterator(); it.hasNext(); ) {\n                        FileAttachment fa = (FileAttachment) it.next();\n                        int ix = 1;\n                        p.setLong(ix++, mo.getMsgIdentity());\n                        p.setString(ix++, fa.getFilename());\n                        p.setLong(ix++, fa.getFileSize());\n                        p.setString(ix++, fa.getKey());\n                        int ins = p.executeUpdate();\n                        if (ins == 0) {\n                            logger.log(Level.SEVERE, \"fileattachment insert returned 0 !!!\");\n                            throw new Exception(\"fileattachment insert returned 0 !!!\");\n                        }\n                    }\n                } finally {\n                    p.close();\n                }\n            }\n            if (boards.size() > 0) {\n                PreparedStatement p = conn.prepareStatement(\"INSERT INTO \" + getBoardAttachmentsTableName() + \" (msgref,boardname,boardpublickey,boardprivatekey,boarddescription)\" + \" VALUES (?,?,?,?,?)\");\n                try {\n                    for (Iterator it = boards.iterator(); it.hasNext(); ) {\n                        BoardAttachment ba = (BoardAttachment) it.next();\n                        Board b = ba.getBoardObj();\n                        int ix = 1;\n                        p.setLong(ix++, mo.getMsgIdentity());\n                        p.setString(ix++, b.getNameLowerCase());\n                        p.setString(ix++, b.getPublicKey());\n                        p.setString(ix++, b.getPrivateKey());\n                        p.setString(ix++, b.getDescription());\n                        int ins = p.executeUpdate();\n                        if (ins == 0) {\n                            logger.log(Level.SEVERE, \"boardattachment insert returned 0 !!!\");\n                            throw new Exception(\"boardattachment insert returned 0 !!!\");\n                        }\n                    }\n                } finally {\n                    p.close();\n                }\n            }\n            conn.commit();\n            conn.setAutoCommit(true);\n            return INSERT_OK;\n        } catch (Throwable t) {\n            boolean isDuplicate;\n            if (t.getMessage().indexOf(\"constraint violation\") > 0 && t.getMessage().indexOf(\"MSG_ID_UNIQUE_ONLY\") > 0) {\n                isDuplicate = true;\n                logger.warning(\"Duplicate message id, not added to database table: msgid='\" + mo.getMessageId() + \"', board=\" + mo.getBoard().getName() + \", date='\" + mo.getDateAndTimeString() + \"', index=\" + mo.getIndex());\n            } else if (t.getMessage().indexOf(\"constraint violation\") > 0 && t.getMessage().indexOf(\"MSG_UNIQUE_ONLY\") > 0) {\n                isDuplicate = true;\n                logger.warning(\"Duplicate msgdatetime,index,board, not added to database table: msgid='\" + mo.getMessageId() + \"', board=\" + mo.getBoard().getName() + \", date='\" + mo.getDateAndTimeString() + \"', index=\" + mo.getIndex());\n            } else {\n                isDuplicate = false;\n                logger.log(Level.SEVERE, \"Exception during insert of message: msgid='\" + mo.getMessageId() + \"', board=\" + mo.getBoard().getName() + \", date='\" + mo.getDateAndTimeString() + \"', index=\" + mo.getIndex(), t);\n                try {\n                    conn.rollback();\n                } catch (Throwable t1) {\n                    logger.log(Level.SEVERE, \"Exception during rollback\", t1);\n                }\n            }\n            try {\n                conn.setAutoCommit(true);\n            } catch (Throwable t1) {\n            }\n            if (isDuplicate) {\n                return INSERT_DUPLICATE;\n            } else {\n                return INSERT_ERROR;\n            }\n        } finally {\n            AppLayerDatabase.getInstance().givePooledConnection(conn);\n        }\n    }\n", "code2": "    public static int getContentLength(String address) {\n        URLConnection conn = null;\n        int contentLength = 0;\n        try {\n            URL url = new URL(address);\n            conn = url.openConnection();\n            contentLength = conn.getContentLength();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return contentLength;\n    }\n", "label": 0, "substitutes": {"mo": ["mobi", "ao", "mor", "go", " fo", " o", "yo", "la", "so", " MO", "co", "message", "ma", "fo", " Mo", "gro", "jo", "object", "ms", "umo", "ho", "ou", "loc", "MO", "po", "oa", "mu", "oo", "bo", "mi", "oco", "vo", "emo", "module", "lo", "wo", "ako", "o", "ob", "ME", "omo", "mod", "mol", " wo", "mos", "oe", "ko", "m", "M", "OO", "mail", "oda", "media", "O", "gone", "flo", "obo", "ilo", " lo", "gor", "md", "me", "mob", "Mo", " om"], "files": ["ums", "Files", "classes", "frames", "mails", "fs", "items", "data", "photos", "objects", "ages", "ources", "models", "filename", "boxes", "phones", "images", "members", "text", "names", "fl", "mail", "fields", "media", "file", "iles", "igs", "fil"], "boards": ["ones", "actions", "tracks", "links", "frames", "lines", "acks", "cards", "mails", "bars", "books", "ups", "objects", "flows", "rooms", "boxes", "Board", " buttons", "members", "ways", "backs", "orders", " board", "banks", "ids", "views", "ards", "board"], "conn": ["h", "sb", "en", "sa", "sql", "connection", "util", "cf", "ws", "ct", "con", "pg", "fp", "client", "ns", "Conn", "fr", "cp", "n", "enc", "ctx", "dn", "mc", "cn", "conf", "ci", "nt", "act", "dh", "cs", "pr", "ch", "ann", "cr", "pool", "connect", "c", "db", "rt", "oci", "ds", "Connection", "ca", "nc"], "ps": [" mp", "Rs", "hs", "ys", "cop", "ks", "ples", "pes", "ils", "lines", "ss", " mc", "TS", "jp", "RS", "pl", "ws", "properties", "pg", " comp", "gs", "ms", "ns", "css", "part", "fs", " pub", "os", "bs", "changes", "es", " fr", "posts", "qs", "js", "vs", "eps", "xs", "res", "pa", " ops", "pps", "cs", "PS", "pr", "ls", "Ps", "pse", " repl", "ops", "ips", "its", "ans", "details", "pp", "pos", "pi", "ds", " scr", " RS", " pg", "pers", "ts", "proxy", "s"], "identity": ["authorace", "authentonymous", "identITY", "authorentity", "stringITY", "equence", " idententity", "stringentity", "stringity", "authententity", "authorifier", "idITY", "identifier", "idifier", "idace", "equonymous", "authentence", "authorence", "equentity", "authority", "stringifier", "authentity", "identonymous", "identence", "authoronymous", "authorITY", " identace", " identifier", "idententity", "equity", "idity", "identace"], "stmt": ["Sttr", " stql", "estmt", " stgr", "Stmp", "stmn", "stgr", "sttr", " stmd", " stm", "stmp", "Stgr", "stmd", "stm", "estql", "STm", "rtr", "estgr", "Stmn", "STmd", "STmn", "rmp", " stmn", "Str", "rmt", " stmp", " str", "Stm", "Stql", "rr", "stql", "str", "Stmt", "Stmd", "STmt", " sttr", "estm"], "rs": ["Rs", "hs", "ys", "ks", "rys", "ows", "ra", "ges", "runs", "rep", "lines", "acks", "RS", "rss", " results", "ars", "ros", "r", "ubs", "rg", "ris", "qs", " rows", "xs", " res", "rc", "icks", "s", "results", "cs", "sr", "hr", "pr", "ls", " Rs", "rows", "ri", "maps", " sr", "rl", " rc", "rt", "rd", "mr", "vers", " ret", "rr", "ras", " RS", "ds", "ts", "kr", "res", "rb"], "i": ["ei", "id", "si", "multi", "qi", "abi", "d", "counter", "iu", "phi", "io", "l", "yi", "f", "data", "di", "bi", "n", "I", "ti", "oi", "gi", "ai", "info", "ji", "esi", "x", "ui", "ci", "o", "u", "e", "eni", "init", "t", "ini", "a", "m", "li", "xi", "v", "slice", "ri", "index", "j", "c", "uri", "ii", "g", "pi", "idi", "fi", "z", "ip", "ie"]}}
{"id1": "22255481", "id2": "23186914", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        MessageDigest encript = MessageDigest.getInstance(\"MD5\");\n        encript.update(password.getBytes());\n        byte[] b = encript.digest();\n        int size = b.length;\n        StringBuffer h = new StringBuffer(size);\n        for (int i = 0; i < size; i++) {\n            h.append(b[i]);\n        }\n        return h.toString();\n    }\n", "code2": "    public void save(Connection conn, boolean commit) throws SQLException {\n        PreparedStatement stmt = null;\n        if (!isValid()) {\n            String errorMessage = \"Unable to save invalid DAO '\" + getClass().getName() + \"'!\";\n            if (log.isErrorEnabled()) {\n                log.error(errorMessage);\n            }\n            throw new SQLException(errorMessage);\n        }\n        try {\n            if (isNew()) {\n                primaryKey = createNewPrimaryKey();\n                stmt = conn.prepareStatement(getInsertSql());\n            } else {\n                stmt = conn.prepareStatement(getUpdateSql());\n            }\n            setValues(stmt);\n            int rowCount = stmt.executeUpdate();\n            if (rowCount != 1) {\n                primaryKey = OvUuid.NULL_UUID;\n                if (commit) {\n                    conn.rollback();\n                }\n                String errorMessage = \"Invalid number of rows changed!\";\n                if (log.isErrorEnabled()) {\n                    log.error(errorMessage);\n                }\n                throw new SQLException(errorMessage);\n            } else {\n                if (commit) {\n                    conn.commit();\n                }\n            }\n        } finally {\n            OvJdbcUtils.closeStatement(stmt);\n        }\n    }\n", "label": 0, "substitutes": {"password": [" Password", "hash", "input", "user", "token", "auth", "buffer", "sword", "username", "message", "wd", "PASS", "data", "phrase", "enc", "prefix", "email", "config", "address", "word", "name", " passwords", "pattern", "parser", "text", "content", "words", "key", "string", "path", "code", "array", "secret", "database", "sudo", "Password", "crypt", "account", "project", "padding", "p", "pass"], "encript": ["ensrypt", "enrypt", " enScript", "encec", "isencript", "encrypt", "isentext", " enparent", "encscript", "enec", "Enhead", "Entext", "Encript", "encparent", "enparent", "enhead", " enscript", "henject", "hencript", "Enparent", "enccript", "ensject", "encject", "entext", "enccode", "Enec", "enscode", "isenScript", " enec", "henrypt", "hencode", " enhead", "isenhead", "enscript", "encode", "enScript", "EnScript", "Enscript", "enject", " entext"], "b": ["cb", "sb", "binary", "d", "bh", "bf", "mb", "buffer", "buff", "br", "pb", "l", "lib", "f", "base", "bd", "bytes", "abb", "bs", "r", "batch", "bb", "ob", "a", "buf", "v", "gb", "blue", "B", "orb", "emb", "ab", "db", "wb", "fb", "array", "boot", "bis", "nb", "s", "rb", "p"], "size": ["shift", "si", "len", "range", "scale", "sized", "iz", "Size", "loc", "SIZE", "style", "enc", "sum", "sh", "address", "shape", "x", "send", "name", "ize", "length", "capacity", "max", "time", "count", "code", "width", "g", "empty", "small", "use", "unit"], "h": ["host", "head", "hash", "ih", "hl", "bh", "auth", "ha", "ah", "HH", "ht", "oh", "hi", "hh", "zh", "hd", "l", "http", "w", "f", "hex", "hm", "H", "sh", "he", "kh", "hp", "u", "o", "uh", "ph", "dh", "rh", "hr", "ch", "buf", "help", "html", "fb", "header", "q", "th", "gh", "eh", "p", "uth"], "i": ["id", "si", "d", "abi", "qi", "multi", "hi", "k", "io", "phi", "l", "f", "di", "n", "r", "bi", "I", "mu", "ti", "oi", "ai", "info", "ji", "gi", "off", "x", "init", "ix", "ui", "u", "o", "ci", "e", "it", "ini", "li", "v", "key", "xi", "index", "ri", "slice", "j", "c", "uri", "ii", "pi", "field", "fi", "chi", "z", "p"]}}
{"id1": "15292308", "id2": "4003117", "code1": "    private static File createFileFromURL(URL url) throws IOException {\n        File tempFile = File.createTempFile(\"oboFile\", \".obo\");\n        PrintStream ps = new PrintStream(tempFile);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            ps.println(line);\n        }\n        ps.close();\n        return tempFile;\n    }\n", "code2": "    public void execute() {\n        check();\n        FTPClient ftp = new FTPClient();\n        try {\n            ftp.connect(host, port);\n        } catch (IOException ex) {\n            throw new BuildException(\"FTP connexion failed : IOException caught (\" + ex.getMessage() + \")\");\n        }\n        if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n            throw new BuildException(\"FTP connexion failed : \" + ftp.getReplyString());\n        }\n        try {\n            try {\n                if (!ftp.login(userid, password)) {\n                    throw new BuildException(\"Identification failed\");\n                }\n            } catch (IOException ex) {\n                throw new BuildException(ex);\n            }\n            if (binary) {\n                try {\n                    ftp.setFileType(FTP.IMAGE_FILE_TYPE);\n                } catch (IOException ex) {\n                    throw new BuildException(ex);\n                }\n                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                    throw new BuildException(\"Transfer type not supported : \" + ftp.getReplyString());\n                }\n            }\n            try {\n                ftp.changeWorkingDirectory(remotedir);\n            } catch (IOException ex) {\n                throw new BuildException(ex);\n            }\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                throw new BuildException(\"Unacessible remote directory : \" + ftp.getReplyString());\n            }\n            String localFullFileName = Files.normalizeDirectoryName(localdir) + remotefile;\n            String remoteFullFileName = (remotedir.endsWith(serverpathseparator) ? remotedir : remotedir + serverpathseparator) + remotefile;\n            BufferedOutputStream outstream = null;\n            try {\n                outstream = new BufferedOutputStream(new FileOutputStream(localFullFileName));\n                ftp.retrieveFile(remoteFullFileName, outstream);\n            } catch (IOException ex) {\n                throw new BuildException(ex);\n            }\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                throw new BuildException(\"File retrieval of '\" + localFullFileName + \"' has failed (\" + ftp.getReplyString() + \")\");\n            }\n        } finally {\n            try {\n                ftp.disconnect();\n            } catch (IOException ex) {\n                System.err.println(\"Disconnexion from \" + host + \":\" + port + \" failed\");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "page", "user", "connection", "buffer", "io", "l", "http", "object", "b", "lr", "loc", "base", "loader", "data", "f", "ref", "resource", "server", "address", "config", "name", "ur", "sl", "job", "string", "path", "rule", "image", "obj", "html", "uri", "file", "ssl", "URL", "service", "Url", "gl", "str", "location"], "tempFile": ["tempFiles", " tempPlace", "tempJar", " tempfile", "tempPath", "empFile", " tempPath", "TempFile", "TempPath", "empJar", "empPath", "empfile", "fakeFile", " tempPage", "tempPage", "tempF", "tempfile", "fakeF", "poraryPage", "poraryfile", "TempFiles", "tmpfile", "TempPlace", "tmpFile", "tmpPlace", "fakefile", "Tempfile", "fakePage", "poraryFile", "TempJar", "poraryF", "tmpFiles", " tempJar", "tempPlace", " tempFiles", " tempF"], "ps": ["py", "ks", "pe", "errors", "events", "ils", "lines", "ss", "ws", "pipe", "fs", "http", "params", "gs", "css", "ep", "as", "po", "ups", "print", "os", "tx", "posts", "eps", "ports", "ppa", "pa", "per", "pps", "cs", "parser", "PS", "pr", "amps", "rs", "ls", "rules", "Ps", "pse", "les", "ips", "file", "pp", "pos", "files", "pi", "ds", "pers", "ras", "p", "reads"], "reader": ["read", "input", "rar", " Reader", "rx", "Reader", "buffer", "iter", "ser", "ro", "l", "ler", "lr", "row", "f", "loader", "worker", "oder", "stream", "r", "her", "handler", "server", "writer", "inner", "er", "rer", "reading", "per", "bird", "parser", "ri", "file", "err", "rr", "cher", "ner", "entry"], "line": ["source", "next", "page", "value", "nl", "link", "user", "pe", "write", "feed", "lf", "lines", "iter", "message", "l", "letter", "object", "char", "end", "LINE", "cell", "Line", "row", "f", "number", "model", "data", "base", "style", "raw", "strip", "word", "name", "cle", "e", "cl", "text", "comment", "content", "lc", "key", "le", "string", "rule", "pass", "file", "code", "i", "character", "block", "lin", "str", "entry"]}}
{"id1": "11444436", "id2": "18519247", "code1": "    public void run() {\n        try {\n            FTPClient c = new FTPClient();\n            c.configure(ftpConfig);\n            logger.debug(\"Trying to connect\");\n            c.connect(\"127.0.0.1\", 21211);\n            logger.debug(\"Connected\");\n            c.setSoTimeout(5000);\n            if (!FTPReply.isPositiveCompletion(c.getReplyCode())) {\n                logger.debug(\"Houston, we have a problem. D/C\");\n                c.disconnect();\n                throw new Exception();\n            }\n            if (c.login(\"drftpd\", \"drftpd\")) {\n                logger.debug(\"Logged-in, now waiting 5 secs and kill the thread.\");\n                _sc.addSuccess();\n                Thread.sleep(5000);\n                c.disconnect();\n            } else {\n                logger.debug(\"Login failed, D/C!\");\n                throw new Exception();\n            }\n        } catch (Exception e) {\n            logger.debug(e, e);\n            _sc.addFailure();\n        }\n        logger.debug(\"exiting\");\n    }\n", "code2": "    public List<PathObject> fetchPath(PathObject parent) throws NetworkException {\n        if (parent.isFetched()) {\n            return parent.getChildren();\n        } else if (!\"d\".equals(parent.getType())) {\n            return null;\n        }\n        HttpClient client = HttpConfig.newInstance();\n        HttpGet get = new HttpGet(HttpConfig.bbsURL() + HttpConfig.BBS_0AN + parent.getPath());\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            Document doc = XmlOperator.readDocument(entity.getContent());\n            BBSBodyParseHelper.parsePathList(doc, parent);\n            return parent.getChildren();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"c": ["dc", "cd", "d", "connection", "cy", "cu", "cm", "cf", "co", "vc", "conn", "fc", "l", "ct", "con", "w", "client", "b", "bc", "f", "ctrl", "ec", "cp", "n", "xc", "ctx", "sc", "enc", "config", "ac", "mc", "pc", "cn", "cur", "exec", "ci", "e", "u", "cl", "tc", "t", "cs", "ch", "m", "lc", "cr", "g", "ce", "cc", "ca", "coll", "p", "C"]}}
{"id1": "20413859", "id2": "7474020", "code1": "    @Override\n    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            final HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n            final HttpServletResponse httpServletResponse = (HttpServletResponse) response;\n            final String contextPath = httpServletRequest.getContextPath() + \"/\";\n            final String requestURI = httpServletRequest.getRequestURI();\n            if (requestURI.startsWith(contextPath)) {\n                final String filterURI = requestURI.substring(contextPath.length());\n                final String filterPath = getFilterPath();\n                if (filterURI.startsWith(filterPath)) {\n                    final String targetURI = filterURI.substring(filterPath.length());\n                    for (final Entry<String, String> entry : mapping.entrySet()) {\n                        final String key = entry.getKey();\n                        final String value = entry.getValue();\n                        if (targetURI.startsWith(key) && (targetURI.length() > key.length())) {\n                            final String resourceName = value + targetURI.substring(key.length());\n                            InputStream is = null;\n                            try {\n                                is = getClass().getResourceAsStream(\"/\" + resourceName);\n                                if (is != null) {\n                                    IOUtils.copy(is, httpServletResponse.getOutputStream());\n                                    httpServletResponse.flushBuffer();\n                                    break;\n                                } else {\n                                    httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n                                    break;\n                                }\n                            } catch (final IOException ioex) {\n                                throw new ServletException(\"Error serving resource [\" + resourceName + \"].\", ioex);\n                            } finally {\n                                IOUtils.closeQuietly(is);\n                            }\n                        }\n                    }\n                } else {\n                    chain.doFilter(request, response);\n                }\n            } else {\n                chain.doFilter(request, response);\n            }\n        } else {\n            chain.doFilter(request, response);\n        }\n    }\n", "code2": "    protected void copyClassFiles(File initFile, File destFile) {\n        if (initFile != null && destFile != null) {\n            File[] children = initFile.listFiles();\n            File childDestinationDirectory = null, destChild = null;\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            FileChannel cin = null, cout = null;\n            for (File child : children) {\n                if (child != null) {\n                    if (child.isDirectory()) {\n                        childDestinationDirectory = fileExistAsChild(destFile, child.getName());\n                        if (childDestinationDirectory == null) {\n                            try {\n                                childDestinationDirectory = new File(destFile, child.getName());\n                                childDestinationDirectory.mkdir();\n                            } catch (Exception ex) {\n                                ex.printStackTrace();\n                            }\n                        }\n                        copyClassFiles(child, childDestinationDirectory);\n                    } else {\n                        try {\n                            destChild = new File(destFile, child.getName());\n                            in = new FileInputStream(child);\n                            out = new FileOutputStream(destChild);\n                            cin = in.getChannel();\n                            cout = out.getChannel();\n                            ByteBuffer buffer = ByteBuffer.allocate(1000);\n                            int pos = 0;\n                            while (cin.position() < cin.size()) {\n                                pos = cin.read(buffer);\n                                if (pos > 0) {\n                                    cout.write(buffer);\n                                }\n                            }\n                            cin.close();\n                            cout.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"request": ["host", "head", "get", "route", "reader", "url", "input", "queue", "user", "req", "require", "connection", "buffer", "xml", "complete", "result", "right", "message", "view", "http", "client", "state", "model", "application", "hello", "data", "worker", "version", "remote", "resource", "server", "call", "condition", "Request", "address", "method", "event", "query", "requ", "report", "instance", "cause", "post", "session", "index", "frame", "path", "image", "uri", "error", "current", "invoke", "q", "header", "create", "subject", "order", "received", "proxy", "ware", "QUEST"], "response": ["next", "host", "page", "respond", "site", "connection", "reference", "success", "reply", "ception", "result", "output", "message", "view", "one", "http", "out", "object", "model", "application", "onse", "data", "version", "resolution", "re", "r", "resource", "server", "serv", "body", "report", " Response", "json", "status", "session", "Response", "index", "string", "respons", "image", "cache", "answer", "error", "err", "resp", "service", "received", "reason", "res", "collection"], "chain": ["chains", "processor", "default", "wrapper", "network", "cycle", "Chain", "range", "build", "function", "result", " chained", "view", "thread", "client", "end", "loop", "row", "channel", "stream", "class", "clean", "call", "config", "module", "query", "batch", "cross", "container", "middle", "hole", "run", "rule", "pool", "list", "cache", "lock", "c", "check", "or", "builder", "block", "process", "self", "group", "stack", "collection", "filter"], "httpServletRequest": ["httpSingleResponse", "httpSingleQuery", "httpServlingMessage", "httpServletsMessage", "httpServetQuery", "httpWebleMessage", "httpWebleSession", "httpServlingRequest", "httpServLETMessage", "httpServletsRequest", "httpServleServer", "httpServLETResponse", "httpServLETResource", "httpServlingSession", "httpServleSession", "httpSingleServer", "httpSingletResponse", "httpServetRequest", "httpWebleResource", "httpWebletResponse", "httpServLETRequest", "httpServleQuery", "httpServletSession", "httpServledMessage", "httpServledSession", "httpServleResponse", "httpServletServer", "httpWebletRequest", "httpWebletResource", "httpServleRequest", "httpServleResource", "httpSingletRequest", "httpWebleRequest", "httpServetResponse", "httpServletResource", "httpWebletSession", "httpSingletQuery", "httpServlingResponse", "httpServetServer", "httpServcelQuery", "httpServledRequest", "httpServleMessage", "httpWebletMessage", "httpServletsResponse", "httpWebleResponse", "httpSingleRequest", "httpServletMessage", "httpServcelRequest", "httpServcelResponse", "httpServcelServer", "httpServletQuery", "httpSingletServer", "httpServledResponse", "httpServletsResource"], "httpServletResponse": ["httpBootlettresponse", "httpServLETResult", "httpServleServer", "httpBootlettResponse", "httpServletsView", "httpServletService", "httpWebletResult", "httpWebletRequest", "httpServlingView", "httpServleteResponse", "httpServledWriter", "httpServleRequest", "httpServleteView", "httpServletePage", "httpServlettresponse", "httpServledResponse", "httpServietResponse", "httpBootlettRequest", "httpServietSession", "httpServLETResponse", "httpServletResult", "httpServietResult", "httpServleresponse", "httpBootlettService", "httpServleResponse", "httpPortletSession", "httpBootletResponse", "httpServletWriter", "httpServetResponse", "httpServietWriter", "httpServletsresponse", "httpServlingWriter", "httpServletsPage", "httpServLETServer", "httpPortietSession", "httpServleResult", "httpPortletWriter", "httpServletsService", "httpServlingSession", "httpPortletResult", "httpWebleServer", "httpServLETRequest", "httpServleteResult", "httpServletView", "httpServledSession", "httpPortietResponse", "httpServletPage", "httpServlettService", "httpPortletResponse", "httpPortietResult", "httpBootletService", "httpPortietWriter", "httpBootletRequest", "httpServlingResponse", "httpServlingResult", "httpWebletServer", "httpServletsResult", "httpServleService", "httpServledResult", "httpServletsRequest", "httpServlingPage", "httpServetRequest", "httpWebletResponse", "httpServletSession", "httpServlettResponse", "httpWebleResult", "httpServletServer", "httpWebleRequest", "httpServetResult", "httpServetServer", "httpServletsResponse", "httpServlettRequest", "httpWebleResponse", "httpServletresponse", "httpBootletresponse"], "contextPath": ["contextPoint", "ContextPath", "requestPATH", " contextPoint", "contextPATH", "backgroundPATH", " contextFile", "backgroundpath", "cachePath", "filterpath", "cachepath", "filterPATH", "contextath", "ContextPoint", "ContextFile", "ContextURI", "backgroundPath", "requestath", "requestpath", "requestFile", "requestPath", "contextpath", "contextFile", "cacheath", " contextpath", "requestPoint", "backgroundURI", "cachePATH", " contextURI", " contextPATH", "contextURI", " contextath"], "requestURI": ["contextURL", "contextLocation", "responseURL", "responseLocation", "responsePath", "requestUrl", "contexturi", " requestFolder", "RequestFolder", "requestFolder", "resourceURI", "RequestURI", "requesturi", "responseUrl", "RequestUrl", "requestLocation", "resourceLocation", "RequestURL", "contextUrl", "resourceuri", "requestPath", "responseURI", " requesturi", "resourcePath", " requestURL", "responseuri", "contextURI", "requestURL", " requestUrl", "contextFolder"], "filterURI": ["contextURL", "sourceUrl", "controlPath", "contexturi", "filterFile", "resourceURI", "filterURL", "requesturi", "targetPath", "sourceFile", "targeturi", "controlURI", "filterUrl", " filterFile", "controlUrl", "filteruri", "targetURL", "resourceUrl", "sourcePath", "requestPath", "controlURL", "targetUrl", "targetFile", "sourceURI", "resourcePath", "resourceURL", "contextURI", "requestURL", " filterUrl"], "filterPath": ["targetPattern", "targetKey", "targetpath", "FilterPath", "filterPart", "FilterCase", "FilterPart", "filterpath", "FilterName", "targetPath", "targetName", "FilterPattern", "Filterpath", "FilterURI", " filterPart", "filterPattern", " filterPattern", "targetCase", " filterCase", "FilterKey", " filterpath", "filterName", "targetPart", " filterName", "filterCase", " filterKey", "filterKey"], "targetURI": ["sourceUrl", "filterString", "requestUrl", " targetString", "filterURL", "requesturi", "targetPath", "TargetURI", "targeturi", " targetURL", "filterUrl", "filteruri", "targetURL", "TargetPath", " targetPath", " targetUrl", "targetUrl", "sourceURI", "Targeturi", "sourceuri", "targetString", "TargetString", " targeturi", "sourceURL", "requestURL"], "entry": ["next", "via", "page", "route", "mission", "id", "reader", "term", "connection", "feed", "result", "ry", "letter", "part", "row", "ries", "data", "no", "directory", "auto", "r", "pair", "her", "archive", "address", "way", "info", "section", "element", "word", "alias", "ge", "e", "escape", "se", "index", "string", "image", "entity", "record", "uri", "file", "parse", "or", "service", "array", "Entry", "rant", "ie"], "key": ["source", "parent", "route", "size", "id", "link", "pe", "connection", "core", "k", "ry", "view", "owner", "root", "part", "base", "ver", "data", "Key", "style", "prefix", "feature", "child", "address", "role", "KEY", "ie", "section", "element", "word", "name", "query", "ge", "target", "length", "text", "index", "string", "path", "point", "rule", "uri", "code", "search", "service", "item", "type", "field", "ip", "use"], "value": ["source", "host", "id", "url", "write", "reference", "username", "output", "message", "val", "base", "data", "version", "VALUE", "resource", "prefix", "server", "address", "element", "section", "name", "volume", "target", "text", "content", "v", "variable", "index", "string", "path", "media", "uri", "attribute", "Value", "property", "service", "type"], "resourceName": ["referencename", "rangePath", "remoteKey", " resourceFamily", "collectionKey", "ResourceName", " resourceType", "resourcename", "collectionName", "resourceFamily", "resourceNames", "remoteType", "remotename", " resourcePath", "collectionFamily", "referenceKey", "rangeNames", "Resourcename", "collectionname", "resourceType", "ResourcePath", "ResourceType", " resourcename", "referenceName", "resourcePath", "ResourceKey", "rangeType", "resourceKey", "remoteName", " resourceNames", "rangeName", " resourceKey", "ResourceNames", "referenceFamily"], "is": ["get", "id", "nis", "si", "ils", "isa", "fs", "ais", "isl", "out", "in", "alis", "ists", "as", "isp", "was", "are", "iss", "stream", "os", "ens", "ris", "serv", "es", "info", "gets", "js", "x", "iv", "has", "isi", "it", "ui", "s", "IS", "api", "rs", "abs", "ri", "il", "lis", "ios", "image", "ops", "isc", "its", "uri", "ori", "i", "or", "ois", "us", "ar", "Is", "bis", "iso", "res", "p", "does"]}}
{"id1": "14974844", "id2": "12783807", "code1": "    public boolean backupFile(File oldFile, File newFile) {\n        boolean isBkupFileOK = false;\n        FileChannel sourceChannel = null;\n        FileChannel targetChannel = null;\n        try {\n            sourceChannel = new FileInputStream(oldFile).getChannel();\n            targetChannel = new FileOutputStream(newFile).getChannel();\n            targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IO exception occurred while copying file\", e);\n        } finally {\n            if ((newFile != null) && (newFile.exists()) && (newFile.length() > 0)) {\n                isBkupFileOK = true;\n            }\n            try {\n                if (sourceChannel != null) {\n                    sourceChannel.close();\n                }\n                if (targetChannel != null) {\n                    targetChannel.close();\n                }\n            } catch (IOException e) {\n                logger.log(Level.INFO, \"closing channels failed\");\n            }\n        }\n        return isBkupFileOK;\n    }\n", "code2": "    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        response.setHeader(\"Content-type\", \"application/force-download\");\n        response.setHeader(\"Content-disposition\", \"attachment\");\n        response.setHeader(\"filename\", \"export.txt\");\n        response.setHeader(\"Pragma\", \"no-cache\");\n        response.setHeader(\"Expires\", \"0\");\n        response.setStatus(HttpServletResponse.SC_OK);\n        baseRequest.setHandled(true);\n        InputStream x = baseRequest.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(x, writer);\n        String theString = writer.toString();\n        System.out.println(theString);\n        response.getWriter().println(request.getParameter(\"file\").replace(\"*\", \"\\n\"));\n    }\n", "label": 1, "substitutes": {"oldFile": [" oldfile", "Oldfile", "OldSourceFile", "olderSourceFile", "oldDirectory", "oldFolder", " oldDirectory", "oldSourceFile", "olderFolder", "oldfile", "olderFile", "olderDirectory", " oldFolder", "oldDir", "olderfile", "OldDirectory", "OldDir", " oldSourceFile", " oldDir", "OldFile", "olderDir", "OldFolder"], "newFile": ["newSourceFile", " newDir", "newPage", "remoteFile", "newfile", "NewDir", "NewPath", "remoteFiles", "NewSourceFile", "NewFilename", "updatePage", "oldDir", "remoteDir", "updatefile", "newPath", "NewFile", "newFiles", "nowfile", "newDir", " newFilename", "nowFile", "targetSourceFile", "targetfile", " newPage", "oldFiles", "oldFilename", "updateDir", "remoteFilename", " newSourceFile", "targetFile", "NewPage", " newFiles", " newfile", "oldPath", "nowSourceFile", "targetDir", "updateFile", "Newfile", " newPath", "NewFiles", "newFilename", "nowFilename"], "sourceChannel": ["sourceConnection", " sourceStream", "targetStream", "proxyChannel", " sourceChan", "resourcechannel", "resourceClient", "sourceChan", "targetBuffer", "Sourcechannel", "resourceChannel", " sourceConnection", " sourceClient", "proxyConnection", "SourceBuffer", "targetClient", " sourceHandler", " sourceBuffer", "proxychannel", "targetHandler", "sourceBuffer", "inputChannel", "targetChan", "targetConnection", "inputchannel", "targetchannel", "inputChan", "SourceConnection", "sourceClient", "SourceChan", "resourceChan", "inputHandler", "sourcechannel", "sourceHandler", "proxyChan", "proxyStream", "SourceChannel", " sourcechannel", "sourceStream"], "targetChannel": ["sourceConnection", "argetPage", "targetStream", " targetStream", "TargetFile", "targetPage", "argetConnection", "TargetManager", "masterChan", "sourceChan", "argetChan", " targetChan", "masterConnection", "masterChannel", "argetchannel", " targetPage", "masterStream", "sourceFile", "Targetchannel", "TargetConnection", "TargetChan", "targetChan", "targetConnection", "targetchannel", "targetManager", "argetManager", "argetChannel", " targetFile", "targetFile", "targetScope", " targetScope", "TargetStream", "argetScope", "sourcePage", "sourcechannel", " targetManager", "TargetChannel", " targetConnection", " targetchannel", "sourceScope"], "isBkupFileOK": ["isBkupfileO", "isBkupFilesSync", "isBkupfileOk", "isBkupFileok", "isBkupefileO", "isBkupDirectoryO", "isBkupFilesOk", "isBkupfileOK", "isBkupTimeO", "isBkupeFileO", "isBkupTimeok", "isBkupFilesOK", "isBkupefileSync", "isBkupFileOk", "isBkupfileok", "isBkupeFileok", "isBkupefileOk", "isBkupStreamOk", "isBkupefileok", "isBkupfileSync", "isBkupefileOK", "isBkupStreamSync", "isBkupTimeOk", "isBkupStreamok", "isBkupStreamOK", "isBkupTimeOK", "isBkupeFileOK", "isBkupFilesok", "isBkupeFileOk", "isBkupeFileSync", "isBkupFileSync", "isBkupFileO", "isBkupDirectoryOk", "isBkupDirectoryOK", "isBkupDirectoryok"]}}
{"id1": "1824914", "id2": "11426721", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        destination.getParentFile().mkdirs();\n        BufferedInputStream in = new BufferedInputStream(new FileInputStream(source));\n        BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(destination));\n        byte[] buffer = new byte[4096];\n        int read = -1;\n        while ((read = in.read(buffer)) != -1) {\n            out.write(buffer, 0, read);\n        }\n        out.flush();\n        out.close();\n        in.close();\n    }\n", "code2": "    public boolean uploadToUrl(URL url, Map postData) {\n        boolean success = false;\n        OutputStream oStream;\n        HttpURLConnection urlConn = null;\n        try {\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setAllowUserInteraction(false);\n            String parametersAsString = \"\";\n            Iterator itParams = postData.entrySet().iterator();\n            while (itParams.hasNext()) {\n                Map.Entry param = (Map.Entry) itParams.next();\n                parametersAsString += (String) param.getKey() + \"=\" + URLEncoder.encode((String) param.getValue(), \"UTF-8\") + \"&\";\n            }\n            byte[] parameterAsBytes = parametersAsString.getBytes();\n            urlConn.setRequestProperty(\"Content=length\", String.valueOf(parameterAsBytes.length));\n            oStream = urlConn.getOutputStream();\n            oStream.write(parameterAsBytes);\n            oStream.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n            String line;\n            while ((line = rd.readLine()) != null) {\n                System.err.println(\"Response: \" + line);\n            }\n            oStream.close();\n            rd.close();\n            success = true;\n        } catch (MalformedURLException ex) {\n            System.err.println(ex + \" (uploadToUrl)\");\n            success = false;\n        } catch (java.io.IOException iox) {\n            System.out.println(iox + \" (uploadToUrl)\");\n            success = false;\n        } catch (Exception generic) {\n            System.out.println(generic.toString() + \" (uploadToUrl)\");\n            success = false;\n        } finally {\n            success = false;\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"source": ["parent", "reader", "site", "url", "input", "connection", "reference", "io", "src", "from", "Source", "base", "table", "directory", "stream", "storage", "resource", "server", "archive", "inner", "ources", "dest", "target", "ource", "SOURCE", "slice", "string", "path", "cache", "file", "service", "proxy", "copy", "null", "use"], "destination": [" destinated", " destinator", "targetinated", "distruction", "distinated", "Destinated", "distination", "destinated", "Destinator", "Destruction", "constinator", " destruction", "targetination", "constination", "targetruction", "destinator", "constinated", "distinator", "destruction", "Destination", "construction"], "in": ["get", "reader", "id", "input", "inc", "din", "win", "pull", "min", "io", "src", "b", "login", "f", "as", "base", "data", "In", "pin", "again", "n", "r", "config", "isin", "inner", "exec", "sync", "init", "ins", "old", "gin", "ini", "a", "m", "ex", "up", "image", "socket", "c", "file", "i", "IN", "err", "inside", "inn", "is", "lin", "bin", "s", "pass"], "out": ["parent", "size", "input", "inc", "write", "user", "with", "extra", "io", "output", "outer", "conn", "lib", "w", "client", "part", "to", "data", "OUT", "Out", "again", "outs", "n", "writer", "inner", "dest", "exec", "x", "sync", "o", "target", "flush", "ex", "copy", "post", "up", "point", "image", "pool", "cache", "pass", "file", "obj", "socket", "err", "bin", "s", "line", "ext"], "buffer": ["reader", "split", "url", "queue", "input", "feed", "reference", "buff", "iter", "result", "message", "limit", "b", "channel", "base", "layer", "data", "available", "address", "pad", "uffer", "null", "transfer", "batch", "length", "flush", "wave", "buf", "offset", "variable", "slice", "document", "seed", "cache", "header", "block", "zero", "position", "bin", "duration"], "read": ["play", "get", "select", " write", "reader", "ad", "size", "input", "id", "write", "feed", "open", "Read", "ind", "fill", "iter", "READ", "io", "ride", "end", "loop", "skip", "add", "data", "find", "n", "raw", "config", "exec", "send", "sync", "init", "old", "reading", "allow", "length", "max", "se", "run", "close", "index", "slice", "count", "next", "pass", "load", "parse", "connect", "i", "seek", "check", "each", "g", "wait", "start", "rate", "copy", "ip", "use", "reads"]}}
{"id1": "17568209", "id2": "15076112", "code1": "    private static boolean CopyFile(File srcFile, File tagFile) throws IOException {\n        if (srcFile == null || tagFile == null) {\n            return false;\n        }\n        int length = 2097152;\n        File dirFile = new File(getFileFolder(tagFile.getAbsolutePath()));\n        if (!dirFile.exists()) {\n            dirFile.mkdirs();\n        }\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(tagFile.getAbsolutePath());\n        FileChannel inC = in.getChannel();\n        FileChannel outC = out.getChannel();\n        int i = 0;\n        while (true) {\n            if (inC.position() == inC.size()) {\n                inC.close();\n                outC.close();\n                break;\n            }\n            if ((inC.size() - inC.position()) < 20971520) length = (int) (inC.size() - inC.position()); else length = 20971520;\n            inC.transferTo(inC.position(), length, outC);\n            inC.position(inC.position() + length);\n            i++;\n        }\n        return true;\n    }\n", "code2": "    @Override\n    public JSONObject getJsonObj(Trip trip, List<Waypoint> stops) throws IOException {\n        JSONObject jsonObject = null;\n        try {\n            List<String> filtered = new LinkedList<String>();\n            filtered.add(trip.getWaypoint().getFromLocation().getCity().replaceAll(\"\\\\W+\", \"+\"));\n            filtered.add(trip.getWaypoint().getToLocation().getCity().replaceAll(\"\\\\W+\", \"+\"));\n            for (Waypoint w : stops) {\n                String from = w.getFromLocation().getCity().replaceAll(\"\\\\W+\", \"+\");\n                if (!filtered.contains(from)) filtered.add(from);\n                String to = w.getToLocation().getCity().replaceAll(\"\\\\W+\", \"+\");\n                if (!filtered.contains(to)) filtered.add(to);\n            }\n            StringBuilder urlBuilder = new StringBuilder();\n            urlBuilder.append(\"http://maps.google.com/maps/api/directions/json\");\n            urlBuilder.append(\"?origin=\").append(filtered.get(0));\n            urlBuilder.append(\"&destination=\").append(filtered.get(1));\n            if (filtered.size() > 2) {\n                urlBuilder.append(\"&waypoints=\");\n                for (int i = 2; i < filtered.size() - 1; i++) urlBuilder.append(filtered.get(i)).append(\"|\");\n                urlBuilder.append(filtered.get(filtered.size() - 1));\n            }\n            urlBuilder.append(\"&sensor=false\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlBuilder.toString()).openStream()));\n            StringBuilder answerBuilder = new StringBuilder();\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) answerBuilder.append(inputLine);\n            in.close();\n            jsonObject = new JSONObject(answerBuilder.toString());\n        } catch (JSONException e) {\n            logger.error(\"Problem with initializing JSONObject\", e);\n        }\n        return jsonObject;\n    }\n", "label": 0, "substitutes": {"srcFile": ["sourceDir", "sourceUrl", "rcfile", "inputFolder", "inputfile", "srcFiles", "srcfile", "srcFolder", "rcDir", "sourceFILE", "viewFile", "rcFiles", "srcUrl", "viewFILE", "viewUrl", " srcFILE", " srcfile", "rcFolder", "sourcefile", "sourceFile", " srcFiles", "rcFilename", " srcUrl", "sourceFiles", "inputFilename", " srcFilename", "srcFILE", " srcDir", "srcFilename", "rcFile", " srcFolder", "viewfile", "inputFile", "srcDir"], "tagFile": ["logFILE", "logPath", "TagFile", "outBase", "tagPath", "ownFILE", "outFile", " tagFILE", "srcfile", "ownPath", "logfile", "outDir", " tagfile", "catPath", "outFILE", "tagfile", "TagDir", "tagDir", "outfile", "logFile", "modDir", " tagDir", "modFILE", "TagPath", "catFile", "ownfile", " tagBase", "srcFILE", "modFile", "TagBase", "catDir", "modfile", "Tagfile", "tagFILE", "catfile", "tagBase", "ownFile", " tagPath", "srcPath"], "length": ["size", "id", "split", "url", "h", "feed", "len", "range", "with", "build", "weight", "limit", "l", "ength", "join", "end", "diff", "pack", "loc", "L", "data", "j", "style", "zip", " Length", "match", "work", "angle", "child", "ime", "sequence", "section", "shape", "depth", "distance", "filename", "name", "iv", "full", "cost", "capacity", "partial", "height", "li", "time", "slice", "string", "count", "path", "load", "delay", "uri", "lock", "Length", "width", "speed", "character", "total", "position", "form", "value", "sl", "duration", "type"], "dirFile": ["buildBook", " directoryFiles", "dirDirectory", "parentFile", "DIRBase", "locFile", "dirBook", " dirfile", "locType", "parentType", " dirBase", "buildfile", "dirfile", "directoryFolder", "DIRFiles", " directoryfile", "directoryBook", "poFile", "directoryfile", " directoryFile", "parentfile", " dirFiles", "DIRFile", "locfile", "dirFiles", "locDirectory", "directoryFile", "poType", "parentDirectory", "dirBase", "poDirectory", " dirBook", "DIRfile", "dirType", "buildFolder", "pofile", "buildFile", " dirFolder", "dirFolder", " directoryBase"], "in": ["plus", "reader", "h", "id", "en", "input", "inc", "din", "arin", "win", "io", "l", "con", "this", "login", "f", "as", "In", "into", "pin", "n", "r", "again", "inner", "init", "ins", "o", "vin", "a", "up", "image", "c", "IN", "inside", "inn", "is", "lin", "bin", "on", "ac"], "out": ["inc", "write", "net", "extra", "down", "io", "output", "outer", "conn", "one", "w", "this", "ou", "on", "to", "OUT", "Out", "auto", "outs", "again", "writer", "inner", "off", "exec", "sync", "name", "o", "other", "ex", "timeout", "up", "point", "file", "or", "outside", "bin", "working", "s", "line"], "inC": [" inVC", "INc", "inL", "inB", "inputVC", "inputc", "InVC", "INC", " inL", " inP", "inputC", "intoL", "INI", "incCL", "intoC", "intoI", "isinCL", "INB", "InCL", " inFile", "uninCL", "inCL", " inU", "incO", "inVC", " inI", "outB", "diffc", "diffC", "incc", "InB", "inO", "InFile", "outL", "inN", "outc", "outP", " inB", "uninC", "uninc", "inc", "isinVC", "INL", " inCL", "InC", "INCL", "diffI", "innC", "INU", "outVC", "uninU", "inP", "inU", "innc", "inputFile", "isinC", " inO", "outCL", "inFile", "diffCL", "innCL", "intoc", " inN", "INO", "outN", "INN", "INP", "incC", "Inc", "inI", " inc", "innL", "INVC"], "outC": ["outCC", " outCC", "tagCD", "inChannel", "againChannel", "inL", "tagC", "outCL", "inCL", " outL", "againL", " outCR", "againC", "OutL", "OutE", "tagE", " outCD", "OUTCD", " outCL", "OutCD", "OUTCC", "outCD", " outChannel", "OUTC", "OUTL", " outE", "outL", "tagCR", "outChannel", "outE", "OutCR", "outCR", "againCL", "OutC", "OutCC"], "i": ["id", "si", "qi", "multi", "ind", "uli", "phi", "l", "b", "f", "di", "n", "zi", "I", "ti", "ni", "ai", "info", "ji", "it", "ui", "ci", "u", "o", "e", "ini", "li", "xi", "index", "slice", "count", "j", "c", "uri", "strength", "ii", "ori", "pi", "z", "ip", "p", "type"]}}
{"id1": "22373758", "id2": "5505335", "code1": "    private static void fileUpload() throws Exception {\n        file = new File(\"c:/Documents and Settings/dinesh/Desktop/ZShareUploaderPlugin.java\");\n        httpclient = new DefaultHttpClient();\n        HttpPost httppost = new HttpPost(\"http://flameupload.com/cgi/ubr_upload.pl?upload_id=\" + uploadid);\n        MultipartEntity mpEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n        ContentBody cbFile = new FileBody(file);\n        mpEntity.addPart(\"upfile_0\", cbFile);\n        mpEntity.addPart(\"uploaded\", new StringBody(\"on\"));\n        mpEntity.addPart(\"hotfile\", new StringBody(\"on\"));\n        mpEntity.addPart(\"turbobit\", new StringBody(\"on\"));\n        mpEntity.addPart(\"depositfiles\", new StringBody(\"on\"));\n        mpEntity.addPart(\"fileserve\", new StringBody(\"on\"));\n        mpEntity.addPart(\"filefactory\", new StringBody(\"on\"));\n        mpEntity.addPart(\"netload\", new StringBody(\"on\"));\n        mpEntity.addPart(\"uploadstation\", new StringBody(\"on\"));\n        mpEntity.addPart(\"badongo\", new StringBody(\"on\"));\n        mpEntity.addPart(\"uploading\", new StringBody(\"on\"));\n        mpEntity.addPart(\"megashare\", new StringBody(\"on\"));\n        mpEntity.addPart(\"_2shared\", new StringBody(\"on\"));\n        httppost.setEntity(mpEntity);\n        NULogger.getLogger().log(Level.INFO, \"executing request {0}\", httppost.getRequestLine());\n        NULogger.getLogger().info(\"Now uploading your file into flameupload.com\");\n        HttpResponse response = httpclient.execute(httppost);\n        HttpEntity resEntity = response.getEntity();\n        NULogger.getLogger().info(response.getStatusLine().toString());\n        NULogger.getLogger().info(EntityUtils.toString(resEntity));\n        Header[] allHeaders = response.getAllHeaders();\n        for (int i = 0; i < allHeaders.length; i++) {\n            System.out.println(allHeaders[i].getName() + \"=\" + allHeaders[i].getValue());\n        }\n        if (response.getStatusLine().getStatusCode() == 302) {\n            NULogger.getLogger().info(\"Files uploaded successfully\");\n        } else {\n            throw new Exception(\"There might be a problem with your internet connection or server error. Please try again later :(\");\n        }\n    }\n", "code2": "    public void desistirCandidatura(Atividade atividade) throws SQLException {\n        Connection conn = null;\n        String insert = \"delete from Atividade_has_recurso_humano where atividade_idatividade=\" + atividade.getIdAtividade() + \" and usuario_idusuario=\" + atividade.getRecursoHumano().getIdUsuario();\n        try {\n            conn = connectionFactory.getConnection(true);\n            conn.setAutoCommit(false);\n            Statement stmt = conn.createStatement();\n            Integer result = stmt.executeUpdate(insert);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.close();\n        }\n    }\n", "label": 0, "substitutes": {"file": ["play", "source", "page", "folder", "url", "queue", "user", "binary", "upload", "connection", "feed", "xml", "buffer", "File", "audio", "l", "http", "object", "fp", "part", "model", "f", "base", "data", "stream", "class", "zip", "resource", "work", "force", "name", "filename", "body", "log", "pic", "picture", "mail", "content", "money", "up", "media", "image", "document", "cache", " File", "db", "files", "service", "FILE", "create", "video", "type"], "httpclient": [" httpClient", "Httpconn", "Httpclient", "httpsconn", " httpconnection", "httpsconnection", "httpserver", "httpClient", "httpconnection", "facebookClient", "Httpconnection", " httpconn", "httpconn", "httpsclient", "facebookserver", "httpsClient", "HttpClient", "facebookclient", " httpserver", "httpsserver"], "httppost": ["httpost", "httepost", "httPPpost", " httpposter", " httpost", "httpppost", "httpgrop", "httPPost", "httppedoster", "httppoint", "httppeoster", "httmposter", "httcppPost", " httpppost", "httpgpost", "httppeost", "httposter", "httppOST", "recippost", "httppedOST", "httPPoint", "httcpppost", "recimpoint", " httppoint", "httppPost", " httppPost", " httpPost", "httpPost", "httmpoint", "httmppost", "httpOST", "httprop", "recipppost", "httcppoint", " httpOST", "httppepost", "httpoint", "recimppost", "recimpost", "recipposter", "httpgoster", "httppeoint", "httpprop", " httppOST", " httpprop", " httprop", "httpperop", "htteposter", "httcppost", "httPPPost", "httpgost", "recimposter", "httppedoint", " httposter", "recippoint", "httepOST", "httepoint", "httmpost", "httppedost", " httpoint", "httpposter"], "mpEntity": ["mpEnt", "mbEnt", "pgEntity", "tmpEnt", "MPEntity", "mbEntity", "mbentity", "pmEnvironment", "MpAction", "mcUnit", " mpCollection", "viewEntity", " mpUnit", "mmEnt", "mbDescription", "ppEntity", "mtEnt", "MPBody", " mpSource", " mpContent", "mmContent", "viewEnt", "mpDoc", "MPentity", "tmpBody", "mpUnit", "copUrl", "mpAction", "mpUrl", " mpEvent", " mpEnvironment", "mpLine", "appDescription", "mbCollection", "appEntity", " mpEnt", "MpSource", "mpEvent", "pmEntity", "pmentity", "lpEntity", "wpDoc", "mcCollection", "MpBody", "mpElement", "lpUnit", "wpEntity", "psentity", " mpDoc", "mpDescription", "viewEnvironment", "mbSource", " mpFile", "pgElement", "mpFile", "mbContent", "mbLine", " mpUrl", "ppentity", " mpDescription", "mbUnit", "appentity", "tmpEntity", "mbElement", "copEntity", "mtEntity", "tmpentity", "mbAction", "mbEnvironment", "psEntity", "psFile", "MPEnt", "mbEvent", "copentity", "ppContent", "psEnt", "mmEntity", "pgAction", "viewentity", "MpEntry", "MPContent", "ppAction", "mbBody", "wpEntry", " mpElement", "lpDoc", " mpentity", "mcEntity", " mpLine", "MpEntity", " mpAction", "mpEnvironment", "mtLine", "wpUnit", "mbUrl", "viewFile", "pgEntry", "mpSource", "MpElement", "mpentity", "mpContent", " mpBody", "MpEvent", "mmentity", "lpEntry", "mpCollection", " mpEntry", "mpBody", "mpEntry", "mbEntry"], "cbFile": ["cbBody", "cfContent", "cbDir", "bcFile", "rbfile", "cdnBody", "grabContent", "rbFiles", "cdnfile", "bcDir", "CBBody", "cbContent", "cfFile", "cdnFile", "bcBody", "rbFile", "rbContent", "grabFile", "cbfile", "cdnDir", "CBFile", "cffile", "cbFiles", "CBfile", "CBDir", "bcfile", "cfFiles", "grabfile", "grabFiles"], "response": ["page", "respond", "default", "connection", "feed", "reply", "flower", "result", "message", "output", "request", "object", "client", "application", "onse", "data", "tree", "resource", "server", "writer", "method", "body", "full", "json", "api", "initial", "ree", "status", "session", "Response", "document", "error", "resp", "service", "res", "collection"], "resEntity": [" resObject", "ResEnt", "Resentity", "resentity", " ResEnt", " ResEntity", " resentity", " resEnt", "ResObject", " ResObject", "resEnt", " Resentity", "resObject", "ResEntity"]}}
{"id1": "8489742", "id2": "3541458", "code1": "    public static void fileCopy(String fromPath, String toPath) throws IOException {\n        File inputFile = new File(fromPath);\n        File outputFile = new File(toPath);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static String post(String strUrl, String strPostString) {\n        NoMuleRuntime.showDebug(\"POST : \" + strUrl + \"(\" + strPostString + \")\");\n        try {\n            URL url = new URL(strUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n            conn.setUseCaches(true);\n            conn.setAllowUserInteraction(true);\n            HttpURLConnection.setFollowRedirects(true);\n            conn.setInstanceFollowRedirects(true);\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            DataOutputStream out = new DataOutputStream(conn.getOutputStream());\n            out.writeBytes(strPostString);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String s = \"\";\n            StringBuffer sRet = new StringBuffer();\n            while ((s = in.readLine()) != null) {\n                sRet.append(s);\n            }\n            in.close();\n            return sRet.toString();\n        } catch (MalformedURLException e) {\n            NoMuleRuntime.showError(\"Internal Error. Malformed URL.\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.out.println(\"Internal I/O Error.\");\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"fromPath": ["toDirectory", " fromDirectory", " fromFile", "formpath", "fromFile", "toName", "Frompath", "topath", "frompath", "FromPoint", "formName", "toPoint", "FromPath", "formPath", "toFile", "FromDirectory", "fromDirectory", "formFile", " fromPoint", "FromName", "fromName", "fromPoint", "FromFile"], "toPath": ["ToFile", "outFile", "TOPath", "targetPoint", "TOUrl", "fromPoint", "fromFile", "targetPath", "outUrl", "outPath", "fromUrl", "ToPath", "toDir", "toPoint", "targetFile", "ToDir", "toFile", "targetDir", "toUrl", "TOFile", "fromDir", "ToPoint"], "inputFile": ["inputPath", "inputfile", "basePath", " inputfile", "Inputfile", "InputPath", " inputPath", "sourcefile", " inputBase", "sourceFile", "InputPage", "baseFile", "basefile", " inputPage", "InputFile", "sourcePath", "InputBase", "inputPage", "inputBase", "baseBase", "sourcePage"], "outputFile": ["inputPath", "inputFolder", "outFile", "toDirectory", " outputPage", "toFolder", "targetPage", " outputPath", "OutputPath", "outDirectory", "outputFolder", " outputDir", "targetPath", "outputDirectory", "outPath", "outputPage", "OutputDir", "outFolder", "OutputPage", "outputDir", "OutputFile", "targetFile", "inputDirectory", "toFile", "targetDir", "outputPath"], "in": ["source", "get", "reader", "url", "input", "inc", "din", "ln", "win", "connection", "asin", "pull", "min", "nin", "l", "con", "b", "login", "f", "as", "data", "In", "pin", "again", "r", "isin", "inner", "init", "ins", "o", "gin", "ini", "a", "issue", "sin", "cin", "image", "socket", "file", "i", "IN", "err", "inside", "inn", "rin", "lin", "bin", "s", "ic"], "out": ["parent", "plain", "inc", "user", "net", "io", "outer", "output", "conn", "one", "w", "b", "client", "over", "as", "to", "n", "Out", "OUT", "outs", "again", "raw", "writer", "off", "exec", "sync", "o", "ex", "copy", "v", "up", "image", "cache", "file", "error", "i", "err", "at", "outside", "s", "null"], "c": ["id", "dc", "cd", "d", "uc", "cy", "cu", "cm", "cf", "k", "l", "w", "b", "char", "f", "ec", "oc", "n", "enc", "xc", "sc", "ac", "x", "ci", "rc", "o", "e", "u", "esc", "cl", "arc", "t", "ch", "m", "lc", "col", "index", "cr", "count", "pointer", "i", "code", "character", "current", "ce", "cc", "ct", "nc", "p", "C"]}}
{"id1": "23413733", "id2": "12759328", "code1": "    public static void copyFile(File from, File to) throws Exception {\n        if (!from.exists()) return;\n        FileInputStream in = new FileInputStream(from);\n        FileOutputStream out = new FileOutputStream(to);\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int bytes_read;\n        while (true) {\n            bytes_read = in.read(buffer);\n            if (bytes_read == -1) break;\n            out.write(buffer, 0, bytes_read);\n        }\n        out.flush();\n        out.close();\n        in.close();\n    }\n", "code2": "    final void importSelectedEntity() {\n        TreePath path = projectsTree.getSelectionPath();\n        DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) path.getLastPathComponent();\n        Object userObject = selectedNode.getUserObject();\n        if (userObject instanceof ProjectSet) {\n            JFileChooser fileChooser = new JFileChooser();\n            fileChooser.setMultiSelectionEnabled(false);\n            fileChooser.setFileFilter(new FileNameExtensionFilter(\"JFPSM Projects\", \"jfpsm.zip\"));\n            int result = fileChooser.showOpenDialog(mainWindow.getApplicativeFrame());\n            if (result == JFileChooser.APPROVE_OPTION) {\n                String fullname = fileChooser.getSelectedFile().getName();\n                String projectName = fullname.substring(0, fullname.length() - Project.getFileExtension().length());\n                ProjectSet workspace = (ProjectSet) userObject;\n                boolean confirmLoad = true;\n                if (Arrays.asList(workspace.getProjectNames()).contains(projectName)) {\n                    confirmLoad = JOptionPane.showConfirmDialog(mainWindow.getApplicativeFrame(), \"Overwrite project \\\"\" + projectName + \"\\\"\" + \"?\", \"Overwrite project\", JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION;\n                    if (confirmLoad) {\n                        final int count = selectedNode.getChildCount();\n                        DefaultMutableTreeNode projectNode = null;\n                        for (int i = 0; i < count; i++) if (((Project) ((DefaultMutableTreeNode) selectedNode.getChildAt(i)).getUserObject()).getName().equals(projectName)) {\n                            projectNode = (DefaultMutableTreeNode) selectedNode.getChildAt(i);\n                            break;\n                        }\n                        Project project = (Project) projectNode.getUserObject();\n                        for (FloorSet floorSet : project.getLevelSet().getFloorSetsList()) for (Floor floor : floorSet.getFloorsList()) mainWindow.getEntityViewer().closeEntityView(floor);\n                        for (Tile tile : project.getTileSet().getTilesList()) mainWindow.getEntityViewer().closeEntityView(tile);\n                        workspace.removeProject(project);\n                        ((DefaultTreeModel) projectsTree.getModel()).removeNodeFromParent(projectNode);\n                    }\n                }\n                if (confirmLoad) {\n                    File projectFile = new File(workspace.createProjectPath(projectName));\n                    boolean success = true;\n                    try {\n                        success = projectFile.createNewFile();\n                        if (success) {\n                            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileChooser.getSelectedFile()));\n                            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(projectFile));\n                            byte[] buf = new byte[1024];\n                            int len;\n                            while ((len = bis.read(buf)) > 0) bos.write(buf, 0, len);\n                            bis.close();\n                            bos.close();\n                        }\n                    } catch (Throwable throwable) {\n                        displayErrorMessage(throwable, false);\n                        success = false;\n                    }\n                    if (success) addProject(projectName);\n                }\n            }\n        } else if (userObject instanceof Map) {\n            Map map = (Map) userObject;\n            Floor floor = (Floor) ((DefaultMutableTreeNode) selectedNode.getParent()).getUserObject();\n            importImageForSelectedMap(floor, map);\n        }\n    }\n", "label": 1, "substitutes": {"from": ["source", "left", "parent", "url", "user", "connection", "with", "range", "io", "origin", "client", "of", "part", "without", "base", "From", "by", "data", "address", "bean", "name", "o", "old", "m", "up", "path", "before", "c", "file", "or", "vol", "ce", "at", "start", "form", "add", "entry"], "to": ["source", "about", "token", "office", "top", "output", "io", "TO", "toc", "To", "as", "po", "by", "os", "eto", "template", "dest", "name", "o", "s", "target", "copy", "temp", "too", "socket", "file", "flo", "database", "at", "two", "so", "p", "tom"], "in": ["source", "read", "reader", "id", "url", "input", "inc", "din", "win", "pull", "io", "nin", "con", "b", "login", "f", "as", "In", "into", "again", "n", "r", "stream", "isin", "inner", "exec", "init", "ins", "old", "gin", "ini", "m", "up", "image", "cin", "c", "file", "socket", "i", "err", "IN", "inside", "inn", "is", "lin", "bin"], "out": ["size", "inc", "write", "with", "extra", "io", "output", "outer", "conn", "w", "b", "client", "this", "as", "by", "In", "n", "Out", "OUT", "outs", "again", "data", "writer", "inner", "off", "exec", "x", "sync", "ins", "o", "flow", "exp", "flush", "ex", "up", "cache", "socket", "file", "i", "err", "at", "bin", "s", "line"], "buffer": ["source", "read", "reader", "queue", "memory", "input", "binary", "feed", "buff", "iter", "result", "Buffer", "message", "limit", "request", "layer", "channel", "base", "data", "bytes", "raw", "address", "pad", "uffer", "shape", "sequence", "transfer", "null", "batch", "length", "flush", "buf", "offset", "slice", "count", "border", "seed", "cache", "character", "header", "block", "zero", "texture", "position", "bin", "value", "padding"], "bytes_read": ["bytes_size", "bytes_load", " bytes_size", " bytes_written", "bytes___read", "bytes___size", "bytes_wait", "bytes___load", "bytes_ride", "bytes_Read", "bytes_add", "bytes___check", "bytes_length", " bytes_add", " bytes_length", " bytes_Read", " bytes_wait", " bytes_load", "bytes_written", "bytes_check", " bytes_check", " bytes_ride"]}}
{"id1": "14232817", "id2": "22961265", "code1": "    protected void lookupForParsedElementAnnotations(JClassType t) {\n        List<JMethod> methods = getParsableElementMethods(t);\n        if (methods != null) {\n            for (JMethod method : methods) {\n                ParsedElement elementAnnotation = method.getAnnotation(ParsedElement.class);\n                if (elementAnnotation.type() == ParsedElement.Types.SYNC) {\n                    try {\n                        String contents = \"\";\n                        URL url = getClass().getClassLoader().getResource(elementAnnotation.file());\n                        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                        String line = null;\n                        while ((line = reader.readLine()) != null) {\n                            contents += line;\n                        }\n                        reader.close();\n                        ParsedElementDescriptor elementDescriptor = new ParsedElementDescriptor(method.getName(), contents.replaceAll(\"\\\"\", \"'\"), elementAnnotation.type());\n                        this.parsedElementList.add(elementDescriptor);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                } else {\n                    ParsedElementDescriptor elementDescriptor = new ParsedElementDescriptor(method.getName(), elementAnnotation.file(), elementAnnotation.type());\n                    this.parsedElementList.add(elementDescriptor);\n                }\n            }\n        }\n    }\n", "code2": "    public static String readFromURL(String sURL) {\n        logger.info(\"com.rooster.utils.URLReader.readFromURL - Entry\");\n        String sWebPage = \"\";\n        try {\n            URL url = new URL(sURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                sWebPage += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            logger.debug(\"com.rooster.utils.URLReader.readFromURL - Error\" + e);\n        }\n        logger.info(\"com.rooster.utils.URLReader.readFromURL - Exit\");\n        return sWebPage;\n    }\n", "label": 1, "substitutes": {"t": ["h", "d", "tor", "the", "l", "this", "b", "types", "Type", "st", "typ", "tf", "f", "class", "n", "r", "template", "dt", "tp", "it", "e", "o", "target", "tc", "T", "tt", "a", "m", "tm", "j", "c", "i", "att", "qt", "ts", "test", "s", "te", "p", "type"], "methods": ["pathes", "structb", "METHODes", " methodits", "pathisms", " methodsisms", "METHODions", " methodss", " methodes", "methodions", "Methodb", "hodits", "structs", "methodes", "METHODacks", "pathb", "pathions", "structes", "methodits", " methodacks", "hodacks", "METHODisms", "paths", "methodisms", "METHODits", "Methodes", "hods", "methodacks", "Methods", " methodses", "hodes", "methodb", "METHODs", " methodsions"], "method": ["source", "Method", "attr", "user", "default", "verb", "plugin", "result", "function", "right", "message", "true", "view", "one", "this", "in", "request", "METHOD", "version", "class", "r", "resource", "feature", "call", "address", "module", "element", "name", "null", "event", "member", "func", "cl", "text", "transform", "instance", "trip", "m", "job", "session", "string", "path", "document", "record", "expression", "each", "attribute", "property", "manager", "header", "block", "process", "hod", "field", "form", "subject", "th", "self", "project", "filter", "month", "type"], "elementAnnotation": ["elementAnment", "elementAnyotation", "elementAcction", "elementEntion", "elementEnotation", "elementEnnotations", "elementAnter", "objectANotation", "lementApzer", "objectAnnter", "objectAnnnotations", "objectAnnment", "elementEnment", "objectAnnotation", "objectANnotations", "elementAnynotations", " elementAnnnotations", "objectANnotation", "objectAnter", "lementAnzer", "elementAnnnotation", "elementCanter", "elementSynotation", "elementAntion", "elementANion", "elementAnzer", " elementAnnotations", "elementAnotation", "elementAnnotations", "lementAnnotations", "objectAnion", "elementAnntion", "elementApnotation", "elementAnnette", "lementApnotations", "lementApnette", "elementANnotations", "elementParnette", "elementANoration", " elementAnnnotation", " elementAntion", "elementCannotations", "elementParnotation", "lementApnotation", "elementAnnnette", "elementParzer", "elementSynnotations", "elementSynment", "elementAnyion", "elementAnnzer", "elementAnnoration", "elementEnoration", "elementSynnotation", "elementAnnnotations", "elementAccment", "elementAnnion", "objectAnotation", "objectAnnotations", " elementAnnment", " elementAnment", "elementEnnotation", "elementAnion", "objectAnment", "elementANter", "elementCannotation", " elementAnntion", "lementAnnotation", "objectAnoration", "elementAnynotation", "elementCanotation", "elementParnotations", "elementApnette", "elementAnnment", "objectANion", "elementApnotations", "objectAnnnotation", "objectAnnoration", "elementANotation", "elementApzer", "elementAccnotation", "lementAnnette", "elementAnoration", "elementAnnter", "elementANnotation", "elementAccnotations"], "url": ["source", "ball", "link", "user", "browser", "connection", "feed", "buffer", "director", "l", "http", "client", "b", "channel", "loader", "base", "data", "layer", "stream", "r", "resource", "handler", "server", "editor", "address", "element", "api", "location", "string", "path", "image", "rule", "file", "uri", "ssl", "URL", "service", "Url", "coll", "sl"], "reader": ["read", "rar", "wrapper", "rx", "Reader", "feed", "buffer", "iter", "ser", "keeper", "io", "ry", "iterator", "ler", "driver", "row", "layer", "loader", "worker", "oder", "stream", "re", "r", "resource", "handler", "server", "editor", "writer", "inner", "er", "rer", "e", "per", "reading", "bird", "parser", "ri", "uri", "file", "i", "err", "or", "rr", "ner", "entry"], "line": ["source", "page", "link", "connection", "lines", "iter", "message", "l", "letter", "char", "end", "description", "cell", "LINE", "Line", "row", "column", "number", "data", "inline", "response", "r", "server", "word", "name", "e", "coll", "cl", "text", "comment", "content", "lc", "key", "col", "le", "string", "pass", "file", "record", "code", "character", "header", "block", "lin", "str", "sample", "sl", "entry"], "contents": ["explcontent", "explodes", "extents", "constices", "Contences", "intens", "conturs", "intcontent", "Content", "contacts", "extodes", "contcontent", " conturs", "compacts", "Conturs", "encents", " content", "Contices", " contacts", "contants", "compent", "constants", "encants", "Contacts", "explens", "content", "contodes", "explents", "compents", "encences", "extens", "Contents", "constences", "encices", "constents", "Contants", "contences", "intodes", "extcontent", "compurs", "intents", "contens", "contices"], "elementDescriptor": ["elementDesccriptory", "elementDescruption", "elementDescendion", "elementDescription", "elementDesriptal", "elementDesriptory", "elementScriptor", "elementDesriptor", "elementDesription", "elementDescruptory", "elementDesributory", "elementDescectors", "elementDesribution", "elementDescributour", "elementDescendory", "elementDescributory", "elementDescriptors", "elementDescector", "elementDescritour", "elementDescriptour", "elementDescributal", "elementDescendors", "elementDescectal", "elementDesccriptor", "elementDesributors", "elementScriptory", "elementScription", "elementDescritor", "elementDescribution", "elementDesccription", "elementDescrition", "elementDesributor", "elementDescruptors", "elementScriptors", "elementDescributors", "elementDesriptour", "elementDescritors", "elementScributor", "elementScributors", "elementDescendor", "elementDesccriptal", "elementDescection", "elementDescruptor", "elementDescriptal", "elementDescriptory", "elementDescributor", "elementScributory", "elementScribution", "elementDesccriptour", "elementDesriptors", "elementDesccriptors"]}}
{"id1": "6677391", "id2": "20833509", "code1": "    @Override\n    protected void doRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String reqPath = req.getPathInfo();\n        if (reqPath.startsWith(\"/\")) reqPath = reqPath.substring(1);\n        ZipEntry entry = zipInfo.get(reqPath);\n        if (entry == null) {\n            logger.debug(Utils.join(\"Requested path not found: [\", reqPath, \"]\"));\n            resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        logger.debug(Utils.join(\"Requested path: [\", reqPath, \"]\"));\n        ServletUtils.establishContentType(reqPath, resp);\n        InputStream in = null;\n        try {\n            in = new BufferedInputStream(zipFile.getInputStream(entry));\n            IOUtils.copy(in, resp.getOutputStream());\n            logger.debug(\"Rendered: \" + reqPath);\n        } catch (FileNotFoundException e) {\n            logger.error(\"zipped resource not found: \" + reqPath);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    protected String doIt() throws java.lang.Exception {\n        StringBuffer sql = null;\n        int no = 0;\n        String clientCheck = \" AND AD_Client_ID=\" + m_AD_Client_ID;\n        if (m_deleteOldImported) {\n            sql = new StringBuffer(\"DELETE I_BPartner \" + \"WHERE I_IsImported='Y'\").append(clientCheck);\n            no = DB.executeUpdate(sql.toString());\n            log.fine(\"Delete Old Impored =\" + no);\n        }\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET AD_Client_ID = COALESCE(AD_Client_ID, \").append(m_AD_Client_ID).append(\"),\" + \" AD_Org_ID = COALESCE(AD_Org_ID, 0),\" + \" IsActive = COALESCE(IsActive, 'Y'),\" + \" Created = COALESCE(Created, current_timestamp),\" + \" CreatedBy = COALESCE(CreatedBy, 0),\" + \" Updated = COALESCE(Updated, current_timestamp),\" + \" UpdatedBy = COALESCE(UpdatedBy, 0),\" + \" I_ErrorMsg = '',\" + \" I_IsImported = 'N' \" + \"WHERE I_IsImported<>'Y' OR I_IsImported IS NULL\");\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Reset=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET GroupValue=(SELECT Value FROM C_BP_Group g WHERE g.IsDefault='Y'\" + \" AND g.AD_Client_ID=i.AD_Client_ID AND ROWNUM=1) \" + \"WHERE GroupValue IS NULL AND C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Group Default=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BP_Group_ID=(SELECT C_BP_Group_ID FROM C_BP_Group g\" + \" WHERE i.GroupValue=g.Value AND g.AD_Client_ID=i.AD_Client_ID ORDER BY g.IsDefault DESC LIMIT 1) \" + \"WHERE C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Group=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'\" + getMsg(\"ImportBPInvalidGroup\") + \". ' \" + \"WHERE C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.config(\"Invalid Group=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET CountryCode=(SELECT CountryCode FROM C_Country c WHERE c.isactive='Y'\" + \" AND c.AD_Client_ID IN (0, i.AD_Client_ID) AND ROWNUM=1) \" + \"WHERE CountryCode IS NULL AND C_Country_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Country Default=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Country_ID=(SELECT C_Country_ID FROM C_Country c\" + \" WHERE i.CountryCode=c.CountryCode AND c.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Country_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Country=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'\" + getMsg(\"ImportBPInvalidCountry\") + \". ' \" + \"WHERE C_Country_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.config(\"Invalid Country=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"Set RegionName=(SELECT Name FROM C_Region r\" + \" WHERE r.IsDefault='Y' AND r.C_Country_ID=i.C_Country_ID\" + \" AND r.AD_Client_ID IN (0, i.AD_Client_ID) AND ROWNUM=1) \" + \"WHERE RegionName IS NULL AND C_Region_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Region Default=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"Set C_Region_ID=(SELECT C_Region_ID FROM C_Region r\" + \" WHERE r.Name=i.RegionName AND r.C_Country_ID=i.C_Country_ID\" + \" AND r.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Region_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Region=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'\" + getMsg(\"ImportBPInvalidRegion\") + \". ' \" + \" WHERE C_Region_ID IS NULL \" + \" AND EXISTS (SELECT * FROM C_Country c\" + \" WHERE c.C_Country_ID=i.C_Country_ID AND c.HasRegion='Y')\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.config(\"Invalid Region=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET BPContactGreeting=NULL WHERE C_Greeting_ID IS NULL AND char_length(trim(BPContactGreeting)) = 0 AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Reset Greeting=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Greeting_ID=(SELECT C_Greeting_ID FROM C_Greeting g\" + \" WHERE i.BPContactGreeting=g.Name AND g.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Greeting_ID IS NULL AND BPContactGreeting IS NOT NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Greeting=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'\" + getMsg(\"ImportBPInvalidGreeting\") + \". ' \" + \"WHERE C_Greeting_ID IS NULL AND BPContactGreeting IS NOT NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.config(\"Invalid Greeting=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BPartner_ID=(SELECT C_BPartner_ID FROM C_BPartner p\" + \" WHERE i.Value=p.Value AND p.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE C_BPartner_ID IS NULL AND Value IS NOT NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Found BPartner=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET AD_User_ID=(SELECT AD_User_ID FROM AD_User c\" + \" WHERE i.ContactName=c.Name AND i.C_BPartner_ID=c.C_BPartner_ID AND c.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE C_BPartner_ID IS NOT NULL AND AD_User_ID IS NULL AND ContactName IS NOT NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Found Contact=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BPartner_Location_ID=(SELECT C_BPartner_Location_ID\" + \" FROM C_BPartner_Location bpl INNER JOIN C_Location l ON (bpl.C_Location_ID=l.C_Location_ID)\" + \" WHERE i.C_BPartner_ID=bpl.C_BPartner_ID AND bpl.AD_Client_ID=i.AD_Client_ID\" + \" AND DUMP(i.Address1)=DUMP(l.Address1) AND DUMP(i.Address2)=DUMP(l.Address2)\" + \" AND DUMP(i.City)=DUMP(l.City) AND DUMP(i.Postal)=DUMP(l.Postal) AND DUMP(i.Postal_Add)=DUMP(l.Postal_Add)\" + \" AND DUMP(i.C_Region_ID)=DUMP(l.C_Region_ID) AND DUMP(i.C_Country_ID)=DUMP(l.C_Country_ID)) \" + \"WHERE C_BPartner_ID IS NOT NULL AND C_BPartner_Location_ID IS NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Found Location=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Categoria_IVA_Codigo=\" + MCategoriaIva.CONSUMIDOR_FINAL + \" WHERE (C_Categoria_IVA_Codigo IS NULL OR C_Categoria_IVA_Codigo = 0) \" + \"  AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Categoria_IVA_ID= \" + \" (SELECT C_Categoria_IVA_ID \" + \"  FROM C_Categoria_IVA c \" + \"  WHERE i.C_Categoria_IVA_Codigo=c.Codigo AND c.AD_Client_ID=i.AD_Client_ID \" + \" ) \" + \"WHERE C_Categoria_IVA_ID IS NULL \" + \"  AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET SalesRep_ID=(SELECT AD_User_ID \" + \"FROM AD_User u \" + \"WHERE u.Name = i.SalesRep_Name AND u.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE SalesRep_ID IS NULL \" + \"AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Country=\" + no);\n        int noInsert = 0;\n        int noUpdate = 0;\n        sql = new StringBuffer(\"SELECT I_BPartner_ID, C_BPartner_ID,\" + \"C_BPartner_Location_ID,COALESCE(Address1,Address2,City,RegionName,CountryCode),\" + \"AD_User_ID,ContactName \" + \"FROM I_BPartner \" + \"WHERE I_IsImported='N'\").append(clientCheck);\n        Connection conn = DB.createConnection(false, Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            log.info(\"En importBPartbner antes de hacer el update en c_BPartner\");\n            PreparedStatement pstmt_updateBPartner = conn.prepareStatement(\"UPDATE C_BPartner \" + \"SET Value=aux.Value\" + \",Name=aux.Name\" + \",Name2=aux.Name2\" + \",Description=aux.Description\" + \",DUNS=aux.DUNS\" + \",TaxID=aux.TaxID\" + \",NAICS=aux.NAICS\" + \",C_BP_Group_ID=aux.C_BP_Group_ID\" + \",Updated=current_timestamp\" + \",UpdatedBy=aux.UpdatedBy\" + \",IIBB=aux.IIBB\" + \" from (SELECT Value,Name,Name2,Description,DUNS,TaxID,NAICS,C_BP_Group_ID,UpdatedBy,IIBB FROM I_BPartner WHERE I_BPartner_ID=?) as aux\" + \" WHERE C_BPartner_ID=?\");\n            log.info(\"En importBPartbner despues de hacer el update en c_BPartner\");\n            PreparedStatement pstmt_insertLocation = conn.prepareStatement(\"INSERT INTO C_Location (C_Location_ID,\" + \"AD_Client_ID,AD_Org_ID,IsActive,Created,CreatedBy,Updated,UpdatedBy,\" + \"Address1,Address2,City,Postal,Postal_Add,C_Country_ID,C_Region_ID) \" + \"SELECT ?,\" + \"AD_Client_ID,AD_Org_ID,'Y',current_timestamp,CreatedBy,current_timestamp,UpdatedBy,\" + \"Address1,Address2,City,Postal,Postal_Add,C_Country_ID,C_Region_ID \" + \"FROM I_BPartner \" + \"WHERE I_BPartner_ID=?\");\n            PreparedStatement pstmt_insertBPLocation = conn.prepareStatement(\"INSERT INTO C_BPartner_Location ( \" + \"\tC_BPartner_Location_ID,\" + \"\tAD_Client_ID,\" + \"\tAD_Org_ID,\" + \"\tIsActive,\" + \"\tCreated,\" + \"\tCreatedBy,\" + \"\tUpdated,\" + \"\tUpdatedBy,\" + \"\tName,\" + \"\tIsBillTo,\" + \"\tIsShipTo,\" + \"\tIsPayFrom,\" + \"\tIsRemitTo,\" + \"\tPhone,\" + \"\tPhone2,\" + \"\tFax,\" + \"\tC_BPartner_ID,\" + \"\tC_Location_ID) \" + \"SELECT ?,AD_Client_ID,AD_Org_ID,'Y',current_timestamp,CreatedBy,current_timestamp,UpdatedBy,\" + \"CASE WHEN char_length(trim(coalesce(address1,''))) > 0 THEN address1 \" + \"     WHEN char_length(trim(coalesce(city,''))) > 0 THEN city \" + \"     WHEN char_length(trim(coalesce(regionname,''))) > 0 THEN regionname \" + \"     ELSE name \" + \"END,\" + \"'Y','Y','Y','Y',\" + \"Phone,Phone2,Fax, ?,? \" + \"FROM I_BPartner \" + \"WHERE I_BPartner_ID=?\");\n            PreparedStatement pstmt_insertBPContact = conn.prepareStatement(\"INSERT INTO AD_User (AD_User_ID,\" + \"AD_Client_ID,AD_Org_ID,IsActive,Created,CreatedBy,Updated,UpdatedBy,\" + \"C_BPartner_ID,C_BPartner_Location_ID,C_Greeting_ID,\" + \"Name,Title,Description,Comments,Phone,Phone2,Fax,EMail,Birthday) \" + \"SELECT ?,\" + \"AD_Client_ID,AD_Org_ID,'Y',current_timestamp,CreatedBy,current_timestamp,UpdatedBy,\" + \"?,?,C_Greeting_ID,\" + \"ContactName,Title,ContactDescription,Comments,Phone,Phone2,Fax,EMail,Birthday \" + \"FROM I_BPartner \" + \" WHERE I_BPartner_ID=?\");\n            PreparedStatement pstmt_updateBPContact = conn.prepareStatement(\"UPDATE AD_User \" + \"SET C_Greeting_ID=aux1.C_Greeting_ID\" + \",Name=aux1.Name\" + \",Title=aux1.Title\" + \",Description=aux1.Description\" + \",Comments=aux1.Commets\" + \",Phone=aux1.Phone\" + \",Phone2=aux1.Phone2\" + \",Fax=aux1.Fax\" + \",EMail=aux1.EMail\" + \",Birthday=aux1.Birthaday\" + \",Updated=current_timestamp\" + \",UpdatedBy=aux1.UpdatedBy\" + \" from (SELECT C_Greeting_ID,ContactName,Title,ContactDescription,Comments,Phone,Phone2,Fax,EMail,Birthday,UpdatedBy FROM I_BPartner WHERE I_BPartner_ID=?) as aux1\" + \" WHERE AD_User_ID=?\");\n            PreparedStatement pstmt_setImported = conn.prepareStatement(\"UPDATE I_BPartner SET I_IsImported='Y',\" + \" C_BPartner_ID=?, C_BPartner_Location_ID=?, AD_User_ID=?, \" + \" Updated=current_timestamp, Processed='Y' WHERE I_BPartner_ID=?\");\n            PreparedStatement pstmt = DB.prepareStatement(sql.toString());\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                int I_BPartner_ID = rs.getInt(1);\n                int C_BPartner_ID = rs.getInt(2);\n                boolean newBPartner = C_BPartner_ID == 0;\n                int C_BPartner_Location_ID = rs.getInt(3);\n                String newLocali = rs.getString(4);\n                boolean newLocation = rs.getString(4) != null;\n                int AD_User_ID = rs.getInt(5);\n                boolean newContact = rs.getString(6) != null;\n                log.fine(\"I_BPartner_ID=\" + I_BPartner_ID + \", C_BPartner_ID=\" + C_BPartner_ID + \", C_BPartner_Location_ID=\" + C_BPartner_Location_ID + \" create=\" + newLocation + \", AD_User_ID=\" + AD_User_ID + \" create=\" + newContact);\n                if (newBPartner) {\n                    X_I_BPartner iBP = new X_I_BPartner(getCtx(), I_BPartner_ID, null);\n                    MBPartner bp = new MBPartner(iBP);\n                    if (bp.save()) {\n                        C_BPartner_ID = bp.getC_BPartner_ID();\n                        log.finest(\"Insert BPartner\");\n                        noInsert++;\n                    } else {\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Insert BPartner failed: \" + CLogger.retrieveErrorAsString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                } else {\n                    pstmt_updateBPartner.setInt(1, I_BPartner_ID);\n                    pstmt_updateBPartner.setInt(2, C_BPartner_ID);\n                    try {\n                        no = pstmt_updateBPartner.executeUpdate();\n                        log.finest(\"Update BPartner = \" + no);\n                        noUpdate++;\n                    } catch (SQLException ex) {\n                        log.finest(\"Update BPartner -- \" + ex.toString());\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Update BPartner: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                }\n                if (C_BPartner_Location_ID != 0) {\n                } else if (newLocation) {\n                    int C_Location_ID = 0;\n                    try {\n                        C_Location_ID = DB.getNextID(m_AD_Client_ID, \"C_Location\", null);\n                        if (C_Location_ID <= 0) {\n                            throw new DBException(\"No NextID (\" + C_Location_ID + \")\");\n                        }\n                        pstmt_insertLocation.setInt(1, C_Location_ID);\n                        pstmt_insertLocation.setInt(2, I_BPartner_ID);\n                        no = pstmt_insertLocation.executeUpdate();\n                        log.finest(\"Insert Location = \" + no);\n                    } catch (SQLException ex) {\n                        log.finest(\"Insert Location - \" + ex.toString());\n                        conn.rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Insert Location: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                    try {\n                        C_BPartner_Location_ID = (DB.getNextID(m_AD_Client_ID, \"C_BPartner_Location\", null));\n                        log.finest(\"C_BPartner_Location_ID es : \" + C_BPartner_Location_ID);\n                        if (C_BPartner_Location_ID <= 0) {\n                            throw new DBException(\"No NextID (\" + C_BPartner_Location_ID + \")\");\n                        }\n                        pstmt_insertBPLocation.setInt(1, C_BPartner_Location_ID);\n                        pstmt_insertBPLocation.setInt(2, C_BPartner_ID);\n                        pstmt_insertBPLocation.setInt(3, C_Location_ID);\n                        pstmt_insertBPLocation.setInt(4, I_BPartner_ID);\n                        no = pstmt_insertBPLocation.executeUpdate();\n                        log.finest(\"Insert BP Location = \" + no);\n                    } catch (Exception ex) {\n                        log.finest(\"Insert BPLocation - \" + ex.toString());\n                        conn.rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Insert BPLocation: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                }\n                if (AD_User_ID != 0) {\n                    pstmt_updateBPContact.setInt(1, I_BPartner_ID);\n                    pstmt_updateBPContact.setInt(2, AD_User_ID);\n                    try {\n                        no = pstmt_updateBPContact.executeUpdate();\n                        log.finest(\"Update BP Contact = \" + no);\n                    } catch (SQLException ex) {\n                        log.finest(\"Update BP Contact - \" + ex.toString());\n                        conn.rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Update BP Contact: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                } else if (newContact) {\n                    try {\n                        AD_User_ID = DB.getNextID(m_AD_Client_ID, \"AD_User\", null);\n                        if (AD_User_ID <= 0) {\n                            throw new DBException(\"No NextID (\" + AD_User_ID + \")\");\n                        }\n                        pstmt_insertBPContact.setInt(1, AD_User_ID);\n                        pstmt_insertBPContact.setInt(2, C_BPartner_ID);\n                        if (C_BPartner_Location_ID == 0) {\n                            pstmt_insertBPContact.setNull(3, Types.NUMERIC);\n                        } else {\n                            pstmt_insertBPContact.setInt(3, C_BPartner_Location_ID);\n                        }\n                        pstmt_insertBPContact.setInt(4, I_BPartner_ID);\n                        no = pstmt_insertBPContact.executeUpdate();\n                        log.finest(\"Insert BP Contact = \" + no);\n                    } catch (Exception ex) {\n                        log.finest(\"Insert BPContact - \" + ex.toString());\n                        conn.rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Insert BPContact: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                }\n                pstmt_setImported.setInt(1, C_BPartner_ID);\n                if (C_BPartner_Location_ID == 0) {\n                    pstmt_setImported.setNull(2, Types.NUMERIC);\n                } else {\n                    pstmt_setImported.setInt(2, C_BPartner_Location_ID);\n                }\n                if (AD_User_ID == 0) {\n                    pstmt_setImported.setNull(3, Types.NUMERIC);\n                } else {\n                    pstmt_setImported.setInt(3, AD_User_ID);\n                }\n                pstmt_setImported.setInt(4, I_BPartner_ID);\n                no = pstmt_setImported.executeUpdate();\n                conn.commit();\n            }\n            rs.close();\n            pstmt.close();\n            pstmt_updateBPartner.close();\n            pstmt_insertLocation.close();\n            pstmt_insertBPLocation.close();\n            pstmt_insertBPContact.close();\n            pstmt_updateBPContact.close();\n            pstmt_setImported.close();\n            conn.close();\n            conn = null;\n        } catch (SQLException e) {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                conn = null;\n            } catch (SQLException ex) {\n            }\n            throw new Exception(\"ImportBPartner.doIt\", e);\n        } finally {\n            if (conn != null) {\n                conn.close();\n            }\n            conn = null;\n        }\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='N', Updated=current_timestamp \" + \"WHERE I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        addLog(0, null, new BigDecimal(no), \"@Errors@\");\n        addLog(0, null, new BigDecimal(noInsert), \"@C_BPartner_ID@: @Inserted@\");\n        addLog(0, null, new BigDecimal(noUpdate), \"@C_BPartner_ID@: @Updated@\");\n        return \"\";\n    }\n", "label": 0, "substitutes": {"req": ["reader", "proc", "rx", "rel", "rep", "conn", "http", "request", "fr", "data", "ref", "re", "r", "response", "resource", "ctx", "zip", "serv", "info", "Request", "exec", "crit", "desc", "query", "e", "requ", "report", "job", "rec", "rw", "obj", "rt", "err", "Resp", "rr", "res", "rb", "jar", "pkg"], "resp": ["respond", "proc", "rel", "rep", "reply", "result", "jp", "conn", "http", "ev", "out", "request", "app", "wa", "client", "fr", "f", "exc", "red", "ref", "re", "response", "r", "ctx", "zip", "server", "serv", "ret", "conf", " response", "bb", "report", "exp", "rh", "job", "temp", "esp", "rec", "Response", "respons", "sp", "html", "rev", "obj", "prev", "err", "wb", "Resp", "rr", "res", "p", "Rec"], "reqPath": ["questpath", "requestName", "reqHandler", "questPart", "reqPart", " reqPart", "requName", "requestUrl", "requestCase", "reqpath", "reqUrl", " reqCase", "apppath", " reqName", "taskPart", "requestHome", "taskCase", " reqHandler", "requpath", "releaseName", "releasePart", "appName", "questPath", "requHandler", "requestpath", "requestPath", "requPart", "reqCase", "reqHome", "reqName", "requestPart", "appPath", "questUrl", " reqpath", "requPath", "releasePath", "taskPath", "questHandler", " reqHome", " reqUrl", "questHome", "requUrl", "taskpath"], "entry": ["source", "reader", " entries", "id", "inc", "si", "ent", "feed", "connection", "result", "ry", "jo", "object", "cell", "part", "ries", "row", "fr", "data", "auto", "zip", "response", "resource", "r", "ie", "archive", "address", "info", "serv", "element", "conf", "ge", "e", "nt", "report", "log", "found", "je", "se", "session", "index", "ri", "path", "image", "entity", "file", "record", "parse", "or", "uri", "Entry", "manager", "rr", "type", "service", " Entry", "jar"], "in": ["source", "reader", "tin", "id", "input", "inc", "din", "win", "min", "cgi", "nin", "con", "out", "b", "login", "f", "data", "In", "pin", "inas", "re", "r", "n", "resource", "again", "thin", "serv", "stream", "isin", "ac", "ins", "s", "ax", "vin", "zin", "gin", "ini", "ex", "m", "fe", "kin", "index", "cin", "c", "socket", "i", "IN", "err", "or", "inn", "rin", "is", "bin", "copy", "p"]}}
{"id1": "17389235", "id2": "14134127", "code1": "    public boolean PrintPage(String page, String url_addr, String charset) {\n        File parent_path = new File(new File(page).getParent());\n        if (!parent_path.exists()) {\n            parent_path.mkdirs();\n        }\n        String r_line = null;\n        BufferedReader bReader = null;\n        FileOutputStream out = null;\n        OutputStreamWriter writer = null;\n        PrintWriter fileOut = null;\n        File file = null;\n        try {\n            InputStream ins = new URL(url_addr).openStream();\n            file = new File(page);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            bReader = new BufferedReader(new InputStreamReader(ins, charset));\n            out = new FileOutputStream(page);\n            writer = new OutputStreamWriter(out, charset);\n            fileOut = new PrintWriter(writer);\n            while ((r_line = bReader.readLine()) != null) {\n                r_line = r_line.trim();\n                int str_len = r_line.length();\n                if (str_len > 0) {\n                    fileOut.println(r_line);\n                    fileOut.flush();\n                }\n            }\n            ins.close();\n            ins = null;\n            fileOut.close();\n            writer.close();\n            out.close();\n            bReader.close();\n            fileOut = null;\n            writer = null;\n            out = null;\n            bReader = null;\n            parent_path = null;\n            file = null;\n            r_line = null;\n            return true;\n        } catch (IOException ioe) {\n            log.error(ioe.getMessage());\n            ioe.printStackTrace();\n            return false;\n        } catch (Exception es) {\n            es.printStackTrace();\n            log.error(\"static----------\" + es.getMessage());\n            return false;\n        } finally {\n            try {\n                if (fileOut != null) {\n                    fileOut.close();\n                    fileOut = null;\n                }\n                if (writer != null) {\n                    writer.close();\n                    writer = null;\n                }\n                if (out != null) {\n                    out.close();\n                    out = null;\n                }\n                if (bReader != null) {\n                    bReader.close();\n                    bReader = null;\n                }\n            } catch (IOException ioe) {\n                log.error(ioe.getMessage());\n            } catch (Exception e) {\n                log.error(e.getMessage());\n            }\n        }\n    }\n", "code2": "    private void addFilesToExistingZip(File zipFile, String[] dirs, File[] files) throws IOException {\n        File tempFile = new File(zipFile.getAbsoluteFile() + \".temp\");\n        if (tempFile.exists()) tempFile.delete();\n        boolean renameOk = zipFile.renameTo(tempFile);\n        if (!renameOk) {\n            throw new RuntimeException(\"Could not rename the file \" + zipFile.getAbsolutePath() + \" to \" + tempFile.getAbsolutePath());\n        }\n        ZipInputStream zin = new ZipInputStream(new FileInputStream(tempFile));\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));\n        ZipEntry entry = zin.getNextEntry();\n        byte[] buf = new byte[1024];\n        while (entry != null) {\n            String entryName = entry.getName();\n            boolean inFiles = false;\n            for (int i = 0; i < files.length; i++) {\n                String fileName = dirs[i] + \"/\" + files[i].getName();\n                if (fileName.equals(entryName)) {\n                    inFiles = true;\n                    break;\n                }\n            }\n            if (!inFiles) {\n                out.putNextEntry(new ZipEntry(entryName));\n                int len;\n                while ((len = zin.read(buf)) > 0) out.write(buf, 0, len);\n            }\n            entry = zin.getNextEntry();\n        }\n        zin.close();\n        for (int i = 0; i < files.length; i++) {\n            InputStream in = new FileInputStream(files[i]);\n            out.putNextEntry(new ZipEntry(dirs[i] + \"/\" + files[i].getName()));\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            out.closeEntry();\n            in.close();\n        }\n        out.close();\n        tempFile.delete();\n    }\n", "label": 0, "substitutes": {"page": ["next", "host", "parent", "route", "source", "site", "url", "pe", "office", "xml", "result", "output", "message", "wiki", "article", "this", "age", "part", "base", "number", "p", "data", "phrase", "resource", "server", "address", "template", "photo", "filename", "name", "pages", "password", "content", "string", "path", "Page", "document", "image", "point", "html", "title", "pp", "pl", "port", "null", "location"], "url_addr": ["urlacaddr", "resource_addr", "urlachandle", "url___address", "url__adr", "url___uri", "url___host", "url__addr", "resource_handle", "url_uri", "urlacadr", "url_handle", "resource_adr", "url_address", "resource_host", "resource_address", "urlacaddress", "resource_uri", "url__address", "url___addr", "url__handle", "url_host", "url_adr"], "charset": ["chactersetting", "changuageset", "chARSet", "chaset", "changuagesET", "chasets", "chararset", "chasetter", "charsheet", "chearset", "chARSET", "charapterset", "chacterspace", "cheARSheet", "chaptersets", "charsET", "chearsetting", "cheARSet", "charsetter", "chactersET", "chapterset", "chactersetter", "cheARSetter", "changuagesetting", "charsets", "chararspace", "cheARSET", "chARSetter", "chacterset", "chaspace", "cheARSetting", "changuagesheet", "chARSetting", "chearsetter", "chararsetting", "chactersets", "charsetting", "chapterspace", "charapterspace", "charaptersets", "charaptersetting", "chararsets", "chearsheet", "chearsET", "chasET", "chaptersetting", "chasetting", "chasheet", "chARSheet", "charspace"], "parent_path": ["parent2part", "Parent_dir", "parent64directory", "parent_pointer", " parent_location", " parent2path", "parent64path", "parent64dir", " parent2part", "parentfullpath", " parent_part", "parent_location", "parent_dir", "parent_link", "Parent_path", "Parent_pointer", "parentfullpointer", "parent\u00b7part", " parent2dir", "parent\u00b7link", " parent_directory", "parent_directory", "Parent_directory", " parent_dir", "parentfullchild", "Parent_child", " parent_link", "parent\u00b7path", "parent_part", "parentfulldir", "Parent_location", "parent64location", " parent2link", "parent_child", "parent2dir", "parent\u00b7dir", "parent2path", "parent2link"], "r_line": ["b_line", "rxkey", "sr_key", "R_lc", "r\u00b7lf", "raclink", "rIPlines", "rxline", "raclen", "r_link", "rIPcell", "raclin", "roneyline", " r_lines", "b_row", "ripline", "roneylines", "r_key", "r\u00b7line", "roneystroke", "r_LINE", "r__str", "r_Line", "pr_link", "r\u00b7lines", "sr_line", "R_line", "riplines", "pr_line", " r_lf", "rIPline", "r___lin", "r_liner", "pr___line", " r_page", "r_lin", "riplen", "rxLINE", "r_lf", "roneycell", "r_str", "pr___len", " r_str", "r_row", " r_len", "rIPstroke", "b_lc", "rxlen", "r___link", "r___len", "r_lc", "pr___lin", "pr___link", "racline", "r_page", "r_lines", "sr_LINE", "r__lf", "r__line", "pr_len", "R_liner", "pr_lin", "R_Line", "r_stroke", " r_stroke", "r___line", "r__lines", "sr_len", "b_lin", "r_len", "rippage", "r\u00b7str", "r_cell", " r_cell"], "bReader": [" bR", "bbParser", " bRead", " bHeader", "BWriter", "bbReader", "bInput", " bParser", "rbStream", "BRead", "bbDriver", "bHeader", "BInput", "fStream", "bDriver", "BR", "rReader", "bbHelper", "fParser", " bStream", " bWriter", "bbWriter", "fbWriter", "fReader", "BReader", "bbreader", "fHelper", "bbInput", "bbRead", " bDriver", "fbInput", "rDriver", "rbWriter", " bHelper", "bRead", "rbParser", "rWriter", "rbInput", "rParser", "bParser", "rbRead", "fRead", "bbR", "rInput", "bHelper", "rbReader", " breader", "fWriter", "fbreader", "fHeader", "bStream", " bInput", "bbHeader", "fbReader", "breader", "bWriter", "fDriver", "bR"], "out": ["source", "parent", "reader", "input", "inc", "write", "user", "office", "net", "win", "result", "co", "io", "output", "outer", "conn", "letter", "w", "in", "client", "object", "part", "data", "version", "OUT", "Out", "again", "outs", "print", "server", "editor", "external", "inner", "off", "word", "name", "null", "query", "it", "o", "flow", "report", "log", "Writer", "writ", "timeout", "book", "index", "string", "path", "image", "window", "cache", "socket", "err", "block", "outside", "bin", "writing", "line", "type"], "writer": ["WR", "parent", "reader", "later", "processor", "wrapper", "write", "term", "win", "connection", "office", "buffer", "xml", "wire", "with", "player", "ee", "engine", "ws", "io", "output", "outer", "w", "in", "driver", "wa", "fd", "object", "worker", "writers", "fw", "OUT", "r", "outs", "riter", "editor", "work", "handler", "inner", "wer", "author", "W", "x", "word", "wt", "null", "o", "flow", "wl", "wave", "Writer", "writ", "temp", "book", "window", "string", "index", "document", "rw", "socket", "lock", "builder", "war", "self", "writing", "entry", "wr", "written"], "fileOut": ["resourceout", " fileOwner", "fileClient", "fileOutside", "printOUT", "fOut", "FILEIn", "letterOut", "fileOwner", "FileOutside", "fileWriter", "FileOutput", "FileOwner", "printOutside", "FileClient", " fileWriter", "feedOut", " fileout", "FileOUT", "fileOUT", "fileIn", "resourceOutput", " fileOutput", "fOutput", "letterWriter", "logOutside", "Fileout", "cacheOUT", "feedIn", "FileIn", "fileout", "cacheout", "logOut", "resourceWriter", "resourceOut", " fileOutside", " fileOUT", "logOUT", "fIn", "cacheOut", "letterOwner", "cacheIn", "FileWriter", " fileIn", "resourceOUT", "feedOUT", "FILEOut", "FILEOutside", "letterout", "letterClient", "fout", "letterIn", "fileOutput", " fileClient", "FileOut", "printOut", "resourceIn"], "file": ["source", "play", "parent", "folder", "reader", "ile", "url", "wrapper", "binary", "pe", "user", "place", "feed", "connection", "buffer", "queue", "function", "File", "io", "output", "limit", "letter", "http", "fp", "in", "home", "object", "model", "part", "f", "base", "po", "data", "fe", "table", "print", "zip", "resource", "work", "handler", "child", "filename", "name", "dir", "full", "flow", "log", "up", "book", "il", "path", "image", "pool", "lock", "socket", "live", "cache", "files", "local", "FILE", "line", "p", "unit"], "ins": ["opens", "INS", "reader", "ks", "alls", "strings", "input", "inc", "din", "events", "errors", "win", "pull", "ils", "lines", "settings", "ws", "io", "rss", "fs", "pins", "in", "login", "as", "ups", "pin", "In", "stream", "inline", "bs", "outs", "ris", "ains", "inner", "vs", "Ins", "plugins", "rs", "gin", "ini", "abs", "ls", "rules", "kin", "ios", "ops", "lock", "its", "ips", "limits", "IN", "ints", "inn", "files", "is", "lin", "ts", "bin", "ps", "s"], "str_len": ["str_fin", "string64data", "str2num", "str__len", "str__length", "string64pos", "str_num", "str2len", "str5data", " str_fin", "str2length", "str2fin", "str64pos", "str_length", "string64len", "str5pos", "str5length", "str64length", "str__fin", " str_length", "string_data", "string64length", "string_len", " str_num", "str64len", "str5len", "string_pos", "str64data", "str_pos", "str_data", "string_length", "str__num"]}}
{"id1": "9046204", "id2": "7993946", "code1": "    public static void makeLPKFile(String[] srcFilePath, String makeFilePath, LPKHeader header) {\n        FileOutputStream os = null;\n        DataOutputStream dos = null;\n        try {\n            LPKTable[] fileTable = new LPKTable[srcFilePath.length];\n            long fileOffset = outputOffset(header);\n            for (int i = 0; i < srcFilePath.length; i++) {\n                String sourceFileName = FileUtils.getFileName(srcFilePath[i]);\n                long sourceFileSize = FileUtils.getFileSize(srcFilePath[i]);\n                LPKTable ft = makeLPKTable(sourceFileName, sourceFileSize, fileOffset);\n                fileOffset = outputNextOffset(sourceFileSize, fileOffset);\n                fileTable[i] = ft;\n            }\n            File file = new File(makeFilePath);\n            if (!file.exists()) {\n                FileUtils.makedirs(file);\n            }\n            os = new FileOutputStream(file);\n            dos = new DataOutputStream(os);\n            dos.writeInt(header.getPAKIdentity());\n            writeByteArray(header.getPassword(), dos);\n            dos.writeFloat(header.getVersion());\n            dos.writeLong(header.getTables());\n            for (int i = 0; i < fileTable.length; i++) {\n                writeByteArray(fileTable[i].getFileName(), dos);\n                dos.writeLong(fileTable[i].getFileSize());\n                dos.writeLong(fileTable[i].getOffSet());\n            }\n            for (int i = 0; i < fileTable.length; i++) {\n                File ftFile = new File(srcFilePath[i]);\n                FileInputStream ftFis = new FileInputStream(ftFile);\n                DataInputStream ftDis = new DataInputStream(ftFis);\n                byte[] buff = new byte[256];\n                int readLength = 0;\n                while ((readLength = ftDis.read(buff)) != -1) {\n                    makeBuffer(buff, readLength);\n                    dos.write(buff, 0, readLength);\n                }\n                ftDis.close();\n                ftFis.close();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (dos != null) {\n                try {\n                    dos.close();\n                    dos = null;\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "code2": "    public void unsplit(String newFilename, File[] files) throws Exception {\n        FileOutputStream stream = new FileOutputStream(new File(newFilename));\n        for (int i = 0; i < files.length; i++) {\n            FileInputStream fin = new FileInputStream(files[i].getAbsolutePath());\n            DataInputStream din = new DataInputStream(fin);\n            while (din.available() > 0) {\n                stream.write(din.read());\n            }\n            din.close();\n            fin.close();\n        }\n        stream.close();\n    }\n", "label": 1, "substitutes": {"srcFilePath": ["rcFilePath", "srcTaskName", "srcSourceFilePath", "srcFileLocation", "srcfilePath", "srcClassName", "rcfilePath", "sourceFilesName", "srcFileName", "srcKeyName", "srcCodeName", "srcFileList", "srcfileName", "sourceFileList", "srcMessageList", "sourceFilesLocation", "secureKeyInfo", "rcfileName", "srcSourceFileLocation", "srcSourceFileRoot", "srcCodeList", "srcFilesCase", "srcFunctionPoint", "rcFileName", "srcFileStream", "sourceFileStream", "srcFilepath", "srcfileLocation", "srcFilePoint", "srcPageName", "srcFileRoot", "srcfileCase", "secureFileName", "sourceFileLocation", "sourceFilesPath", "srcFilesPoint", "sourceFileRoot", "sourceFilespath", "srcKeyLocation", "srcSourceFilepath", "srcMessagePath", "secureFilePath", "rcFileCase", "srcFilesList", "srcFileCase", "srcfilePoint", "srcCodepath", "srcFunctionPath", "srcFilespath", "sourceFilesRoot", "rcfilePoint", "srcClassInfo", "srcPagePath", "srcFunctionCase", "sourceFilepath", "srcTaskPath", "sourceFilesStream", "srcMessagepath", "secureKeyPath", "srcKeypath", "secureKeyName", "rcFilePoint", "srcFilesRoot", "srcTaskRoot", "srcTaskStream", "sourceFilesList", "srcMessageName", "srcFilesPath", "rcfileCase", "srcPageStream", "sourceFilePath", "srcPageLocation", "srcClasspath", "srcFilesStream", "srcFilesName", "srcFileInfo", "secureFileInfo", "secureFilepath", "srcSourceFileStream", "srcCodePath", "srcKeyPath", "srcSourceFileName", "secureKeypath", "srcFunctionName", "srcClassPath", "srcFilesInfo", "srcfileStream", "srcFilesLocation", "srcKeyInfo"], "makeFilePath": ["parseLinePath", "makeFilespath", "makeFilenamePath", "makefilePath", "parseLinepath", "parseFilePoint", "makeFilepath", "targetFilenameCase", "makeFileName", "makefilepath", "makeLinepath", "makeFilenameCase", "makeClassText", "parseLinePoint", "targetFilenameText", "makeClassPath", "makeClassCase", "targetFileCase", "makeLinePath", "targetFilepath", "makefileCase", "targetFilenamePath", "makeDirPoint", "makeFilenamepath", "makeDirPath", "makefileText", "makeFileCase", "targetFileText", "makeClasspath", "makeFilesName", "parseFilepath", "makeFilesPoint", "parseFileName", "makeDirpath", "targetFilenamepath", "makeLinePoint", "makeFilesPath", "makeFileText", "makeLineName", "makeDirName", "makeFilenameText", "parseFilePath", "makeFilePoint", "targetFilePath", "parseLineName"], "header": ["source", "host", "head", "reader", "h", "later", "input", "queue", "line", "token", "connection", "buffer", "xml", "director", "cf", "result", "player", "output", "message", "http", "definition", "in", "client", "request", "layer", "data", "version", "table", "cover", "hard", "worker", "master", "handler", "server", "config", "writer", "info", "her", "feature", "author", "filename", "name", "body", "liner", "event", "component", "Header", "protection", "report", "per", "cookie", "kernel", "parser", "comment", "dr", "offset", "string", "rule", "document", "headers", "socket", "ssl", "character", "block", "manager", "metadata", "pillar", "project", "null", "type"], "os": ["los", "om", "so", "oses", "io", "fs", "out", "object", "ns", "OS", "bos", "oes", "oa", "zip", "bs", "es", "oi", "ens", "sys", "vs", "oss", "oos", "o", "aos", "mos", "Os", "nos", "ose", "ios", "ops", "ori", "flo", "ol", "pos", "us", "is", "ds", "cos", "boot", "obs", "et", "osi", "s", "ot", "does"], "dos": ["dl", "los", "dose", "die", "did", "des", "Ds", "ils", "dll", "settings", "lines", "oses", "ws", "io", "fo", "cas", "foo", "css", "ros", "bos", "oes", "drops", "lins", "di", "bi", "bs", "zip", "es", "dis", "dp", "DS", "DOS", "lo", "vs", "oss", "oos", "zo", "dds", "da", "aos", "tis", "mos", "ls", "fits", "nos", "done", "rows", "docs", "lis", "ios", "ops", "DoS", "vals", "limits", "flo", "pos", "ses", "ds", "cos", "dal", "bis", "odo", "dat", "does", "uds"], "fileTable": ["liveSection", "FileInfo", "wordChain", "controlTable", "FileChart", "FileBuffer", " fileChain", "fileFile", "liveTable", "FilePath", "fileArray", "resourceChain", "controlFamily", "FileChain", "fileFamily", "ileFile", "fInfo", " fileType", "fileChain", "wordTable", "fileType", "controlSection", "fileRow", " fileChart", "FileArray", "FileType", " fileHeader", "wordType", "fileHeader", "fTable", "fileSection", "placeChain", "controlType", " fileRow", " fileFile", "ileChain", "resourceArray", " filePath", "fChart", "liveType", "FileHeader", "FileTable", "fileInfo", "placeType", "placePath", " fileFamily", "fRow", "resourceTable", " fileInfo", "resourceBuffer", "FileFile", "filePath", "placeTable", "placeRow", " fileSection", " fileBuffer", "fileBuffer", " fileArray", "ileTable", "fileChart", "liveFamily", "ileHeader", "placeFile", "FileRow"], "fileOffset": ["pageShift", "FileOffset", "lineLength", " fileoffset", "logSize", "fileoffset", "FileEntry", " fileShift", "logoffset", " fileLength", "pageoffset", "FileSize", "FileLength", "fileSize", "fileShift", " fileEntry", "logOffset", "lineSize", "pageOffset", "fileLength", "lineOffset", "lineoffset", "fileEntry", "Fileoffset", "logEntry", " fileSize", "FileShift", "pageLength"], "i": ["abi", "l", "bi", "gi", "info", "name", "u", "cli", "xi", "ri", "slice", "ori", "line", "ip", "id", "phi", "io", "yi", "one", "b", "part", "I", "ni", "ti", "ai", "oi", "iv", "it", "ui", "ini", "key", "index", "c", "ii", "pi", "is", "fi", "my", "si", "multi", "hi", "in", "f", "base", "n", "ji", "module", "x", "o", "e", "eni", "v", "j", "q", "uni", "p", "ie", "h", "qi", "iu", "y", "data", "di", "mu", "esi", "inner", "ix", "init", "ci", "m", "li", "uri", "z", "mi", "type"], "sourceFileName": ["sourceDirName", "srcTableFamily", "sourceFolderInfo", "sourceClassName", "sourceFilePath", "sourceTableFamily", "sourceFullAddress", "srcFileSize", "sourceDirPath", "sourceTableSize", "sourceFolderName", "sourceTableName", "srcTableName", "sourceDirAddress", "sourceFileAddress", "sourceDirSize", "srcFileInfo", "sourceTableInfo", "srcClassName", "sourceClassPath", "sourceFullSize", "srcFileFamily", "srcFileAddress", "sourceFolderSize", "srcFileName", "srcClassSize", "sourceFolderFamily", "sourceClassAddress", "srcTableInfo", "sourceFullFamily", "sourceFileInfo", "sourceFullInfo", "srcClassAddress", "srcClassPath", "srcTableSize", "sourceClassSize", "sourceFullPath", "sourceFileFamily", "sourceFullName"], "sourceFileSize": ["sourceDataSIZE", "sourceSectionsize", "srcFileOffset", "srcFileLength", "srcFileSIZE", "srcFileSize", "srcLineSize", "sourceByteSize", "srcPageOffset", "srcSourceFileLength", "srcFilesize", "sourceByteLength", "sourceLineName", "sourceDatasize", "sourceByteName", "sourceFilesInfo", "srcLinesize", "sourceSectionSIZE", "sourceSourceFileName", "srcFileInfo", "srcSourceFileSize", "sourcePageSize", "srcLineSIZE", "sourceDataSize", "sourceFilesize", "srcLineName", "sourceFilesName", "sourceLineOffset", "sourcePageInfo", "sourceSourceFileSize", "srcFileName", "sourceLinesize", "sourcePageName", "srcPageSize", "sourcePageOffset", "srcPageName", "sourceFilesLength", "sourceFileSIZE", "sourceFilesSize", "sourceLineSize", "srcPageLength", "srcSourceFileName", "sourceFileInfo", "sourceLineSIZE", "sourceSectionName", "sourceFileOffset", "srcSourceFileInfo", "sourceFileLength", "sourceLineLength", "sourceSourceFileLength", "sourcePageLength", "sourceByteOffset", "sourceSectionSize", "sourceDataName", "sourceSourceFileInfo"], "ft": ["af", "fts", "bf", "util", "lf", " fl", "flat", "fs", "fp", "sf", "fd", "fr", "f", "fast", " ff", "elt", "det", "fat", "feat", "gt", "t", "tt", "former", "fl", "FH", "tta", " MFT", "aft", "pt", "ut", " FT", "rt", "bt", "let", "att", "fact", "struct", "vt", "at", "FT", "ff", "et", "ct", " ret", "fab", "kt", "wt"], "file": ["source", "play", "folder", "plain", "h", "die", "ile", "binary", "pe", "function", "File", "l", "letter", "http", "out", "fp", "b", "home", "model", "f", "base", "loc", "data", "fe", "to", "directory", "remote", "zip", "single", "work", "resource", "class", "info", "el", "module", "it", "full", "dir", "e", "fly", "php", "o", "log", "le", "book", "il", "path", "image", "document", "rule", "lock", "live", "db", "uri", "ol", "or", "files", "local", "FILE", "line", "use", "unit"], "ftFile": ["ktFiles", "FTRel", "ktRel", "ftTable", "ktDir", "ftF", "ctRel", "ctF", "aftTable", "aftFiles", "FTF", "ctTable", " ftFiles", "ftFiles", "ktFile", "ftRel", "ftDir", "FTFile", "ktTable", " ftTable", "aftDir", "FTTable", "ctFile", " ftDir", "aftFile", "ktF"], "ftFis": ["ftfis", "ftBiss", "ftFus", "fortFis", "ftBis", "ftFIS", "ftLIs", "fortFides", "ftDides", "ftLiss", "fortGFis", "aftFris", "ftDus", "ftFsIs", "ftGFiss", " ftFIs", " ftCiss", "ftFsis", "ftLisc", " ftCis", "ftDiss", " ftFisc", "ftFides", "ftCisc", " ftCIs", "aftLis", "ftfris", "ftLis", "fortGFides", "aftLiss", "aftFIS", "ftGFus", " ftCisc", "ftFisc", "ftLris", "aftLris", "fortGFiss", "ftFris", "aftFiss", "ftFiss", "ftBris", "ftBIS", "ftFIs", "ftfIS", " ftFiss", "ftLIS", "ftCis", "ftCiss", "ftGFides", "ftGFis", "ftCIs", "fortGFus", "aftFis", "fortFus", "fortFiss", "ftfiss", "ftFsisc", "aftLIS", "ftFsiss"], "ftDis": [" ftIs", "wdDes", " FTDis", "aftLo", "wtDis", "wdDis", "aftDe", "faDet", "faDis", " FTDIS", "wtDe", "aftDIS", " ftDIS", " ftDet", "faDIS", "ftDes", "wtIs", " ftDe", "aftIs", "aftDis", " ftLo", "ftDe", "wdDet", "ftIs", "aftDet", " FTDet", "rtDes", "rtDet", "ftLo", "wdDIS", "ftDIS", "faDes", " FTDe", "ftDet", "rtDis", "rtDIS", "wtLo"], "buff": ["read", "cb", "bf", "txt", "append", "feed", "buffer", "tab", "now", "flat", "FF", "app", "b", "char", "cmd", "bug", "fe", "butt", "hack", "qq", "raw", "info", "pad", "Buff", "batch", "grab", "bb", "ob", "ph", "length", "flush", "text", "uf", "bound", "buf", "bag", "gb", "count", "eb", "load", "font", "gg", "fb", "oct", "cast", "front", "uff", "boot", "ff", "nd", "cod", "fab"], "readLength": [" readLibrary", "loadlength", "loadWidth", "readLen", "Readlength", "ReadWidth", "readWidth", "ReadLength", "writeLength", " readWidth", "writeLibrary", "readLibrary", "loadLength", "loadLen", "loadLibrary", "writeWidth", "readlength", " readLen", "writelength", " readlength", "writeLen"]}}
{"id1": "18157910", "id2": "21960653", "code1": "    private static ArrayList<String> YahooSearch(String query) {\n        ArrayList<String> yahooSearchResults = new ArrayList<String>();\n        try {\n            String request = \"http://boss.yahooapis.com/ysearch/web/v1/\" + URLEncoder.encode(\"Java example for \" + query, \"UTF-8\") + \"?appid=zfau5aPV34ETbq9mWU0ui5e04y0rIewg1zwvzHb1tGoBFK2nSCU1SKS2D4zphh2rd3Wf\" + \"&format=xml&count=30&type=-msoffice,-pdf\";\n            URL url = new URL(request);\n            System.out.println(\"Host : \" + url.getHost());\n            url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            String finalContents = \"\";\n            while ((inputLine = reader.readLine()) != null) {\n                finalContents += \"\\n\" + inputLine;\n            }\n            Document doc = Jsoup.parse(finalContents);\n            Elements eles = doc.getElementsByTag(\"url\");\n            for (Element ele : eles) {\n                yahooSearchResults.add(ele.text());\n                System.out.println(\"YahooResult: \" + ele.text());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return yahooSearchResults;\n    }\n", "code2": "    public void adjustPadding(File file, int paddingSize, long audioStart) throws FileNotFoundException, IOException {\n        logger.finer(\"Need to move audio file to accomodate tag\");\n        FileChannel fcIn;\n        FileChannel fcOut;\n        ByteBuffer paddingBuffer = ByteBuffer.wrap(new byte[paddingSize]);\n        File paddedFile = File.createTempFile(\"temp\", \".mp3\", file.getParentFile());\n        fcOut = new FileOutputStream(paddedFile).getChannel();\n        fcIn = new FileInputStream(file).getChannel();\n        long written = (long) fcOut.write(paddingBuffer);\n        logger.finer(\"Copying:\" + (file.length() - audioStart) + \"bytes\");\n        long audiolength = file.length() - audioStart;\n        if (audiolength <= MAXIMUM_WRITABLE_CHUNK_SIZE) {\n            long written2 = fcIn.transferTo(audioStart, audiolength, fcOut);\n            logger.finer(\"Written padding:\" + written + \" Data:\" + written2);\n            if (written2 != audiolength) {\n                throw new RuntimeException(\"Problem adjusting padding, expecting to write:\" + audiolength + \":only wrote:\" + written2);\n            }\n        } else {\n            long noOfChunks = audiolength / MAXIMUM_WRITABLE_CHUNK_SIZE;\n            long lastChunkSize = audiolength % MAXIMUM_WRITABLE_CHUNK_SIZE;\n            long written2 = 0;\n            for (int i = 0; i < noOfChunks; i++) {\n                written2 += fcIn.transferTo(audioStart + (i * MAXIMUM_WRITABLE_CHUNK_SIZE), MAXIMUM_WRITABLE_CHUNK_SIZE, fcOut);\n                Runtime.getRuntime().gc();\n            }\n            written2 += fcIn.transferTo(audioStart + (noOfChunks * MAXIMUM_WRITABLE_CHUNK_SIZE), lastChunkSize, fcOut);\n            logger.finer(\"Written padding:\" + written + \" Data:\" + written2);\n            if (written2 != audiolength) {\n                throw new RuntimeException(\"Problem adjusting padding in large file, expecting to write:\" + audiolength + \":only wrote:\" + written2);\n            }\n        }\n        long lastModified = file.lastModified();\n        fcIn.close();\n        fcOut.close();\n        file.delete();\n        paddedFile.renameTo(file);\n        paddedFile.setLastModified(lastModified);\n    }\n", "label": 0, "substitutes": {"query": ["source", "page", "id", "term", "xml", "result", "params", "resource", "feature", "qq", "qs", "word", "tag", "name", "results", "qu", "report", "json", "text", "content", "words", "index", "string", "answer", "uri", "html", "expression", "Query", "search", "q", "gallery", "question", "filter", "quer", "type"], "yahooSearchResults": ["yahooResultResults", "ahooSearchRESULTS", "yahooQueryresults", "ahooSearchRes", "yahooFindResults", "yahooSearchResult", "yahooSearchRESULTS", "yahooFindResult", "yahooQueryResult", "googleSearchResult", "yahoosearchresults", "googlesearchReturns", "yahooSquareResult", "yahooResultResult", "ahoosearchItems", "yahooResultresults", "yahooListItems", "yahoosearchRes", "yahoosearchResults", "yahooListResult", "yahooListResults", "ahooSearchItems", "yahooSearchRes", "yahooQueryResults", "yahoosearchItems", "yahooAnswerResult", "yahooSearchresults", "ahoosearchResults", "yahooAnswerReturns", "yahooSquareItems", "ahooSearchResult", "yahooSquareResults", "yahoosearchReturns", "ahooQueryResults", "yahoosearchResult", "yahooResultReturns", "googlesearchresults", "googlesearchResult", "ahooQueryResult", "yahooAnswerResults", "ahooQueryresults", "ahoosearchResult", "ahooSearchresults", "yahooAnswerresults", "ahoosearchRESULTS", "yahooSearchReturns", "yahoosearchRESULTS", "yahooQueryRes", "ahooSearchResults", "ahooQueryRes", "yahooFindRes", "yahooListRESULTS", "googlesearchResults", "googleSearchResults", "yahooSearchItems", "googleSearchReturns", "yahooFindresults", "yahooSquareRESULTS", "googleSearchresults"], "request": ["input", "queue", "req", "open", "xml", "reference", "complete", "result", "message", "http", "params", "object", "data", "response", "resource", "server", "call", "address", "Request", "name", "method", "transfer", "report", "post", "string", "path", "frame", "uri", "parse", "search", "q", "create", "question", "register", "QUEST"], "url": ["source", "host", "page", "user", "link", "browser", "connection", "feed", "buffer", "pull", "open", "build", "download", "result", "conn", "l", "view", "http", "article", "out", "b", "client", "home", "album", "bug", "f", "loader", "base", "layer", "ver", "ref", "stream", "r", "resource", "org", "server", "email", "address", "info", "tool", "force", "bb", "ob", "api", "bel", "location", "mail", "key", "book", "string", "image", "impl", "socket", "file", "uri", "ssl", "html", "search", "URL", "item", "hub", "Url", "www", "blog", "proxy", "web", "coll", "sl", "entry"], "reader": ["read", "upper", "input", "rar", "Reader", "feed", "buffer", "result", "iter", "keeper", "io", "out", "in", "ler", "driver", "row", "f", "loader", "data", "oder", "worker", "stream", "r", "resource", "handler", "server", "writer", "inner", "er", "rer", "reading", "per", "bird", "parser", "ri", "file", "i", "or", "rr", "ner", "entry"], "inputLine": [" inputLINE", "InputLine", " inputBlock", "inputRow", "readableL", " inputRow", "inputline", "readableLine", " inputL", "rawLine", "InputRow", "InputL", "requestBlock", " inputline", "requestLine", "Inputline", "rawBlock", "readableline", "rawL", "inputL", "requestline", "readableLINE", "InputBlock", "inputLINE", "inputBlock", "InputLINE", "requestRow"], "finalContents": [" finalResults", "finishedContent", " finalReader", "completeString", "finalLine", "FinalParts", "FinalContents", "FinalContent", " finalLine", " finalContent", " finalParts", "finishedReader", "completeReader", "completeContents", "FinalResults", "completeContent", "completeResults", "finalContent", "completeParts", "finalReader", "FinalLine", "finalResults", "finalString", "finishedContents", " finalString", "finalParts", "finishedString", "completeLine"], "doc": ["div", "dec", "dc", "id", "d", "Document", "xml", "result", "http", "out", "app", "home", "f", "git", "data", "oc", "di", "pub", "org", "tx", "mc", "desc", "body", "de", "exp", "Doc", "parser", "oup", "df", "docs", "document", "node", "sp", "html", "parse", "db", "c", "cam", "md", "dom", "DOC"], "eles": ["elends", " leends", "ELes", "Elists", "Eles", "Elis", " elends", "Elises", "eltis", " leES", "elists", "ELe", "eltes", "ELis", " elES", "ELends", "elis", "elES", " lee", " lees", "eltises", "ELES", "ELists", "eltists", "ELises", "elises"], "ele": ["sel", "entry", "Ele", " ELE", "ea", "lem", "tle", "ette", "eor", "elle", "ellen", "ee", "mel", " ce", "sole", "ler", "ole", "tile", "ere", "nel", "eur", "elt", "el", " element", "element", "oodle", "ite", "ge", "ne", "e", "de", "enne", "ef", "yle", "oe", "LE", "sl", "kel", "eed", "ple", "ect", "le", "ell", "sle", "eb", "eller", "efe", "eu", "een", "elope", "bat", "line", "ie"]}}
{"id1": "21028028", "id2": "17568209", "code1": "    public int save(String newInventory, String inventoryType, int compareResult, boolean renameCorruptedFile) {\n        if (newInventory == null || newInventory.equals(\"\")) return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        Category log = ThreadCategory.getInstance(getClass());\n        try {\n            log.debug(newInventory);\n            init(newInventory);\n        } catch (ValidationException ve) {\n            log.error(\"Unable to parse new Inventory.\");\n            log.error(ve);\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        } catch (MarshalException me) {\n            log.error(\"Unable to parse new Inventory.\");\n            log.error(me);\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        }\n        InventoryConfiguration iConfig = InventoryConfigFactory.getInstance().getConfiguration();\n        String directory_repository = iConfig.getFileRepository();\n        String path = (String) parameters.get(\"path\");\n        if (path == null) {\n            log.error(\"Parameter 'path' not found.\");\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        }\n        java.sql.Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            dbConn.setAutoCommit(false);\n        } catch (SQLException s) {\n            log.error(\"Unable to connect to DB\");\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        } catch (Exception s) {\n            log.error(\"Unable to connect to DB\");\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        }\n        String nodeDirectory_repository = \"\";\n        String file_repository = \"\";\n        String oldPathToFile = \"\";\n        String newPathToFile = \"\";\n        boolean renameFile = false;\n        ResultSet rs = null;\n        try {\n            PreparedStatement stmt = dbConn.prepareStatement(SELECT_NODEID_BY_INTERFACE);\n            stmt.setString(1, ipAddress);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                nodeId = rs.getInt(1);\n            }\n            if (directory_repository.endsWith(\"/\") == false && directory_repository.endsWith(File.separator) == false) {\n                directory_repository += File.separator;\n            }\n            nodeDirectory_repository = directory_repository + nodeId;\n        } catch (SQLException s) {\n            try {\n                dbConn.rollback();\n            } catch (SQLException sqle) {\n                log.error(\"Unable to rollback on db. \" + sqle);\n            }\n            log.error(\"Unable to read from DB\");\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        }\n        rs = null;\n        try {\n            PreparedStatement stmt = dbConn.prepareStatement(SELECT_PATHTOFILE);\n            stmt.setInt(1, nodeId);\n            stmt.setString(2, inventoryType);\n            stmt.setString(3, \"A\");\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                oldPathToFile = rs.getString(1);\n            }\n            String newDirRep = nodeDirectory_repository;\n            if (path.startsWith(\"/\") == false && path.startsWith(File.separator) == false) {\n                newDirRep += File.separator;\n            }\n            long time = System.currentTimeMillis();\n            Timestamp currTime = new Timestamp(time);\n            java.util.Date currTimeDate = new java.util.Date(currTime.getTime());\n            SimpleDateFormat ObjectformatDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            newPathToFile = newDirRep + path + \"[\" + ObjectformatDate.format(currTimeDate) + \"]\";\n        } catch (SQLException s) {\n            log.error(\"Unable to read from DB\");\n            try {\n                dbConn.rollback();\n            } catch (SQLException sqle) {\n                log.error(\"Unable to rollback on db. \" + sqle);\n            }\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        }\n        int returnValue = InventoryMonitor.CONFIGURATION_SAVED;\n        rs = null;\n        int found = -1;\n        try {\n            PreparedStatement stmt = dbConn.prepareStatement(COUNT_NODEID_CONFIGURATION_NAME);\n            stmt.setInt(1, nodeId);\n            stmt.setString(2, inventoryType);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                found = rs.getInt(1);\n            }\n        } catch (SQLException s) {\n            log.error(\"Unable to read from DB\");\n            log.error(s);\n            try {\n                dbConn.rollback();\n            } catch (SQLException sqle) {\n                log.error(\"Unable to rollback on db. \" + sqle);\n            }\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        }\n        long time = System.currentTimeMillis();\n        Timestamp currentTime = new Timestamp(time);\n        if (found > 0) {\n            if (compareResult == InventoryMonitor.CONFIGURATION_CHANGED || compareResult == InventoryMonitor.FIRST_ACTIVE_CONFIGURATION_DOWNLOAD) {\n                try {\n                    log.debug(\"FOUND=\" + found + \" row/s in configuration, UPDATE it\");\n                    PreparedStatement stmt = dbConn.prepareStatement(UPDATE_CONFIGURATION_TO_STATUS_N);\n                    stmt.setInt(1, nodeId);\n                    stmt.setString(2, inventoryType);\n                    stmt.executeUpdate();\n                } catch (SQLException s) {\n                    log.error(\"Unable to update DB\" + s);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.error(\"Unable to rollback on db. \" + sqle);\n                    }\n                    saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n                    return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n                }\n                try {\n                    PreparedStatement stmt = dbConn.prepareStatement(INSERT_IN_CONFIGURATION);\n                    stmt.setInt(1, nodeId);\n                    stmt.setTimestamp(2, currentTime);\n                    stmt.setTimestamp(3, currentTime);\n                    stmt.setString(4, inventoryType);\n                    stmt.setString(5, newPathToFile);\n                    stmt.execute();\n                } catch (SQLException s) {\n                    log.error(\"Unable to insert in DB\");\n                    log.error(s);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.error(\"Unable to rollback on db. \" + sqle);\n                    }\n                    saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n                    return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n                }\n            } else {\n                try {\n                    log.debug(\"FOUND=\" + found + \" row/s in configuration, UPDATE it\");\n                    PreparedStatement stmt = dbConn.prepareStatement(UPDATE_LASTPOLLTIME_PATHTOFILE);\n                    stmt.setTimestamp(1, currentTime);\n                    stmt.setString(2, newPathToFile);\n                    stmt.setInt(3, nodeId);\n                    stmt.setString(4, inventoryType);\n                    stmt.executeUpdate();\n                    renameFile = true;\n                } catch (SQLException s) {\n                    log.error(\"Unable to update DB\");\n                    log.error(s);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.error(\"Unable to rollback on db. \" + sqle);\n                    }\n                    saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n                    return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n                }\n            }\n            try {\n                dbConn.commit();\n            } catch (SQLException s) {\n                log.error(\"Unable to commit to DB \" + s);\n                try {\n                    dbConn.rollback();\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to rollback on db. \" + sqle);\n                }\n                return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n            }\n        } else {\n            try {\n                PreparedStatement stmt = dbConn.prepareStatement(INSERT_IN_CONFIGURATION);\n                stmt.setInt(1, nodeId);\n                stmt.setTimestamp(2, currentTime);\n                stmt.setTimestamp(3, currentTime);\n                stmt.setString(4, inventoryType);\n                stmt.setString(5, newPathToFile);\n                stmt.execute();\n            } catch (SQLException s) {\n                log.error(\"Unable to insert in DB\");\n                log.error(s);\n                try {\n                    dbConn.rollback();\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to rollback on db. \" + sqle);\n                }\n                saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n                return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n            }\n        }\n        rs = null;\n        found = -1;\n        try {\n            PreparedStatement stmt = dbConn.prepareStatement(COUNT_NODEID_IN_ASSET);\n            stmt.setInt(1, nodeId);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                found = rs.getInt(1);\n            }\n        } catch (SQLException s) {\n            log.error(\"Unable to write into DB\");\n            log.error(s);\n            try {\n                dbConn.rollback();\n            } catch (SQLException sqle) {\n                log.error(\"Unable to rollback on db. \" + sqle);\n            }\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        }\n        time = System.currentTimeMillis();\n        currentTime = new Timestamp(time);\n        if (found > 0) {\n            try {\n                log.debug(\"Found \" + found + \" rows in table assets: UPDATE it\");\n                Iterator dbColumnIter = asset.keySet().iterator();\n                String queryParam = \"\";\n                int counter = 0;\n                while (dbColumnIter.hasNext()) {\n                    counter++;\n                    String currDbColumn = (String) dbColumnIter.next();\n                    String dataItem = (String) asset.get(currDbColumn);\n                    dataItem = dataItem.replaceAll(\"[ \\t]+\", \" \");\n                    queryParam += currDbColumn + \"='\" + dataItem + \"',\";\n                }\n                if (counter > 0) {\n                    String updateAssets = \"UPDATE assets SET  \" + queryParam + \" lastmodifieddate=? WHERE nodeID =?\";\n                    PreparedStatement stmt = dbConn.prepareStatement(updateAssets);\n                    stmt.setTimestamp(1, currentTime);\n                    stmt.setInt(2, nodeId);\n                    log.debug(\"UPDATEQUERY \" + updateAssets);\n                    stmt.executeUpdate();\n                }\n            } catch (SQLException s) {\n                log.error(\"Unable to update DB\" + s);\n                try {\n                    dbConn.rollback();\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to rollback on db. \" + sqle);\n                }\n                saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n                return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n            }\n        } else {\n            try {\n                log.debug(\"row not found. INSERT into assets\");\n                InsertIntoAssets(dbConn);\n            } catch (SQLException s) {\n                log.error(\"Unable to insert in DB\");\n                log.error(s);\n                try {\n                    dbConn.rollback();\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to rollback on db. \" + sqle);\n                }\n                saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n                return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n            }\n        }\n        try {\n            dbConn.commit();\n        } catch (SQLException sqle) {\n            log.error(\"Unable to save into DB\" + sqle);\n            try {\n                dbConn.rollback();\n            } catch (SQLException sqlex) {\n                log.error(\"Unable to rollback on db. \" + sqlex);\n            }\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        }\n        try {\n            boolean exists = (new File(directory_repository)).exists();\n            if (!exists) {\n                log.warn(\"file-repository '\" + directory_repository + \"' not found: trying to create it.\");\n                boolean success = (new File(directory_repository)).mkdir();\n                if (!success) {\n                    log.error(\"Directory creation failed\");\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException s) {\n                        log.error(\"Unable to rollback DB\");\n                    }\n                    return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n                }\n                log.warn(\"file-repository '\" + directory_repository + \"' created.\");\n            }\n            exists = (new File(nodeDirectory_repository)).exists();\n            if (!exists) {\n                boolean success = (new File(nodeDirectory_repository)).mkdir();\n                if (!success) {\n                    log.error(\"Node Directory '\" + nodeDirectory_repository + \"' creation failed.\");\n                    saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException s) {\n                        log.error(\"Unable to rollback DB\");\n                    }\n                    return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n                }\n            }\n            exists = (new File(oldPathToFile)).exists();\n            log.debug(oldPathToFile + \" exists=\" + exists);\n            if (!exists) {\n                if (renameCorruptedFile) {\n                    log.warn(\"renameCorruptedFile=true and old configuration doesn't exist.\");\n                }\n                returnValue = InventoryMonitor.FIRST_ACTIVE_CONFIGURATION_DOWNLOAD;\n            }\n            if (renameCorruptedFile) {\n                File f = new File(oldPathToFile);\n                String oldConfigurationFileDestination = oldPathToFile + \"_Corrupted\";\n                File dest = new File(oldConfigurationFileDestination);\n                dest.createNewFile();\n                f.renameTo(dest);\n                FileWriter fileout = new FileWriter(newPathToFile);\n                BufferedWriter filebufwri = new BufferedWriter(fileout);\n                PrintWriter printout = new PrintWriter(filebufwri);\n                printout.println(newInventory);\n                printout.close();\n            } else {\n                if (renameFile) {\n                    File f = new File(oldPathToFile);\n                    File dest = new File(newPathToFile);\n                    dest.createNewFile();\n                    f.renameTo(dest);\n                } else {\n                    FileWriter fileout = new FileWriter(newPathToFile);\n                    BufferedWriter filebufwri = new BufferedWriter(fileout);\n                    PrintWriter printout = new PrintWriter(filebufwri);\n                    printout.print(newInventory);\n                    printout.close();\n                }\n            }\n        } catch (IOException ioex) {\n            try {\n                dbConn.rollback();\n            } catch (SQLException s) {\n                log.error(\"Unable to rollback DB\");\n            }\n            log.error(\"Failed writing to file '\" + newPathToFile + \"'.\");\n            saveMessage = \"Unable to save \" + inventoryType + \" configuration.<br>\";\n            return InventoryMonitor.CONFIGURATION_NOT_SAVED;\n        } finally {\n            try {\n                dbConn.close();\n            } catch (SQLException s) {\n                log.error(\"Unable to close connection to DB\");\n            }\n        }\n        saveMessage = \"inventory \" + inventoryType + \" success.<br>\";\n        log.debug(\"\" + returnValue);\n        return returnValue;\n    }\n", "code2": "    private static boolean CopyFile(File srcFile, File tagFile) throws IOException {\n        if (srcFile == null || tagFile == null) {\n            return false;\n        }\n        int length = 2097152;\n        File dirFile = new File(getFileFolder(tagFile.getAbsolutePath()));\n        if (!dirFile.exists()) {\n            dirFile.mkdirs();\n        }\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(tagFile.getAbsolutePath());\n        FileChannel inC = in.getChannel();\n        FileChannel outC = out.getChannel();\n        int i = 0;\n        while (true) {\n            if (inC.position() == inC.size()) {\n                inC.close();\n                outC.close();\n                break;\n            }\n            if ((inC.size() - inC.position()) < 20971520) length = (int) (inC.size() - inC.position()); else length = 20971520;\n            inC.transferTo(inC.position(), length, outC);\n            inC.position(inC.position() + length);\n            i++;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"newInventory": ["newINuration", "NewedInMemory", "newedInstrument", "newInventure", "newNinventory", " newINventory", "NewedInventure", "newEnuration", "newINstrument", "newINventory", "newInuration", "NewINuration", "newedInuration", "newedInventure", "newINvent", " newINstrument", "newinvent", "newinventure", "NewInventure", "NewedInuration", "newINventure", "NewInMemory", "newedInventory", " newINinventory", "NewInventory", "newINinventory", "newIninventory", "newininventory", "NewINstrument", "newNinMemory", "NewInvent", "NewedInventory", "NewedInstrument", " newInventure", "newInMemory", "newinventory", " newIninventory", "newinuration", "newEninventory", "newInvent", "newNinstrument", " newInstrument", "NewIninventory", " newINventure", "newinstrument", "newInstrument", "newedInvent", "newEnstrument", "NewInstrument", "NewInuration", "NewINinventory", "NewINventory", "NewedInvent", "newedInMemory", "newEnventory", "newNinuration", "newINMemory", "newedIninventory"], "inventoryType": [" inventoryFile", "networkType", "databaseTYPE", "physicalPart", "archiveName", "physicaltype", "inventoryFile", "inventoryStyle", "inventoryName", "databaseType", "physicalTyp", "inventoryTyp", " inventorytype", "networkInfo", "networktype", "physicalType", "archiveTyp", "archiveTypes", "archiveType", "ventoryFile", " inventoryStyle", " inventoryInfo", " inventoryTYPE", "ventoryType", "databasetype", "inventoryTYPE", "inventoryInfo", " inventoryName", "archiveFile", "networkTyp", "ventoryTYPE", " inventoryTyp", " inventoryPart", "inventoryPart", "ventoryTyp", "databaseStyle", "archivetype", " inventoryTypes", "inventorytype", "ventoryPart", "inventoryTypes", "physicalStyle", "ventoryName", "physicalTYPE", "archiveInfo", "ventoryTypes"], "compareResult": ["computeReturn", "ComparesReturn", "computeResults", "comparesReturn", "computeResult", "comparesResults", "ComparesResults", "ComparesResult", "compareResults", "compCompareResult", "Comparesresult", "compCompareReturn", "compareReturn", "compCompareresult", "comparesResult", "compareresult", "computeresult", "CompareReturn", "CompareResult", "compCompareResults", "comparesresult", "Compareresult", "CompareResults"], "renameCorruptedFile": ["renameCorruptionPath", "renameCorruptedDirectory", "renameCorruptionFiles", "renameCorruptFiles", "renameCororedFile", "renameCororedPath", "renameCorruptedPath", "renameCorruptDirectory", "renameCororedFiles", "renameCororedDirectory", "renameCorruptedFiles", "renameCorruptPath", "renameCorruptionDirectory", "renameCorruptFile", "renameCorruptionFile"], "log": ["get", "contract", "LOG", "url", "pot", "user", "write", "net", "plug", "build", "ld", "min", "cat", "sign", "ger", "og", "l", "view", "Log", "http", "one", "this", "pg", "bug", "model", "login", "base", "loc", "server", "call", "config", "info", "serv", "use", "lo", "crit", "tag", "shell", "ge", "full", "it", "exp", "cl", "stat", "sl", "ext", "lc", "com", "le", "col", "key", "port", "pool", "list", "debug", "lock", "c", "db", "son", "fail", "cache", "struct", "arg", "lex", "level", "cal", "blog", "pl", "put", "p", "entry"], "iConfig": ["iConf", " iConf", "iuLoc", "ILoc", "siConfig", "iniConf", "siCert", "iuConf", "piConf", "iuConfig", "iniCert", "piCert", "iStruct", "iLoc", "piConfig", " iStruct", "IConf", "siLoc", "iniLoc", "iniConfig", "IConfig", " iLoc", "iCert", "IStruct", "piLoc", "iuStruct", "siConf"], "directory_repository": ["directory_reposository", "directory_repoitory", "directory_rpository", "directory_repoository", "directory_relfository", "directory_relfience", "directory_relfitory", "directory_revalository", "directory_rpoience", "directory_relfure", "directory_rposure", "directory_reposience", "directory_reposure", "directory_rpoure", "directory_rpoository", "directory_rposience", "directory_rpoitory", "directory_revalitory", "directory_repoure", "directory_rposository", "directory_revalience", "directory_repoience", "directory_revalure"], "path": ["source", "host", "folder", "route", "id", "url", "sign", "http", "PATH", "object", "Path", "root", "base", "prop", "p", "data", "directory", "resource", "prefix", "child", "config", "ath", "alias", "sync", "name", "method", "dir", "pattern", "target", "container", "text", "content", "key", "index", "string", "image", "pointer", "cache", "uri", "file", "value", "collection", "location", "type"], "saveMessage": ["ageMedium", "closeColor", "aveMedium", "ageMessage", "saveError", "exportLanguage", "copyMessage", "exportError", " saveAmount", "saveAmount", "saveMedium", "aveLanguage", "ageDescription", "savemessage", "closeLanguage", " savemessage", "saveDescription", " saveError", " saveColor", "copyAmount", "aveDescription", "saveLanguage", "aveMessage", "closeMessage", "exportAmount", "exportmessage", " saveMedium", "copymessage", "copyError", "exportColor", "saveColor", "exportMessage", "ageLanguage", " saveDescription", " saveLanguage"], "dbConn": ["dbColl", "DBCh", "DbCh", "databaseconn", "DbEnc", " dbCol", "sqlConn", " dbCh", " dbConnection", "DBColl", "dbCmd", " dbSocket", "DbCol", "DbColl", "DbSocket", "DbCmd", "DBConn", "sqlconn", "sqlCol", " dbCmd", "databaseConnection", " dbconn", "sqlConnection", "databaseConfig", "sqlEnc", "DBSocket", "dbConfig", "dbSocket", " dbColl", "dbConnection", "dbconn", "databaseConn", "dbEnc", " dbConfig", "dbCol", "dbCh", "sqlCmd", " dbEnc", "sqlConfig", "DbConn"], "nodeDirectory_repository": ["newDirectory_repouration", "newDirectory_revalitory", "newDirectory_repoitory", "newDirectory_revalue", "newDirectory_composue", "newDirectory_reosuration", "newDirectory_reposuration", "newDirectory_reosository", "newDirectory_compoitory", "newDirectory_repository", "newDirectory_compouration", "newDirectory_revaluration", "newDirectory_revalository", "newDirectory_reposository", "newDirectory_repoository", "newDirectory_compository", "newDirectory_reosue", "newDirectory_composository", "newDirectory_composuration", "newDirectory_reository", "newDirectory_compoository", "newDirectory_repoue", "newDirectory_compoue", "newDirectory_reposue"], "oldPathToFile": ["oldpathOfDirectory", "oldPathOfDirectory", "oldPathToDirectory", "oldpathOfFiles", "oldPath2Directory", "oldPathOfFiles", "oldPath2Files", "oldPath2Path", "oldpathToFiles", "oldPathOfPath", "oldPathToFiles", "oldPathFromPath", "oldPathFromFiles", "oldpathToPath", "oldpathToFile", "oldpathOfPath", "oldPathFromFile", "oldPath2File", "oldPathToPath", "oldpathToDirectory", "oldPathOfFile", "oldPathFromDirectory", "oldpathOfFile"], "newPathToFile": ["newPathToFolder", "newpathOfFolder", "newpathOfDisk", "newPathTOFolder", "newPathOfDisk", "newPathForFile", "newpathToDirectory", "newpathOfDirectory", "newpathToFolder", "newPathTODirectory", "newpathToDisk", "newpathOfFile", "newPathForFolder", "newPathTODisk", "newPathOfFolder", "newPathForDisk", "newPathTOFile", "newPathForDirectory", "newPathToDirectory", "newpathToFile", "newPathToDisk", "newPathOfDirectory", "newPathOfFile"], "renameFile": ["enamefile", "renAMEfile", "renAME\n", "ename\n", "renamefile", "enage\n", "renage\n", "enameNew", "enagefile", "renameNew", "enageNew", "renagefile", "renAMENew", "renokeNew", "rename\n", "renageNew", "renoke\n", "renokefile"]}}
{"id1": "20150442", "id2": "3257108", "code1": "    public String accessURL_Post(String url, Map<String, String> keyValue, String encoding) throws Throwable {\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        for (String key : keyValue.keySet()) {\n            formparams.add(new BasicNameValuePair(key, keyValue.get(key)));\n        }\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, encoding);\n        HttpPost httpPost = new HttpPost(url);\n        httpPost.setEntity(entity);\n        HttpResponse response = client.execute(httpPost);\n        String entuity = EntityUtils.toString(response.getEntity());\n        handleHeaders(response.getAllHeaders());\n        return entuity;\n    }\n", "code2": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            s = new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return s;\n    }\n", "label": 0, "substitutes": {"url": ["language", "host", "source", "page", "route", "id", "connection", "username", "l", "http", "object", "f", "base", "channel", "data", "r", "resource", "email", "server", "address", " URL", "name", "method", "json", "api", "text", "location", "string", "path", "document", "uri", "file", "code", "URL", "Url", "str", "entry", "sl", "type"], "keyValue": ["baseMap", " keyvalue", "keyMap", "KeyValues", "rowMap", "keyValues", "linkMap", "linkValues", "baseValues", " keyMap", "linkvalue", "KeyValue", "Keyvalue", "baseValue", "basevalue", "KeyMap", "keyvalue", "rowValues", "linkValue", " keyValues", "rowvalue", "rowValue"], "encoding": ["coded", "cryption", "encasing", "Encoder", "encoded", "enoding", "Encasing", "Encryption", "enryption", "encoder", "coding", "ecoding", "Encoding", "ecoder", "coder", "casing", "ecoded", "enoder", "Encoded", "encryption", "enoded", "ecasing"], "formparams": ["Formparts", "fargs", "fparams", "formParameters", "formargs", "formparam", "Formparams", "Formams", "FormParameters", "fparam", "fams", "qparts", " formparam", " formparts", "fParameters", " formams", "qparams", "formams", "formparts", " formargs", "qparam", "Formargs", "Formparam", " formParameters"], "key": ["next", "page", "parent", "str", "id", "pe", "net", "connection", "keys", "k", "letter", "val", "op", "part", "base", "data", "Key", "match", "pair", "resource", "prefix", "KEY", "element", "x", "section", "name", "ace", "feat", "param", "act", "step", "text", "a", "ex", "col", "string", "rule", "change", "ask", "code", "label", "type", "field", "value", "entry", "ip", "ie"], "entity": ["parent", "ent", "connection", "xml", "result", "ee", "http", "article", "client", "object", "this", "model", "data", "ec", "resource", "email", "server", "address", "el", "element", "component", "null", "e", "Entity", "api", "instance", "post", "content", "string", "document", "file", "code", "service", "ce", "form", "et", "em", "collection", "entry", "coll", "type"], "httpPost": ["httpDo", " httpPatch", " httpPut", "webDo", "hCreate", "HttpDo", "httpRequest", "HttpCreate", "HttpPut", "httpspost", "HttpPatch", "webCopy", "webpost", " httpCreate", "hpost", "httppost", "webPost", " httpCopy", "hPatch", "HttpRequest", " httpRequest", "httpsPut", "httpPut", "httpPatch", "hPost", "HttpCopy", " httppost", "httpsPost", "httpCreate", "httpCopy", "httpsRequest", " httpDo", "HttpPost", "Httppost"], "response": ["page", "successful", "respond", "default", "ful", "connection", "feed", "success", "reply", "result", "message", "output", "http", "flash", "request", "client", "environment", "application", "data", "version", "resource", "handler", "server", "serv", "method", "body", "full", "json", "api", "wave", "status", "Response", "respons", "document", "error", "resp", "throw", "fully", "received", "res", "collection"], "entuity": ["entuous", "ntuity", "settuously", "entuum", "octuation", "ENTuum", "entunciation", "ntuation", "etuity", "ntuously", "octunciation", "entuation", "etuous", "entuously", "settuity", "ENTunciation", "settuous", "ntunciation", "ntuum", "settuum", "ntuous", "octuum", "etuum", "ENTuation", "ENTuity", "octuity", "etuously"]}}
{"id1": "4209026", "id2": "8014777", "code1": "    public Collection<Module> loadModules() {\n        URL url = getClass().getResource(\"/modules.xml\");\n        if (url == null) {\n            java.util.logging.Logger.getLogger(ModuleLoader.class.getName()).log(java.util.logging.Level.SEVERE, \"Cannot find modules.xml file in classpath\");\n            return Collections.<Module>emptyList();\n        }\n        DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();\n        Document document = null;\n        InputStream input = null;\n        try {\n            input = url.openStream();\n            DocumentBuilder bui = fac.newDocumentBuilder();\n            document = bui.parse(url.openStream());\n        } catch (SAXException ex) {\n            Logger.getLogger(ModuleLoader.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (IOException ex) {\n            Logger.getLogger(ModuleLoader.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (ParserConfigurationException ex) {\n            Logger.getLogger(ModuleLoader.class.getName()).log(Level.SEVERE, null, ex);\n        } finally {\n            if (input != null) {\n                try {\n                    input.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(ModuleLoader.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        if (document == null) {\n            return Collections.<Module>emptyList();\n        }\n        List<Module> modules = new LinkedList<Module>();\n        NodeList moduleListNodes = document.getElementsByTagName(\"module-list\");\n        for (int i = 0; i < moduleListNodes.getLength(); i++) {\n            Element moduleListNode = (Element) moduleListNodes.item(i);\n            NodeList moduleNodes = moduleListNode.getElementsByTagName(\"module\");\n            for (int j = 0; j < moduleNodes.getLength(); j++) {\n                Element moduleNode = (Element) moduleNodes.item(j);\n                String moduleClass = moduleNode.getAttribute(\"class\");\n                if (moduleClass != null) {\n                    instantiateModule(moduleClass, modules);\n                }\n            }\n        }\n        return modules;\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"url": ["source", "resources", "page", "browser", "connection", "feed", "xml", "buffer", "download", "material", "io", "src", "l", "view", "http", "object", "b", "fr", "f", "loader", "base", "data", "loc", "channel", "stream", "class", "resource", "server", "config", "address", "name", "ur", "bb", "ob", "json", "api", "instance", "location", "job", "string", "path", "image", "rl", "impl", "html", "file", "uri", "ssl", "URL", "service", "Url", "www", "web", "filter", "sl"], "fac": ["af", "pac", "frac", "cf", "real", "jac", "doc", "fc", "faces", "acs", "con", "cas", "fp", "sf", "bc", "aux", "fr", "f", "ctrl", "fe", "circ", "ctx", "fat", "aci", "fam", "ifa", "aug", "func", "brace", "feat", "complex", "Fac", "cap", "buf", "com", "auc", "fact", "cam", "cos", "fi", "perm", "hum", "acc", "fab", "ac"], "document": ["language", "host", "page", "parent", "layout", "office", "Document", "xml", "connection", "dict", "director", "result", "material", "output", "doc", "l", "view", "license", "out", "object", "request", "model", "f", "base", "application", "data", "directory", "response", "system", "resource", "writer", "container", "parser", "api", "instance", "content", " documentation", "session", "docs", "media", "graph", "library", "node", "ml", "record", "context", "html", "ocument", "present", "builder", "manager", "header", "database", "metadata", "design", "project", "copy", "collection", "null", "coll"], "input": ["source", "reader", "inc", "upload", "feed", "connection", "xml", "buffer", "pull", "result", "iter", "argument", "output", "conn", "l", "view", "http", "audio", "out", "in", "inf", "loader", "data", "ref", "stream", "resource", "raw", "address", "child", "inner", "element", "Input", "ack", "bb", "json", "api", "text", "instance", "radio", "a", "parser", "session", "index", "string", "path", "image", "media", "socket", "ssl", "context", "inside", "error", "focus", "IN", "file", "form", "accept", "bin", "alpha", "qa", "null"], "bui": ["baseUI", "bbui", "BUI", "Bapi", " bdi", "baseui", "bbapi", "Bui", "baseuli", "bapi", "bdi", " buli", "basedi", "Buli", "buli", "bbUI", "bUI", " bapi", "Bdi", "bbdi", " bUI"], "modules": ["tests", "classes", "reports", "packages", "ules", "parents", "items", "types", "objects", "models", "ports", "groups", "users", "plugins", "results", "members", "lists", "versions", "docs", "utils", "features", "mods", "maps", "apps", "projects", "files", "jobs", "services"], "moduleListNodes": ["moduleSetNlements", "moduleSetJode", "moduleListNodeoms", "moduleGroupNodeasts", "moduleGroupNodeows", "modulelistLodes", "moduleListNodeotes", "moduleSetJodes", "modulelistLode", "moduleListXows", "moduleListJlements", "moduleGroupNodeodes", "moduleListNodeodes", "moduleListnows", "moduleGroupNasts", "moduleListDode", "moduleListDotes", "moduleListNodelements", "moduleGroupNodelements", "moduleListnodes", "moduleListNows", "moduleSetNoms", "moduleListJodes", "moduleListLlements", "modulelistNodes", "modulelistLlements", "moduleListLotes", "moduleListXlements", "modulelistNotes", "moduleListNasts", "moduleListNodeode", "moduleListDodes", "moduleSetNodes", "moduleGroupNows", "modulelistLotes", "moduleListDlements", "moduleListNoms", "moduleListJoms", "moduleListNodeasts", "moduleListLode", "moduleListNlements", "moduleGroupNlements", "moduleListNodeows", "modulelistNlements", "moduleSetJoms", "moduleSetNode", "moduleListXasts", "moduleListnasts", "moduleListXodes", "modulelistNode", "moduleListLodes", "moduleSetJlements", "moduleListNotes", "moduleListJode", "moduleGroupNodes", "moduleListnlements"], "i": ["id", "ik", "si", "d", "qi", "iu", "phi", "io", "hi", "yi", "y", "b", "f", "ij", "di", "bi", "I", "ni", "ji", "ai", "gi", "oi", "ix", "it", "ui", "ci", "u", "api", "ini", "li", "xi", "v", "ri", "index", "ori", "uri", "ii", "pi", "is", "fi", "mi", "ip", "ie"], "moduleListNode": ["ModulelistBlock", " moduleListKey", "modulelistDay", "modulePointElement", " moduleMapName", "ModulelistDay", "modulelistN", "modulelistKey", "ModuleListN", "moduleListKey", "moduleMapKey", "modulePointNode", "moduleTableNode", "modulelistBlock", "modulelistElement", " moduleListName", "ModulelistNode", "moduleListName", "moduleStreamBlock", "ModuleListNode", "moduleMapName", "moduleStreamNode", "modulelistName", "moduleListDay", "moduleTableBlock", " moduleListElement", "moduleMapNode", "moduleListElement", "ModuleListDay", " moduleMapNode", "moduleStreamN", "moduleListN", "modulePointKey", "moduleStreamDay", "moduleTableN", "moduleListBlock", "moduleTableDay", "ModulelistN", "ModuleListBlock", "modulelistNode", " moduleMapKey", "modulePointName", " moduleMapElement", "moduleMapElement"], "moduleNodes": [" moduleSnodes", "moduleNodeideos", "moduleSnubes", "moduleLodes", " moduleSnideos", " moduleSnoms", " moduleNlements", "moduleCNNlements", "moduleNoms", "moduleCNNode", "moduleNlements", "moduleSnodes", " moduleNideos", "moduleSNubes", " moduleLlements", " moduleLodes", "moduleNodeode", " moduleNums", "modulenodes", " moduleNubes", " moduleSnubes", "moduleNubes", "moduleNodelements", "modulenoms", "moduleNideos", "moduleLideos", "moduleLlements", " moduleLode", "moduleSnode", "moduleNums", "moduleSNideos", "modulenums", "moduleSnideos", "moduleCNNideos", "moduleLode", "moduleNodeodes", " moduleNoms", "moduleSNoms", "moduleSNodes", "modulenode", " moduleLideos", "moduleCNNodes", "moduleSnums", "moduleSnoms"], "j": ["h", "jj", "d", "J", "br", "jp", "k", "l", "y", "jo", "out", "b", "ja", "fr", "aj", "f", "ij", "n", "r", "ji", "el", "section", "js", "bj", "it", "o", "s", "uj", "dj", "m", "je", "jc", "v", "key", "li", "index", "obj", "jl", "ii", "g", "q", "em", "z", "str", "p", "ie"], "moduleNode": ["modelKey", "ModuleNode", "fileHash", "ModuleElement", "ModuleKey", "fileElement", "modelNode", "ModuleHash", "fileNode", "modelElement", "moduleElement", "moduleHash", "fileKey", "modelHash", "moduleKey"], "moduleClass": ["Config", "http", "data", "config", "js", "plugins", "_", "path", "parse", "Error", "s"]}}
{"id1": "460892", "id2": "19592942", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public Fen_Download_FlameRobin() {\n        super();\n        initialize();\n        long HeureDebut = System.currentTimeMillis();\n        long HeureActuelle;\n        String urlsetup = \"http://downloads.sourceforge.net/project/autobackupbysim/tools/flamerobin-0.9.2-1-setup.exe\";\n        int erreurOuverture = 0;\n        InputStream input = null;\n        String cheminFichier = \"\";\n        File fichier;\n        FileOutputStream writeFile = null;\n        try {\n            URL url = new URL(urlsetup);\n            URLConnection connection = url.openConnection();\n            final int fileLength = connection.getContentLength();\n            if ((fileLength == -1) || (fileLength == 0)) {\n                System.out.println(\"Invalide URL or file.\");\n                erreurOuverture++;\n            }\n            input = connection.getInputStream();\n            String fileName = url.getFile().substring(url.getFile().lastIndexOf('/') + 1);\n            if (fileName.contains(\"%20\") == true) {\n                fileName = fileName.replaceAll(\"%20\", \" \");\n            }\n            if (fileName.contains(\"&amp;\") == true) {\n                fileName = fileName.replaceAll(\"&amp;\", \" and \");\n            }\n            cheminFichier = GestionRepertoire.RecupRepTravail() + \"\\\\\" + fileName;\n            jLabel1.setText(\" Fichier en cours : \" + fileName);\n            fichier = new File(cheminFichier);\n            writeFile = new FileOutputStream(cheminFichier);\n            byte[] buffer = new byte[4096 * 1024];\n            int read;\n            while ((read = input.read(buffer)) > 0) {\n                writeFile.write(buffer, 0, read);\n                long TailleEncours = fichier.length();\n                int progressionEnCours = (int) ((100 * (TailleEncours + 1)) / fileLength);\n                HeureActuelle = System.currentTimeMillis();\n                long Vitesse = (long) (TailleEncours / (HeureActuelle - HeureDebut));\n                jLabel1.setText(\"T\ufffdl\ufffdchargement du fichier , Vitesse Actuelle : \" + Vitesse + \" Ko/s\");\n                jProgressBar.setValue(progressionEnCours);\n                jProgressBar.setString(progressionEnCours + \" %\");\n            }\n            writeFile.flush();\n        } catch (IOException e) {\n            System.out.println(\"Error while trying to download the file.\");\n            e.printStackTrace();\n        } finally {\n            try {\n                if (erreurOuverture == 0) {\n                    writeFile.close();\n                    input.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        String cmdExecuteSetup = (\"cmd /c \\\"\" + cheminFichier + \"\\\" /silent\");\n        Runtime r = Runtime.getRuntime();\n        Process p = null;\n        try {\n            p = r.exec(cmdExecuteSetup);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            p.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"src": ["source", "sel", "RC", "reader", "sb", "tmp", "url", "input", "proc", "cb", "req", "upload", "SourceFile", "dep", "download", "sth", "sit", "username", "fp", "Source", "supp", "st", "loc", "cpp", "href", "ref", "stream", "storage", "resource", "sc", "ctx", "config", "filename", "name", "component", "rc", "inst", "prot", "feat", "gn", "spec", "fn", "ource", "Dest", "buf", "back", "sin", "gb", "slice", "sec", "path", "gz", "string", "rl", "obj", "load", "uri", "ssl", "file", "secure", "code", "impl", "vr", "dist", "img", "sn", "s", "rb", "cmp", "sl"], "dest": ["source", "tmp", "dc", "txt", "disk", "lib", "home", " destination", "std", "di", "class", "dir", "target", "cont", "fn", "Dest", "temp", "orig", "path", "obj", "wb", "dist", " dst", "img", "bin", "dat", "null"], "in": ["source", "reader", "input", "inc", "din", "d", "win", "io", "doc", "inf", "val", "login", "f", "as", "data", "In", "pin", "stream", "n", "r", "inas", "isin", "ins", "t", "ini", "a", "ex", "up", "file", "i", "IN", "err", "inn", "is", "bin", "ps", "pass"], "p": ["lp", "cop", "bp", "py", "h", "P", "d", "pe", "jp", "pb", "pd", "l", "pre", "fp", "pg", "b", "part", "f", "po", "cp", "wp", "pc", "tp", "pa", "o", "s", "e", "per", "t", "parser", "pr", "m", "v", "pm", "sp", "c", "j", "i", "np", "pp", "g", "pi", "ps", "op"], "ds": ["hs", "d", "dd", "ils", "ld", "lines", "tools", "ns", "bs", "DS", "dp", "sys", "vs", "eps", "sync", "dt", "da", "cs", "ls", "ays", "dist", "ts", "ys", " DS", "pd", " ps", "os", "posts", "models", "cons", "ins", "dm", "els", "scripts", "sts", "dates", "nas", "ps", "dl", "dc", "Ds", "points", "ss", "gs", "styles", "ups", "dos", "qs", "js", " props", "rs", "df", "words", "docs", "utils", "vals", "ans", " sd", "s", "lp", "tests", "ks", " db", "des", "ded", "ws", "gd", "cdn", "ads", "data", "di", "xs", "plugins", "dds", "icks", " dd", "amps", "ants", "db", "parts", "obs", "dat", "uds"], "format": ["source", "language", "host", "url", "ant", "Format", "layout", "xml", "plugin", "function", "scale", "letter", "fp", "object", "fd", "model", "part", "f", "magic", "data", "table", "version", "class", "style", "match", "handler", "prefix", "config", "template", "tag", "filename", "name", "pattern", "feat", "unit", "spec", "fn", "parser", "t", "atter", "api", "act", "frame", "string", "path", "file", "record", "struct", "nat", "sche", "at", "form", "filter", "type"], "hasPixelData": ["haspixelStyle", "hasPicturedata", "hasByteSize", "hasPicOps", " hasPixelStyle", "hasPixelStyle", "hasBytedata", "hasPictureDATA", "hasPicStyle", "hasPicData", "haspixelOps", "hasByteData", " hasPixelSize", "hasPictureData", " hasPixeldata", " hasPixelDATA", "haspixeldata", "haspixelDATA", "haspixelData", " hasPixelOps", "hasPixelSize", "hasPixelOps", "hasPixeldata", "hasPixelDATA", "haspixelSize"], "inflate": ["inflocate", " informate", " inflase", "infolate", "uninfloute", "inFlate", "infloase", "incollute", "incollocate", "infloation", "infloame", "incollame", "inFlation", "uninflate", " informase", "inFlATE", "inflATE", " inflation", "uninfloame", " informATE", "informase", "inflase", "infolocate", "incollate", "inflame", "uninfloocate", "information", "infolute", " inflATE", "inflation", " information", "infloATE", "uninflocate", "informate", "infloate", "infolame", "uninflute", "infloute", "uninfloate", "uninflame", "influte", "informATE", "infloocate", "inFlase"], "pxlen": ["pxlength", "xpval", "pxval", "cpl", "pnglen", "fxlength", "pyln", "xylen", "xplen", "cplen", "pglen", "ppln", "pglength", "pylen", "npfin", "pxden", "pgval", "nplin", "rxlen", "cpden", "pxlin", "pglf", "xplf", "pxfin", "cpln", "rxfin", "npden", "rxden", "pxln", "xplength", "pxl", "xyden", "pyden", "pngLen", "fxval", "ppLen", "ppden", "pplen", "pxlf", "xylin", "pyl", "nplen", "pngln", "rxlin", "fxl", "pngden", "fxlf", "fxden", "pxLen", "xyfin", "fxlen", "xyln", "fxln", "xyLen"], "out": ["page", "parent", "user", "io", "output", "conn", "lib", "dump", "gen", "base", "again", "OUT", "Out", "outs", "work", "server", "print", "re", "prefix", "sys", "inter", "step", "log", "cli", "post", "v", "up", "session", "point", "list", "obj", "lock", "cache", "error", "code", "err", "group", "store", "copy", "line"]}}
{"id1": "623042", "id2": "5410594", "code1": "    public RepositoryHandler(String[] args) {\n        if (args.length < 2) return;\n        System.out.println(\"param 1: \" + args[0] + \"\\r\\n\");\n        System.out.println(\"param 2: \" + args[1] + \"\\r\\n\");\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setFollowRedirects(true);\n            connection.connect();\n            BufferedInputStream in = new BufferedInputStream(connection.getInputStream());\n            FileOutputStream out = new FileOutputStream(args[1]);\n            int c = -1;\n            while ((c = in.read()) >= 0) {\n                out.write(c);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e + \"\\r\\n\");\n        }\n    }\n", "code2": "    @Override\n    public void insert(Connection conn) throws SQLException {\n        PreparedStatement objectInsert = null;\n        String sqlString = null;\n        int newID = 0;\n        try {\n            conn.setAutoCommit(false);\n            sqlString = \"SELECT NEXTVAL(OBJ_SEQ) AS NEXTVAL\";\n            objectInsert = conn.prepareStatement(sqlString);\n            ResultSet r = objectInsert.executeQuery(sqlString);\n            newID = r.getInt(\"NEXTVAL\");\n            sqlString = \"INSERT INTO OBJECTS\" + \"(\" + \"OBJ_ID,\" + \"OBJ_NAME,\" + \"OBTY_CDE\" + \")\" + \"VALUES\" + \"(\" + \"?,\" + \"?,\" + \"?\" + \")\" + \"\";\n            objectInsert = conn.prepareStatement(sqlString);\n            objectInsert.setInt(1, newID);\n            objectInsert.setString(2, getRoomKey());\n            objectInsert.setString(3, \"ROOM\");\n            objectInsert.executeUpdate();\n            sqlString = \"INSERT INTO ROOMS\" + \"(\" + \"\";\n            conn.commit();\n        } catch (SQLException e) {\n            e.printStackTrace();\n            if (conn != null) {\n                try {\n                    System.err.print(\"Transaction is being rolled back\");\n                    conn.rollback();\n                } catch (SQLException excep) {\n                    excep.printStackTrace();\n                }\n            }\n        } finally {\n            if (objectInsert != null) {\n                objectInsert.close();\n            }\n            conn.setAutoCommit(true);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "page", "user", "link", "open", "conn", "l", "http", "client", "b", "channel", "base", "https", "f", "loc", "version", "resource", "org", "server", "use", "api", "ls", "li", "string", "path", "image", "connect", "socket", "file", "uri", "ssl", "URL", "service", "Url", "web", "sl"], "connection": ["link", "wrapper", "open", "cf", "function", "io", "conn", "l", "communication", "http", "con", "client", "union", "bc", "control", "connected", "channel", "loc", "version", "n", "response", "resource", "handler", "ctx", "server", "config", "condition", "inner", "section", "ci", "password", "relation", "cli", "connect", "j", "uri", "socket", "context", "ssl", "or", "service", "character", "database", "position", "cond", "Connection", "proxy", "web", "use"], "in": ["source", "reader", "id", "input", "inc", "din", "pull", "io", "nin", "conn", "con", "b", "login", "f", "as", "In", "into", "stream", "again", "r", "version", "isin", "inner", "init", "ins", "gin", "ini", "a", "up", "image", "socket", "file", "i", "IN", "inside", "inn", "is", "lin", "bin", "s"], "out": ["source", "page", "str", "reader", "default", "msg", "write", "ln", "inc", "net", "extra", "co", "io", "output", "doc", "conn", "outer", "w", "dump", "cmd", "diff", "b", "base", "to", "data", "again", "OUT", "Out", "print", "outs", "n", "call", "writer", "inner", "exec", "sync", "init", "o", "s", "log", "password", "m", "ex", "copy", "temp", "up", "list", "obj", "file", "error", "i", "err", "socket", "is", "at", "bin", "op", "line", "wr"], "c": ["dc", " i", "id", "d", "uc", "cm", "cu", "cy", "chain", " n", "k", "limit", "fc", "l", "char", "bc", "f", "p", "ec", "n", "r", "xc", "enc", "sc", "pc", "exec", "ci", "rc", "e", "o", "u", "esc", "arc", "cl", "t", "ch", "lc", "abc", "col", "cr", "pointer", " rc", "code", "i", " C", "character", "ce", "cc", " count", "ct", "nc", "ac", "C"]}}
{"id1": "323592", "id2": "20068372", "code1": "    public void elimina(Pedido pe) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorPedido.elimina()\");\n        int id = pe.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM pedido WHERE id=\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorPedido.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorPedido.elimina(): \" + e);\n        }\n    }\n", "code2": "    @Override\n    public DataUpdateResult<Record> updateRecord(String authToken, Record record, Filter filter, Field sourceField, InputModel inputmodel) throws DataOperationException {\n        validateUserIsSignedOn(authToken);\n        DataUpdateResult<Record> recordUpdateResult = new DataUpdateResult<Record>();\n        HttpSession session = getSession();\n        if (record != null) {\n            Connection connection = null;\n            boolean updated = false;\n            try {\n                connection = DatabaseConnector.getConnection();\n                connection.setAutoCommit(false);\n                recordUpdateResult.setMessage(messages.server_record_update_success(\"\"));\n                recordUpdateResult.setSuccessful(true);\n                long userId = getSignedOnUser(authToken).getUserId();\n                AuditTrailManager.updateAuditTrail(connection, AuditTrailManager.createAuditTrailEvent(record, userId, AuditableEvent.EVENTYPE_UPDATE), authToken, session);\n                if (record.isTopicsChanged()) {\n                    ArrayList<Topic> currentTopics = TopicRetrievalServiceImpl.getTopics(record.getRecordid(), getSession(), authToken);\n                    TopicUpdateServiceImpl.removeRecordTopics(connection, currentTopics, record.getRecordid());\n                    TopicUpdateServiceImpl.insertRecordTopics(connection, record.getTopics(), record.getRecordid());\n                }\n                ArrayList<RecordAttribute> recordAttributes = record.getRecordattributes();\n                if (recordAttributes != null && recordAttributes.size() > 0) {\n                    Iterator<RecordAttribute> rItr = recordAttributes.iterator();\n                    while (rItr.hasNext()) {\n                        RecordAttribute r = rItr.next();\n                        if (r.getRecordattributeid() > 0) {\n                            if (r.getArchivedtimestamp() == null) {\n                                String rAtSql = \"update tms.recordattributes set chardata = ? \" + \"where recordattributeid = ?\";\n                                PreparedStatement updateRecordAttribute = connection.prepareStatement(rAtSql);\n                                updateRecordAttribute.setString(1, r.getChardata());\n                                updateRecordAttribute.setLong(2, r.getRecordattributeid());\n                                updateRecordAttribute.executeUpdate();\n                                AuditTrailManager.updateAuditTrail(connection, AuditTrailManager.createAuditTrailEvent(r, userId, AuditableEvent.EVENTYPE_UPDATE), authToken, session);\n                            } else {\n                                String rAtSql = \"update tms.recordattributes set archivedtimestamp = now() where  recordattributeid = ?\";\n                                PreparedStatement updateRecordAttribute = connection.prepareStatement(rAtSql);\n                                updateRecordAttribute.setLong(1, r.getRecordattributeid());\n                                updateRecordAttribute.executeUpdate();\n                                AuditTrailManager.updateAuditTrail(connection, AuditTrailManager.createAuditTrailEvent(r, userId, AuditableEvent.EVENTYPE_DELETE), authToken, session);\n                            }\n                        } else {\n                            String rAtSql = \"insert into tms.recordattributes \" + \"(inputmodelfieldid, chardata, recordid) \" + \"values (?, ?, ?) returning recordattributeid\";\n                            PreparedStatement insertRecordAttribute = connection.prepareStatement(rAtSql);\n                            insertRecordAttribute.setLong(1, r.getInputmodelfieldid());\n                            insertRecordAttribute.setString(2, r.getChardata());\n                            insertRecordAttribute.setLong(3, record.getRecordid());\n                            ResultSet result = insertRecordAttribute.executeQuery();\n                            if (result.next()) {\n                                long recordattributeid = result.getLong(\"recordattributeid\");\n                                r.setRecordattributeid(recordattributeid);\n                                AuditTrailManager.updateAuditTrail(connection, AuditTrailManager.createAuditTrailEvent(r, userId, AuditableEvent.EVENTYPE_CREATE), authToken, session);\n                            }\n                        }\n                    }\n                }\n                ArrayList<Term> terms = record.getTerms();\n                Iterator<Term> termsItr = terms.iterator();\n                while (termsItr.hasNext()) {\n                    Term term = termsItr.next();\n                    if (term.getTermid() != -1) TermUpdater.updateTerm(connection, term, userId, authToken, getSession()); else {\n                        TermAdditionServiceImpl termAdder = new TermAdditionServiceImpl();\n                        termAdder.addTerm(connection, term, userId, authToken, session);\n                    }\n                }\n                connection.commit();\n                updated = true;\n                if (filter != null) RecordIdTracker.refreshRecordIdsInSessionByFilter(session, connection, true, filter, sourceField, authToken); else RecordIdTracker.refreshRecordIdsInSession(session, connection, false, authToken);\n                RecordRetrievalServiceImpl retriever = new RecordRetrievalServiceImpl();\n                Record updatedRecord = retriever.retrieveRecordByRecordId(initSignedOnUser(authToken), record.getRecordid(), session, false, inputmodel, authToken);\n                recordUpdateResult.setResult(updatedRecord);\n            } catch (Exception e) {\n                if (!updated && connection != null) {\n                    try {\n                        connection.rollback();\n                    } catch (SQLException e1) {\n                        LogUtility.log(Level.SEVERE, session, messages.log_db_rollback(\"\"), e1, authToken);\n                        e1.printStackTrace();\n                    }\n                }\n                recordUpdateResult.setFailed(true);\n                if (updated) {\n                    recordUpdateResult.setMessage(messages.server_record_update_retrieve(\"\"));\n                    recordUpdateResult.setException(e);\n                    LogUtility.log(Level.SEVERE, session, messages.server_record_update_retrieve(\"\"), e, authToken);\n                } else {\n                    recordUpdateResult.setMessage(messages.server_record_update_fail(\"\"));\n                    recordUpdateResult.setException(new PersistenceException(e));\n                    LogUtility.log(Level.SEVERE, session, messages.server_record_update_fail(\"\"), e, authToken);\n                }\n                GWT.log(recordUpdateResult.getMessage(), e);\n            } finally {\n                try {\n                    if (connection != null) {\n                        connection.setAutoCommit(true);\n                        connection.close();\n                    }\n                } catch (Exception e) {\n                    LogUtility.log(Level.SEVERE, session, messages.log_db_close(\"\"), e, authToken);\n                }\n            }\n        }\n        return recordUpdateResult;\n    }\n", "label": 1, "substitutes": {"pe": ["PE", "ppe", "py", "ipe", "Pe", "pee", "pes", "pet", "ee", "pd", "xe", "pie", "po", "fe", "pex", "ffe", "ppa", "ge", "pa", "ne", "e", "ace", "de", "oe", "ple", "se", "le", "pse", "ape", "ke", "plate", "file", "pp", "spe", "ope", "pei", "ce", "ps", "me", "p"], "id": ["head", "url", "num", "en", "d", "oid", "mid", "in", "part", "aid", "f", "Id", "style", "zip", "ident", "info", "ql", "name", "pid", "patch", "key", "index", "string", "path", "db", "code", "rid", "i", "like", "vid", "q", "ids", "ip", "kid", "ID", "sid", "entry", "uid", "p", "type"], "sql": ["dl", "select", "su", "sb", "url", "nl", "msg", "util", "xml", "result", "ss", "statement", "join", "http", "params", "pg", "cmd", "sf", "delete", "data", "summary", "zip", "repl", "ql", "sys", "update", "generic", "shell", "eps", "section", "plan", "query", "s", "printf", "json", "log", "bool", "text", "comment", "sv", "SQL", "ls", "cli", "status", "mail", "string", "seed", "ssl", "db", "error", "err", "lua", "sol", "sq", " SQL", "reason", "str", "null", "sl", "type"], "stmt": ["estmt", "tmp", " stmr", "strpt", "strmd", "tmt", "ctmr", "ctm", "strnt", "ostmt", "Stmb", " stmd", "ctmd", " stm", "stnt", "Stt", "stmp", " stbl", "STpt", "stmd", "stm", "ostmr", "stpt", "stmr", "estt", "stmb", "STmd", "ctmt", " stnt", "stbl", "strmt", " stmp", "tbl", " stpt", "ostmd", " stt", "STnt", "Stm", "STmp", "stt", "estmb", "tmd", "STbl", " stmb", "Stmt", "ostm", "STmt", "estm"]}}
{"id1": "18570187", "id2": "3177725", "code1": "    public ClassifiedCandidate postToClassifiedCandidate(ClassifiedCandidate cand, RawCandidateMatched basic) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpPost req = new HttpPost(remoteHost.getUrl() + \"/cand/\" + Long.toHexString(cand.getId()));\n                req.setHeader(\"Accept-Encoding\", \"gzip\");\n                ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n                XMLWriter.write(out, basic);\n                ByteArrayInputStream in2 = new ByteArrayInputStream(out.toByteArray());\n                req.setEntity(new InputStreamEntity(in2, -1));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        InputStream in = resp.getEntity().getContent();\n                        Header hdr = resp.getFirstHeader(\"Content-Encoding\");\n                        String enc = \"\";\n                        if (hdr != null) {\n                            enc = resp.getFirstHeader(\"Content-Encoding\").getValue();\n                        }\n                        if (enc.equals(\"gzip\")) {\n                            in = new GZIPInputStream(in);\n                        }\n                        XMLAble xmlable = XMLReader.read(in);\n                        in.close();\n                        if (xmlable instanceof ClassifiedCandidate) {\n                            ClassifiedCandidate p = (ClassifiedCandidate) xmlable;\n                            return p;\n                        } else {\n                            resp.getEntity().consumeContent();\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for ClassifiedCandidate\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "code2": "    public DBAccess(String pathToDb) {\n        if (instance != null) {\n            throw new IllegalStateException();\n        }\n        System.setProperty(\"derby.system.home\", pathToDb);\n        try {\n            boolean exists = new File(pathToDb).exists();\n            new EmbeddedDriver();\n            Properties props = new Properties();\n            if (exists) {\n                connection = DriverManager.getConnection(protocol + \"rmpDB;\", props);\n                connection.setAutoCommit(true);\n                Statement statement = connection.createStatement();\n                try {\n                } finally {\n                    statement.close();\n                }\n            } else {\n                connection = DriverManager.getConnection(protocol + \"rmpDB;create=true\", props);\n                connection.setAutoCommit(true);\n                URL url = Platform.getBundle(\"ru.spbu.dorms.geo.rmp\").getResource(\"sql/createdb.sql\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                StringBuilder query = new StringBuilder();\n                for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                    if (query.length() > 0) {\n                        query.append('\\n');\n                    }\n                    query.append(s);\n                }\n                reader.close();\n                Statement statement = connection.createStatement();\n                try {\n                    String[] statements = query.toString().split(\";(\\\\s)*\");\n                    for (String s : statements) {\n                        statement.execute(s);\n                    }\n                } finally {\n                    statement.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        instance = this;\n    }\n", "label": 0, "substitutes": {"cand": ["div", "my", "proc", "msg", "cm", "ind", "cf", "co", "dev", "cat", "doc", "conn", "app", "char", "val", "client", "cmd", "bug", "part", "base", "data", "cp", "prom", "match", "fac", "sam", "mc", "conf", "tri", "coll", "Cand", "ch", "temp", "col", "c", "err", "coord", "or", "service", "local", "valid", "cast", "ce", "cher", "cmp", "cor"], "basic": ["reader", "cb", " ra", "proc", "ra", " sub", " compat", "cf", "mat", "doc", "fc", " recip", "b", "cmd", "client", "idd", "common", "base", "channel", "f", "data", " pub", "re", "ctx", "match", "sc", "raw", "config", "comp", " fr", "comm", "mc", " matches", "sub", "conf", "bid", "ci", "pattern", "param", "Basic", "partial", "abc", " dup", " soap", " conf", "cast", "dist", " client"], "req": ["hop", "respond", "cb", "gr", "proc", "rx", "require", "rel", "task", "xml", "download", "pull", "rep", "build", "jp", "cgi", "wx", "http", "request", "client", "fp", "fr", "f", "worker", "ref", "r", "response", "ctx", "qq", "org", "call", "work", "Request", "exec", "sub", "tar", "access", "cur", "query", "grab", "requ", "exp", "pr", "post", "temp", "issue", "rec", "rw", "err", "fb", "Resp", "required", "q", "rr", "res", "rb", "cmp"], "out": ["plain", "default", "write", "net", "buffer", "result", "io", "output", "conn", "lib", "wx", "w", "client", "base", "data", "OUT", "Out", "again", "outs", "sum", "prefix", "writer", "exec", "sync", "o", "aos", "exp", "flush", "ex", "buf", "job", "up", "pool", "obj", "cache", "lock", "err", "array", "at", "img", "bin", "null"], "in2": [" inls", "In1", "inTwo", " in256", "inner2", "in256", " in4", "out2", "out1", "inls", "in1", "in4", " in52", "inner52", "In2", "ins2", "ins256", "outTwo", "ins52", " inTwo", "out4", "innerls", "in52", " in1", "insls", "InTwo", "inner256", "In4"], "resp": ["rem", "respond", "proc", "msg", "rel", "rup", "rep", "reply", "cmp", "result", "rss", "conn", "http", "ev", "client", "request", "fr", "f", "exc", "onse", "ref", "re", "response", "r", "comp", "repl", "serv", "par", "server", "comm", "exec", "bb", "exp", "report", "coll", "api", "rh", "temp", "esp", "rec", "Response", "session", "status", "sp", "html", "rev", "prev", "error", "err", "obj", "Resp", "rr", "soc", "received", "inv", "res", "imp"], "in": ["source", "get", "read", "reader", "input", "inc", "din", "win", "xml", "buffer", "min", "cgi", "nin", "io", "fc", "con", "b", "login", "f", "loader", "data", "In", "stream", "n", "r", "again", "inas", "serv", "isin", "inner", "pc", "body", "ins", "ax", "exp", "gin", "ini", "ex", "rec", "gz", "impl", "socket", "c", "ssl", "i", "IN", "inn", "rin", "is", "bin", "ac"], "hdr": ["ihdt", "bhdr", "hpr", "handbr", "adhheader", "handpr", "handstr", "hheader", "ohdr", "ohstr", "handdr", "Hstr", "adhdt", "Hbr", "ihheader", "ohpr", "bhhr", "adhdr", "bhheader", "Hdr", "Hpr", "bhdt", "hdt", "ihhr", "ihdr", "adhhr", "ohbr", "hhr", "hbr", "hstr"], "enc": ["sel", "dec", "dc", "en", "inc", "ang", "ent", "lang", "alg", "oding", "unic", "vc", "conn", "fr", "loc", "ver", "ec", "oder", "mac", "iv", "desc", "rc", "ENC", "feat", "exp", "cel", "Enc", "sl", "ext", "rh", "content", "lc", "adr", "dr", "auc", "sec", "abc", "emb", "c", "code", "vec", "oct", "conv", "eng", "ct", "env", "nc", "coll", "ac", "hl", "type"], "xmlable": ["parseble", " xmlble", " xmlability", "parseatable", " xmlables", "webstable", "webables", "peble", " jsonorable", "xeorable", "semability", "peable", "parseorable", "peorable", "parseable", "xeatable", " jsonable", "xmlble", "semables", "xmlatable", "semable", "xmlables", "webability", " jsonble", "xmlorable", " xmlorable", "webable", "semstable", "peables", " xmlatable", " xmlstable", " jsonables", "xmlstable", "xmlability", "xeable", "xeble"], "p": ["lp", "page", "parent", "py", "h", "P", "pe", "br", "jp", "pb", "l", "pre", "app", "fp", "object", "part", "model", "f", "cp", "n", "pc", "e", "per", "api", "parser", "t", "pr", "m", "v", "sp", "j", "c", "i", "np", "pp", "g", "q", "pi", "current", "item", "z", "ps"]}}
{"id1": "8731413", "id2": "12728035", "code1": "    public ImportFromFile() {\n        JFrame jf = new JFrame();\n        JFileChooser fc = new JFileChooser(KTH.data._path);\n        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        int returnVal = fc.showOpenDialog(jf);\n        File file = null;\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            file = fc.getSelectedFile();\n            KTH.data._path = file.getParent();\n            System.out.println(file.getAbsolutePath() + \"\\n\");\n        } else {\n        }\n        if (file != null) {\n            File f = new File(KTH.data.getHomeDir() + File.separator + KTH.data.katalogName);\n            System.out.println(f + (f.exists() ? \" is found \" : \" is missing \"));\n            if (f.exists() && !IOUtils.isNewerContent(file, f)) {\n            } else {\n                try {\n                    IOUtils.copyFile(file, f, true);\n                } catch (Exception e) {\n                    KTH.out.err(e);\n                }\n            }\n            KTH.dc2.removeDc(\"Import\");\n        } else {\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"jf": ["bf", "jfd", " jfs", "jjfd", "ojfd", "bc", "jrf", "jfile", "jjcf", "ojf", "bfile", "gf", "Jf", "ojfs", "gc", "gfile", "jcf", "jjf", "jfs", "ojcf", "Jrf", "jc", "grf", "Jfile", " jfd", " jcf", "jjfs", "Jc", "brf"], "fc": ["xf", "af", "dc", "rf", "bf", "uc", "lf", "cf", "vc", "fs", "con", " FC", "fp", "sf", "fd", "bc", "fr", "cv", "wic", "fe", "ec", "ctrl", "fw", "circ", "xc", "enc", "mc", "pc", "FC", "GF", "cl", "fn", "fl", "lc", "jc", "abc", "il", "CF", "c", "flo", "fb", "fm", "cc", "fi", "ct", "nc", "fa", "fx"], "returnVal": ["resultval", " returnValue", " returnval", "ReturnNum", "returnValue", "returnval", "returnNum", " returnNum", "ReturnVal", "ReturnValue", "resultValue", " returnTx", "openTx", "resultNum", "Returnval", "openVal", "openval", "ReturnTx", "openValue", "resultVal", "returnTx"], "file": ["cf", "l", "sf", "model", "directory", "resource", "info", "name", "log", "cl", " files", "le", "image", "files", "fa", "line", "folder", "bf", "place", "feed", "lf", "lib", "object", "b", "po", "future", "handler", "child", "it", "F", "found", "il", "pool", "cache", "c", "live", "local", "FILE", "self", "fi", "source", "page", "parent", "url", "pe", "function", "fo", "http", "fp", "base", "work", "el", "x", "filename", "full", "e", "o", "path", "null", "p", "h", "ile", "File", "letter", "fr", "fe", "where", "dir", "document", " File", "db", "form", "unit"], "KTH": ["NKTH", " KATH", "KITT", "JETH", " KAST", "KOTH", "JTH", "HKCOM", " KTh", " KCOM", " Kth", "KSTh", "SKCH", "KINGth", " KETH", "kATH", "KINGTH", "KTh", "kAST", "KSth", "KINGITT", "SKATH", " KITT", "HKITT", "KETH", "SKETH", " KOTH", " KTD", "KSOTH", "ELCOM", "HKTH", "AKth", "NKTD", "OKTh", "KCOM", "kTH", "SKAST", " KTHER", "SKTH", "SKTHER", "ELTH", "KATH", "AKETH", "NKth", "KTD", "AKTH", "KTHER", "Kth", "HKth", "OKTH", "OKth", "KAST", "NKETH", "Jth", "AKTD", "HKTh", "ELTh", "ELth", "kTHER", "KINGTh", "KCH", "KSTH", " KCH", "OKOTH", "JCH", "SKth"], "data": ["language", "resources", "div", "parent", "next", "reader", "site", "general", "default", "input", "memory", "user", "layout", "admin", "output", "join", "this", "state", "root", "model", "base", "loader", "di", "storage", "system", "style", "resource", "server", "config", "info", "writer", "module", "body", "DATA", "management", "da", "results", "json", "api", "internal", "media", "cache", "apps", "service", "database", "group", "design", "dat"], "_path": ["_dir", " _dir", " _cat", " _location", "_Path", "_location", " _Path", " _name", "_cat", "_name"], "f": ["af", "folder", "h", "rf", "url", "d", "feed", "cf", "function", "File", "fo", "l", "fs", "w", "foo", "fp", "b", "sf", "fd", "fr", "base", "fe", "n", "x", "fun", "name", "filename", "dir", "u", "e", "o", "flow", "fn", "t", "F", "found", "m", "df", "fold", "v", "fl", "path", "j", "c", "i", "fb", "g", "fen", "s", "fa", "p", "fx"]}}
{"id1": "2640244", "id2": "22961265", "code1": "    public DocumentDialog(Frame frame, String title, String document) {\n        setTitle(title);\n        textArea = new JTextArea();\n        textPane = new StdScrollPane(textArea, StdScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, StdScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n        textArea.setEditable(false);\n        getContentPane().add(textPane);\n        URL url = DocumentDialog.class.getClassLoader().getResource(document);\n        try {\n            StringBuilder sb = new StringBuilder();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            String buildNumber = MessageBundle.getBuildNumber();\n            String releaseNumber = MessageBundle.getReleaseNumber();\n            String tmp;\n            while ((tmp = in.readLine()) != null) {\n                tmp = tmp.replace(\"${build_number}\", buildNumber);\n                tmp = tmp.replace(\"${release_number}\", releaseNumber);\n                sb.append(tmp + \"\\n\");\n            }\n            textArea.setText(sb.toString());\n            textArea.setCaretPosition(0);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String readFromURL(String sURL) {\n        logger.info(\"com.rooster.utils.URLReader.readFromURL - Entry\");\n        String sWebPage = \"\";\n        try {\n            URL url = new URL(sURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                sWebPage += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            logger.debug(\"com.rooster.utils.URLReader.readFromURL - Error\" + e);\n        }\n        logger.info(\"com.rooster.utils.URLReader.readFromURL - Exit\");\n        return sWebPage;\n    }\n", "label": 1, "substitutes": {"frame": ["movie", "frames", " Frame", "panel", "message", "thread", "object", "state", "f", "loader", "base", "config", "component", "framework", "flow", "screen", "Frame", "window", "media", "image", "file", "code", "fb", "scene", "process", "video", "figure"], "title": ["page", "display", "term", "theme", "message", "doc", "format", "license", "article", "description", "part", "application", "summary", "prefix", "heading", "filename", "name", " Title", "text", "content", "media", "company", "html", "setup", "details", "label", "itle", "header", "Title", "subject", "metadata", "project", "notes", "chapter", "type"], "document": ["language", "source", "page", "host", "parent", "program", "office", "Document", "download", "message", "doc", "output", "object", "description", "application", "directory", "resource", "address", "filename", "name", "body", "target", "content", " documentation", "docs", "string", "media", "image", "uri", "context", "ocument", "database", "video", "subject", "position", "location"], "textArea": ["fontArea", "formCenter", "extBar", "TextBook", "textarea", "textPa", "Textarea", "textCenter", "textBook", " textBook", " textarea", "extArea", "eventarea", "contentarea", "formarea", "contentCenter", "fontarea", " textPa", "textBox", "eventBar", "formBar", " textBox", "TextBox", "fontBook", "eventArea", "fontPa", "contentBar", "extarea", "formArea", "textPanel", "extBox", "eventPanel", " textBar", "TextPa", "contentArea", "textBar", "TextBar", "formPanel", "TextCenter", "TextArea", " textPanel"], "textPane": ["scrollpace", "textPoANE", "scrollPane", "textpair", "textPoane", "scrollpane", "scrollPace", "textpanes", "textPoanes", "scrollPanes", "textPale", "textChale", "textpace", "textPanes", "textChanes", "scrollPale", "contentpane", "contentpanes", "contentPANE", "contentpair", "textGane", "textGanes", "textPace", "textpane", "textGale", "contentPanes", "scrollpanes", "textPoair", "contentPane", "contentPair", "textChane", "textpANE", "textpale", "contentpANE", "textChace", "scrollpale", "textPair", "textPANE", "textGace"], "url": ["source", "page", "ball", "user", "connection", "buffer", "io", "src", "l", "http", "client", "base", "loader", "data", "r", "resource", "org", "server", "address", "ur", "gl", "api", "bel", "ls", "job", "up", "string", "path", "image", "rule", "rl", "impl", "socket", "file", "uri", "ssl", "err", "URL", "hub", "Url", "web", "coll", "sl"], "sb": ["bp", "cb", "sa", "bf", "si", "txt", "bh", "mb", "buffer", "usb", "sg", "pb", "BB", "src", "fp", "b", "sf", "bc", "storage", "abb", "bs", "erb", "ub", "sup", "bj", "SB", " SB", "bb", "zb", "buf", "ls", "gb", "xb", "eb", "sp", "bsp", "bt", "db", "wb", "fb", "sq", "lab", "nb", "lb", "rb", "ib", "bl"], "in": ["source", "reader", "input", "inc", "din", "buffer", "io", "nin", "con", "out", "b", "login", "f", "fe", "In", "pin", "stream", "again", "r", "resource", "isin", "inner", "ins", "e", "gin", "ini", "m", "image", "c", "file", "ssl", "i", "IN", "socket", "inn", "is", "ilo", "lin", "bin", "s", "line"], "buildNumber": ["lockNo", "BuildNumber", "locknumber", "lockNum", "lockNumber", "BuildUnit", "Buildnumber", "buildString", "BuildNo", "buildnumber", " buildUnit", " buildString", " buildNum", "releaseString", "BuildNum", "releaseUnit", "buildUnit", "releaseNum", "buildNum", " buildnumber", "buildNo", " buildNo", "BuildString"], "releaseNumber": ["releaseVersion", "installnumber", "leasenumber", "installCode", " releaseCode", "installVersion", "installString", "installNum", " releasenumber", "ReleaseString", "installUnit", " releaseUnit", "releaseString", "installNumber", "releaseUnit", "leaseNum", "releasenumber", " releaseString", "ReleaseNumber", " releaseNum", "ReleaseCode", " releaseVersion", "leaseVersion", "releaseNum", "releaseCode", "ReleaseUnit", "leaseNumber"], "tmp": ["attr", "appy", "str", "py", "su", "cb", "bf", "txt", "append", "proc", "term", "tab", "result", "pb", "mm", "src", "kk", "stuff", "wx", "pre", "mmm", "fp", "app", "diff", "st", "const", "part", "tf", "cpp", "data", "mo", "cp", "storage", "zip", "pad", "dest", "sup", "ppa", "body", "mp", "bb", "amp", "tc", "api", "tt", "nm", "buf", "temp", "job", "own", "string", "sp", "obj", "cache", "bt", "vm", "wb", "np", "fb", "vt", "nb", "md", "img", "test", "copy", "rb", "cmp", "pkg"]}}
{"id1": "11028858", "id2": "15193222", "code1": "    @Override\n    public void runTask(HashMap pjobParameters) throws Exception {\n        if (hasRequiredResources(isSubTask())) {\n            File lfileSource = new File(getSource());\n            File lfileTarget = new File(getTarget());\n            FileChannel lfisInput = null;\n            FileChannel lfosOutput = null;\n            try {\n                int mbCount = 64;\n                boolean lblnDone = false;\n                while (!lblnDone) {\n                    lfisInput = new FileInputStream(lfileSource).getChannel();\n                    lfosOutput = new FileOutputStream(lfileTarget).getChannel();\n                    try {\n                        int maxCount = (mbCount * 1024 * 1024) - (32 * 1024);\n                        long size = lfisInput.size();\n                        long position = 0;\n                        while (position < size) {\n                            position += lfisInput.transferTo(position, maxCount, lfosOutput);\n                        }\n                        lblnDone = true;\n                    } catch (IOException lioXcp) {\n                        getLog().warn(lioXcp);\n                        if (lioXcp.getMessage().contains(\"Insufficient system resources exist to complete the requested servic\")) {\n                            mbCount--;\n                            getLog().debug(\"Dropped resource count down to [\" + mbCount + \"]\");\n                            if (mbCount == 0) {\n                                lblnDone = true;\n                            }\n                            if (lfisInput != null) {\n                                lfisInput.close();\n                            }\n                            if (lfosOutput != null) {\n                                lfosOutput.close();\n                            }\n                        } else {\n                            throw lioXcp;\n                        }\n                    }\n                }\n            } finally {\n                if (lfisInput != null) {\n                    lfisInput.close();\n                }\n                if (lfosOutput != null) {\n                    lfosOutput.close();\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public void copy(final String fileName) throws FileIOException {\n        try {\n            if (opened) {\n                fileChannel.position(0);\n            } else {\n                fileChannel = new FileInputStream(file).getChannel();\n            }\n            FileChannel dstChannel = null;\n            try {\n                dstChannel = new FileOutputStream(fileName).getChannel();\n                dstChannel.transferFrom(fileChannel, 0, fileChannel.size());\n            } finally {\n                try {\n                    if (dstChannel != null) {\n                        dstChannel.close();\n                    }\n                } catch (Exception exception) {\n                }\n            }\n            if (opened) {\n                fileChannel.position(currentPositionInFile);\n            } else {\n                fileChannel.close();\n            }\n        } catch (IOException exception) {\n            throw HELPER_FILE_UTIL.fileIOException(\"failed copy \" + file + \" to \" + fileName, null, exception);\n        }\n    }\n", "label": 1, "substitutes": {"pjobParameters": ["pJobParameter", "PjobSettings", "PduArgs", "PJobSettings", "PduParameters", "pTaskParameter", "PTaskParameter", "PJobArgs", "PjobParameter", "pTaskParameters", "PduParameter", "PJobParameter", "PTaskSettings", "pTaskSettings", "pJobParameters", "pTaskArgs", "PduSettings", "pJobSettings", "PjobArgs", "PJobParameters", "PTaskParameters", "PjobParameters", "PTaskArgs", "pJobArgs"], "lfileSource": ["lfiliSource", "elfileTarget", "lfilSync", "lfilOrigin", "ElfilInput", "elfileSource", "lfilesOrigin", "ElfileInput", "lfilesInput", "lfilTarget", "elfileOrigin", "lffileTarget", "elfileInput", "lfilesSource", "ElfilSource", "lfilInput", "lfileInput", "lfilesTarget", "ElfileSource", "ElfileSync", "elfilesSource", "lfiliTarget", "lfilSource", "elfilesOrigin", "lffileInput", "lffileSync", "ElfileTarget", "elfilesTarget", "lfileOrigin", "ElfilTarget", "lfiliInput", "elfilesInput", "lfiliOrigin", "lfilesSync", "lffileSource", "lfileSync", "ElfilSync"], "lfileTarget": ["lfipeInput", "lfailInput", "ElfockInput", "lffileOutput", "lfipeFile", "elfileTarget", "lfilOutput", "lfockInput", "elfileSource", "elfileOutput", "ElfileInput", "lfilFile", "lfilTarget", "lfileFile", "lffileTarget", "ElfockOutput", "lfileInput", "lfipeTarget", "ElfileOutput", "lfockTarget", "elfipeFile", "ElfockTarget", "lfilSource", "lffileFile", "ElfileTarget", "lfailTarget", "lfileOutput", "elfileFile", "lffileSource", "elfipeTarget", "lfockOutput", "elfipeSource", "lfipeOutput", "elfipeOutput", "lfailOutput", "lfipeSource"], "lfisInput": ["lfusInput", "lfaisStart", "losInput", "lfrisSource", "lfisSource", "lfisStream", "flisAudio", "lfrisInput", "ldisUrl", "ldosConnection", "lfrisLibrary", "lfosSource", "elfisStream", "lforiInput", "flosInput", "ldosOutput", "lfosStream", "lfoisInput", "ldisUnit", "lisInput", "flosLibrary", "lfosUrl", "lfissUrl", "lfoisOutput", "lfisUnit", "lfsInput", "lfusUrl", "lfisoUnit", "lfusOutput", "elfrisStream", "ldisInput", "lfnisSource", "lfisOutput", "elfisOutput", "lisSource", "lfnisOutput", "flisLibrary", "flosOutput", "lfrisStream", "flisInput", "lfnisInput", "flosSource", "lfnisAudio", "lforiOutput", "elfrisSource", "lfosConnection", "lfnisLibrary", "lfaisInput", "ldosSource", "elfisSource", "lfisUrl", "lfissSource", "lfrisOutput", "elfrisInput", "lfsOutput", "ldosUnit", "lfaisUnit", "ldisSource", "lfisLibrary", "lforisStream", "flisSource", "lfosAudio", "lfosStart", "flisOutput", "lforisInput", "elfisInput", "lfusLibrary", "lflisInput", "ldosStart", "lfissOutput", "lfissInput", "lfisAudio", "lfisoStart", "lforiSource", "lfoisConnection", "lfisStart", "ldosUrl", "lforisSource", "lisOutput", "elfrisOutput", "ldisOutput", "lfosLibrary", "lfisoInput", "lfosUnit", "lfisConnection", "lforisOutput", "ldisStart", "lflisOutput", "lfisoOutput", "losOutput", "ldisConnection", "lfusSource", "lflisSource", "lfoisSource", "lfsSource", "lfaisSource", "lfosInput", "flosAudio", "lfaisOutput", "lfaisConnection", "ldosInput", "losSource", "lfusAudio"], "lfosOutput": ["lfisTarget", "lfusInput", "lfoOutput", "lfotesOutput", "ldotesInput", "lfoInput", "elfsInput", "flosInput", "ldosOutput", "lfoisInput", "elfisTarget", "elfasOutput", "lfotesTarget", "lfosoutput", "ldotesTarget", "lfossoutput", "lfrosoutput", "lfoisOutput", "ldosTarget", "lfisApplication", "lfsInput", "elfosApplication", "lfusOutput", "lfrosInput", "ldisInput", "lfasoutput", "lfopsInput", "lfisOutput", "elfisOutput", "lfasApplication", "flosOutput", "elfosInput", "flisInput", "elfosoutput", "lfopsTarget", "lfsTarget", "lfosesOutput", "lfoOU", "elfisOut", "lfusOut", "elfosTarget", "lfsoutput", "lfossTarget", "lfosesInput", "ldisTarget", "lfsOutput", "lfasOutput", "lfosApplication", "elfasInput", "lfossInput", "ldotesoutput", "elfsTarget", "ldotesOutput", "flisOutput", "elfasoutput", "elfisInput", "elfosOut", "elfsoutput", "lfrosTarget", "lfossOutput", "elfasApplication", "lfsApplication", "lfotesInput", "elfsOutput", "flosOU", "lfossOU", "lfosTarget", "ldisOutput", "lfisoutput", "flisOU", "lfotesoutput", "elfosOutput", "lfusTarget", "lfrosOutput", "lfisOut", "lfosOU", "ldosoutput", "ldisoutput", "lfopsOutput", "lfosInput", "lfosOut", "lfasInput", "ldosInput", "lfopsOut", "lfopsoutput", "lfisOU"], "mbCount": ["mpCount", "bbCount", "MBSize", "mbSize", "MBLen", "GBSize", "lbcount", "debSum", "bytecount", "GBcount", "mbLen", "byteSize", "MBcount", "debCount", "byteLen", "MBCount", "byteCount", "maxcount", "mdCount", "mbLength", "MBLength", "mdSize", "debLength", "GBCount", "bbcount", "mmCount", "GBLength", "mmSize", "mdCost", "lbCount", "mpcount", "mmLength", "lbLen", "lbSize", "mpLength", "mbcount", "MBCost", "debcount", "maxCost", "mpSum", "maxSize", "mbSum", "mmcount", "MBSum", "mbCost", "mdcount", "bbSize"], "lblnDone": ["lblnCompleted", "lblndDone", "lblnsSent", "lBlcDe", "lblpndone", "lblntDone", "lblpnDe", "lBlnDone", "lblcCompleted", "lbrnChanged", "lBlcdone", "lBlnDe", "lblndSent", "lBlcOk", "lblcOk", "lbrnsChanged", "lblncOk", "lblnOk", "lbrninCode", "lblanDes", "lbrninDone", "lblncDes", "lblandone", "lblnsDone", "lBlnCompleted", "lbrninChanged", "lBlcCompleted", "lbrnsDone", "lblncDone", "lblnChanged", "lblcChanged", "lBlcDone", "lblninDone", "lblndCode", "lbrninSent", "lbrnsSent", "lblninCode", "lblnsChanged", "lblndChanged", "lblcDes", "lblndone", "lblntCode", "lblninSent", "lBlndone", "lblntChanged", "lblpnCompleted", "lblcSent", "lBlnOk", "lblcDe", "lblanOk", "lblcdone", "lblnDes", "lbrnSent", "lbrnCode", "lblnDe", "lblnSent", "lblninChanged", "lblcDone", "lblpnDone", "lblncdone", "lBlcDes", "lbrnDone", "lBlnDes", "lblnCode", "lblanDone", "lblntSent"], "maxCount": ["MAXSize", "maxLimit", "axCount", " maxCode", "MaxCount", "MaxSize", "Maxcount", " maxSize", "maxcount", "MAXCount", "maxCode", "axcount", "axSize", "MaxCode", " maxcount", "MAXcount", " maxLimit", "MaxLimit", "maxSize", "axCode", "MAXLimit"], "size": ["source", "memory", "write", "connection", "len", "scale", "now", "weight", "limit", "sized", "Size", "loc", "number", "base", "data", "SIZE", "storage", "available", "address", "condition", "shape", "send", "name", "transfer", "volume", "large", "ize", "length", "capacity", "max", "timeout", "area", "offset", "done", "count", "file", "error", "width", "speed", "pos", "level", "start", "empty", "small", "entry", "location", "unit"], "position": ["parent", "operation", "url", "pixel", "connection", "range", "limit", "maximum", "object", "portion", "move", "part", "loc", "layer", "number", "base", "version", "resolution", "address", "condition", "sequence", "Position", "action", "volume", "slot", "other", "unit", "length", "capacity", "area", "offset", "release", "index", "point", "image", "pointer", "motion", "i", "pos", "character", "item", "block", "mount", "osition", "order", "start", "location", "entry"]}}
{"id1": "18340402", "id2": "153462", "code1": "    public String tranportRemoteUnitToLocalTempFile(String urlStr) throws UnitTransportException {\n        URL url = null;\n        File tempUnit = null;\n        BufferedOutputStream bos = null;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e1) {\n            logger.error(String.format(\"The url [%s] is illegal.\", urlStr), e1);\n            throw new UnitTransportException(String.format(\"The url [%s] is illegal.\", urlStr), e1);\n        }\n        URLConnection con = null;\n        BufferedInputStream in = null;\n        try {\n            con = url.openConnection();\n            in = new BufferedInputStream(con.getInputStream());\n        } catch (IOException e) {\n            logger.error(String.format(\"Can't open url [%s].\", urlStr));\n            throw new UnitTransportException(String.format(\"Can't open url [%s].\", urlStr), e);\n        } catch (Exception e) {\n            logger.error(String.format(\"Unknown error. Maybe miss the username and password in url [%s].\", urlStr), e);\n            throw new UnitTransportException(String.format(\"Unknown error. Maybe miss the username and password in url [%s].\", urlStr), e);\n        }\n        String unitName = urlStr.substring(urlStr.lastIndexOf('/') + 1);\n        try {\n            if (!StringUtils.isEmpty(unitName)) tempUnit = new File(CommonUtil.getTempDir(), unitName); else tempUnit = new File(CommonUtil.createTempFile());\n        } catch (DeployToolException e) {\n            logger.error(String.format(\"Can't get temp file [%s].\", tempUnit));\n            throw new UnitTransportException(String.format(\"Can't get temp file [%s].\", tempUnit), e);\n        }\n        try {\n            bos = new BufferedOutputStream(new FileOutputStream(tempUnit));\n            logger.info(String.format(\"Use [%s] for ftp unit [%s].\", tempUnit, urlStr));\n        } catch (FileNotFoundException e) {\n            logger.error(String.format(\"File [%s] don't exist.\", tempUnit));\n            throw new UnitTransportException(String.format(\"File [%s] don't exist.\", tempUnit), e);\n        }\n        try {\n            IOUtils.copy(in, bos);\n            bos.flush();\n        } catch (IOException e) {\n            logger.error(String.format(\"Error when download [%s] to [%s].\", urlStr, tempUnit), e);\n            throw new UnitTransportException(String.format(\"Error when download [%s] to [%s].\", urlStr, tempUnit), e);\n        } finally {\n            IOUtils.closeQuietly(bos);\n            IOUtils.closeQuietly(in);\n        }\n        logger.info(String.format(\"Download unit to [%s].\", tempUnit.getAbsolutePath()));\n        return tempUnit.getAbsolutePath();\n    }\n", "code2": "    private static File copyFileTo(File file, File directory) throws IOException {\n        File newFile = new File(directory, file.getName());\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(file);\n            fos = new FileOutputStream(newFile);\n            byte buff[] = new byte[1024];\n            int val;\n            while ((val = fis.read(buff)) > 0) fos.write(buff, 0, val);\n        } finally {\n            if (fis != null) fis.close();\n            if (fos != null) fos.close();\n        }\n        return newFile;\n    }\n", "label": 1, "substitutes": {"urlStr": ["UrlString", "urlSpec", "servicestr", "urlSTR", " urlString", "webBr", "uristr", "URLSTR", "uriSt", "emailSTR", "urlWr", "resourceSt", "logSt", "uriWr", "urlstr", "urlEl", "fileString", "URLString", "URLStr", "URLBr", " urlBr", "sourcestr", "resourceStr", " urlSpec", " urlCh", "URLstr", "logStr", " urlstr", "uriStr", "urlBr", "resourceSTR", "strstr", "urlString", "sourceStr", "fileStr", "UrlSTR", "UrlSpec", "emailDec", "emailStr", "URLDec", "serviceStr", "UrlStr", "urlSt", "uriString", "sourceSTR", "uriCh", "URLCh", "resourcestr", "logEl", "serviceString", "emailString", "urlCh", " urlDec", "Urlstr", "resourceString", " urlSTR", "resourceBr", "strSTR", "UrlSt", "webStr", " urlSt", "sourceString", "URLSt", "urlDec", "strStr", "webSt", "filestr", " urlEl", " urlWr", "strString", "logBr", "URLWr", "URLSpec", "webEl"], "url": ["input", "rel", "l", "uu", "model", "channel", "ctrl", "style", "resource", "address", "name", "log", "image", "impl", "secure", "file", "ssl", "web", "location", "ll", "feed", "xml", "conn", "lib", "ul", "ur", "ob", "job", "il", "rl", "URL", "Url", "www", "str", "source", "page", "link", "user", "open", "http", "base", "f", "loc", "version", "ref", "org", "server", "el", "e", "text", "string", "path", "service", "account", "gl", "play", "host", "connection", "pull", "download", "username", "format", "lr", "layer", "config", "api", "bel", "fl", "course", "socket", "uri", "form", "blog", "proxy", "coll", "sl", "unit"], "tempUnit": ["thinKit", "tempTest", "tempunit", "tmpTest", "baseUnity", " tempUnity", "tmpUn", "tempFile", "testUn", "localTest", "TempUnit", "baseUnit", "tempRule", "TempFile", " tempFamily", "tmpunit", "testKit", "testingUnit", "thinUnity", "fakeUnit", "TempUn", "testUnit", " tempUn", "masterUnit", "poraryFamily", "localUnity", "fakeFamily", "poraryHome", "localUnit", "singleHome", "thinUnit", " tempFile", "masterHome", " tempTest", "thinUn", "testUnity", "fakeUnity", "baseFile", "tmpRule", "tempKit", "tmpFile", "masterunit", "singleUnit", "baseRule", "poraryUnit", " tempRule", "testFile", "tmpUnity", " tempHome", "singleunit", "testingUnity", "tempHome", "testunit", "tempUnity", "tmpUnit", " tempunit", "localUn", "Tempunit", "tempFamily", "TempUnity", "fakeHome", "testingUn", "testingKit", "tempUn", "poraryUnity"], "bos": ["los", "bott", "ubis", "bh", "abi", "oses", "fs", "pins", "bps", "ros", "bm", "osa", "bi", "os", "bs", "outs", "org", "bo", "uts", "iban", "lo", "oin", "oss", "oos", "zo", "oks", "zos", "oops", "aos", "ob", "tis", "mos", "mis", "fits", "ios", "ops", "opus", "obo", "cos", "boot", "bis", "obs", "bits", "bin"], "con": ["en", "inc", "win", "connection", "cm", "uc", "open", "cf", "co", "conn", "fc", "l", "out", "bc", "Conn", "fr", "login", "f", "pin", "xc", "enc", "can", "inner", "pc", "cn", "conf", "cons", "aff", "func", "rc", "hel", "CON", "cl", "syn", "ocon", "ch", "com", "close", "cr", "connect", "cache", "c", "ran", "conv", "cc", "bin", "ca", "fa", "coll", "Con"], "in": ["id", "en", "input", "inc", "din", "win", "connection", "with", "io", "conn", "src", "out", "b", "bc", "diff", "login", "as", "gen", "In", "into", "pin", "n", "again", "org", "info", "isin", "pc", "conf", "init", "it", "ins", "unin", "s", "per", "zin", "m", "kin", "index", "string", "cin", "image", "make", "file", "ran", "i", "IN", "check", "inn", "rin", "is", "cos", "bis", "lin", "cms", "fin", "bin", "on", "ac"], "unitName": ["componentDesc", "UnitPath", " unitDesc", "pluginPath", "unitUnit", "unDesc", "componentname", "unitPath", "UnitName", "pluginName", "fileName", "componentName", "connectionPath", "UnitUnit", "unName", "connectionUnit", "connectionName", "pluginname", "unname", "unitname", "filename", "unitDesc", "componentPath", " unitUnit", "connectionname", "filePath", "unPath", "Unitname", " unitname", " unitPath"]}}
{"id1": "20215222", "id2": "762814", "code1": "    public static void main(String[] args) {\n        String in = \"/Users/laemmel/svn/shared-svn/projects/120multiDestPeds/floor_plan/boundaries.shp\";\n        String out = \"/Users/laemmel/svn/shared-svn/projects/120multiDestPeds/floor_plan/boundaries_closed.shp\";\n        ShapeFileReader reader = new ShapeFileReader();\n        reader.readFileAndInitialize(in);\n        QuadTree<Coordinate> quad = new QuadTree<Coordinate>(reader.getBounds().getMinX(), reader.getBounds().getMinY(), reader.getBounds().getMaxX(), reader.getBounds().getMaxY());\n        for (Feature ft : reader.getFeatureSet()) {\n            MultiLineString ml = (MultiLineString) ft.getDefaultGeometry();\n            for (int i = 0; i < ml.getNumGeometries(); i++) {\n                LineString ls = (LineString) ml.getGeometryN(i);\n                Point start = ls.getStartPoint();\n                checkIt(start, quad);\n                Point end = ls.getEndPoint();\n                checkIt(end, quad);\n            }\n        }\n        ShapeFileWriter.writeGeometries(reader.getFeatureSet(), out);\n    }\n", "code2": "    public static void zipFile(String file, String entry) throws IOException {\n        FileInputStream in = new FileInputStream(file);\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(file + \".zip\"));\n        out.putNextEntry(new ZipEntry(entry));\n        byte[] buffer = new byte[4096];\n        int bytes_read;\n        while ((bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n        in.close();\n        out.closeEntry();\n        out.close();\n        File fin = new File(file);\n        fin.delete();\n    }\n", "label": 1, "substitutes": {"in": ["source", "id", "url", "input", "inc", "din", "xml", "min", "diff", "login", "f", "base", "include", "In", "data", "inas", "n", "resource", "work", "config", "info", "name", "init", "ins", "ini", "slice", "string", "path", "image", "c", "file", "IN", "lin", "bin", "s"], "out": ["page", "id", "url", "msg", "user", "result", "extra", "png", "output", "io", "outer", "letter", "this", "diff", "ou", "gen", "OUT", "Out", "again", "outs", "external", "template", "writer", "config", "inner", "conf", "filename", "name", "query", "target", "dot", "password", "comment", "key", "string", "point", "cfg", "list", "image", "file", "error", "err", "group", "bin", "res", "line"], "reader": ["pdf", "input", "dd", "audio", "over", "r", "system", "resource", "writer", "info", "rc", "report", "reading", "ri", "image", "file", "rr", "project", "actor", "read", "Reader", "feed", "buffer", "xml", "iter", "io", "rator", "bug", "worker", "riter", "handler", "editor", "er", "rer", "parse", "or", "source", "user", "http", "ler", "this", "client", "f", "loader", "oder", "server", "per", "book", "context", "builder", "manager", "ner", "h", "rar", "director", "vd", "w", "driver", "layer", "data", "feature", "config", "inner", "der", "parser", "former", "enter", "dr", "seed", "author", "entry"], "quad": [" Quad", "dq", "ad", "id", "split", "quarter", "pixel", "phase", "multi", "layout", "phi", "cgi", "qua", "gd", "bc", "diff", "bug", "loop", "poly", "circ", "zip", "round", "qq", "angle", "config", "pad", "shape", "cur", "tick", "sync", "query", "tri", "direction", "dir", "dog", "dot", "quant", "pattern", "step", "three", "patch", "bit", "chart", "post", "gb", "trap", "slice", "point", "rect", "coord", "sq", "q", "dollar", "circle", "grad", "quart", "square"], "ft": ["af", "fts", "ant", "bf", "txt", "fort", "ht", "cf", "fs", "xt", "wd", "fp", "sf", "fd", "fr", "Fact", "f", "part", "fw", "feature", "feat", "gt", "oft", "F", "fl", "aft", "pt", "TF", " FT", "bt", "rt", "font", "att", "fact", "Feature", "vt", "FT", "ff", "th", "et", "ct", "kt", "wt"], "ml": ["dl", "lp", "sel", "nl", "ln", "la", "LM", "cm", "lf", "xml", "ll", "mm", "lim", "l", "las", "lv", "lr", "fr", "wm", "kl", "vel", "ql", "gm", "cel", "ML", "cl", "wl", "bel", "fl", "li", "lc", "kel", "pm", "il", "mr", "vm", "jl", "fm", "lin", "pl", "line", "sl", "bl", "wt"], "i": ["id", "si", "qi", "iu", "hi", "io", "l", "b", "f", "di", "n", "zi", "mu", "I", "bi", "ti", "oi", "ai", "ni", "gi", "ji", "x", "ix", "ui", "ci", "u", "o", "e", "t", "ini", "m", "li", "v", "xi", "index", "ri", "j", "c", "uri", "ii", "pi", "is", "fi", "chi", "z", "mi", "s", "ip", "p"], "ls": ["ums", "lp", "los", "als", "ples", "ks", "dl", "ln", "la", "lf", "ils", "lines", "ss", "l", "las", "ns", "ms", "lv", "lr", "lins", "lt", "bs", "LS", "qs", "vs", "ins", "els", "pps", "cs", "lists", "sl", "sels", "lc", "li", "lis", " lines", "les", "rl", "ails", "its", "ii", "ols", "ds", "ts", "ps", "s", "coll", "ll"], "start": ["next", "Start", "id", "first", "last", "mid", "range", "min", "origin", "from", "l", "st", "part", "base", "loc", "skip", "set", "stop", "use", "name", "init", "patch", "step", "length", "cost", "offset", "art", "index", "point", "pos", "starting", "add", "line", "p", "type"], "end": ["End", "id", "url", "en", "append", "ends", "open", "complete", "edge", "eff", "object", "b", "begin", "base", "est", "ending", "set", "END", "stop", "off", "use", "patch", "length", "api", "max", "post", "offset", "point", "vert", "c", "pos", "position", "nd", "ended", "ad", "p"]}}
{"id1": "2255198", "id2": "15903468", "code1": "    public boolean open() {\n        if (null == _uu) {\n            try {\n                if (null == url) return false; else {\n                    if (null != this.query) this.url = constructQuery(url, this.query);\n                    _uu = url.openConnection();\n                    _uu.setAllowUserInteraction(false);\n                    _uu.setDoInput(true);\n                    if (null != super._loc) {\n                        try {\n                            _uu.setRequestProperty(\"Accept-Language\", jsGet_locale());\n                        } catch (JavaScriptException jsx) {\n                        }\n                    }\n                    encoding = _uu.getContentEncoding();\n                    bytesize = _uu.getContentLength();\n                    mimetype = _uu.getContentType();\n                    serviceDate = _uu.getDate();\n                    contentExpires = _uu.getExpiration();\n                    contentLastmod = _uu.getLastModified();\n                    return true;\n                }\n            } catch (Exception exc) {\n                close();\n                return false;\n            }\n        } else return true;\n    }\n", "code2": "    private String[] getHersheyFontNames() {\n        String[] fontNames = null;\n        URL url = HersheyFont.class.getResource(\"futural.jhf\");\n        String protocol = url.getProtocol();\n        if (protocol.equals(\"file\")) {\n            File f = new File(url.getFile());\n            f = f.getParentFile();\n            FilenameFilter filter = new FilenameFilter() {\n\n                public boolean accept(File dir, String name) {\n                    return name.endsWith(\".jhf\");\n                }\n            };\n            String[] children = f.list(filter);\n            if (children == null) {\n                return null;\n            }\n            fontNames = new String[children.length];\n            for (int i = 0; i < children.length; i++) {\n                fontNames[i] = children[i].substring(0, children[i].length() - 4);\n            }\n        } else if (protocol.equals(\"jar\")) {\n            try {\n                JarURLConnection jarURL = (JarURLConnection) url.openConnection();\n                ZipFile zf = new ZipFile(jarURL.getJarFile().getName());\n                Enumeration e = zf.entries();\n                Vector namesVector = new Vector();\n                while (e.hasMoreElements()) {\n                    ZipEntry ze = (ZipEntry) e.nextElement();\n                    String name = ze.getName();\n                    if (name.startsWith(\"visad/util/\") && name.endsWith(\".jhf\")) {\n                        namesVector.add(name.substring(11));\n                    }\n                }\n                zf.close();\n                if (namesVector.size() == 0) {\n                    return null;\n                }\n                fontNames = new String[namesVector.size()];\n                for (int i = 0; i < fontNames.length; i++) {\n                    String name = (String) namesVector.elementAt(i);\n                    fontNames[i] = name.substring(0, name.length() - 4);\n                }\n            } catch (Exception e) {\n                System.out.println(e);\n            }\n        } else {\n            System.out.println(\"Cannot locate the HersheyFonts.\");\n        }\n        return fontNames;\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "user", "browser", "connection", "uc", "xml", "buffer", "conn", "lib", "l", "http", "client", "object", "request", "this", "loc", "loader", "base", "f", "class", "resource", "server", "address", "config", "name", "method", "body", "query", "ur", "u", "json", "api", "location", "session", "path", "image", "cache", "socket", "uri", "ssl", "html", "URL", "service", "Url", "www", "form", "proxy", "web", "sl"], "_uu": [" _uni", " _lu", " _ku", "lognu", "lexuv", "lexu", "_ku", "_nu", "_cu", "jru", "xcu", " _ucc", "_u", "_uv", "lexuu", "___uu", "Juu", " _gu", " _nu", "loguc", "_hu", "loguu", "keyuu", "Juy", "pyuu", "jcu", "_menu", "_uri", " _hu", "pycu", " _eu", " _uri", "_ucc", "___hu", "postuu", "_gu", "_uni", "postnu", "Juv", "___uf", "_uy", "___eu", "xnu", "xku", "_uno", "keyru", "loglu", "jmenu", "xuu", "xuy", " _menu", "_lu", " _ru", "_uf", "pyku", "keymenu", " _uy", "_ru", "postuv", " _cu", "Jru", "postuy", "pyru", "xuv", "lexcu", " _uf", "_eu", "juu", " _uc", "keycu", "_uc", "lexuno"], "encoding": ["decoder", "encoder", "enapping", "enoder", "enode", "decapping", "Encoding", "Encoder", "decode", "Encode", "encode", "decoding", "Encapping", "enoding", "encapping"], "bytesize": ["blocksize", "bitsiz", "keysiz", "bytesiz", "blockssize", "bytesource", "bitssize", "bytessize", "blocksource", "keysource", "blocksiz", "keysize", "keyssize", "bitsource", "bitsize"], "mimetype": ["mtimetyype", "mimearpe", "mtimitype", "mimetyode", "mtimityt", "mtimetyt", "mimearype", "mimeart", "mimempe", "mimemype", "mimityt", "mimemode", "mimetyype", "mimemt", "mtimetype", "mtimityype", "mimityode", "mtimetyode", "mimitype", "mimearode", "mimityype", "mimetyt", "mtimityode"], "serviceDate": ["contentDate", "contentdate", "transferdate", "servicedate", "serverTime", "transferTime", "contentYear", "transferDate", "transferYear", "serviceTime", "serverYear", "serverDate", "serviceYear", "contentTime", "serverdate"], "contentExpires": ["contentexpires", "contentRemired", "contentExpired", "contentexpenses", " contentExperies", " contentExpenses", " contentExpired", "contentexperies", "contentExpenses", "contentExperies", "contentRemeries", "contentRemires", "contentexpired", "contentRemenses"], "contentLastmod": ["contentlastMOD", "ContentFirstmodified", "contentFirstmodified", "contentLastMOD", "contentFirstmod", "ContentLastMod", "ContentFirstMod", "contentFirstMOD", "ContentFirstmod", "contentlastMod", "ContentLastmod", "contentLastmodified", "ContentFirstMOD", "ContentLastmodified", "contentlastmod", "contentLastMod", "contentlastmodified", "contentFirstMod", "ContentLastMOD"]}}
{"id1": "22373758", "id2": "11092394", "code1": "    private static void fileUpload() throws Exception {\n        file = new File(\"c:/Documents and Settings/dinesh/Desktop/ZShareUploaderPlugin.java\");\n        httpclient = new DefaultHttpClient();\n        HttpPost httppost = new HttpPost(\"http://flameupload.com/cgi/ubr_upload.pl?upload_id=\" + uploadid);\n        MultipartEntity mpEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n        ContentBody cbFile = new FileBody(file);\n        mpEntity.addPart(\"upfile_0\", cbFile);\n        mpEntity.addPart(\"uploaded\", new StringBody(\"on\"));\n        mpEntity.addPart(\"hotfile\", new StringBody(\"on\"));\n        mpEntity.addPart(\"turbobit\", new StringBody(\"on\"));\n        mpEntity.addPart(\"depositfiles\", new StringBody(\"on\"));\n        mpEntity.addPart(\"fileserve\", new StringBody(\"on\"));\n        mpEntity.addPart(\"filefactory\", new StringBody(\"on\"));\n        mpEntity.addPart(\"netload\", new StringBody(\"on\"));\n        mpEntity.addPart(\"uploadstation\", new StringBody(\"on\"));\n        mpEntity.addPart(\"badongo\", new StringBody(\"on\"));\n        mpEntity.addPart(\"uploading\", new StringBody(\"on\"));\n        mpEntity.addPart(\"megashare\", new StringBody(\"on\"));\n        mpEntity.addPart(\"_2shared\", new StringBody(\"on\"));\n        httppost.setEntity(mpEntity);\n        NULogger.getLogger().log(Level.INFO, \"executing request {0}\", httppost.getRequestLine());\n        NULogger.getLogger().info(\"Now uploading your file into flameupload.com\");\n        HttpResponse response = httpclient.execute(httppost);\n        HttpEntity resEntity = response.getEntity();\n        NULogger.getLogger().info(response.getStatusLine().toString());\n        NULogger.getLogger().info(EntityUtils.toString(resEntity));\n        Header[] allHeaders = response.getAllHeaders();\n        for (int i = 0; i < allHeaders.length; i++) {\n            System.out.println(allHeaders[i].getName() + \"=\" + allHeaders[i].getValue());\n        }\n        if (response.getStatusLine().getStatusCode() == 302) {\n            NULogger.getLogger().info(\"Files uploaded successfully\");\n        } else {\n            throw new Exception(\"There might be a problem with your internet connection or server error. Please try again later :(\");\n        }\n    }\n", "code2": "    private void copy(final File file) throws IOException {\n        String targetFilename = targetFilename(file);\n        FileInputStream fis = new FileInputStream(file);\n        try {\n            FileChannel source = fis.getChannel();\n            try {\n                FileOutputStream fos = new FileOutputStream(targetFilename);\n                try {\n                    FileChannel target = fos.getChannel();\n                    try {\n                        target.transferFrom(source, 0, source.size());\n                    } finally {\n                        target.close();\n                    }\n                } finally {\n                    fos.close();\n                }\n            } finally {\n                source.close();\n            }\n        } finally {\n            fis.close();\n        }\n    }\n", "label": 0, "substitutes": {"file": ["play", "source", "page", "folder", "url", "queue", "user", "binary", "upload", "connection", "feed", "xml", "buffer", "File", "audio", "l", "http", "object", "fp", "part", "model", "f", "base", "data", "stream", "class", "zip", "resource", "work", "force", "name", "filename", "body", "log", "pic", "picture", "mail", "content", "money", "up", "media", "image", "document", "cache", " File", "db", "files", "service", "FILE", "create", "video", "type"], "httpclient": [" httpClient", "Httpconn", "Httpclient", "httpsconn", " httpconnection", "httpsconnection", "httpserver", "httpClient", "httpconnection", "facebookClient", "Httpconnection", " httpconn", "httpconn", "httpsclient", "facebookserver", "httpsClient", "HttpClient", "facebookclient", " httpserver", "httpsserver"], "httppost": ["httpost", "httepost", "httPPpost", " httpposter", " httpost", "httpppost", "httpgrop", "httPPost", "httppedoster", "httppoint", "httppeoster", "httmposter", "httcppPost", " httpppost", "httpgpost", "httppeost", "httposter", "httppOST", "recippost", "httppedOST", "httPPoint", "httcpppost", "recimpoint", " httppoint", "httppPost", " httppPost", " httpPost", "httpPost", "httmpoint", "httmppost", "httpOST", "httprop", "recipppost", "httcppoint", " httpOST", "httppepost", "httpoint", "recimppost", "recimpost", "recipposter", "httpgoster", "httppeoint", "httpprop", " httppOST", " httpprop", " httprop", "httpperop", "htteposter", "httcppost", "httPPPost", "httpgost", "recimposter", "httppedoint", " httposter", "recippoint", "httepOST", "httepoint", "httmpost", "httppedost", " httpoint", "httpposter"], "mpEntity": ["mpEnt", "mbEnt", "pgEntity", "tmpEnt", "MPEntity", "mbEntity", "mbentity", "pmEnvironment", "MpAction", "mcUnit", " mpCollection", "viewEntity", " mpUnit", "mmEnt", "mbDescription", "ppEntity", "mtEnt", "MPBody", " mpSource", " mpContent", "mmContent", "viewEnt", "mpDoc", "MPentity", "tmpBody", "mpUnit", "copUrl", "mpAction", "mpUrl", " mpEvent", " mpEnvironment", "mpLine", "appDescription", "mbCollection", "appEntity", " mpEnt", "MpSource", "mpEvent", "pmEntity", "pmentity", "lpEntity", "wpDoc", "mcCollection", "MpBody", "mpElement", "lpUnit", "wpEntity", "psentity", " mpDoc", "mpDescription", "viewEnvironment", "mbSource", " mpFile", "pgElement", "mpFile", "mbContent", "mbLine", " mpUrl", "ppentity", " mpDescription", "mbUnit", "appentity", "tmpEntity", "mbElement", "copEntity", "mtEntity", "tmpentity", "mbAction", "mbEnvironment", "psEntity", "psFile", "MPEnt", "mbEvent", "copentity", "ppContent", "psEnt", "mmEntity", "pgAction", "viewentity", "MpEntry", "MPContent", "ppAction", "mbBody", "wpEntry", " mpElement", "lpDoc", " mpentity", "mcEntity", " mpLine", "MpEntity", " mpAction", "mpEnvironment", "mtLine", "wpUnit", "mbUrl", "viewFile", "pgEntry", "mpSource", "MpElement", "mpentity", "mpContent", " mpBody", "MpEvent", "mmentity", "lpEntry", "mpCollection", " mpEntry", "mpBody", "mpEntry", "mbEntry"], "cbFile": ["cbBody", "cfContent", "cbDir", "bcFile", "rbfile", "cdnBody", "grabContent", "rbFiles", "cdnfile", "bcDir", "CBBody", "cbContent", "cfFile", "cdnFile", "bcBody", "rbFile", "rbContent", "grabFile", "cbfile", "cdnDir", "CBFile", "cffile", "cbFiles", "CBfile", "CBDir", "bcfile", "cfFiles", "grabfile", "grabFiles"], "response": ["page", "respond", "default", "connection", "feed", "reply", "flower", "result", "message", "output", "request", "object", "client", "application", "onse", "data", "tree", "resource", "server", "writer", "method", "body", "full", "json", "api", "initial", "ree", "status", "session", "Response", "document", "error", "resp", "service", "res", "collection"], "resEntity": [" resObject", "ResEnt", "Resentity", "resentity", " ResEnt", " ResEntity", " resentity", " resEnt", "ResObject", " ResObject", "resEnt", " Resentity", "resObject", "ResEntity"]}}
{"id1": "6405249", "id2": "8250472", "code1": "    public static String generateHexadecimalCodedString(String stringToBeCoded) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n        digest.update(stringToBeCoded.getBytes());\n        byte[] hashedKey = digest.digest();\n        final int radix = 16;\n        String result = \"\";\n        for (byte b : hashedKey) {\n            int unsignedByte = b + 128;\n            result += Integer.toString(unsignedByte, radix);\n        }\n        return result;\n    }\n", "code2": "    private final String encryptPassword(final String password) throws EncryptionExecption {\n        if ((password == null) || (password.length() == 0)) {\n            throw new NullPointerException();\n        }\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update((password).getBytes(\"UTF-8\"));\n            return new BASE64Encoder().encode(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            throw new EncryptionExecption(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new EncryptionExecption(e);\n        }\n    }\n", "label": 1, "substitutes": {"stringToBeCoded": ["stringToBECrypted", "stringToBeEnccoded", "stringToBeClrypted", "stringTobeCrypted", "stringTobeEncressed", "stringToBEDecoded", "stringToBECoded", "stringToBeScrypted", "stringToBeClached", "stringToBeDeccoded", "stringTobeCached", "stringToBeEncrypted", "stringTobeCressed", "stringToBeDecrypted", "stringToBEDecached", "stringTobeEncoded", "stringToBeClcoded", "stringToBeEncressed", "stringToBEDecrypted", "stringToBeScached", "stringToBeDecressed", "stringTobeCoded", "stringTobeEncached", "stringToBeEncached", "stringToBECcoded", "stringToBeEncoded", "stringToBeCached", "stringToBeDecoded", "stringToBeDecached", "stringToBeScressed", "stringTobeEncrypted", "stringToBeCcoded", "stringToBeCrypted", "stringToBECached", "stringToBeCloded", "stringToBeCressed", "stringToBeScoded", "stringToBEDeccoded"], "digest": ["decest", "Diger", "mdester", "digester", "digests", "signester", "DigEST", "digiter", " digests", "mdest", "cutusher", "Digeter", "codester", "diger", "signEST", "Digiter", "decitter", " digusher", "cutester", "digeter", "mditter", " digeter", "digusher", "cutiter", "digEST", "Digester", "Digested", "Digitter", " digEST", "decester", "decested", "digitter", "coder", "Diggest", "diggest", "decests", "codeter", "mdgest", " digiter", " digester", "signer", "signest", "cutest", "Digusher", "codest", "digested", " diger", "decgest", "Digests", " digested", "Digest"], "hashedKey": ["hahedHash", "hashKey", "hahedBase", "shashedPart", "hahedkey", "shashedkey", "shachedKeys", "shachedKey", "hhedHash", "hashkey", "hryptedkey", "shachedPart", "hachedKey", "hahedKey", "shashedKey", "hhedkey", "hashingKey", "hashedKeys", "hashingBase", "hashingKeys", "hashedHash", "haashedKey", "hashBase", "hashedBase", "hashingPart", "hashedPart", "hryptedKeys", "hachedKeys", "hachedPart", "haashedBase", "hashingHash", "hashHash", "hachedkey", "hryptedPart", "hashedkey", "haashedHash", "hhedKey", "shachedkey", "haashedkey", "shashedKeys", "hashingkey", "hhedBase", "hryptedKey"], "radix": ["radirection", "radfix", "Radice", " radius", "radius", "differentius", " radirection", "multiplix", " radfix", "multiplius", "differentfix", "radice", "multiplx", "multiplice", "radx", "Radirection", "differentix", "differentirection", "Radx", " radx", "Radfix", "Radius", "Radix", " radice"], "b": ["id", "sb", "cb", "binary", "d", "mb", "buffer", "be", "k", "pb", "l", "bc", "f", "kb", "bytes", "r", "abb", " eb", "e", "bb", "ob", "a", "bit", "gb", "B", "ib", "orb", "eb", "obj", "c", "ab", " B", "db", "i", "wb", "fb", "block", "lb", "bin", "s", "rb", "p"], "unsignedByte": ["signedByte", "signedBytes", "unsignedBytes", "uintInt", " unsignedInt", "unsignedBitcoin", " unsignedBytes", "unsignedInt", "signedInt", "binaryBit", "uintBit", " unsignedBit", "signedBit", "binaryBytes", "binaryByte", "unsignedBit", "uintBytes", "binaryBitcoin", " unsignedBitcoin", "uintByte", "signedBitcoin"], "result": ["source", "value", "str", "default", "url", "our", "success", "buffer", "Result", "range", "expected", "function", "username", "message", "output", "card", "format", "request", "val", "description", "root", "data", "future", "style", "response", "match", "feature", "ret", "prefix", "info", "results", "report", "json", "password", "length", "text", "comment", "content", "key", "string", "answer", "error", "array", "secret", "valid", "floor", "current", "reason", "test", "res", "null"]}}
{"id1": "21273054", "id2": "1824914", "code1": "    public RobotList<Enemy> sort_decr_Enemy(RobotList<Enemy> list, String field) {\n        int length = list.size();\n        Index_value[] enemy_dist = new Index_value[length];\n        if (field.equals(\"\") || field.equals(\"location\")) {\n            Location cur_loc = this.getLocation();\n            for (int i = 0; i < length; i++) {\n                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));\n            }\n        } else if (field.equals(\"health\")) {\n            for (int i = 0; i < length; i++) {\n                enemy_dist[i] = new Index_value(i, list.get(i).health);\n            }\n        } else {\n            say(\"impossible to sort list - nothing modified\");\n            return list;\n        }\n        boolean permut;\n        do {\n            permut = false;\n            for (int i = 0; i < length - 1; i++) {\n                if (enemy_dist[i].value < enemy_dist[i + 1].value) {\n                    Index_value a = enemy_dist[i];\n                    enemy_dist[i] = enemy_dist[i + 1];\n                    enemy_dist[i + 1] = a;\n                    permut = true;\n                }\n            }\n        } while (permut);\n        RobotList<Enemy> new_enemy_list = new RobotList<Enemy>(Enemy.class);\n        for (int i = 0; i < length; i++) {\n            new_enemy_list.addLast(list.get(enemy_dist[i].index));\n        }\n        return new_enemy_list;\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        destination.getParentFile().mkdirs();\n        BufferedInputStream in = new BufferedInputStream(new FileInputStream(source));\n        BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(destination));\n        byte[] buffer = new byte[4096];\n        int read = -1;\n        while ((read = in.read(buffer)) != -1) {\n            out.write(buffer, 0, read);\n        }\n        out.flush();\n        out.close();\n        in.close();\n    }\n", "label": 0, "substitutes": {"list": ["later", "result", "l", "st", "loop", "stage", "name", "cl", "cli", "slice", "obj", "array", "level", "arr", "range", "object", "diff", "part", "table", "to", "it", "batch", "lists", "all", "index", "pool", "load", "fail", "self", "add", "stack", "str", "collection", "bl", "source", "parent", "left", "queue", "the", "complete", "this", "you", "base", "set", "x", "word", "yet", "full", "e", "we", "listed", "v", "string", "record", "order", "s", "best", "null", "p", "lat", "lp", "LIST", "rank", "chain", "view", "que", "out", "state", "layer", "data", "tree", "match", "low", "members", "lc", "li", "document", "code", "like", "map", "current", "form", "empty", "test", "coll"], "field": ["source", "folder", "value", "id", "url", "input", "term", "append", "token", "division", "ld", "flower", "message", "ment", "object", "fix", "end", "row", "layer", "f", "data", "style", "match", "feature", "condition", "off", "element", "word", "tag", "name", "holder", "force", "query", "Field", "post", "lc", "fields", "key", "time", "rule", "string", "document", "load", "lock", "attribute", "label", "date", "service", "FIELD", "manager", "str", "line", "type"], "length": ["size", "id", "url", "len", "pull", "build", "range", "limit", "l", "view", "lv", "model", "part", "base", "number", "f", "loc", "style", "zip", "match", "sh", "angle", "sequence", "section", "shape", "depth", "distance", "full", "ph", "li", "se", "time", "slice", "string", "count", "path", "lock", "Length", "width", "code", "block", "database", "mount", "total", "level", "position", "collection", "line", "square", "p", "duration", "type"], "enemy_dist": ["life_Dist", "enemy_search", "enemyJtest", "enemyNDist", "enemyJdist", "life_test", "enemyJDist", "winnerklength", "enemy___dist", "enemy_distance", "enemyklength", "enemykdist", "enemy_des", "elementkDist", "enemy_src", "enemykdistance", "winnerkdone", "enemy___des", " enemy_depend", " enemy_del", "enemyJdis", "enemyLogdiff", "winner_dist", "enemyacdist", "hero_length", "enemy_depth", " enemy_dis", "elementkdone", "enemyNlength", "enemy_done", "winner_distance", "enemy_del", "enemykDist", "hero_dist", "life_dis", "enemy_depend", "enemy_test", " enemy_Dist", "enemy_store", "enemyJstore", "enemykdone", "axe_dist", "enemyacDist", "winner_length", "heroNDist", "element_done", "enemykdiff", "axe_ist", "enemyaclist", "enemyLogsrc", "heroNlength", "enemyNlist", " enemy_distance", "enemy___Dist", "heroNlist", "element_Dist", "enemyaclength", "winnerkdistance", "element_diff", "hero_Dist", "enemy_master", "enemyJdiff", " enemy_store", "enemy_Dist", "axe_depth", "enemy_dis", "enemy_length", "heroNdist", " enemy_search", "winnerkdist", "elementkdist", " enemy_master", "axe_diff", "enemyLogdist", "enemy___del", "enemy_diff", "enemyJsearch", " enemy_diff", "enemy_ist", "winner_done", "element_dist", " enemy_src", "enemyNdist", "hero_list", "life_dist", "enemy_list", " enemy_des", "enemyLogdis", "elementkdiff"], "cur_loc": [" cur_pl", "cur__la", "curptlocation", " cur_local", "cur__location", "cur_local", "cur__local", " cur_location", "curptloc", "curptcoord", " cur_la", "cur_pl", "cur_coord", "curptpl", " cur_coord", "cur_location", "cur__loc", "cur_la"], "i": ["d", "abi", "result", "l", "directory", "bi", "resource", "gi", "info", "isi", "u", "cli", "xi", "ri", "slice", "ori", "mini", "ip", "id", "range", "phi", "io", "yi", "b", "zi", "I", "oi", "ti", "ai", "ni", "adi", "iv", "it", "ui", "ini", "key", "index", "c", "ii", "pi", "is", "fi", "source", "my", "si", "multi", "hi", "in", "f", "ji", "isin", "module", "x", "o", "e", "eni", "v", "j", "g", "q", "uni", "p", "ie", "h", "qi", "iu", "k", "y", "di", "mu", "esi", "inner", "ix", "init", "ci", "api", "m", "lc", "li", "uri", "z", "mi"], "permut": ["promut", "permutation", "mmute", "permur", "mmut", "premut", "premute", "perur", " permaut", " permute", "peruted", "peraut", "permute", " permur", "perute", "mmur", "perut", "expluted", " permutt", "explute", "perutt", "perutation", "explut", "promute", "premuted", "permaut", " permutation", "promur", "promutt", "permutt", " permuted", "explaut", "permuted", "mmutation", "premutt"], "a": ["sa", "an", "A", "d", "another", "ia", "l", "y", "ga", "app", "b", "as", "f", "ca", "data", "n", "ac", "access", "name", "e", "s", "au", "ae", "area", "ba", "abc", "c", "ab", "array", "aa", "at", "z", "alpha", "ad", "p", "va"], "new_enemy_list": ["new_enemylonglist", "new_enemy_table", "new_enemylonglists", "new_enemyapplist", "new_enemy_l", "new_enemy_test", "new_enemy___list", "new_enemy_lists", "new_enemy___l", "new_enemyjstack", "new_enemyjtable", "new_enemylongl", "new_enemyjl", "new_axe_table", "new_enemy_parent", "new_game_lists", "new_enemyappparent", "new_enemy__lists", "new_enemyappl", "new_enemyapptest", "new_enemy__l", "new_game_l", "new_axe_l", "new_game_list", "new_enemy_stack", "new_enemy___stack", "new_enemy___table", "new_axe_list", "new_axe_test", "new_enemyjlist", "new_axe_stack", "new_enemy__list", "new_axe_parent"]}}
{"id1": "9741008", "id2": "14807299", "code1": "    public MetaService() {\n        super();\n        URL url = this.getClass().getResource(Resource);\n        if (null != url) {\n            this.location = url;\n            String value = null;\n            try {\n                InputStream in = url.openStream();\n                try {\n                    value = (new java.io.DataInputStream(in).readLine());\n                    if (null != value) {\n                        value = value.trim();\n                        if (1 > value.length()) value = null;\n                    }\n                } finally {\n                    in.close();\n                }\n            } catch (IOException exc) {\n                exc.printStackTrace();\n            }\n            this.value = value;\n        } else {\n            this.location = null;\n            this.value = null;\n        }\n    }\n", "code2": "    public void testRetrieve() throws DigitalObjectManager.DigitalObjectNotFoundException, URISyntaxException, IOException {\n        DigitalObjectManager man = new FedoraObjectManager(\"fedoraAdmin\", \"fedoraAdminPass\", \"http://localhost:7910/fedora\");\n        DigitalObject r = man.retrieve(new URI(\"demo:dc2mods.1\"));\n        String title = r.getTitle();\n        List<Metadata> met = r.getMetadata();\n        InputStream content = r.getContent().read();\n        StringWriter theString = new StringWriter();\n        IOUtils.copy(content, theString);\n        assertNotNull(theString.toString(), \"Content should not be null\");\n        assertNotNull(title, \"The title should be set\");\n        assertNotNull(met.get(0).getContent(), \"There should be some metadata\");\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "route", "id", "link", "connection", "feed", "buffer", "download", "result", "io", "src", "l", "http", "object", "b", "home", "lr", "fr", "loc", "base", "loader", "data", "f", "ref", "href", "re", "r", "remote", "resource", "org", "server", "zip", "address", "el", "element", "name", "ur", "bb", "ob", "target", "api", "bel", "found", "ls", "job", "index", "string", "path", "image", "rl", "impl", "socket", "file", "uri", "ssl", "URL", "service", "type", "Url", "www", "str", "coll", "sl", "entry"], "location": ["language", "folder", "parent", "site", "layout", "connection", "origin", "message", "definition", "home", "loc", "href", "directory", "region", "remote", "resource", "server", "address", "Location", "where", "section", "filename", "name", "component", "target", "selection", "area", "path", "uri", "property", "position", "collection", "population"], "value": ["default", "token", "result", "home", "val", "model", "style", "resource", "address", "info", "name", "status", "expression", "Value", "label", "type", "reason", "line", "feed", "reference", "range", "one", "join", "object", "part", "remote", "component", "values", "sv", "job", "key", "variable", "search", "collection", "source", "parent", "write", "function", "description", "hello", "version", "region", "server", "usage", "section", "word", "text", "comment", "v", "show", "media", "string", "error", "property", "valid", "null", "entry", "journal", "language", "memory", "message", "output", "view", "format", "data", "summary", "VALUE", "response", "feature", "sequence", "member", "target", "json", "password", "content", "replace", "uri", "character", "current", "unit"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "connection", "io", "nin", "conn", "out", "b", "login", "as", "f", "data", "In", "stream", "n", "r", "again", "resource", "isin", "inner", "init", "it", "ins", "gin", "ini", "image", "socket", "file", "ssl", "i", "IN", "err", "inn", "is", "lin", "cms", "bin"]}}
{"id1": "13650581", "id2": "9769234", "code1": "    public static ChannelIF addChannel(String url) throws Exception {\n        ChannelIF channel = null;\n        try {\n            channel = FeedParser.parse(new ChannelBuilder(), url);\n            if (channel.getLocation() == null) channel.setLocation(new URL(url));\n        } catch (ParseException e) {\n            InputStream is = new URL(url).openStream();\n            InputStreamReader reader = new InputStreamReader(is);\n            channel = FeedParser.parse(new ChannelBuilder(), reader);\n            reader.close();\n            is.close();\n            if (channel.getLocation() == null) channel.setLocation(new URL(url));\n        }\n        DAOChannel.addChannel(channel);\n        DAOFavicon.addFaviconForChannel(channel);\n        return channel;\n    }\n", "code2": "    void downloadImage(String filename, File imageFile) throws Exception {\n        String URL = Constants.IMAGE_URL + \"/\" + filename;\n        SiteResponse response = stratSite.getResponse(URL);\n        InputStream inputStream = response.getInputStream();\n        OutputStream outputStream = new FileOutputStream(imageFile);\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "route", "id", "link", "feed", "connection", "xml", "pull", "download", "rel", "ll", "br", "l", "ul", "http", "view", "fr", "loc", "f", "data", "href", "base", "stream", "style", "version", "resource", "server", "config", "address", "el", "name", "ur", "full", "large", "e", "text", "found", "location", "ls", "string", "path", "image", "html", "uri", "file", "i", "URL", "hub", "Url", "www", "gl", "str", "null", "coll", "sl"], "channel": ["contract", "an", "default", "cf", "fc", "console", "model", "loop", "resource", "bean", "rc", "log", "image", "type", "group", "wan", "feed", "plugin", "conn", "Channel", "part", "class", "handler", "component", "event", "instance", "category", "key", "cache", "c", "or", "video", "source", "page", "parent", "route", "queue", "user", "core", "player", "chan", "client", "bc", "base", "version", "sc", "server", "fat", "hel", "ch", "ann", "context", "service", "manager", "chron", "null", "language", "connection", "cm", "chain", "cat", "message", "view", "center", "layer", "config", "can", "inner", "member", "container", "ko", "chart", "course", "content", "session", "change", "socket", "db", "character", "cup", "unit"], "is": ["get", "id", "isa", "io", "rss", "src", "fs", "http", "ais", "out", "in", "app", "isl", "as", "was", "iss", "are", "stream", "os", "ris", "es", "ai", "info", "serv", "ir", "has", "isi", "it", "ui", "IS", "api", "ri", "isc", "ios", "its", "uri", "i", "im", "us", "bis", "Is", "ar", "iso", "s", "ip", "ie"], "reader": ["source", "read", "Reader", "feed", "iter", "ser", "ro", "io", "rss", "http", "in", "ler", "driver", "row", "f", "loader", "worker", "oder", "stream", "serial", "r", "resource", "handler", "server", "writer", "info", "inner", "er", "rc", "reading", "per", "iris", "parser", "ri", "i", "or", "builder", "rr", "ar", "entry"]}}
{"id1": "751335", "id2": "15416858", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void download(File archive, File timestamp, URL url, IProgressMonitor monitor) throws IOException {\n        monitor.subTask(\"download \" + url.toString());\n        InputStream in = null;\n        FileOutputStream out = null;\n        URLConnection conn = null;\n        try {\n            conn = url.openConnection();\n            Writer writer = null;\n            try {\n                Date date = new Date(conn.getLastModified());\n                writer = new FileWriter(timestamp);\n                writer.write(this.FORMAT.format(date));\n            } catch (IOException e) {\n                timestamp.delete();\n            } finally {\n                IOUtils.closeQuietly(writer);\n            }\n            in = conn.getInputStream();\n            out = new FileOutputStream(archive);\n            IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 1, "substitutes": {"inFile": ["inputfile", "inPlace", "InFiles", "oldfile", "inputFiles", "incPlace", " inPath", "outFilename", "outfile", "inFilename", "outPlace", "outPath", "oldFiles", "inputFilename", "infile", "InFile", "oldFilename", "incfile", "oldFile", "outFiles", "inPath", "incFile", "inFiles", " inFiles", "incFiles", "InPlace", " infile", "inputFile", "Infile", "InPath"], "outFile": [" outTable", "zipFile", " outPlace", "inputFolder", "outTable", "zipString", "newfile", " outString", "newPlace", "OutFile", " outfile", "outputFILE", "outputFilename", "outDir", "zipFilename", "outputFile", "outputFolder", "outFILE", "outFilename", "outputString", " outFolder", " outDir", "outfile", "newDir", "inputPlace", "outPlace", "OutPlace", "Outfile", " outFilename", "outFolder", "OutDir", "newFile", "inputTable", " outFILE", "outString", "inputFile", "outputPlace", "outputTable", "zipFILE"], "iis": [" iIS", " iiss", "Iisc", " iIs", "iniais", "ciis", "iois", "iiIS", "ioIs", "IIs", "iIS", "iniIS", "iiIs", "iid", "iisc", "ioiss", " iais", "Iiss", "ciid", "iiss", "iniIs", "iils", "ciais", "Iis", " iils", "iiils", " iid", "ioisc", "iniis", "iniisc", "iiis", "iniiss", "iniid", "iIs", "ciiss", "iniils", "iais"], "dcmParser": ["dcpJar", " dpmarser", "dcpReader", "dcmLoader", "pdymJar", "dpmarser", "dpmLoader", "dcyJar", "pdcmparser", "dcyReader", "Dcmarser", " dpmPlugin", "dsemPlugin", "dmcarser", "dcmparser", "dsemStreamer", "dcrarser", "dpmStreamer", "dcrParser", "dmoduleParser", "dymReader", "dcrparser", "dsemParser", " dcmStreamer", "dtermStreamer", "dpmparser", "dtermParser", "ddcReader", "dcmBuilder", "dmmWriter", "dymparser", "dmmParser", " dcmPlugin", "dmoduleBuilder", "dcmWriter", "ddcParser", " dpmJar", "dmcParser", "dmodulePlugin", "dpmJar", "pdcmReader", "dpmParser", " dcmReader", " dpmLoader", "DcmReader", "dcyParser", "ddcLoader", "dymParser", "dcyarser", " dpmReader", "pdymparser", "pdymReader", "dpmPlugin", " dcmJar", " dcmPar", "DcmJar", "dtermPlugin", "dcpParser", "dcpparser", " dpmPar", " dcmLoader", "pdcmParser", "dpmPar", " dpmBuilder", "dmcJar", "dmoduleReader", " dpmStreamer", "dpmBuilder", " dcmBuilder", " dcmarser", "dymJar", "dcmStreamer", "dmmReader", "dcrWriter", "dcmPlugin", "dmcPar", "dcmJar", "ddcPlugin", " dpmParser", "Dcmparser", "DcmParser", "dsemReader", "dcmarser", "dcmPar", "dcrPar", "DcmWriter", "pdymParser", "dmmarser", "dcmReader", "dtermReader", "dcrReader", "dpmReader", "pdcmJar", "dcrJar"], "ds": ["ys", "ks", "dc", "ipes", "Ds", "des", "d", "points", "dd", "ils", "ld", "ss", "ws", "gd", "src", "pd", "conn", "cdn", "gs", "client", "ns", "ads", "fd", "ros", "Db", "asi", "data", "iss", "di", "os", "bs", "DS", "tx", "drivers", "sys", "js", "vs", "eps", "sync", "dt", "xs", "plugins", "ins", "dds", "da", "rs", "cs", "Ts", "amps", "dr", "ls", "df", "Os", "ays", "session", "docs", "utils", "db", "details", "parts", "services", "is", "tes", "ts", "nas", "ps", "s", "dat", "uds"], "pdReader": ["wdRead", "pcParser", "dsreader", "pbParser", "pcLoader", "pdreader", "pbReader", "xdreader", "xdWriter", "hdreader", "pdRead", "pcReader", "dsRead", "pdLoader", "hdRead", "pidParser", "pbLoader", "hdWriter", "wdReader", "pdParser", "pidScan", "pcScan", "dsLoader", "pbScan", "pcRead", "pcWriter", "wdLoader", "hdReader", "pidReader", "wdWriter", "pidLoader", "xdReader", "dsWriter", "dsReader", "pdScan", "xdRead"], "out": ["default", "later", "d", "net", "with", "result", "down", "now", "doc", "model", "over", "Out", "call", "writer", "sys", "sync", "name", "dot", "log", "flush", "cli", "temp", "image", "list", "obj", "file", "ssl", "err", "array", "img", "group", "store", "line", "pass", "co", "outer", "io", "conn", "lib", "object", "gen", "to", "OUT", "auto", "class", "child", "exp", "ex", "key", "point", "pool", "cache", "at", "copy", "ext", "page", "parent", "url", "user", "write", "inc", "term", "in", "client", "login", "base", "oder", "sum", "external", "exec", "word", "full", "o", "builder", "manager", "order", "s", "null", "connection", "output", "w", "as", "data", "again", "outs", "inner", "flow", "password", "session", "up", "lock", "db", "code", "device"], "dcmEncParam": ["dcmElParameter", "dcmDecParam", "dpmDecParam", "dcmEngType", "dcmDecParameter", "dcmEnVar", "dcmDecPar", "dcmElVar", "dcmEncType", "dcmElType", "dcmencParam", "dpmEncParam", "dcmEnPar", "dcmEncSm", "dcmEngParam", "dcmEnParam", "dcmElParam", "dcmAccParameter", "dcmDecSm", "dpmEncSm", "dcmencParameter", "dpmDecParameter", "dcmEngVar", "dcmAccParam", "dcmencSm", "dpmEncParameter", "dcmAccSm", "dpmDecSm", "dcmEnParameter", "dcmEncPar", "dcmEncVar", "dcmEncParameter", "dcmEnType", "dcmEngParameter"], "pdWriter": ["hdOutput", "pdContent", "pxContent", "PDOutput", "pxReader", "PDReader", "PDWriter", "PDContent", "pxWriter", "tdReader", "ddWR", "dsWrite", "hdWriter", "pxOutput", "ddWrite", "ddOutput", "hdWrite", "pdOutput", "pdWrite", "hdWR", "pdWR", "tdWriter", "dsOutput", "tdContent", "dsWriter", "tdOutput", "ddWriter", "dsWR"]}}
{"id1": "16474825", "id2": "21585427", "code1": "    public static void copyFile(String file1, String file2) {\n        File filedata1 = new java.io.File(file1);\n        if (filedata1.exists()) {\n            try {\n                BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file2));\n                BufferedInputStream in = new BufferedInputStream(new FileInputStream(file1));\n                try {\n                    int read;\n                    while ((read = in.read()) != -1) {\n                        out.write(read);\n                    }\n                    out.flush();\n                } catch (IOException ex1) {\n                    ex1.printStackTrace();\n                } finally {\n                    out.close();\n                    in.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static String hash(final String text) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] sha1hash = new byte[40];\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n            return Sha1.convertToHex(sha1hash);\n        } catch (final Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"file1": ["f2", "FILE14", "file0", "FILE3", "f0", "FileOne", "FILE1", "FILE2", "f14", "File3", "File2", "f3", "file3", " fileOne", " file0", "fileOne", " file3", "File14", "fOne", "file14", "File1", "File0", "f1"], "file2": ["fileTo", "model1", "base2", "modelsecond", "filesecond", "file0", "base0", "FILEsecond", "FILE1", "FILE2", "FileTo", "model2", "baseTwo", "modelTo", "Filesecond", "File2", "fileTwo", "FILETo", " fileTwo", "FileTwo", " file0", "base1", "File1", "File0"], "filedata1": ["fledataOne", "filedadaFirst", "fledATA2", "filedATA2", "filedoca1", "fledataFirst", "fledATA1", "filedataOne", "filedadaOne", "filedATAStart", "filedtaOne", "fledATAOne", "filedoca2", "filedtaFirst", "filedocaStart", "filedATA1", "filedata2", "fledata1", "filedta1", "filedataStart", "filedocaOne", "filedataFirst", "fledata2", "filedada2", "fledATAFirst", "fledataStart", "fledATAStart", "filedtaStart", "filedATAFirst", "filedada1", "filedATAOne", "filedta2"], "out": ["source", "size", "inc", "write", "user", "net", "win", "io", "output", "conn", "w", "b", "client", "this", "base", "data", "In", "OUT", "Out", "os", "outs", "again", "writer", "off", "exec", "x", "sync", "name", "init", "o", "ax", "exp", "flush", "ex", "post", "temp", "up", "pool", "pass", "obj", "socket", "file", "error", "lock", "err", "bin", "copy", "line", "ext"], "in": ["source", "reader", "id", "url", "input", "inc", "din", "ic", "win", "connection", "nin", "conn", "con", "b", "login", "f", "In", "pin", "again", "stream", "r", "isin", "inner", "exec", "init", "ins", "o", "gin", "ini", "a", "m", "ex", "sin", "cin", "image", "c", "i", "IN", "err", "inn", "rin", "is", "lin", "bin", "ac", "pass"], "read": ["select", "get", "play", " write", "reader", "size", "input", "write", "line", "feed", "open", "buffer", "Read", "iter", "READ", "io", "ride", "reads", "end", "char", "loop", "f", "sleep", "skip", "data", "stream", "n", "r", "work", "raw", " Read", "exec", "send", "sync", "reading", "allow", "length", "text", "content", "run", "close", "index", "count", "pass", "load", "readable", "connect", "parse", "check", "current", "wait", "start", "add", "copy", "ip", "use", "type"]}}
{"id1": "7727956", "id2": "4003117", "code1": "    public static void createOutputStructure(String templatePath) throws InterruptedException {\n        try {\n            templatePath = new File(templatePath).getCanonicalPath();\n            templatePath = templatePath.replace('\\\\', '/');\n            File file = null;\n            Paths paths = (Paths) GragGenerator.getObjectsFromTree(Paths.class).get(0);\n            Config config = (Config) GragGenerator.getObjectsFromTree(Config.class).get(0);\n            DirectoryIterator iterator = new DirectoryIterator(templatePath, true, true);\n            while ((file = iterator.getNext()) != null) {\n                boolean copyFile = false;\n                String fullFilename = file.getCanonicalPath();\n                int lastDirPos = fullFilename.lastIndexOf(System.getProperty(\"file.separator\"));\n                if (CVS_DIR.equals(file.getCanonicalPath().substring(fullFilename.length() - CVS_DIR.length(), fullFilename.length())) || CVS_DIR.equals(fullFilename.substring(lastDirPos - CVS_DIR.length(), lastDirPos))) {\n                    continue;\n                }\n                if (\"readme.txt\".equals(file.getName())) {\n                    continue;\n                }\n                String fileOut = outputDir.replace('\\\\', '/');\n                String path = file.getCanonicalPath().replace('\\\\', '/');\n                if (path.indexOf(templatePath) == 0) {\n                    path = path.substring(templatePath.length());\n                    if (path.startsWith(Paths.CONF_GENERAL_DIR)) {\n                        path = paths.getConfigOutput() + path.substring(Paths.CONF_GENERAL_DIR.length());\n                        copyFile = true;\n                    } else if (path.startsWith(Paths.CONF_STRUTS_DIR)) {\n                        path = paths.getConfigOutput() + path.substring(Paths.CONF_STRUTS_DIR.length());\n                        copyFile = true;\n                    } else if (path.startsWith(Paths.CONF_TAPESTRY4_DIR)) {\n                        path = paths.getConfigOutput() + path.substring(Paths.CONF_TAPESTRY4_DIR.length());\n                        copyFile = true;\n                    } else if (path.startsWith(Paths.CONF_SWING_DIR)) {\n                        path = paths.getConfigOutput() + path.substring(Paths.CONF_SWING_DIR.length());\n                        copyFile = true;\n                    } else if (path.startsWith(Paths.JAVA_WEB_STRUTS_DIR)) {\n                        path = paths.getJspOutput() + path.substring(Paths.JAVA_WEB_STRUTS_DIR.length());\n                        if (config.matchWebTier(\"struts\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_WEB_TAPESTRY4_DIR)) {\n                        path = paths.getJspOutput() + path.substring(Paths.JAVA_WEB_TAPESTRY4_DIR.length());\n                        if (config.matchWebTier(\"tapestry\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_SWING_DIR)) {\n                        path = paths.getSwingOutput() + path.substring(Paths.JAVA_SWING_DIR.length());\n                        if (config.matchWebTier(\"swing\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_STRUTS_DIR)) {\n                        path = paths.getWebOutput() + path.substring(Paths.JAVA_STRUTS_DIR.length());\n                        if (config.matchWebTier(\"struts\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_TAPESTRY4_DIR)) {\n                        path = paths.getWebOutput() + path.substring(Paths.JAVA_TAPESTRY4_DIR.length());\n                        if (config.matchWebTier(\"tapestry\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_EJB2_DIR)) {\n                        path = paths.getEjbOutput() + path.substring(Paths.JAVA_EJB2_DIR.length());\n                        if (config.matchBusinessTier(\"ejb 2\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_EJB3_DIR)) {\n                        path = paths.getEjbOutput() + path.substring(Paths.JAVA_EJB3_DIR.length());\n                        if (config.matchBusinessTier(\"ejb 3\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_HIBERNATE2_DIR)) {\n                        path = paths.getHibernateOutput() + path.substring(Paths.JAVA_HIBERNATE2_DIR.length());\n                        if (config.matchBusinessTier(\"hibernate 2\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_HIBERNATE3_DIR)) {\n                        path = paths.getHibernateOutput() + path.substring(Paths.JAVA_HIBERNATE3_DIR.length());\n                        if (config.matchBusinessTier(\"hibernate 3\").booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_MOCK_DIR)) {\n                        path = paths.getMockOutput() + path.substring(Paths.JAVA_MOCK_DIR.length());\n                        if (config.useMock().booleanValue()) {\n                            copyFile = true;\n                        }\n                    } else if (path.startsWith(Paths.JAVA_SERVICE_DIR)) {\n                        path = paths.getServiceOutput() + path.substring(Paths.JAVA_SERVICE_DIR.length());\n                        copyFile = true;\n                    } else if (path.startsWith(Paths.JAVA_TEST_DIR)) {\n                        path = paths.getTestOutput() + path.substring(Paths.JAVA_TEST_DIR.length());\n                        copyFile = true;\n                    } else if ((path.indexOf(\"build.bat\") != -1) || ((path.indexOf(\"deploy.bat\") != -1))) {\n                        copyFile = true;\n                    }\n                }\n                if (!path.startsWith(\"/\")) {\n                    path = \"/\" + path;\n                }\n                if (copyFile) {\n                    fileOut += path;\n                    path = outputDir + path;\n                    if (!file.isDirectory()) {\n                        String name = file.getName();\n                        path = path.substring(0, (path.length() - name.length()));\n                    }\n                    new File(path).mkdirs();\n                    if (!file.isDirectory()) {\n                        byte array[] = new byte[1024];\n                        int size = 0;\n                        try {\n                            BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));\n                            BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(fileOut));\n                            while ((size = in.read(array)) != -1) out.write(array, 0, size);\n                            in.close();\n                            out.flush();\n                            out.close();\n                        } catch (Exception exc) {\n                            log(\"[Error] Copy output file failed : \" + fileOut);\n                            log(exc.getMessage());\n                        }\n                    }\n                }\n            }\n        } catch (Exception exc) {\n            log.error(\"Error while copying files: \", exc);\n            log(exc.getMessage());\n        }\n    }\n", "code2": "    public void execute() {\n        check();\n        FTPClient ftp = new FTPClient();\n        try {\n            ftp.connect(host, port);\n        } catch (IOException ex) {\n            throw new BuildException(\"FTP connexion failed : IOException caught (\" + ex.getMessage() + \")\");\n        }\n        if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n            throw new BuildException(\"FTP connexion failed : \" + ftp.getReplyString());\n        }\n        try {\n            try {\n                if (!ftp.login(userid, password)) {\n                    throw new BuildException(\"Identification failed\");\n                }\n            } catch (IOException ex) {\n                throw new BuildException(ex);\n            }\n            if (binary) {\n                try {\n                    ftp.setFileType(FTP.IMAGE_FILE_TYPE);\n                } catch (IOException ex) {\n                    throw new BuildException(ex);\n                }\n                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                    throw new BuildException(\"Transfer type not supported : \" + ftp.getReplyString());\n                }\n            }\n            try {\n                ftp.changeWorkingDirectory(remotedir);\n            } catch (IOException ex) {\n                throw new BuildException(ex);\n            }\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                throw new BuildException(\"Unacessible remote directory : \" + ftp.getReplyString());\n            }\n            String localFullFileName = Files.normalizeDirectoryName(localdir) + remotefile;\n            String remoteFullFileName = (remotedir.endsWith(serverpathseparator) ? remotedir : remotedir + serverpathseparator) + remotefile;\n            BufferedOutputStream outstream = null;\n            try {\n                outstream = new BufferedOutputStream(new FileOutputStream(localFullFileName));\n                ftp.retrieveFile(remoteFullFileName, outstream);\n            } catch (IOException ex) {\n                throw new BuildException(ex);\n            }\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                throw new BuildException(\"File retrieval of '\" + localFullFileName + \"' has failed (\" + ftp.getReplyString() + \")\");\n            }\n        } finally {\n            try {\n                ftp.disconnect();\n            } catch (IOException ex) {\n                System.err.println(\"Disconnexion from \" + host + \":\" + port + \" failed\");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"templatePath": ["sourceDir", "TemplatePath", "viewPath", "layoutFile", "sourceUrl", "themeFolder", "tempPath", "tempFile", "TemplateUrl", "sourceHome", " templateUrl", "templatepath", " templateHome", "TemplateFile", "viewFile", "sourceName", "templateFile", " templatepath", "TemplateName", "themeFile", "viewUrl", "layoutDir", "temppath", "tempTree", "sourceFile", "layoutpath", "templateUrl", "Templatepath", "templateName", "configFile", "templateFolder", "configpath", " templateFile", "configName", "configPath", "themePath", "sourcePath", "tempDir", "templateHome", "viewpath", " templateName", "templateDir", "sourcepath", "TemplateHome", "templateTree", "themeDir", "layoutPath", " templateFolder", " templateDir", "TemplateTree", " templateTree", "TemplateDir", "tempFolder", "tempUrl"], "file": ["source", "get", "folder", "parent", "page", "reader", "ile", "url", "queue", "pe", "connection", "feed", "buffer", "result", "function", "File", "message", "http", "object", "fp", "model", "f", "base", "loader", "data", "directory", "future", "class", "single", "tree", "resource", "handler", "al", "template", "module", "filename", "body", "dir", "full", "e", "log", "comment", "picture", "show", "le", "il", "image", "rule", "leaf", "document", "load", " File", "uri", "socket", "change", "or", "cache", "files", "service", "FILE", "lane", "line", "ie"], "paths": ["PATHubs", "pathls", "Paths", "pathubs", "patternches", "ystems", " optS", "urlls", "ystemubs", "Pathparams", "Pathches", " Pathses", " opts", "Pathses", "Pathubs", "urls", "PATHparams", "pathparams", "PATHls", "PATHs", "urlches", " optses", "patterns", "Pathls", " PathS", "ystemls", "ystemparams", "patternls", "pathches", "PathS", "pathS", " Paths", "pathses"], "config": ["options", " configurations", "Config", "proc", "txt", "settings", "lib", "object", "b", "bc", "f", "data", "directory", "ctx", "sc", "conf", "rc", "log", "ch", "cfg", "cache", "c", "files", "fig", "cal", "ca", "sl", "ext"], "iterator": ["reader", "later", "operator", "ator", "iter", " router", " ste", "keeper", "io", "interstitial", "outer", "engine", "driver", "end", "walker", "loop", "starter", "data", "directory", "stream", "set", "archive", "ators", "info", "inner", "Iter", "started", "inter", "transfer", "init", "eni", "parser", "runner", "transform", "instance", " iteration", "slice", " generator", "uri", "i", "context", "Iterator", "database", "finder", "timer", "collection", "forward", "ie"], "fullFilename": ["fullySourceFile", "fullString", "partialfilename", "FullString", "fullFile", " fullIdent", "FullURI", "fullyURI", " fullSourceFile", "partialFilename", "fulIdent", " fullFile", "FullFile", " fullHandle", "fullIdent", "fullyFilename", " fullDirectory", "fullDirectory", "fulString", "fulFilename", " fullURI", "partialSourceFile", "partialFile", "fullSourceFile", "fullfilename", "completeFile", " fullfilename", "completeSourceFile", "Fullfilename", "FullFilename", "FullSourceFile", " fullString", "FullIdent", "fullURI", "FullHandle", "completeFilename", "fullyHandle", "FullDirectory", "completefilename", "fullyfilename", "fulDirectory", "fullHandle"], "lastDirPos": [" lastFilePosition", "firstCharPos", "firstDirLen", "lastDirPosition", " lastRelPosition", "lastDirectorypos", "lastCharPos", "lastCharLen", "lastLinePosition", "lastdirPos", "lastDIRpos", " lastRelPos", " lastDirDec", "firstCharLen", "lastCharPost", "lastFilePosition", "lastDirectoryDec", " lastFileDec", "lastDirectoryPosition", "lastDIRPos", " lastRelpos", "lastFilePos", " lastFilePos", "firstDirPosition", " lastRelVal", "lastdirPost", "lastFilePost", "lastRelVal", "firstDirPost", "lastdirPosition", "lastCharPosition", "firstCharPost", "lastFileLen", " lastDirPosition", "lastDirDec", " lastDirVal", "lastFileDec", "lastLinePos", "lastDirVal", "lastDirpos", "lastDelPosition", "lastLineVal", "lastRelPosition", "lastdirLen", "lastDirectoryPos", "lastDelpos", "lastDelPos", "lastDIRPosition", "lastRelpos", "lastFilepos", "firstDirPos", "lastDelVal", "lastDIRDec", " lastFilepos", " lastDirpos", "lastDirLen", "lastDirPost", "lastLinepos", "firstCharPosition", "lastRelPos"], "fileOut": ["FileOutput", " fileStr", "fileout", "pathStr", "FileStr", "fileStr", "fileOutput", " fileout", "pathout", "FileOut", "pathOutput", " fileOutput", "pathOut", "Fileout"], "path": ["input", "token", "not", "sign", "PATH", "end", "Path", "model", "directory", "resource", "sync", "method", "log", "image", "list", "reason", "location", "pass", "folder", "id", "xml", "object", "part", "child", "component", "it", "pattern", "key", "index", "point", "str", "value", "port", "source", "page", "parent", "route", "left", "url", "link", "request", "skip", "loc", "version", "work", "template", "module", "full", "text", "string", "pointer", "context", "p", "next", "host", "right", "message", "view", "walk", "root", "prop", "data", "response", "match", "prefix", "inner", "where", "ath", "dir", "target", "json", "password", "transform", "content", "uri", "code", "current", "form", "test", "type"], "copyFile": ["copyfile", " copyDir", " copyTime", "CopyFiles", "CopyTime", "copyPath", "transferFile", "writefile", "CopyFile", "copyFiles", " copyfile", "Copyfile", "CopyPath", "transferPath", "useFile", " copyPath", "useDir", " copyFiles", "copyTime", "transferfile", "CopyDir", "copyDir", "writeFiles", "writeFile", "writeDir", "useFiles", "usefile", "transferTime"]}}
{"id1": "20372195", "id2": "14588787", "code1": "    public static void copy(String a, String b) throws IOException {\n        File inputFile = new File(a);\n        File outputFile = new File(b);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void saveFile(final InputStream inputStream, final String fileName) {\n        final File file = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + fileName);\n        FileOutputStream fileOut = null;\n        try {\n            fileOut = new FileOutputStream(file);\n            IOUtils.copy(inputStream, fileOut);\n        } catch (FileNotFoundException e) {\n            LOGGER.error(\"saveFile() - File Not Found.\" + e);\n        } catch (IOException e) {\n            LOGGER.error(\"saveFile() - Error while saving file.\" + e);\n        } finally {\n            try {\n                inputStream.close();\n                if (fileOut != null) {\n                    fileOut.close();\n                }\n            } catch (IOException e) {\n                LOGGER.error(e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"a": ["source", "sa", "an", "input", "A", "la", "audio", "am", "alpha", "app", "as", "f", "ai", "ac", "sta", "name", "pa", "e", "au", "ae", "area", "ba", "art", "ab", "file", "i", "aa", "ca", "s", "fa", "p"], "b": ["sb", "mb", "d", "be", "pb", "y", "end", "bc", "f", "base", "p", "abb", "bs", "r", "bad", "erb", "ub", "e", "bb", "ob", "abs", "beta", "job", "ba", "xb", "eb", "B", "emb", "ab", "db", "wb", "fb", "boot", "bis", "lb", "bin", "rb", "ib"], "inputFile": ["sourceDir", "parentFile", "inputFolder", "inputfile", "InputDirectory", "sourceFolder", " inputfile", " inputDir", " inputFolder", "Inputfile", " inputDirectory", "sourcefile", "sourceFile", "InputDir", "parentfile", "InputFile", "inputDirectory", "parentDirectory", "inputDir", "InputFolder", "parentDir"], "outputFile": ["inputPath", " outputfile", "inputfile", "Outputfile", " outputPath", "resourceFile", "outputFiles", " outputDir", "resourceFiles", "OutputFiles", "outputfile", " outputFiles", "OutputDir", "outputDir", "OutputFile", "resourcePath", "inputDir", "outputPath", "resourceDir", "resourcefile"], "in": ["source", "get", "reader", "id", "url", "input", "inc", "din", "win", "connection", "pull", "min", "nin", "l", "con", "login", "f", "as", "In", "into", "again", "n", "r", "pin", "isin", "inner", "init", "ins", "o", "e", "ini", "up", "sin", "image", "cin", "file", "i", "IN", "inside", "inn", "rin", "lin", "bin", "s", "ic"], "out": ["parent", "inc", "write", "user", "net", "outer", "io", "output", "one", "w", "client", "ou", "over", "to", "data", "n", "Out", "OUT", "outs", "again", "writer", "off", "exec", "sync", "o", "s", "ex", "temp", "v", "up", "image", "cache", "file", "error", "i", "err", "obj", "is", "at", "outside", "bin", "copy", "line"], "c": ["id", "cd", "d", "uc", "cy", "cu", "cm", "cf", "k", "fc", "l", "w", "char", "f", "ec", "n", "r", "enc", "xc", "ac", "pc", "x", "ci", "u", "rc", "e", "o", "esc", "cl", "t", "m", "lc", "ch", "v", "col", "index", "cr", "count", "pointer", "i", "code", "character", "cc", "ct", "line", "p", "C"]}}
{"id1": "2687277", "id2": "10895680", "code1": "    @Override\n    protected void copy(Reader reader, OutputStream outputs) throws IOException {\n        if (outputs == null) {\n            throw new NullPointerException();\n        }\n        if (reader == null) {\n            throw new NullPointerException();\n        }\n        ZipOutputStream zipoutputs = null;\n        try {\n            zipoutputs = new ZipOutputStream(outputs);\n            zipoutputs.putNextEntry(new ZipEntry(\"default\"));\n            IOUtils.copy(reader, zipoutputs);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw e;\n        } finally {\n            if (zipoutputs != null) {\n                zipoutputs.close();\n            }\n            if (reader != null) {\n                reader.close();\n            }\n        }\n    }\n", "code2": "    private DefaultMutableTreeNode parseTree() {\n        try {\n            DefaultMutableTreeNode root;\n            URL url = RebusHelp.class.getResource(\"/org/olga/rebus/gui/help/html/content.xml\");\n            InputStream is = url.openStream();\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(true);\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            Document document = parser.parse(is);\n            NodeList elements = document.getElementsByTagName(\"help\");\n            Element element = (Element) elements.item(0);\n            root = createTreeContent(element);\n            is.close();\n            return root;\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            return null;\n        } catch (ParserConfigurationException e1) {\n            System.out.println(e1.getMessage());\n            return null;\n        } catch (org.xml.sax.SAXException e2) {\n            System.out.println(e2.getMessage());\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"reader": ["source", "read", "input", "rar", "Reader", "feed", "buffer", "director", "iter", "ser", "keeper", "io", "audio", "out", "ler", "driver", "row", "loader", "data", "oder", "ruby", "stream", "r", "zip", "resource", "handler", "server", "riter", "editor", "writer", "her", "inner", "ipper", "er", "iver", "rer", "e", "report", "reading", "per", "cer", "parser", "dr", "book", "pointer", "library", "file", "i", "err", "or", "builder", "manager", "database", "ner", "entry"], "outputs": ["inputs", "inputes", "outputories", "inputats", "pathes", "outputfs", "outputats", "Outputfs", "inputments", "inputd", "inputtypes", "Outputs", " outputfs", "pathfs", " outputories", "Outputories", "Outputd", "paths", " outputments", "inputfs", " outputd", "outputments", "Outputments", " outputtypes", "outputd", "outputes", "inputories", "outputtypes", "Outputats", " outputats", "pathtypes", " outputes"], "zipoutputs": ["zipoutputches", "zoneoutputs", "zipcontrolws", "zipplatforms", "ziplogfs", "zipdownloadp", "zipinputstream", "Zipinputfs", "zipdirs", "zipcontrolses", "zipdirws", "zipdownloadps", "zipcontrols", "Zipoutputs", "zipdownloadds", "zoutputws", "zoneoutputstream", "zOutputws", "zipOutputils", "zipoutputils", "zipOutputts", "zipplatformps", "zoneinputs", "ziplogs", "zOutputses", "zipcontrolts", "zoutputses", "zoutputls", "ziplogts", "zipOutputs", "zipinputts", "ziplogos", "zipplatformses", "zoutputts", "Zipoutputos", "zipinputp", "zipinputfs", "zoneinputstream", "zipoutputts", "zipOutputls", "zipoutputos", "zOutputs", "zoutputches", "zoutputp", "zipoutputls", "zipOutputws", "zipdownloadches", "Zipinputts", "Zipoutputts", "zipdownloadts", "zipdownloads", "zoneoutputts", "zipdirils", "zoneoutputds", "zOutputp", "zoneinputds", "zipcontrolps", "zipoutputps", "zipOutputos", "zOutputches", "zipplatformts", "zipinputds", "zipinputs", "zipinputos", "zipOutputds", "zipOutputches", "zOutputps", "zOutputts", "zoutputils", "zipoutputfs", "zipOutputses", "zipinputps", "zipoutputstream", "zipoutputds", "zipdirps", "Zipinputos", "Zipinputs", "zipOutputfs", "zipoutputses", "zipinputches", "zipinputls", "zOutputils", "zipOutputp", "zipOutputstream", "zoutputs", "Zipoutputfs", "zoneinputts", "zipOutputps", "zoutputps", "zOutputls", "zipoutputp", "zipdownloadstream", "zipcontrolils", "zipoutputws"]}}
{"id1": "8172652", "id2": "8075979", "code1": "    @Test\n    @JUnitHttpServer(port = 10342, https = false, webapps = { @Webapp(context = \"/fmpm\", path = \"src/test/resources/test-webapp\") })\n    public void testTestServlet() throws Exception {\n        TestServlet.reset();\n        HttpClient client = new DefaultHttpClient();\n        HttpEntity entity = new StringEntity(xml);\n        HttpPost method = new HttpPost(\"http://localhost:10342/fmpm/restful/NotificationMessageRelay\");\n        method.setEntity(entity);\n        HttpResponse response = client.execute(method);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(xml, TestServlet.getPosted());\n    }\n", "code2": "    private URLConnection tryOpenConnection(String url) throws RuntimeException {\n        URLConnection connection = null;\n        try {\n            connection = new URL(\"https://\" + url).openConnection();\n            connection.getInputStream();\n            connection = new URL(\"https://\" + url).openConnection();\n            return connection;\n        } catch (Exception e) {\n            Log.w(\"ERROR\", \" \" + e.getStackTrace()[0]);\n        }\n        try {\n            connection = new URL(\"http://\" + url).openConnection();\n            connection.getInputStream();\n            connection = new URL(\"http://\" + url).openConnection();\n            return connection;\n        } catch (Exception e) {\n            Log.w(\"ERROR\", \" \" + e.getStackTrace()[0]);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"client": ["host", "url", "connection", "plugin", "output", "conn", "http", "con", "app", "request", "channel", "https", "application", "resource", "handler", "server", "child", "config", "force", "per", "cl", "api", "Client", "cli", "m", "session", "pool", "cache", "c", "context", "service", "ce", "proxy", "project", "web", "collection"], "entity": ["translation", "url", "pe", "ent", "xml", "message", "output", "security", "object", "model", "ep", "environment", "data", "ec", "enc", "resource", "email", "server", "el", "element", "component", "body", "event", "e", "Entity", "json", "instance", "text", "content", "agent", "string", "document", "file", "code", "attribute", "em", "collection", "null"], "method": ["Method", "POST", "route", "operation", "url", "wrapper", "term", "plugin", "build", "function", "message", "http", "request", "this", "end", "object", "model", "data", "METHOD", "stream", "remote", "r", "resource", "server", "call", "address", "module", "send", "event", "report", "api", "instance", "rh", "post", "m", "content", "trip", "path", "document", "record", "uri", "each", "command", "service", "header", "array", "invoke", "manager", "process", "subject", "hod", "form", "project", "collection", "ip", "p"], "response": ["page", "respond", "site", "connection", "success", "reply", "result", "message", "output", "http", "request", "object", "model", "channel", "application", "data", "version", "resource", "server", "child", "writer", "body", "report", "json", "api", "content", "status", "Response", "document", "resp", "received", "collection"]}}
{"id1": "16030263", "id2": "12631774", "code1": "    public static String md5(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            return ForumUtil.bufferToHex(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static String getMd5Hash(String plaintext) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(plaintext.getBytes());\n            byte[] digest = md5.digest();\n            BigInteger bigInt = new BigInteger(1, digest);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            return hashtext;\n        } catch (final NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"text": ["source", "contract", "input", "TEXT", "txt", "connection", "buffer", "message", "output", "format", "letter", "out", "object", "this", "in", "Text", "data", "hex", "bytes", "class", "editor", "config", "template", "name", "method", "pattern", "target", "password", "content", "key", "string", "path", "image", "obj", "font", "code", "struct", "secret", "str", "ext"], "md": ["um", "hash", "cd", "bf", "d", "mb", "dd", "material", "hd", "message", "ma", "mm", "pd", " MD", "gd", "wd", "sm", "pg", "cmd", "ms", "f", "po", "mo", "mac", "bd", "di", "bm", "mand", "editor", "mag", "meta", "mc", "kg", "mp", "dm", "mod", "rm", "MD", "mt", "m", "od", "pm", "mg", "mad", "metadata", "amd", "nm", "dig", "ad"]}}
{"id1": "4540202", "id2": "411630", "code1": "    public void myClickHandler(View view) {\n        switch(view.getId()) {\n            case R.id.ReadWebPage:\n                try {\n                    textView.setText(\"\");\n                    URL url = new URL(urlText.getText().toString());\n                    BufferedReader rd = new BufferedReader(new InputStreamReader(url.openStream()));\n                    String line = \"\";\n                    while ((line = rd.readLine()) != null) {\n                        textView.append(line);\n                    }\n                } catch (Exception e) {\n                    System.out.println(\"Nay, did not work\");\n                    textView.setText(e.getMessage());\n                }\n                break;\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"view": ["source", "page", "route", "reader", "id", "input", "link", "layout", "review", "message", "widget", "object", "out", "this", "controller", "model", "row", "stream", "response", "resource", "View", "server", "template", "element", "update", "action", "event", "e", "VIEW", "see", "container", "content", "v", "session", "window", "index", "change", "image", "context", " View", "item", "block", "views", "iew"], "url": ["source", "page", "ball", "reader", "connection", "feed", "ll", "output", "src", "l", "conn", "http", "client", "fr", "channel", "data", "stream", "r", "resource", "email", "server", "address", "ur", "log", "api", "text", "bel", "fl", "ls", "string", "path", "rl", "file", "uri", "ssl", "db", "URL", "service", "Url", "www", "blog", "web", "sl"], "rd": ["reader", "cd", "ra", "d", "rx", "rowd", "ded", "dig", "dd", "ld", "xd", "vd", "pd", "wd", "ird", "fd", "fr", "idd", "red", "bd", "std", "r", "rob", "rg", "erd", "rs", "rod", "rh", "dr", "adr", "hr", "ri", "rl", "rw", "rt", "rr", "ds", "nd", "dra", "rb", "RD"], "line": ["page", "split", "link", "feed", "buffer", "lf", "lines", "message", "l", "letter", "char", "val", "LINE", "cell", "end", "Line", "row", "part", "data", "inline", "style", "response", "strip", "el", "word", "name", "e", "unit", "cl", "text", "comment", "content", "lc", "key", "string", "rule", "frame", "point", "pass", "file", "error", "code", "character", "block", "lin", "str", "sl", "entry"]}}
{"id1": "11270196", "id2": "14356579", "code1": "    public static String encipherAMessage(String message) {\n        try {\n            MessageDigest sha1 = MessageDigest.getInstance(java.util.ResourceBundle.getBundle(\"com/jjcp/resources/Strings\").getString(\"SHA1\"));\n            sha1.update(message.getBytes(java.util.ResourceBundle.getBundle(\"com/jjcp/resources/Strings\").getString(\"UTF-16LE\")));\n            byte[] digest = sha1.digest();\n            BASE64Encoder base64encoder = new BASE64Encoder();\n            String cipherTextB64 = base64encoder.encode(digest);\n            return cipherTextB64;\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(SelectorView.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(SelectorView.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return \"\";\n    }\n", "code2": "    public String getRandomGUID() {\n        MessageDigest md5 = null;\n        String valueBeforeMD5 = \"\";\n        String retValue = \"\";\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            InetAddress id = InetAddress.getLocalHost();\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            rand = random.nextLong();\n            sbValueBeforeMD5.append(id.toString());\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            retValue = sb.toString();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error:\" + e);\n        }\n        return retValue;\n    }\n", "label": 1, "substitutes": {"message": ["source", "url", "queue", "msg", "buffer", "result", "username", "Message", "definition", "object", "request", "description", "application", "hello", "data", "phrase", "stream", "response", "resource", "match", "email", "server", "address", "body", "e", "password", "text", "m", "content", "mail", "essage", "string", "image", "document", "load", "file", "attribute", "array", "header", "mess", "subject", "value"], "sha1": [" SHA16", "sha16", "ma1", "mac64", "sha256", "md64", "sha64", " SHA64", "SHA16", "SHA2", "a64", " SHA1", "mac1", "md1", "mac256", "ma16", "SHA256", "a1", "SHA1", " SHA2", "ma2", "SHA64", "ma64", "sha2", "a256"], "digest": ["digger", "digester", "digoder", "signester", "keyger", "generode", "DigEST", "genest", "Digger", "generoder", "keyester", "reddig", "redoder", "digode", "generdig", "signested", "signEST", "hashdig", "Digoded", "generest", "digoded", "digEST", "genester", "Digester", "redode", "Digested", "hashoder", " digEST", "keyoded", "keyest", "hashode", "genger", " digester", "signest", "hashest", "digdig", "digested", " digested", "Digest", "genoded", "redest"], "base64encoder": ["base32encoding", "base64ecoder", "base32encoder", "base64Encoder", "base58Encoder", "base64Encoser", "base32encipher", "base64Encode", "base58encoding", "base64enoding", "base58encode", "base64enode", "base64ecoded", "base58Encoding", "base58encoded", "base64encoding", "base58Encode", "base32encoser", "base64ecode", "base64decoder", "base64encipher", "base64Encipher", "base64Encoding", "base64encode", "base64ecoding", "base64decoser", "base64enoder", "base64decipher", "base64encoser", "base58encoder", "base58Encoded", "base64decoding", "base64enoded", "base64encoded", "base64Encoded"], "cipherTextB64": ["ciphertextB16", "ciphertextB64", "cipherTextF256", "cipherTextF16", "cipherTextB32", "cipherTextBase16", "cipherTextb64", "cipherTextF48", "cipherTextA48", "cipherTextBase32", "cipherTextB48", "cipherTextA256", "cipherTextA16", "cipherTextB256", "ciphertextA64", "cipherTextBase256", "ciphertextA256", "cipherTextBase64", "cipherTextF32", "ciphertextA48", "ciphertextB256", "ciphertextA16", "cipherTextF64", "cipherTextb32", "ciphertextB48", "cipherTextB16", "cipherTextb256", "cipherTextA64", "cipherTextBase48"]}}
{"id1": "20004216", "id2": "11902597", "code1": "        public boolean check(Object credentials) {\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5) {\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                } else {\n                    md.update(username.getBytes(StringUtil.__ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StringUtil.__ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StringUtil.__ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                md.reset();\n                md.update(method.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StringUtil.__ISO_8859_1));\n                byte[] ha2 = md.digest();\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StringUtil.__ISO_8859_1));\n                byte[] digest = md.digest();\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n            } catch (Exception e) {\n                log.warn(LogSupport.EXCEPTION, e);\n            }\n            return false;\n        }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Start filtering zgps...\");\n        final Config config = Gbl.createConfig(args);\n        final String CONFIG_MODULE = \"GPSFilterZGPS\";\n        File sourceFileSelectedStages = new File(config.findParam(CONFIG_MODULE, \"sourceFileSelectedStages\"));\n        File sourceFileZGPS = new File(config.findParam(CONFIG_MODULE, \"sourceFileZGPS\"));\n        File targetFile = new File(config.findParam(CONFIG_MODULE, \"targetFile\"));\n        System.out.println(\"Start reading selected stages...\");\n        FilterZGPSSelectedStages selectedStages = new FilterZGPSSelectedStages();\n        selectedStages.createSelectedStages(sourceFileSelectedStages);\n        System.out.println(\"Done. \" + selectedStages.getSelectedStages().size() + \" stages were stored\");\n        System.out.println(\"Start reading and writing zgps...\");\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFileZGPS)));\n            BufferedWriter out = new BufferedWriter(new FileWriter(targetFile));\n            out.write(in.readLine());\n            out.newLine();\n            String lineFromInputFile;\n            while ((lineFromInputFile = in.readLine()) != null) {\n                String[] entries = lineFromInputFile.split(\"\\t\");\n                if (selectedStages.containsStage(Integer.parseInt(entries[0]), Integer.parseInt(entries[1]), Integer.parseInt(entries[2]))) {\n                    out.write(lineFromInputFile);\n                    out.newLine();\n                    out.flush();\n                }\n            }\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find source file for selected stages.\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.out.println(\"IO Exception while reading or writing zgps.\");\n            e.printStackTrace();\n        }\n        System.out.println(\"Done.\");\n    }\n", "label": 0, "substitutes": {"credentials": ["chedmissions", "chedents", "cronential", "cargentials", "coururation", "Credmissions", "creditsential", "cribents", "chedlins", "courmissions", "chedlaus", "credlaus", "courential", "carpmissions", "criblines", "chedkins", "cribential", "carguration", "condaentials", "Credlins", "creditsences", "Credents", "Chedential", "condalaus", "Credential", "carpuration", "cronentials", "cronmissions", "chedential", "crafential", "Cheduration", "crafkins", "cheduration", "Credlaus", "Credlines", "cribentials", "Chedents", "credmissions", "credential", "cntential", "Chedlaus", "credents", "Chedentials", "condalins", "Creduration", "Chedences", "condaences", "credlines", "carpentials", "cntmissions", "credences", "crafentials", "chedentials", "cargents", "cronlins", "cronences", "creduration", "chedences", "Chedlins", "Credences", "courentials", "cargential", "cntentials", "creditsentials", "condaential", "Credkins", "Credentials", "chedlines", "credlins", "craflines", "cribkins", "carpential", "cntences", "Chedlines", "credkins", "Chedkins", "criburation", "Chedmissions", "creditslaus"], "password": [" Password", "hash", "user", "token", "auth", "sword", "nick", "username", "message", "wd", "security", "cmd", "channel", "phrase", " username", "prefix", "server", "address", "word", "alias", "name", "method", "ssh", "device", "param", "text", "session", " credential", "key", "string", "path", "agent", "uri", "code", "attribute", "secret", "sudo", "Password", "crypt", "account", "staff", "pass"], "md": ["cd", "d", "dd", "ld", "hd", "mm", "doc", "mac", "hm", "meta", "old", "mod", "nt", "ok", "od", "pm", "mr", "nd", "amd", "em", " cmd", "msg", "lf", "mid", "ht", "dev", "pd", "mode", "bd", "mc", "gm", "dm", "de", "MD", "mail", "html", "self", "ad", "mn", "dc", "om", "my", "ind", " MD", "sm", "ma", "cmd", "git", "bm", "n", "mand", "mag", "module", "sha", "sym", "kg", "_", "mt", "ml", "mg", "Cmd", "ds", "metadata", "nm", "s", "pkg", "mb", "cm", "wd", "ms", "mo", "di", "mu", "dn", "body", "mp", "rm", " dd", "m", "db", "ng", "mi"], "ha1": ["vaone", "shaOne", "ha4", "la3", "haX", "ha3", "HA81", "HAOne", "haone", "va0", "haOne", "wa1", "la1", "va2", "wa8", "sha81", "la4", "wa3", "va1", "shaone", "HAX", "ha0", "sha0", "ya1", "wa2", "sha1", "la8", "sha8", "HA2", "HA1", "sha4", "la2", "HAone", "vaX", "shaX", "ha8", "ya81", "sha3", "va4", "sha2", "ha81", "yaOne", "ya2", "la0"], "ha2": ["ha6", "ha4", "na1", "wa1", "la1", "wa0", "va2", "na4", "la4", "va1", "ha0", "na2", "sha0", "wa2", "sha1", "va6", "sha4", "la2", "sha6", "va4", "sha2", "la0", "na6", "wa4"], "digest": ["decert", "decest", "digitested", "digester", "DigEST", "decher", "ngEST", "digitest", "Digher", "Digert", "digEST", "Digester", "Digested", "ngest", "digher", " digester", "digitester", "decEST", "digested", "ngher", "digert", " digested", "Digest", "ngert"]}}
{"id1": "11129960", "id2": "18760096", "code1": "    public static String getGoGl(final String urlPath, String key) {\n        log.debug(\"getGoGl url \" + urlPath);\n        log.debug(\"getGoGl key \" + key);\n        String shortUrl = null;\n        URL simpleURL = null;\n        HttpsURLConnection url = null;\n        BufferedInputStream bStream = null;\n        StringBuffer resultString = new StringBuffer(\"\");\n        String inputString = \"{\\\"longUrl\\\":\\\"\" + urlPath + \"\\\"}\";\n        log.debug(\"getGoGl inputString \" + inputString);\n        try {\n            simpleURL = new URL(\"https://www.googleapis.com/urlshortener/v1/url?key=\" + key);\n            url = (HttpsURLConnection) simpleURL.openConnection();\n            url.setDoOutput(true);\n            url.setRequestProperty(\"content-type\", \"application/json\");\n            PrintWriter pw = new PrintWriter(url.getOutputStream());\n            pw.print(inputString);\n            pw.close();\n        } catch (Exception ex) {\n            log.error(ex);\n            shortUrl = urlPath;\n        }\n        try {\n            bStream = new BufferedInputStream(url.getInputStream());\n            int i;\n            while ((i = bStream.read()) >= 0) {\n                resultString.append((char) i);\n            }\n        } catch (Exception ex) {\n            SocialUtils.log.error(ex);\n            shortUrl = urlPath;\n        }\n        return shortUrl;\n    }\n", "code2": "    protected String saveJar2TmpFile(String jarUrl, boolean reportError) {\n        InputStream is = null;\n        try {\n            URL url = new URL(jad.getJarURL());\n            URLConnection conn = url.openConnection();\n            if (url.getUserInfo() != null) {\n                String userInfo = new String(Base64Coder.encode(url.getUserInfo().getBytes(\"UTF-8\")));\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + userInfo);\n            }\n            is = conn.getInputStream();\n            File tmpDir = null;\n            String systemTmpDir = MIDletSystemProperties.getSystemProperty(\"java.io.tmpdir\");\n            if (systemTmpDir != null) {\n                tmpDir = new File(systemTmpDir, \"microemulator-apps\");\n                if ((!tmpDir.exists()) && (!tmpDir.mkdirs())) {\n                    tmpDir = null;\n                }\n            }\n            File tmp = File.createTempFile(\"me2-app-\", \".jar\", tmpDir);\n            tmp.deleteOnExit();\n            IOUtils.copyToFile(is, tmp);\n            return IOUtils.getCanonicalFileClassLoaderURL(tmp);\n        } catch (IOException e) {\n            if (reportError) {\n                Message.error(\"Unable to open jar \" + jarUrl, e);\n            }\n            return null;\n        } finally {\n            IOUtils.closeQuietly(is);\n        }\n    }\n", "label": 0, "substitutes": {"urlPath": [" urlContext", "blogInfo", "UrlString", "resourceFull", "urlUrl", "URLCry", "uriPoint", "urlPart", " urlPATH", " urlUrl", "Urlpath", " urlString", "workInfo", "shortCry", "emailUrl", "urlPATH", "urlpath", "shortpath", "UrlContext", " urlInfo", "URLPoint", "uriLocation", " urlPoint", "uriPath", " urlpath", "resourceContext", "workPath", "blogPATH", "urlLocation", "URLPart", "URLInfo", "shortPart", "emailpath", "resourceUrl", "URLpath", "shortPath", "workPATH", " urlLocation", "URLLocation", "urlInfo", "urlCry", " urlCry", "URLPath", " urlFull", "urlString", "emailPath", "blogPath", "UrlPath", "urlFull", "resourcePath", "emailFull", "urlPoint", "uriInfo", "resourcepath", " urlPart", "resourceString", "urlContext"], "key": ["page", "parent", "value", "id", "hash", "link", "my", "token", "year", "right", "keys", "k", "ry", "sign", "y", "license", "part", "mode", "base", "row", "by", "phrase", "Key", "mac", "enc", "resource", "ie", "KEY", "where", "name", "query", "ace", "json", "password", "text", "ey", "time", "index", "string", "path", "list", "cert", "cache", "lock", "ssl", "error", "code", "date", "secret", "service", "lease", "is", "kw", "order", "which", "kid", "reason", "str", "ip", "type"], "shortUrl": ["rightLine", "privateLink", "privateURL", "longPage", "actUrl", "actPage", "nextPath", "rightURL", "longURL", " shortLine", "longLink", "rightLink", "ShortUrl", " shortURL", " shortLink", "rawURL", " shortPage", "longUr", "nextURL", "ShortPath", "actURL", "shortEmail", "shortLink", "longUrl", "nextUr", "longPath", "shortURL", "ShortLine", "shortPath", "actEmail", "rawUr", "nextUrl", "shortLine", "rawUrl", "ShortLink", "rawPath", "ShortURL", "privateUrl", "privatePath", " shortEmail", "shortUr", "rightUrl", "shortPage", "longEmail"], "simpleURL": ["easyBB", " simpleFile", "prettyUrl", "SimpleURL", "simpleUrl", "SimpleURI", "simpleHTTP", "SimpleBB", "prettyGR", "prettyURL", "easyHTTP", "SimpleHTTP", " simpleSSL", "simpleURI", "simpleBB", "SimpleSSL", "basicURI", "SimpleUrl", "simpleFile", "basicURL", "easyURL", " simpleBB", "prettyHTTP", " simpleUrl", "simpleSSL", "simpleGR", "easyUrl", "SimpleGR", "basicFile", " simpleURI", "easySSL", "easyGR", "SimpleFile", "basicUrl"], "url": ["rel", " impl", "now", "l", "channel", "resource", "call", "address", "sync", "bb", "log", "cl", "image", "impl", "file", "ssl", "web", "ll", "location", "id", "feed", "xml", "build", "ul", "object", "b", "ver", "update", "ob", "atom", "job", "html", "URL", "Url", "www", "str", "source", "page", "user", "link", "browser", " server", " curl", "http", " library", "client", "base", "f", "https", "git", "loc", " factory", "org", "server", "el", " config", "string", "path", "date", " internet", " http", "use", "host", "connection", "pull", "out", "lr", "layer", "config", " timeout", "api", "bel", "fl", "li", "socket", "uri", "proxy", "blog", "both", " protocol", "coll", "sl"], "bStream": ["brThread", "lStream", "fbstream", "iStream", " bThread", "lWriter", "bbStream", "lbWriter", "iString", "lSteam", "iPath", "bstream", " bStack", "pPath", "pStream", "fbWriter", " bMode", "bbThread", "bbStack", "brSteam", "bbSteam", "bMode", "bPath", " bSteam", "iMode", "bSteam", "lbSteam", "bThread", "lbstream", "bString", "brStack", "fbStream", "bStack", "brStream", " bString", "lstream", "fbSteam", "pMode", "lbStream", "bWriter", " bPath", "pString"], "resultString": ["returnString", "outputStream", " resultLine", " resultArray", "resultsString", "answerString", "resultLine", "returnArray", "answerLine", "ResultStr", "returnStream", "outputBuffer", "resultsStream", " resultStr", "resultsArray", "resultBuffer", "outputString", "answerStr", "resultStr", "resultArray", "ResultLine", "ResultString", "resultsBuffer", "resultStream", "ResultArray", "outputArray", "answerArray", "returnBuffer"], "inputString": ["resultData", "inputPath", "outputStream", "InputStr", " inputArray", "requestStream", "submitString", "requeststring", "InputStream", "InputPath", " inputPath", "outputString", " inputstring", " inputData", " inputStr", "submitPath", "resultStr", "inputData", "resultstring", "outputData", "inputArray", "resultArray", "submitstring", "requestString", "inputstring", " inputStream", "resultStream", "Inputstring", "InputString", "outputArray", "inputStr", "requestArray", "submitStream", "inputStream", "InputArray"], "pw": ["psW", " pwb", "pswa", " pwr", "Pwa", "pwr", "ptw", " pW", "pwb", "lpW", "apwa", "lpwr", "apW", "fw", "pW", "PW", "pwa", "frw", "Prw", "prw", "Pw", "fW", "Pwb", "lpw", "apwb", "apw", "fwa", " ptw", "psw", "Ptw", "psrw", "Pwr", " pwa", "lptw"], "i": ["id", "d", "si", "qi", "multi", "phi", "io", "k", "limit", "l", "b", "f", "di", "n", "zi", "bi", "I", "mu", "oi", "ji", "ai", "info", "r", "gi", "x", "ui", "ci", "u", "e", "length", "t", "ini", "a", "m", "li", "v", "xi", "index", "ri", "count", "j", "c", "ii", "pi", "is", "chi", "z", "line", "ip", "p", "ie"]}}
{"id1": "19388622", "id2": "8581121", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static String hexHash(Object obj) {\n        String toHash = obj.toString();\n        try {\n            MessageDigest dg = MessageDigest.getInstance(\"MD5\");\n            dg.update(toHash.getBytes(\"UTF-8\"));\n            return bytesToHex(dg.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error while hashing string: \" + toHash, e);\n        }\n    }\n", "label": 1, "substitutes": {"secure": ["host", "active", "protect", "require", "deep", "safe", "secondary", "pure", "security", "Secure", "stable", "https", "remote", "zip", "smart", "server", "config", "external", "random", "force", "depth", "relative", " insecure", "allow", "sr", "exclusive", "timeout", "session", "sec", "confirmed", "seed", "debug", "encrypted", "ssl", "sensitive", "quiet", "service", "secret", "unsigned", "proxy", "weak", "use"], "md5": ["mand3", "mand85", "cmd2", " MD512", "cmd512", "md3", "MD13", " md256", " MD2", "mand2", "MD5", "mand5", "MD85", " MD5", "md305", "MD512", "md85", "MD3", "md512", " MD305", "md256", "md13", " md85", "mand256", "mand512", "cmd5", "cmd305", "MD2", " MD3", " md13", "md2", " md2", " md305", " MD13", " md512", " md3", "MD256"], "sbValueBeforeMD5": ["sbValueBeforemd85", "sbValueBeforeMDle", "sbValueBeforeMD3", "sbValueBeforeVM3", "sbValueBeforeMC512", "sbValueWithoutSHA3", "sbValueBeforeMA15", "sbValueBeforeMOD85", "sbValueAfterMD85", "sbValueBeforeMD1", "sbValueBeforeMP7", "sbValueBeforeHTML50", "sbValueBeforeMN145", "sbValueBeforeMSle", "sbValueBeforemd8", "sbValueBeforeMS3", "sbValueWithoutSHA512", "sbValueBeforeMP145", "sbValueBeforeHTML7", "sbValueBeforeMAC50", "sbValueBeforeMAC15", "sbValueWithoutVM145", "sbValueAfterMD7", "sbValueBeforeVM145", "sbValueBesidesMF7", "sbValueBeforeSHA5", "sbValueWithoutMD145", "sbValueAfterMS85", "sbValueBeforeMOD5", "sbValueBeforeMF5", "sbValueBeforeMSLink", "sbValueBeforeAMD3", "sbValueBeforeVM5", "sbValueWithoutMD1", "sbValueBesidesMF5", "sbValueAfterMD5", "sbValueBesidesMF85", "sbValueBeforeSHA512", "sbValueBeforeMP50", "sbValueAfterMD3", "sbValueAfterMD15", "sbValueWithoutSHA1", "sbValueAfterMS5", "sbValueBeforeMD512", "sbValueBeforeM3", "sbValueBeforeMP25", "sbValueBeforeMD8", "sbValueBeforeMF7", "sbValueAfterAMD15", "sbValueBesidesMD8", "sbValueBeforeMAC5", "sbValueBeforeMP3", "sbValueWithoutMD3", "sbValueBesidesMDLink", "sbValueBeforemd3", "sbValueBeforemdle", "sbValueBeforeMD43", "sbValueWithoutVM25", "sbValueBeforeHTML3", "sbValueBeforeMAC43", "sbValueBeforeMD25", "sbValueBeforeMAC7", "sbValueBeforeMD7", "sbValueAfterMP3", "sbValueWithoutVM3", "sbValueWithoutMD5", "sbValueBeforeM512", "sbValueBeforeMOD3", "sbValueBeforeMC1", "sbValueBesidesMD7", "sbValueBeforeMC5", "sbValueBeforeMN25", "sbValueBeforeMS7", "sbValueBeforeMN3", "sbValueBeforeAMD15", "sbValueBeforeVM25", "sbValueBesidesMD85", "sbValueBeforeM5", "sbValueAfterMD43", "sbValueBeforeAMD5", "sbValueBeforeMF85", "sbValueWithoutMD512", "sbValueBeforeAMD43", "sbValueAfterMDle", "sbValueBeforeMN5", "sbValueBeforeM1", "sbValueBeforeMS5", "sbValueBeforeMA5", "sbValueBeforeMD85", "sbValueWithoutMD25", "sbValueBeforeMS85", "sbValueWithoutVM5", "sbValueAfterMP7", "sbValueAfterAMD3", "sbValueBeforeMF3", "sbValueBeforeMD50", "sbValueBeforeSHA3", "sbValueBeforeMD15", "sbValueBeforeMA43", "sbValueBeforeMDLink", "sbValueAfterMP50", "sbValueBeforeSHA1", "sbValueAfterMS3", "sbValueBeforemd7", "sbValueBeforeMD145", "sbValueBeforeMC3", "sbValueAfterAMD5", "sbValueBeforemdLink", "sbValueBeforeMS8", "sbValueBeforemd5", "sbValueBeforeMP5", "sbValueAfterMD50", "sbValueAfterMP5", "sbValueBesidesMF3", "sbValueAfterMSle", "sbValueBeforeHTML5", "sbValueBeforeMA3", "sbValueAfterAMD43", "sbValueBesidesMD3", "sbValueWithoutSHA5", "sbValueBeforeMAC3", "sbValueBeforeMODle", "sbValueBesidesMD5"], "time": ["host", "size", "id", "user", "hour", "race", "year", "counter", "tim", "tz", "clock", "mode", "loc", "sleep", "version", "serial", "work", "ime", "random", "etime", "depth", "name", "event", "length", "cost", "money", "timeout", "count", "seed", "delay", "error", "TIME", "speed", "date", "Time", "start", "timer", "rate", "value", "port", "month", "duration", "type"], "rand": ["id", "rar", "rank", "win", "year", "lang", "mid", "range", "right", "ro", "dev", "winner", "root", "bug", "gen", "version", "serial", "r", "clean", "round", "rage", "random", "depth", "rc", "pattern", "patch", "length", "max", "rh", "raid", "bit", "index", "rule", "count", "seed", "reg", "delay", "error", "rr", "q", "dist", "order", "ng", "rate", "Rand", "alpha", "pick", "type"], "valueBeforeMD5": ["valueBeforeAMD2", "valueBeforeMC3", "valueBeforeMF25", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAfterMD25", "valueBeforeMP50", "valueBeforeAMD3", "valueAfterAMD3", "valueBeforeMF2", "valueAfterMD3", "valueBeforeMP2", "valueBeforeME5", "valueAfterAMD5", "valueBeforeMD3", "valueBeforeMD25", "valueBeforeME3", "valueBeforeAMD50", "valueBeforeAMD5", "valueBeforeMD50", "valueBeforeMF3", "valueAfterAMD50", "valueBeforeMC2", "valueBeforeMF5", "valueAfterMD50", "valueBeforeME2", "valueAfterAMD2", "valueAfterMD2", "valueBeforeMC5", "valueBeforeMC25", "valueBeforeME50"], "array": ["hash", "binary", "our", "Array", "arr", "range", "arrow", "function", "result", "message", "audio", "view", "object", "app", "ray", "row", "number", "data", "r", "integer", "pair", "archive", "feature", "address", "angle", "element", "section", "shape", "batch", "allow", "api", "instance", "a", "area", "v", "abc", "index", "string", "image", "list", "record", "error", "expression", "map", "database", "value", "collection", "sample"], "sb": ["sa", "cb", "tmp", "bf", "mb", "bh", "nn", "si", "binary", "buffer", "usb", "sg", "bg", "pb", "BB", "src", "sf", "bc", "kb", "bm", "abb", "obb", "bs", "rob", "sup", "bj", "SB", "bb", " SB", "sv", "zb", "buf", "gb", "xb", "eb", "ib", "orb", "bsp", "ab", "bt", "wb", "fb", "sq", "lab", "nb", "bis", "lb", "s", "rb", "bp", "bl"], "j": ["jj", "d", "br", "J", "jp", "k", "l", "y", "jo", "ja", "part", "aj", "f", "ij", "n", "ji", "adj", "js", "x", "bj", "o", "e", "uj", "dj", "length", "pr", "ch", "job", "li", "v", "key", "jc", "dy", "index", "obj", "c", "i", "ii", "im", "code", "jl", "oj", "q", "z", "p", "ie"], "b": ["cb", "bf", "d", "mb", "be", "br", "BB", "pb", "l", "y", "bc", "bug", "f", "p", "bd", "n", "bs", "x", "e", "bb", "ob", "o", "bit", "bar", "job", "a", "ba", "eb", "B", "orb", "obj", "c", "ab", "db", "i", "fb", "nb", "lb", "bin", "rb", "ib"], "valueAfterMD5": ["valueAfterMP3", "valueAfterMP4", "valueAfterMP2", "valueAfterMD4", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueBeforeMD4", "valueBeforeMP4", "valueAfterAMD4", "valueAfterAMD3", "valueAfterM3", "valueBeforeMP2", "valueAfterMD3", "valueAfterAMD5", "valueAfterM5", "valueBeforeMD3", "valueAfterM4", "valueAfterMP5", "valueAfterAMD2", "valueAfterMD2", "valueAfterM2"]}}
{"id1": "15826301", "id2": "11028858", "code1": "    public static int getContentLength(String address) {\n        URLConnection conn = null;\n        int contentLength = 0;\n        try {\n            URL url = new URL(address);\n            conn = url.openConnection();\n            contentLength = conn.getContentLength();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return contentLength;\n    }\n", "code2": "    @Override\n    public void runTask(HashMap pjobParameters) throws Exception {\n        if (hasRequiredResources(isSubTask())) {\n            File lfileSource = new File(getSource());\n            File lfileTarget = new File(getTarget());\n            FileChannel lfisInput = null;\n            FileChannel lfosOutput = null;\n            try {\n                int mbCount = 64;\n                boolean lblnDone = false;\n                while (!lblnDone) {\n                    lfisInput = new FileInputStream(lfileSource).getChannel();\n                    lfosOutput = new FileOutputStream(lfileTarget).getChannel();\n                    try {\n                        int maxCount = (mbCount * 1024 * 1024) - (32 * 1024);\n                        long size = lfisInput.size();\n                        long position = 0;\n                        while (position < size) {\n                            position += lfisInput.transferTo(position, maxCount, lfosOutput);\n                        }\n                        lblnDone = true;\n                    } catch (IOException lioXcp) {\n                        getLog().warn(lioXcp);\n                        if (lioXcp.getMessage().contains(\"Insufficient system resources exist to complete the requested servic\")) {\n                            mbCount--;\n                            getLog().debug(\"Dropped resource count down to [\" + mbCount + \"]\");\n                            if (mbCount == 0) {\n                                lblnDone = true;\n                            }\n                            if (lfisInput != null) {\n                                lfisInput.close();\n                            }\n                            if (lfosOutput != null) {\n                                lfosOutput.close();\n                            }\n                        } else {\n                            throw lioXcp;\n                        }\n                    }\n                }\n            } finally {\n                if (lfisInput != null) {\n                    lfisInput.close();\n                }\n                if (lfosOutput != null) {\n                    lfosOutput.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"address": ["host", "route", "connection", "reference", "network", "output", "message", "format", "object", "state", "base", "number", "data", "resource", "prefix", "server", "email", "config", "Address", "name", "length", "content", "localhost", "offset", "key", "string", "path", "point", "uri", "code", "attribute", "URL", "addr", "position", "port", "ip", "location", "type"], "conn": ["dc", "cb", "connection", "cm", "open", "cf", "co", "l", "ct", "con", "fp", "client", "pg", "Conn", "loc", "channel", "po", "cp", "n", "enc", "server", "config", "info", "ai", "pc", "cn", "conf", "exec", "oss", "ci", "rc", "nt", "act", "api", "Connect", "ch", "cli", "ann", "close", "path", "connect", "cert", "c", "rt", "code", "err", "Url", "Connection", "ca", "nc", "coll"], "contentLength": ["ContentType", "addressLength", "ContentLen", "ontentBuffer", "contentLen", " contentType", "paddingLife", "addressLen", "contentContent", "paddingLength", "ContentContent", "Contentlength", "addresslength", " contentlength", "ontentLength", "addressContent", "ontentLen", "contentInfo", "contentBuffer", "paddingInfo", " contentInfo", "ContentBuffer", "ContentLength", " contentLen", " contentContent", "contentlength", " contentBuffer", "ContentInfo", "contentType", "paddingLen", "ContentLife", "contentLife", "ontentType", " contentLife"], "url": ["host", "page", "cb", "connection", "open", "rel", "feed", "build", "l", "http", "object", "b", "channel", "f", "loc", "n", "r", "zip", "resource", "server", "config", "cur", "bb", "ob", "sl", "ch", "fl", "ls", "path", "orb", "image", "rl", "obj", "c", "file", "ssl", "connect", "URL", "Url", "blog", "web", "ll"]}}
{"id1": "12097100", "id2": "14647876", "code1": "    public void getStation(String prefecture, String line) {\n        HttpClient httpclient = null;\n        try {\n            httpclient = new DefaultHttpClient();\n            List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n            qparams.add(new BasicNameValuePair(\"method\", \"getStations\"));\n            qparams.add(new BasicNameValuePair(\"prefecture\", prefecture));\n            qparams.add(new BasicNameValuePair(\"line\", line));\n            URI uri = URIUtils.createURI(\"http\", \"express.heartrails.com\", -1, \"/api/xml\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream, \"UTF-8\"));\n            StringBuffer buf = new StringBuffer();\n            String str;\n            while ((str = reader.readLine()) != null) {\n                buf.append(str);\n                buf.append(\"\\n\");\n            }\n            reader.close();\n            stationRes = new StationResponse(buf.toString());\n        } catch (URISyntaxException ex) {\n            ex.printStackTrace();\n        } catch (ClientProtocolException ex) {\n            ex.printStackTrace();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        } catch (SAXException ex) {\n            ex.printStackTrace();\n        } catch (ParserConfigurationException ex) {\n            ex.printStackTrace();\n        } finally {\n            mSearchStation.setEnabled(true);\n        }\n    }\n", "code2": "    public static void copyFile(IPath fromFileName, IPath toFileName) throws IOException {\n        File fromFile = fromFileName.toFile();\n        File toFile = toFileName.toFile();\n        if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFileName);\n        if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n        if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) throw new IOException(\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n        }\n        InputStream from = null;\n        OutputStream to = null;\n        try {\n            from = new BufferedInputStream(new FileInputStream(fromFile));\n            to = new BufferedOutputStream(new FileOutputStream(toFile));\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"prefecture": ["basecision", "interfecture", "Premarine", "pofecture", "preville", "prestate", "Prestate", " preville", "prestation", "persection", "interfect", "preartment", "poartment", "Preartment", "intersection", "baseartment", "basemarine", "fefecture", "prefect", "precision", "Predivision", "perfect", "premarine", " prestate", "prifect", "Prefecture", " predivision", "interstation", "Preville", "feville", "pocision", "pomarine", "perfecture", "perstation", "festate", "presection", "predivision", "basefecture", "prisection", "prifecture", "pristation", "fedivision", "Precision"], "line": ["source", "page", "entry", "route", "site", "url", "queue", "link", "pe", "layout", "place", "range", "lines", "grade", "letter", "license", "definition", "LINE", "cell", "state", "Line", "model", "profile", "ine", "style", "zip", "email", "address", "strip", "name", "zone", "plan", "liner", "job", "status", "time", "side", "string", "rule", "point", "path", "lock", "file", "code", "label", "type", "block", "level", "lin", "position", "lane", "location", "unit"], "httpclient": ["htmlclient", "htmlget", "workClient", "ttppost", "Httpcache", "workclient", " httpClient", " httpcache", "ttpapi", "Httpclient", "ttpconn", "httpcache", "httpsapi", "httpsconn", "htmlpost", "ttpClient", "phpstore", "Httpserver", "ttpclient", "ttpstore", "httppost", "httpserver", "httpClient", "httpstore", "ttpget", "httpsstore", "htmlClient", "httpapi", "httpconn", "phpclient", "httpsclient", "phpconn", "phpapi", " httppost", "HttpClient", "workserver", " httpserver", "workcache"], "qparams": [" qwords", "sqparams", "kparam", "pargs", "iqparams", "pparam", "iqvalues", " qchanges", "formParameters", "qlines", "qwords", "qusettings", "formwords", "pproperties", "requsettings", "qargs", "qproperties", "kproperties", "qsettings", " qlines", "sqParameters", " qapps", "quparams", "qannels", " qannels", "qulines", "requchanges", "Qapps", " qposts", "kparams", "pparams", "quchanges", "iqParameters", "formparams", "Qparams", "sqvalues", "quwords", "Qposts", "qqparam", "Qparam", " qsettings", "quannels", "sqparam", "quposts", "qqvalues", "requannels", " qParameters", "qapps", "Qargs", "qParameters", "formlines", "qparam", "Qproperties", "qchanges", "qqParameters", "qqparams", "quparam", "qposts", "qvalues", "iqparam", "requparams", "quapps", " qparam", "quParameters", "kargs"], "uri": ["absolute", "route", "url", "qi", "abi", "connection", "plugin", "io", "http", "request", " URI", "environment", "base", "directory", "remote", "resource", "handler", "server", "gi", "info", "address", "ui", "ci", "api", "cli", "iri", "ri", "string", "path", "document", "file", "i", "service", " url", "database", "pi", "URI", "proxy", "uni", "location"], "httpget": ["ttprequest", "httpsend", " httpparse", "Httprequest", "Httpclient", "hget", "httpGet", "ttpclient", "hparse", "httpsGet", "ttpshow", "httpssend", "hsend", "Httpshow", " httprequest", "ttpget", "httpsget", "httprequest", " httpshow", "httpshow", "httpsparse", " httpGet", "httpparse", " httpsend", "Httpget", "hGet"], "response": ["page", "respond", "queue", "connection", "reply", "ception", "result", "message", "output", "request", "object", "client", "model", "environment", "channel", "application", "onse", "data", "stream", "re", "resource", "server", "body", "query", "full", "json", "api", "status", "Response", "document", "resp", "generation", "received", "res", "collection", "entry"], "entity": ["page", "translation", "office", "ent", "connection", "xml", "result", "oter", "article", "ity", "object", "model", "environment", "application", "data", "resource", "email", "server", "el", "element", "body", "e", "Entity", "json", "api", "content", "agent", "string", "document", "image", "index", "file", "eme", "resp", "person", "service", "em", "collection"], "instream": [" inchannel", "insstream", "inputfile", " inStream", "insfile", "inputstream", "inputform", "Inform", "inputmodel", "Instream", "outchannel", "inform", "outstream", " inmodel", "inputchannel", "inchannel", "inStream", "Inchannel", "infile", "inmodel", "insform", "outStream", "outmodel", "inputStream", "Infile", "inschannel"], "reader": ["read", "upper", "input", "rar", "rx", "Reader", "feed", "buffer", "director", "iter", "result", "ser", "keeper", "io", "iterator", "http", "in", "ler", "row", "f", "loader", "data", "oder", "stream", "r", "resource", "handler", "editor", "writer", "er", "rer", "rc", "reading", "per", "bird", "parser", "ri", "i", "err", "or", "rr", "cher", "ner"], "buf": ["cb", "sb", "bf", "la", "bh", "binary", "uc", "buffer", "buff", "cf", "result", "br", "Buffer", "cat", "b", "aux", "bc", "base", "cv", "agg", "data", "bytes", "r", "box", "raw", "fam", "func", "brace", "grab", "bb", "ob", "text", "uf", "cap", "bag", "v", "abc", "gb", "string", "orig", "pool", "ab", "uv", "db", "vec", "wb", "fb", "map", "array", "builder", "obo", "conv", "nb", "bu", "rb", "bp"], "str": ["id", "STR", "url", "arr", "iter", "br", "l", "in", "char", "st", "fr", "f", "data", "style", "r", "enc", "n", "er", "cur", "ring", "exp", "cl", "spec", "Str", "text", "sr", "pr", "dr", "lc", "tr", "key", "string", "cr", "sp", "obj", "c", "i", "err", "sol", "rr", "stri", "kr", "ner", "coll", "sl"], "stationRes": ["stationResp", "stationResponse", "exportResp", " stationResp", "stationres", "Stationres", " stationres", "StationRes", "exportres", "StationResp", "exportRes", " stationResponse", "StationResponse", "exportResponse"]}}
{"id1": "1863214", "id2": "15988143", "code1": "    public static final void copyFile(File source, File target) {\n        try {\n            FileChannel srcChannel = new FileInputStream(source).getChannel();\n            FileChannel dstChannel = new FileOutputStream(target).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (java.io.IOException e) {\n        }\n    }\n", "code2": "    public static List getUrlData(URL url) throws IOException {\n        List beans = new ArrayList(256);\n        System.out.println(\"Retreiving content for: \" + url);\n        StringBuffer content = new StringBuffer(4096);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String str;\n        while ((str = in.readLine()) != null) {\n            if (str.startsWith(\"#\")) {\n                continue;\n            }\n            StringTokenizer stringTokenizer = new StringTokenizer(str, \"\\t\");\n            String InteractionAc = stringTokenizer.nextToken();\n            String reactomeId = stringTokenizer.nextToken();\n            ReactomeBean reactomeBean = new ReactomeBean();\n            reactomeBean.setReactomeID(reactomeId);\n            reactomeBean.setInteractionAC(InteractionAc);\n            beans.add(reactomeBean);\n        }\n        in.close();\n        return beans;\n    }\n", "label": 0, "substitutes": {"source": ["parent", "size", "site", "route", "url", "series", "connection", "core", "origin", "grade", "src", "from", "object", "this", "Source", "base", "stream", "remote", "resource", "slave", "server", "component", "ource", "sin", "SOURCE", "slice", "image", "file", "service", "current", "scene", "ce", "start", "null", "sample", "use", "unit"], "target": ["next", "parent", "office", "open", "director", "top", "result", "output", "flat", "src", "effect", "object", "end", "root", "base", "to", "style", "master", "resource", "compatible", "external", "template", "dest", "Target", "it", "large", "prot", "temp", "path", "point", "file", "that", "goal", "service", "database", "destroy", "project", "platform", "port", "arget"], "srcChannel": ["scCh", "scChan", "srcChar", "srcchannel", "srcBuffer", "sslchannel", "srcClient", "sourceChan", "rcChan", " srcChan", "destChan", "scChar", "securechannel", "sslClient", "scChannel", " srcConnection", " srcCh", "rcchannel", "destchannel", "srcChan", "rcChannel", "sourceBuffer", "rcCh", "srcCh", "secureChannel", "destConnection", "secureBuffer", " srcBuffer", "rcChar", "rcClient", "rcConnection", "destChannel", " srcchannel", "secureChan", " srcClient", "sslChannel", "sourcechannel", "sourceChannel", "srcConnection", "sslChan", " srcChar"], "dstChannel": ["ddestManager", "ddestChan", "DdestContext", "ddsrcContext", "dstsChan", "ddestchannel", "Ddestchannel", "DstManager", "ddestChannel", "DstConnection", "ddestContext", "destChan", "DstChan", "dstContext", "dsrcManager", "DstChannel", "dsrcchannel", "DdestManager", "ddestConnection", "destContext", "dsrcContext", "destchannel", "dsrcConnection", "ddsrcChan", "dstChan", "dstsContext", "ddsrcChannel", "dstschannel", "dvchannel", "DdestConnection", "dvManager", "dsrcChannel", "ddstChannel", "ddsrcchannel", "DstContext", "ddstChan", "dstManager", "destChannel", "Dstchannel", "DdestChan", "DdestChannel", "dstchannel", "dstConnection", "ddstContext", "dvChannel", "dsrcChan", "dvConnection", "ddstchannel", "dstsChannel"]}}
{"id1": "21459233", "id2": "19332849", "code1": "    private static IProject createCopyProject(IProject project, String pName, IWorkspace ws, IProgressMonitor pm) throws Exception {\n        pm.beginTask(\"Creating temp project\", 1);\n        IPath destination = new Path(pName);\n        IJavaProject oldJavaproj = JavaCore.create(project);\n        IClasspathEntry[] classPath = oldJavaproj.getRawClasspath();\n        IProject newProject = ResourcesPlugin.getWorkspace().getRoot().getProject(pName);\n        newProject.create(null);\n        newProject.open(null);\n        IProjectDescription desc = newProject.getDescription();\n        desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n        newProject.setDescription(desc, null);\n        List<IClasspathEntry> newClassPath = new ArrayList<IClasspathEntry>();\n        for (IClasspathEntry cEntry : classPath) {\n            switch(cEntry.getEntryKind()) {\n                case IClasspathEntry.CPE_SOURCE:\n                    System.out.println(\"Source folder \" + cEntry.getPath());\n                    newClassPath.add(copySourceFolder(project, newProject, cEntry, destination));\n                    break;\n                case IClasspathEntry.CPE_LIBRARY:\n                    System.out.println(\"library folder \" + cEntry.getPath());\n                    newClassPath.add(cEntry);\n                    break;\n                case IClasspathEntry.CPE_PROJECT:\n                    System.out.println(\"project folder \" + cEntry.getPath());\n                    newClassPath.add(cEntry);\n                    break;\n                case IClasspathEntry.CPE_VARIABLE:\n                    System.out.println(\"variable folder \" + cEntry.getPath());\n                    newClassPath.add(cEntry);\n                    break;\n                default:\n                    System.out.println(\"container folder \" + cEntry.getPath());\n                    newClassPath.add(cEntry);\n            }\n        }\n        copyDir(project.getLocation().toString(), \"/translator\", newProject.getLocation().toString(), \"\", new ArrayList<String>() {\n\n            {\n                add(\"generated\");\n                add(\"classes\");\n                add(\".svn\");\n            }\n        });\n        newProject.refreshLocal(IResource.DEPTH_INFINITE, pm);\n        newProject.build(IncrementalProjectBuilder.AUTO_BUILD, pm);\n        newProject.touch(pm);\n        IJavaProject javaproj = JavaCore.create(newProject);\n        javaproj.setOutputLocation(new Path(\"/\" + newProject.getName() + \"/classes/bin\"), null);\n        javaproj.setRawClasspath(newClassPath.toArray(new IClasspathEntry[newClassPath.size()]), pm);\n        Map opts = oldJavaproj.getOptions(true);\n        javaproj.setOptions(opts);\n        javaproj.makeConsistent(pm);\n        javaproj.save(pm, true);\n        return newProject;\n    }\n", "code2": "    public String getResponse(String URLstring) {\n        String str = \"\";\n        try {\n            URL url = new URL(URLstring);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String st = \"\";\n            while ((st = in.readLine()) != null) {\n                str += \"\\n\" + st;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return str;\n    }\n", "label": 0, "substitutes": {"project": ["source", "resources", "folder", "parent", "program", "contract", "Project", "input", "queue", "task", "connection", "product", "reference", "plugin", "build", "result", "output", "python", "lib", "view", "app", "home", "object", "client", "request", "base", "application", "profile", "directory", "future", "version", "class", "zip", "ruby", "resource", "prefix", "archive", "system", "config", "primary", "tool", "module", "name", "component", "target", "report", "text", "job", "book", "path", "document", "file", "context", "code", "command", "projects", "property", "database", "process", "subject", "proxy", "port", "p", "type"], "pName": ["pNames", "pname", " pVersion", "gNAME", " pNames", "packagename", "pVersion", "cpname", "PName", " pname", "gName", "PNames", "Pname", "cpVersion", " pNAME", " pInfo", "cpName", "packageName", "PNAME", "pNAME", "pInfo", "PVersion", "gname", "packageInfo", "cpNames", "PInfo"], "ws": ["works", "paces", "space", "widget", "wx", "wd", "w", "sw", "Ws", "wh", "work", "resource", "writer", "WS", "wp", " wh", " works", " swap", " wid", " wa", "workshop", "rw", "wordpress", "ww", " WS", "wid", "www", "RW", "wr"], "pm": [" mp", "lp", " pp", "PT", "P", "BM", "cm", "jp", "pb", "mm", "pd", "am", "ps", "fp", " pr", "ym", "po", "bm", "cp", "wm", "vim", "dp", "pc", "pa", "mp", "tp", "rpm", "gm", "dm", "rm", "pr", "m", "WM", "pt", " am", "TP", "mr", " p", "pp", " cm", "pi", "fm", "PM", "mi", "pl", " PM", "p"], "destination": ["destinate", "Desturation", "declination", " destinations", "desturation", "declinations", "decluration", "Destinate", " destinate", "continations", "contribution", "destinations", "Destinations", "contination", " destribution", " desturation", "continate", "destribution", "declribution", "Destination", "Destribution"], "oldJavaproj": ["oldJavaprobjs", "oldJavapROj", "oldJavarrojo", "oldJavaprobJ", "oldJavaprajs", "oldJavapROji", "oldJavatraji", "oldJavarrijs", "oldJavapriJ", "oldJavaprajo", "oldJavapraj", "oldJavaprojs", "oldJavaprobj", "oldJavaprijs", "oldJavatraJ", "oldJavatroJ", "oldJavatrojs", "oldJavaprojo", "oldJavaproji", "oldJavaprij", "oldJavarroJ", "oldJavapROJ", "oldJavatrajs", "oldJavapriji", "oldJavarrij", "oldJavaprijo", "oldJavapraJ", "oldJavarriJ", "oldJavarrojs", "oldJavapROjs", "oldJavaproJ", "oldJavarroj", "oldJavapraji", "oldJavaprobjo", "oldJavatroj", "oldJavatraj", "oldJavarrijo", "oldJavatroji"], "classPath": ["ClassData", " classList", "classList", "packagePath", "classPATH", " classpath", "ClassPATH", "classpath", "ClassPath", "packagePATH", "lassPath", "lasspath", "ClassList", "lassList", " classPATH", "classData", "packagepath", "lassData", " classData", "Classpath", "packageList"], "newProject": ["newproject", "oldProject", "sameProject", "Newproject", " newConfig", "oldDirectory", "oldFolder", "NewPath", "newsproject", "newText", "nextPath", "oldConfig", " newDirectory", "nowproject", "oldText", "nextZip", "nowProject", "newsFolder", "NewZip", "oldModule", " newZip", "oldZip", "newPath", "NewFile", "nextproject", "newJob", "nowConfig", "nowJob", "oldproject", "NewFolder", " newJob", "sameFolder", "newFile", "newFolder", "newsProject", "NewConfig", " newServer", "NewDirectory", "newZip", "newConfig", "oldFile", "NewJob", " newModule", " newText", "newServer", "oldServer", "newModule", "sameText", "NewModule", "sameproject", "NewProject", " newproject", " newPath", "NewServer", "newDirectory", " newFile", "nextProject", " newFolder", "newsConfig"], "desc": ["dec", "attr", "contract", "dc", "id", "en", "anc", "default", "des", "txt", "uc", "dep", "dev", " description", "doc", "src", "aux", "description", "loc", "def", "neg", "summary", "Desc", "sc", "config", "info", "meta", "dest", "sub", "sup", "name", "rc", "de", "esc", "nt", "text", "comment", "rec", "sec", "asc", "type", "dist", "Description", "bot", "ca", "env", "ext"], "newClassPath": ["NewFileTree", " newClassURL", "newPackageFile", "newResourcePath", " newPackagepath", "newClasspath", "NewClasspath", "newclassPath", "newResourceList", " newPackageFile", " newClassName", "newFileFolder", "newLanguagePath", "newClassArray", "newClassName", "newclasspath", "newClassFolder", "newClassTree", "newclassList", " newclassFolder", "newPackagepath", " newClassList", "newPackageName", "NewFilePath", "newPackageArray", " newClassArray", " newPackagePath", " newClassMember", " newclassList", "newPackageTree", "newResourceFolder", "newPackageMember", " newClassFile", "newclassName", "newFilepath", "newClassList", "NewFilepath", " newPackageArray", "NewFileList", "NewClassTree", "NewClassPath", "newFilePath", " newPackageURL", "newSiteTree", "newClassMember", " newPackageMember", "newPackagePath", "newclassMember", " newclassPath", "newLanguageMember", "newSitePath", " newClasspath", "newClassURL", "newLanguagepath", "newSitepath", " newclasspath", "newPackageURL", "NewClassList", "newFileList", "newclassFolder", "newSiteList", "newFileTree", "newResourcepath", " newPackageName", "newClassFile", "newclassArray", "newPackageList", " newClassFolder"], "cEntry": ["ecEnt", "fElement", " cEnter", "CEnt", "lcEnt", "lcElement", "CError", "cResource", "pElement", "pEntry", "pEnter", "ecEnter", "lcentry", "fentry", "fEnter", " cRoute", "fcEnt", "lentry", "cEnt", "fcEntry", "cEx", "lRoute", "cRoute", "lEntry", "CEntry", " cEx", "pError", "lcAdd", " cError", "cError", "fcentry", " centry", "lcRoute", "fcEnter", "fEnt", "crentry", "rcEntry", "fError", "centry", "lcData", "lcEnter", "rcEnt", "cacheElement", "ecEntry", "cEnter", "fcResource", "crEnt", " cAdd", "fcEx", " cResource", "CEx", "lEnt", "crEx", "crEntry", "CEnter", " cElement", "cElement", " cData", " cEnt", "lcResource", "cacheEntry", "fEntry", "Centry", "rcEnter", "ecError", "cacheEnt", "cData", "rcData", "CAdd", "pentry", "CElement", "lcEx", "lcError", "pEnt", "cacheEnter", "lcEntry", "cAdd"]}}
{"id1": "268806", "id2": "8988243", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void extractSOUNDFILES() throws Exception {\n        ArrayList<File> soundFiles = new ArrayList<File>();\n        File soundsFolder = new File(\"/var/lib/asterisk/sounds/\");\n        if (soundsFolder.exists()) {\n            File soundFiles1[] = soundsFolder.listFiles(new FilenameFilter() {\n\n                @Override\n                public boolean accept(File dir, String name) {\n                    if (NullStatus.isNull(name)) {\n                        return false;\n                    }\n                    if (name.endsWith(\"-sounds.jar\")) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            for (int i = 0; i < soundFiles1.length; i++) {\n                soundFiles.add(soundFiles1[i]);\n            }\n        }\n        soundsFolder = new File(\"/opt/jboss/server/default/deploy/Tobe.war/WEB-INF/lib/\");\n        if (soundsFolder.exists()) {\n            File soundFiles1[] = soundsFolder.listFiles(new FilenameFilter() {\n\n                @Override\n                public boolean accept(File dir, String name) {\n                    if (NullStatus.isNull(name)) {\n                        return false;\n                    }\n                    if (name.endsWith(\"-sounds.jar\")) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            for (int i = 0; i < soundFiles1.length; i++) {\n                soundFiles.add(soundFiles1[i]);\n            }\n        }\n        for (int i = 0; i < soundFiles.size(); i++) {\n            ZipFile zipFile = new ZipFile(soundFiles.get(i));\n            InputStream inputStream = null;\n            Enumeration<? extends ZipEntry> oEnum = zipFile.entries();\n            while (oEnum.hasMoreElements()) {\n                ZipEntry zipEntry = oEnum.nextElement();\n                File file = new File(\"/var/lib/asterisk/sounds/\", zipEntry.getName());\n                if (zipEntry.isDirectory()) {\n                    file.mkdirs();\n                } else {\n                    inputStream = zipFile.getInputStream(zipEntry);\n                    FileOutputStream fos = new FileOutputStream(file);\n                    IOUtils.copy(inputStream, fos);\n                    fos.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "RC", "reader", "sb", "tmp", "url", "input", "proc", "cb", "req", "upload", "SourceFile", "dep", "download", "sth", "sit", "username", "fp", "Source", "supp", "st", "loc", "cpp", "href", "ref", "stream", "storage", "resource", "sc", "ctx", "config", "filename", "name", "component", "rc", "inst", "prot", "feat", "gn", "spec", "fn", "ource", "Dest", "buf", "back", "sin", "gb", "slice", "sec", "path", "gz", "string", "rl", "obj", "load", "uri", "ssl", "file", "secure", "code", "impl", "vr", "dist", "img", "sn", "s", "rb", "cmp", "sl"], "dest": ["source", "tmp", "dc", "txt", "disk", "lib", "home", " destination", "std", "di", "class", "dir", "target", "cont", "fn", "Dest", "temp", "orig", "path", "obj", "wb", "dist", " dst", "img", "bin", "dat", "null"], "in": ["source", "reader", "input", "inc", "din", "d", "win", "io", "doc", "inf", "val", "login", "f", "as", "data", "In", "pin", "stream", "n", "r", "inas", "isin", "ins", "t", "ini", "a", "ex", "up", "file", "i", "IN", "err", "inn", "is", "bin", "ps", "pass"], "p": ["lp", "cop", "bp", "py", "h", "P", "d", "pe", "jp", "pb", "pd", "l", "pre", "fp", "pg", "b", "part", "f", "po", "cp", "wp", "pc", "tp", "pa", "o", "s", "e", "per", "t", "parser", "pr", "m", "v", "pm", "sp", "c", "j", "i", "np", "pp", "g", "pi", "ps", "op"], "ds": ["hs", "d", "dd", "ils", "ld", "lines", "tools", "ns", "bs", "DS", "dp", "sys", "vs", "eps", "sync", "dt", "da", "cs", "ls", "ays", "dist", "ts", "ys", " DS", "pd", " ps", "os", "posts", "models", "cons", "ins", "dm", "els", "scripts", "sts", "dates", "nas", "ps", "dl", "dc", "Ds", "points", "ss", "gs", "styles", "ups", "dos", "qs", "js", " props", "rs", "df", "words", "docs", "utils", "vals", "ans", " sd", "s", "lp", "tests", "ks", " db", "des", "ded", "ws", "gd", "cdn", "ads", "data", "di", "xs", "plugins", "dds", "icks", " dd", "amps", "ants", "db", "parts", "obs", "dat", "uds"], "format": ["source", "language", "host", "url", "ant", "Format", "layout", "xml", "plugin", "function", "scale", "letter", "fp", "object", "fd", "model", "part", "f", "magic", "data", "table", "version", "class", "style", "match", "handler", "prefix", "config", "template", "tag", "filename", "name", "pattern", "feat", "unit", "spec", "fn", "parser", "t", "atter", "api", "act", "frame", "string", "path", "file", "record", "struct", "nat", "sche", "at", "form", "filter", "type"], "hasPixelData": ["haspixelStyle", "hasPicturedata", "hasByteSize", "hasPicOps", " hasPixelStyle", "hasPixelStyle", "hasBytedata", "hasPictureDATA", "hasPicStyle", "hasPicData", "haspixelOps", "hasByteData", " hasPixelSize", "hasPictureData", " hasPixeldata", " hasPixelDATA", "haspixeldata", "haspixelDATA", "haspixelData", " hasPixelOps", "hasPixelSize", "hasPixelOps", "hasPixeldata", "hasPixelDATA", "haspixelSize"], "inflate": ["inflocate", " informate", " inflase", "infolate", "uninfloute", "inFlate", "infloase", "incollute", "incollocate", "infloation", "infloame", "incollame", "inFlation", "uninflate", " informase", "inFlATE", "inflATE", " inflation", "uninfloame", " informATE", "informase", "inflase", "infolocate", "incollate", "inflame", "uninfloocate", "information", "infolute", " inflATE", "inflation", " information", "infloATE", "uninflocate", "informate", "infloate", "infolame", "uninflute", "infloute", "uninfloate", "uninflame", "influte", "informATE", "infloocate", "inFlase"], "pxlen": ["pxlength", "xpval", "pxval", "cpl", "pnglen", "fxlength", "pyln", "xylen", "xplen", "cplen", "pglen", "ppln", "pglength", "pylen", "npfin", "pxden", "pgval", "nplin", "rxlen", "cpden", "pxlin", "pglf", "xplf", "pxfin", "cpln", "rxfin", "npden", "rxden", "pxln", "xplength", "pxl", "xyden", "pyden", "pngLen", "fxval", "ppLen", "ppden", "pplen", "pxlf", "xylin", "pyl", "nplen", "pngln", "rxlin", "fxl", "pngden", "fxlf", "fxden", "pxLen", "xyfin", "fxlen", "xyln", "fxln", "xyLen"], "out": ["page", "parent", "user", "io", "output", "conn", "lib", "dump", "gen", "base", "again", "OUT", "Out", "outs", "work", "server", "print", "re", "prefix", "sys", "inter", "step", "log", "cli", "post", "v", "up", "session", "point", "list", "obj", "lock", "cache", "error", "code", "err", "group", "store", "copy", "line"]}}
{"id1": "15257300", "id2": "3109015", "code1": "    private String readFile(String urlFileString) throws IOException {\n        URL url = new URL(urlFileString);\n        VizDebugUtils.debug(\"url: \" + url.toString());\n        InputStream stream = url.openStream();\n        Reader reader = new InputStreamReader(stream, \"iso-8859-1\");\n        StringWriter writer = new StringWriter();\n        StreamUtils.transfer(reader, writer);\n        stream.close();\n        return writer.toString();\n    }\n", "code2": "    private void copy(File parent) {\n        System.out.println(\"parent---\" + parent.getAbsolutePath());\n        if (parent.isDirectory() && !\".svn\".equals(parent.getName())) {\n            File cases = new File(parent, \"cases\");\n            if (cases.exists()) {\n                File answers = new File(parent, \"answers\");\n                if (!answers.exists()) {\n                    answers.mkdir();\n                    File answers_linux = new File(parent, \"answers_linux\");\n                    for (File file : answers_linux.listFiles()) {\n                        if (file.isDirectory()) {\n                            continue;\n                        }\n                        File target = new File(answers, file.getName());\n                        try {\n                            IOUtils.copy(new FileInputStream(file), new FileOutputStream(target));\n                        } catch (Throwable t) {\n                            t.printStackTrace();\n                        }\n                    }\n                }\n            } else {\n                for (File son : parent.listFiles()) {\n                    System.out.println(\"parent---\" + son.getAbsolutePath());\n                    copySon(son);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"urlFileString": ["fileStringFile", "fileStringArray", "urlClassStr", "urlPathFile", "urlNameFile", "urlFullstring", "urlFullStr", "urlFullString", "urlFullSingle", "urlFileSingle", "urlStringStr", "fileFileFile", " urlStringSingle", " urlFileStr", "urlClassSingle", " urlFilestring", "urlPathStr", "fileFileStr", " urlFileSingle", "urlClassstring", "fileFileArray", "urlPathString", "urlStringstring", "urlFileArray", " urlStringStr", "urlNameArray", "urlStringString", "urlClassString", "urlPathArray", "urlStringArray", "fileFileString", "urlNameString", "urlNameStr", "fileStringStr", " urlStringstring", "urlStringSingle", "fileStringString", "urlStringFile", "urlFileStr", " urlStringString", "urlFilestring", "urlFileFile"], "url": ["source", "host", "page", "ball", "id", "user", "browser", "feed", "connection", "xml", "download", "l", "http", "object", "b", "bug", "f", "base", "loader", "resource", "server", "address", "full", "bb", "log", "bel", "sl", "fl", "ls", "string", "path", "image", "rl", "html", "file", "ssl", "uri", "URL", "Url", "www", "blog", "web", "str", "ll"], "stream": ["source", "read", "draft", "input", "wrapper", "roll", "user", "upload", "feed", "Stream", "buffer", "iter", "output", "io", "iterator", "w", "thread", "out", "in", "http", "sw", "driver", "client", "model", "loop", "channel", "f", "loader", "data", "row", "system", "resource", "handler", "server", "raw", "serv", "inner", "per", "log", "length", "transform", "temp", "slice", "file", "context", "ssl", "service", "self", "form", "stack", "filter", "sl"], "reader": ["source", "read", "input", "rar", " Reader", "Reader", "feed", "buffer", "director", "iter", "ser", "io", "ler", "in", "row", "channel", "loader", "f", "data", "oder", "worker", "r", "resource", "handler", "server", "raw", "er", "rer", "rc", "e", "per", "parser", "rr", "ner", "entry"], "writer": ["wrote", "WR", "entry", "wrapper", "write", "buffer", "breaker", "ee", "output", "io", "letter", "w", "out", "ler", "object", "driver", "worker", "data", "writers", "oder", "r", "riter", "handler", "her", "editor", "inner", "wer", "server", "element", "er", "word", "null", "e", "text", "Writer", "writ", "temp", "key", "book", "string", "rw", "code", "builder", "service", "war", "writing", "ner", "wr", "written"]}}
{"id1": "9413061", "id2": "17526811", "code1": "    @Override\n    public void run() {\n        try {\n            FileChannel out = new FileOutputStream(outputfile).getChannel();\n            long pos = 0;\n            status.setText(\"Slu\u010dova\u010d: Proces slu\u010dov\u00e1n\u00ed spu\u0161t\u011bn.. Pros\u00edm \u010dekejte..\");\n            for (int i = 1; i <= noofparts; i++) {\n                FileChannel in = new FileInputStream(originalfilename.getAbsolutePath() + \".\" + String.format(\"%03d\", i)).getChannel();\n                status.setText(\"Slu\u010dova\u010d: Slu\u010duji \u010d\u00e1st \" + i + \"..\");\n                this.splitsize = in.size();\n                out.transferFrom(in, pos, splitsize);\n                pos += splitsize;\n                in.close();\n                if (deleteOnFinish) new File(originalfilename + String.format(\".%03d\", i)).delete();\n                pb.setValue(100 * i / noofparts);\n            }\n            out.close();\n            status.setText(\"Slu\u010dova\u010d: Hotovo..\");\n            JOptionPane.showMessageDialog(null, \"Slou\u010deno!\", \"Slu\u010dova\u010d\", JOptionPane.INFORMATION_MESSAGE);\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    private String getDocumentAsString(URL url) throws IOException {\n        StringBuffer result = new StringBuffer();\n        InputStream in = url.openStream();\n        int c;\n        while ((c = in.read()) != -1) result.append((char) c);\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"out": ["page", "parent", "plus", "size", "input", "inc", "buffer", "extra", "png", "io", "output", "conn", "w", "this", "b", "client", "part", "login", "base", "channel", "to", "In", "OUT", "Out", "again", "outs", "prefix", "writer", "exec", "x", "sync", "init", "o", "password", "ex", "cli", "temp", "v", "status", "up", "cache", "socket", "obj", "ssl", "err", "process", "bin", "copy", "line", "p"], "pos": ["POS", "size", "len", "min", "pose", "iter", "limit", "end", "diff", "part", "loc", "neg", "po", "data", "style", "os", "sum", "off", "conf", "x", "it", "o", "pid", "unit", " position", "length", "found", "temp", "offset", "pt", "index", "point", "pointer", "obj", "cache", "block", "pi", "is", "Pos", "start", "position", "s", "port", "p", "type"], "i": ["id", "split", "si", "qi", "multi", "abi", "d", "iu", "hi", "phi", "l", "part", "f", "number", "directory", "di", "n", "zi", "bi", "I", "ti", "ni", "ai", "gi", "ji", "esi", "adi", "ix", "it", "ui", "ci", "e", "o", "u", "eni", "ski", "ini", "a", "dim", "li", "v", "xi", "ri", "index", "count", "slice", "j", "c", "uri", "ii", "vi", "pi", "is", "parts", "start", "fi", "chi", "position", "z", "mi", "mini", "ip", "p", "ie"], "in": ["source", "reader", "tin", "url", "input", "inc", "din", "binary", "win", "connection", "buffer", "min", "nin", "conn", "l", "con", "client", "this", "diff", "part", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "config", "isin", "inner", "pc", "x", "exec", "init", "ins", "e", "s", "gin", "ini", "ex", "cin", "image", "c", "socket", "ssl", "IN", "err", "inside", "or", "inn", "file", "is", "bin", "on"], "splitsize": ["plitsize", "splitiz", "spliteize", "Splinsiz", "splitessize", "splatssize", "splatsIZE", "plitssize", "plitesization", "splinsize", "Splitssize", "splitization", "splitsze", "splitssize", "splitsIZE", "Splinssize", "plitessize", "splinssize", "splitze", "Splitsize", "SplitsIZE", "splatsiz", "splinsze", "spliteization", "plitsiz", "plitsization", "Splitsiz", "plitize", "plitze", "splitesization", "splitesize", "splitize", "plitiz", "splinsiz", "splinsIZE", "splitsization", "splitsiz", "splitesze", "plitsze", "splatsize", "plitesiz", "splitIZE", "Splinsize", "spliteiz", "plitesize", "SplinsIZE", "splitesiz"]}}
{"id1": "9796809", "id2": "19515832", "code1": "    @Override\n    protected byte[] computeHash() {\n        try {\n            final MessageDigest inputHash = MessageDigest.getInstance(\"SHA\");\n            inputHash.update(bufferFileData().getBytes());\n            return inputHash.digest();\n        } catch (final NoSuchAlgorithmException nsae) {\n            lastException = nsae;\n            return new byte[0];\n        } catch (final IOException ioe) {\n            lastException = ioe;\n            return new byte[0];\n        }\n    }\n", "code2": "    private static String calcReturnKey(String key) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        String text = new String();\n        byte[] sha1hash = new byte[20];\n        text = key + GUUI;\n        md.update(text.getBytes(), 0, text.length());\n        sha1hash = md.digest();\n        return (Helper.getBASE64(sha1hash));\n    }\n", "label": 1, "substitutes": {"inputHash": ["InputBuild", "newBuild", "outputhash", "InputSHA", " inputhash", "InputHash", " inputBlock", "outputBlock", "outputHash", "Inputhash", "inputVersion", " inputSHA", "inputBuild", " inputVersion", "inputSalt", "InputVersion", "InputCache", "internalhash", "newHash", " inputCache", "newBlock", "newCache", "internalHash", "outputVersion", "inputhash", "InputSalt", "inputSHA", " inputSalt", "internalSHA", "InputBlock", " inputBuild", "inputCache", "inputBlock", "internalSalt"], "lastException": ["firstError", "firstception", "LastExc", "lastception", " lastception", "LastError", "lastExc", "lastError", "firstExc", " lastExc", "firstException", " lastError", "Lastception", "LastException"]}}
{"id1": "11953289", "id2": "5600261", "code1": "    private static String hashPass(String p) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(p.getBytes(\"iso-8859-1\"), 0, p.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private String calculateMD5(String value) {\n        String finalString = new String(\"\");\n        try {\n            MessageDigest md5Alg = MessageDigest.getInstance(\"MD5\");\n            md5Alg.reset();\n            md5Alg.update(value.getBytes());\n            byte messageDigest[] = md5Alg.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            finalString = hexString.toString();\n        } catch (NoSuchAlgorithmException exc) {\n            throw new RuntimeException(\"Hashing error happened:\", exc);\n        }\n        return finalString;\n    }\n", "label": 1, "substitutes": {"p": ["lp", "input", "P", "pe", "d", "jp", "pb", "l", "http", "params", "fp", "b", "op", "f", "base", "po", "data", "cp", "n", "r", "null", "tp", "pa", "u", "e", "o", "param", "t", "pr", "a", "m", "v", "string", "path", "pro", "sp", "c", "i", "np", "pp", "g", "ps", "s", "padding", " P"], "md": ["ad", "hash", "d", "mb", "dig", "dd", "ind", "ld", "hd", "message", " MD", "mm", "mem", "ma", "pd", "sm", "wd", "gd", "am", "cmd", "ms", "mode", "gen", "data", "mac", "mo", "bd", "mand", "editor", "mag", "meta", "mc", "sha", "body", "mp", "dm", "mod", "rm", "MD", "mt", "m", "M", "dr", "df", "od", "pm", "mg", "code", "mad", "valid", "Cmd", "metadata", "amd", "nm", "me", "mn", "vd"], "sha1hash": ["SHA2hash", " SHA1hash", "mac5number", "shaOnekh", "sha01hash", "sha5hex", "sha2dot", "shaonesha", "mac5hash", "sha1number", "sha2Hash", "sha5hash", "shaoneh", "shaonenumber", "SHA2h", "mac1hex", "sha7hex", "sha1dot", "shaoneHash", " SHAOnesum", "sha2hash", "SHA2Hash", " SHAOnedot", "sha5sha", "shaOnehash", "sha2sum", "sha2sha", "SHA1hash", "sha512sha", "sha01sum", "sha1sum", "SHA1sha", "sha7number", " SHAOnehash", "sha1Hash", "sha2kh", "sha5number", "sha01kh", "sha7sha", "mac5sha", "shaonehex", "sha1h", " SHA1kh", "sha512hash", "sha512Hash", "sha01dot", " SHA1dot", "SHA2sha", "mac1hash", "mac5hex", "shaOnedot", "shaOnesum", "sha1kh", " SHA1sum", "sha1sha", "mac1sha", "mac1number", "sha1hex", "SHA1h", "SHA1Hash", "sha2h", "shaonehash", " SHAOnekh", "sha512h", "sha7hash"]}}
{"id1": "6907994", "id2": "20109501", "code1": "        void copy(String source_name, String dest_name) throws IOException {\n            File source_file = new File(source_name);\n            File destination_file = new File(dest_name);\n            FileInputStream source = null;\n            FileOutputStream destination = null;\n            byte[] buffer;\n            int bytes_read;\n            try {\n                if (!source_file.exists() || !source_file.isFile()) {\n                    throw new FileCopyException(\"FileCopy: no such source file: \" + source_name);\n                }\n                if (!source_file.canRead()) {\n                    throw new FileCopyException(\"FileCopy: source file \" + \"is unreadable: \" + source_name);\n                }\n                if (!destination_file.exists()) {\n                    File parentdir = parent(destination_file);\n                    if (!parentdir.exists()) {\n                        throw new FileCopyException(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                    }\n                    if (!parentdir.canWrite()) {\n                        throw new FileCopyException(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                    }\n                }\n                source = new FileInputStream(source_file);\n                destination = new FileOutputStream(destination_file);\n                buffer = new byte[1024];\n                while (true) {\n                    bytes_read = source.read(buffer);\n                    if (bytes_read == -1) {\n                        break;\n                    }\n                    destination.write(buffer, 0, bytes_read);\n                }\n            } finally {\n                if (source != null) {\n                    try {\n                        source.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (destination != null) {\n                    try {\n                        destination.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n", "code2": "    private void native2ascii(LanguageInfo info) {\n        if (!info.isUTF8()) throw new IllegalArgumentException(\"requires utf8 language.\");\n        InputStream in = null;\n        OutputStream out = null;\n        print(\"\\tConverting to ASCII... \");\n        try {\n            in = new BufferedInputStream(new FileInputStream(info.getFileName()));\n            in.mark(3);\n            if (in.read() != 0xEF || in.read() != 0xBB || in.read() != 0xBF) in.reset();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in, \"UTF8\"));\n            out = new BufferedOutputStream(new FileOutputStream(info.getAlternateFileName()));\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, \"ISO-8859-1\"));\n            String read;\n            while ((read = reader.readLine()) != null) {\n                writer.write(ascii(read));\n                writer.newLine();\n            }\n            writer.flush();\n            out.flush();\n            println(\"... done!\");\n        } catch (IOException ignored) {\n            println(\"... error! (\" + ignored.getMessage() + \")\");\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (IOException ignored) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"source_name": ["source_key", "ource_name", " source_path", " source_war", "source_path", "source_war", "ource_path", "ource_file", "ource_names", "source_names", "ource_key", " source_id", "source_id"], "dest_name": ["destackey", "target_name", "destFilefile", "dest_path", "dest_key", "targetacname", "dest_write", "destacfile", " dest_key", "target_filename", "destacfilename", "destaclock", "target_file", " dest_write", "target_lock", "dest_filename", " dest_file", "destFilefilename", "dest_lock", " dest_path", "targetacfilename", "destacname", "targetaclock", "destFilelock", "destFilename", "destacpath", "dest_file", "targetacfile"], "source_file": ["source___name", "sourceamfile", "source_function", "ource_base", "source_cache", "sourcejbase", " source__name", "sourcejload", "sourcejfile", "source__name", "sourcejsource", "source_files", " source_files", "source_load", "ource_cache", "sourceamcache", " source__files", "source___files", "ource_function", "sourceamfunction", "source__file", " source_class", " source_filename", "source_resource", "ource_resource", "source__source", "ource_file", "source_class", " source__file", "ource_load", "ource_source", " source_base", "ource_name", "sourceamname", "source___source", "source__files", "source___file", "source_filename", "source_base", " source__source", "source_source", " source_source"], "destination_file": ["destination_db", "destination_string", "destination_filename", "destinationJfile", "destination_directory", "destinator_file", "destection_child", "destinationJchild", "destation_directory", "destination_name", "destinationJstring", "destinator_filename", "destation_file", "destination_base", "destation_name", "destinator_files", "destination_path", "destination_child", "destinator_db", "destection_file", "destation_base", "destation_path", "destation_files", "destection_string", "destination_files"], "source": ["via", "input", "result", "src", "directory", "storage", "zip", "resource", "ources", "dest", "name", "ite", "scope", "ource", "slice", "image", "file", "create", "project", "site", "id", "reference", "iter", "table", "class", "slave", "master", "force", "component", "see", "se", "sin", "cache", "parse", "local", "start", "copy", "parent", "size", "open", "core", "grade", "license", "client", "loader", "stream", "server", "ize", "google", "service", "manager", "subject", "sample", "use", "ie", "select", "resources", "reader", "connection", "output", "driver", "Source", "single", "config", "target", "spec", "api", "SOURCE", "rule", "seed", "uri", "current", "ce", "proxy", "unit"], "destination": ["testruction", "estruction", " destinator", "diner", "declruction", "destinate", "destiner", "contruction", "estinated", "declination", "declinator", "Destinated", "generinate", "coordinate", "construction", "Destification", "Destiner", "testinator", "destinated", "generinator", "sourceinated", "generination", "dependinated", "Destinate", "teminator", "destification", "declinated", " destinate", "testination", "sourceination", "transinated", "transinate", "dependination", "dependinator", "Destinator", "canoninator", "Destruction", "constinator", "estinator", "estination", "sourceinate", "dinated", " destation", "continated", "dinator", "contination", "continator", "coordinated", "Destation", "originated", "dependification", "coordination", "origination", "temination", "teminer", "canonination", "teminated", "coordinator", "dination", "transinator", "constination", "origruction", "destinator", "testinated", "constinated", "generation", "originator", "canoninated", "destation", "destruction", "canonification", "Destination", "transination", "sourceinator"], "buffer": ["read", "size", "reader", "split", "url", "queue", "binary", "feed", "len", "counter", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "layer", "base", "number", "data", "table", "bytes", "resource", "server", "address", "writer", "uffer", "sequence", "transfer", "padding", "null", "batch", "bb", "length", "flush", "wave", "comment", "FFER", "buf", "offset", "slice", "string", "count", "border", "seed", "cache", "seek", "header", "block", "texture", "position", "bin"], "bytes_read": ["bytes___play", "bytes___read", "gets___read", "bytes_available", "gets_available", "gets_size", "bytes_found", " bytes_load", "bytes___found", "gets_read", "bytes___set", "bytesavwrite", "bytesavavailable", "bytes___size", "gets_found", "bytes_Read", "bytes___write", " bytes_available", "bytesavset", "bytes_received", "bytesavread", " bytes_set", "bytes_set", " bytes_Read", "bytes___available", "bytes_play", "bytes___received", "bytes_size", "bytes_load", "gets___size", " bytes_write", " bytes_play", "bytes_written", " bytes_received", " bytes_written", "gets___available", "gets___found", "bytes_write"], "parentdir": [" parentdirectory", "partdir", "parentdirectory", "partdb", " parentfile", "Parentdirectory", " parentdb", "childdb", "Parentfolder", "Parentfile", "childdir", "parentdb", "partfile", "parentfile", "partdirectory", "outfolder", "childdirectory", "Parentdir", " parentfolder", "outdirectory", "parentfolder", "outdir"]}}
{"id1": "10277959", "id2": "7099534", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "label": 1, "substitutes": {"text": ["source", "input", "TEXT", "txt", "binary", "token", "buffer", "username", "message", "output", "letter", "out", "object", "in", "Text", "data", "bytes", "class", "editor", "config", "word", "name", "body", "pattern", "password", "content", "string", "path", "image", "obj", "code", "struct", "secret", "texture", "test", "str", "ext"], "md": ["ad", "um", "cd", "d", "mb", " Md", "cm", "dd", "ind", "hd", "sm", " MD", "mm", "pd", "ma", "vd", "am", "wd", "gd", "cmd", "ms", "f", "bm", "mac", "bd", "di", "hm", "mand", "mag", "mc", "mp", "rpm", "bb", "dm", "mod", "rm", "dh", "MD", "mt", "m", "df", "od", "pm", "db", "mad", "grad", "metadata", "amd", "mn"], "sb": ["su", "cb", "sa", "bf", "mb", "bh", "binary", "buffer", "usb", "sg", "BB", "pb", "src", "sf", "bc", "bm", "kb", "bd", "bs", "obb", "erb", " eb", "sync", "bb", "SB", " SB", "ob", "sr", "ls", "buf", "gb", "xb", "eb", "ib", "bsp", "ab", "ssl", "db", "bt", "wb", "fb", "nb", "lb", "s", "rb", "bp"], "b": ["cb", "binary", "mb", "d", "bf", "buffer", "be", "br", "pb", "l", "object", "base", "f", "bd", "bytes", "bs", "machine", "body", "bb", "ob", "a", "beta", "eb", "B", "orb", "obj", "ab", "c", "db", "i", "fb", "block", "nb", "boot", "bis", "bot", "bin", "rb", "p"]}}
{"id1": "17972560", "id2": "15262412", "code1": "    private void folderFileChooserActionPerformed(java.awt.event.ActionEvent evt) {\n        if (evt.getActionCommand().equals(JFileChooser.APPROVE_SELECTION)) {\n            File selectedFolder = folderFileChooser.getSelectedFile();\n            File collectionCopyFile;\n            String newDocumentName;\n            Document newDocument;\n            StringBuilder distinguisherReplacer = new StringBuilder();\n            int matchingFilenameDistinguisher;\n            String nextToken;\n            Term newTerm;\n            String userHome;\n            String fileSeparator;\n            int userOption;\n            ArrayList<File> folderTextFiles = new ArrayList<File>();\n            ArrayList<File> folderRejectedFiles = new ArrayList<File>();\n            HashSet<File> ignoredFiles = new HashSet<File>();\n            FileNameExtensionFilter textFileFilter = new FileNameExtensionFilter(\"Text Files\", \"txt\");\n            Scanner tokenizer = null;\n            FileChannel fileSource = null;\n            FileChannel collectionDestination = null;\n            HashMap<String, Integer> termHashMap = null;\n            Index collectionIndex = activeCollection.getIndex();\n            int documentTermMaxFrequency;\n            int currentTermFrequency;\n            for (File folderFile : selectedFolder.listFiles()) if (textFileFilter.accept(folderFile)) folderTextFiles.add(folderFile); else folderRejectedFiles.add(folderFile);\n            for (File selectedFile : folderTextFiles) {\n                newDocumentName = selectedFile.getName();\n                newDocument = new Document(newDocumentName);\n                if (activeCollection.containsDocument(newDocument)) {\n                    matchingFilenameDistinguisher = 1;\n                    newDocumentName = newDocumentName.concat(\"(\" + matchingFilenameDistinguisher + \")\");\n                    newDocument.setDocumentName(newDocumentName);\n                    while (activeCollection.containsDocument(newDocument)) {\n                        matchingFilenameDistinguisher++;\n                        newDocumentName = distinguisherReplacer.replace(newDocumentName.length() - 2, newDocumentName.length() - 1, new Integer(matchingFilenameDistinguisher).toString()).toString();\n                        newDocument.setDocumentName(newDocumentName);\n                    }\n                }\n                termHashMap = new HashMap<String, Integer>();\n                try {\n                    tokenizer = new Scanner(new BufferedReader(new FileReader(selectedFile)));\n                    tokenizer.useDelimiter(Pattern.compile(\"\\\\p{Space}|\\\\p{Punct}|\\\\p{Cntrl}\"));\n                    while (tokenizer.hasNext()) {\n                        nextToken = tokenizer.next().toLowerCase();\n                        if (!nextToken.isEmpty()) if (termHashMap.containsKey(nextToken)) termHashMap.put(nextToken, termHashMap.get(nextToken) + 1); else termHashMap.put(nextToken, 1);\n                    }\n                    documentTermMaxFrequency = 0;\n                    for (String term : termHashMap.keySet()) {\n                        newTerm = new Term(term);\n                        if (!collectionIndex.termExists(newTerm)) collectionIndex.addTerm(newTerm);\n                        currentTermFrequency = termHashMap.get(term);\n                        if (currentTermFrequency > documentTermMaxFrequency) documentTermMaxFrequency = currentTermFrequency;\n                        collectionIndex.addOccurence(newTerm, newDocument, currentTermFrequency);\n                    }\n                    newDocument.setTermMaxFrequency(documentTermMaxFrequency);\n                    activeCollection.addDocument(newDocument);\n                    userHome = System.getProperty(\"user.home\");\n                    fileSeparator = System.getProperty(\"file.separator\");\n                    collectionCopyFile = new File(userHome + fileSeparator + \"Infrared\" + fileSeparator + activeCollection.getDocumentCollectionName() + fileSeparator + newDocumentName);\n                    collectionCopyFile.createNewFile();\n                    fileSource = new FileInputStream(selectedFile).getChannel();\n                    collectionDestination = new FileOutputStream(collectionCopyFile).getChannel();\n                    collectionDestination.transferFrom(fileSource, 0, fileSource.size());\n                } catch (FileNotFoundException e) {\n                    System.err.println(e.getMessage() + \" This error should never occur! The file was just selected!\");\n                    return;\n                } catch (IOException e) {\n                    userOption = JOptionPane.showConfirmDialog(this, \"A file insertion has failed. If you want it to ignore this\" + \"file, press YES, else press NO to repeat the insertion\", \"FileInsertionFailure\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                    if (userOption == JOptionPane.NO_OPTION) {\n                        activeCollection.removeDocument(newDocument);\n                        for (String term : termHashMap.keySet()) {\n                            collectionIndex.removeAllOccurences(new Term(term), newDocument);\n                        }\n                        folderTextFiles.add(selectedFile);\n                    } else ignoredFiles.add(selectedFile);\n                } finally {\n                    try {\n                        if (tokenizer != null) tokenizer.close();\n                        if (fileSource != null) fileSource.close();\n                        if (collectionDestination != null) collectionDestination.close();\n                    } catch (IOException e) {\n                        System.err.println(e.getMessage());\n                    }\n                }\n            }\n            if (ignoredFiles.size() > 0) {\n                IgnoredFilesDialog ignoredFilesDialog = new IgnoredFilesDialog(ignoredFiles, this);\n                ignoredFilesDialog.setVisible(true);\n            }\n            processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));\n        } else if (evt.getActionCommand().equalsIgnoreCase(JFileChooser.CANCEL_SELECTION)) processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));\n    }\n", "code2": "    String fetch_m3u(String m3u) {\n        InputStream pstream = null;\n        if (m3u.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), m3u);\n                } else {\n                    url = new URL(m3u);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + m3u);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            return line;\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"evt": [" evte", "evts", "ekte", "evmt", "ekt", " Evts", "evT", " Evtz", "evte", " Evte", " Evt", " evts", " evtz", "emt", "evtz", " evT", "ekT", "emte", "ekmt", " evmt", " awte", "emmt", " awtz", " awt", "emT", " awts"], "selectedFolder": ["currentArea", "lectedFolder", " selectedDir", "lectedArea", " selectedArea", "selectedContainer", " selectedDirectory", "lectedContainer", "currentDirectory", "currentFolder", "currentFile", "currentContainer", "lectedDirectory", " selectedContainer", "selectedDir", "lectedDir", "currentDir", "lectedFile", "selectedArea", "selectedDirectory"], "collectionCopyFile": ["collectionActivefile", "collectionEditedSourceFile", "collectionEditedFile", " collectionCopyfile", " collectionCopySourceFile", "collectionActiveFile", "collectionActiveSourceFile", "collectionCopyfile", "collectionEditedfile", "collectionCopySourceFile"], "newDocumentName": ["newdocumentUrl", "newFileLine", "freshDocumentLength", "newDocumentDefinition", "newDocAlias", "newFeaturePath", "newProductname", " newDocumentInfo", "newMediaName", "oldDocumentName", "newFileDefinition", "newQuerySync", " newDocumentNames", "NEWDocumentAlias", "newFileUrl", "newDocumentNames", " newDirectoryDefinition", "newContextName", " newDocumentUrl", "newProductAlias", "newFileNames", "newDocUrl", "newDirectoryName", " newDocumentLine", "olddocumentname", "NEWDocAlias", "newDocumentLine", "initialDocumentInfo", "newProductName", "newFileName", "newDocumentSync", " newDocumentAlias", "olddocumentAlias", "newConnectionname", "newQueryInfo", "newDocumentAlias", "newdocumentname", "newdocumentPath", "newdocumentInfo", "freshApplicationname", "freshDocumentName", " newDocumentPath", " newDirectoryInfo", "newConnectionLength", "newDocname", "newDirectoryNames", "newFeatureName", "newFeatureUrl", "newDocSync", "newDocumentPath", "oldDocumentAlias", "newFileAlias", "newdocumentLine", "newApplicationLength", " newDocumentDefinition", "NEWDocumentSync", "NEWDocName", "newDirectoryInfo", "freshApplicationLength", "initialMediaName", " newDirectoryUrl", "newDocumentUrl", "newApplicationName", "NEWDocumentName", "newdocumentAlias", " newDirectoryLine", "newContextname", "newFilePath", "newContextLength", "initialMediaInfo", "newQueryAlias", "newdocumentNames", "newdocumentTime", "NEWDocSync", "newDocumentLength", " newDirectoryName", "newDocumentname", "newdocumentSync", " newDirectoryAlias", "newDirectoryUrl", "newQueryTime", "newQueryName", "newMediaInfo", "NEWDocumentTime", " newDirectoryPath", "oldDocumentname", "newDirectoryAlias", "newdocumentName", "freshApplicationName", "initialDocumentName", "newDocName", "newApplicationname", "newDirectoryLine", "newDirectoryPath", "newDocDefinition", "NEWDocTime", "newFileInfo", "olddocumentName", "newConnectionName", "freshDocumentname", "newDocTime", "newDocumentTime", "newDocPath", "newDirectoryDefinition", "newDocumentInfo", " newDirectoryNames"], "newDocument": ["viewdocument", "nextNumber", "differentdocument", "differentProduct", "olddocument", "oldDirectory", "nextNode", "nextDoc", "newProduct", "currentDocument", "freshDirectory", " newContent", "newContent", "nextProduct", "differentContent", "freshProduct", "differentDocument", "oldProduct", " newDoc", "freshDocument", "oldDocument", "newNode", "currentDoc", " newDocuments", " newProduct", "newNumber", "newSession", "differentDocuments", "NewFile", "NewDoc", "freshDoc", "nextDocument", "Newdocument", "NewDocument", "nextContent", "oldDoc", "newDocuments", "NewNode", "currentFile", "currentdocument", "viewDoc", "newFile", "differentSession", "viewDocument", " newdocument", "nextFile", " newNumber", "freshNumber", "oldSession", "newdocument", "freshSession", "newDoc", "differentDirectory", "nextdocument", " newFile", "nextDocuments", "newDirectory", " newNode", "viewDocuments", "oldDocuments", "NewDocuments"], "distinguisherReplacer": ["distinguisherPrefacer", "distinguisherPlacers", "distinguishersPlacer", "distinguishReplacer", "distinguishReplacement", "distinguisherPrefacement", "distinguisherReplacers", "distinguishreplacement", "distinguishRepliner", "distinguishReplacers", "distinguisherJoaser", "distinguisherJoacer", "distinguisherPlaser", "distinguishreplacer", "distinguishersReplaser", "distinguisherPlacer", "distinguisherPlformer", "distinguisherreplacer", "distinguisherrepliner", "distinguisherJoformer", "distinguishersReplformer", "distinguisherPrefiner", "distinguishersReplacement", "distinguisherreplacement", "distinguishreplacers", "distinguisherPlacement", "distinguishersPlaser", "distinguisherPliner", "distinguisherPrefformer", "distinguisherReplaser", "distinguishersReplacer", "distinguisherreplacers", "distinguisherReplformer", "distinguisherPrefaser", "distinguishersPlformer", "distinguisherReplacement", "distinguisherJoacement", "distinguisherPrefacers", "distinguishersPlacement", "distinguisherRepliner", "distinguishrepliner"], "matchingFilenameDistinguisher": ["matchingFilenameDistinctisher", "matchingFilenameDistinguishers", "matchingFilenameDistributer", "matchingFilenameRestinctisher", "matchingFilenameDistanguishes", "matchingFilenameDistinctiner", "matchingFilenameDistinctioninger", "matchingFilenameContinguiner", "matchingFilenameRestinguishedcher", "matchingFilenameChinctionisher", "matchingFilenameChinguinger", "matchingFilenameRestinguishedishing", "matchingFilenameDistinguishedisher", "matchingFilenameChinctionishes", "matchingFilenameDistinguer", "matchingFilenameContinguishers", "matchingFilenameDistortioniner", "matchingFilenameDistinguish", "matchingFilenameDistortionishers", "matchingFilenameDistinquinger", "matchingFilenameDistinguished", "matchingFilenameContortionishers", "matchingFilenameDistinctcher", "matchingFilenameDistanguisher", "matchingFilenameRestinctishers", "matchingFilenameDistinctioncher", "matchingFilenameChinguished", "matchingFilenameContinguisher", "matchingFilenameDistricishers", "matchingFilenameDistributish", "matchingFilenameDistortionish", "matchingFilenameDistinquisher", "matchingFilenameDistriccher", "matchingFilenameRestinguish", "matchingFilenameDistributishing", "matchingFilenameDistinctishers", "matchingFilenameRestinguisher", "matchingFilenameDistricishing", "matchingFilenameDistingucher", "matchingFilenameDistributcher", "matchingFilenameDistinctionishes", "matchingFilenameDistinguishedishing", "matchingFilenameDistinctionished", "matchingFilenameChinguishes", "matchingFilenameRestingucher", "matchingFilenameContortionisher", "matchingFilenameDistinguishedishers", "matchingFilenameDistinctionisher", "matchingFilenameDistinctish", "matchingFilenameDistinguishedcher", "matchingFilenameDistinctionishers", "matchingFilenameRestinguishers", "matchingFilenameDistributishers", "matchingFilenameRestinguishedish", "matchingFilenameRestinguishing", "matchingFilenameDistinguinger", "matchingFilenameRestincter", "matchingFilenameDistinguishediller", "matchingFilenameDistinguishing", "matchingFilenameChinctioninger", "matchingFilenameDistanguished", "matchingFilenameRestinctish", "matchingFilenameDistinctioniner", "matchingFilenameDistinquished", "matchingFilenameDistinguiner", "matchingFilenameChinguisher", "matchingFilenameRestinguiller", "matchingFilenameRestinguishedisher", "matchingFilenameDistricisher", "matchingFilenameDistortioniller", "matchingFilenameDistinquishes", "matchingFilenameDistortioncher", "matchingFilenameRestinguer", "matchingFilenameContingucher", "matchingFilenameRestinguishediller", "matchingFilenameDistinguishedish", "matchingFilenameDistributisher", "matchingFilenameDistinguiller", "matchingFilenameDistinctioniller", "matchingFilenameDistinguishes", "matchingFilenameContortioniner", "matchingFilenameDistinctionish", "matchingFilenameRestinguishedishers", "matchingFilenameDistinguisheder", "matchingFilenameContortioncher", "matchingFilenameDistanguinger", "matchingFilenameDistincter", "matchingFilenameDistortionisher", "matchingFilenameChinctionished"], "nextToken": ["NextTerm", "newWord", " nextTerm", "NextWord", "NextTokens", "nextWord", "nextTokens", "newToken", "newTokens", " nextWord", " nextTokens", "nextTerm", "NextToken"], "newTerm": [" nextText", "newterm", " newWord", " nextTerm", " newText", " nextterm", "nextWord", " nextWord", "nextterm", "nextText", "newText", "nextTerm", " newterm", "newWord"], "userHome": [" userLocation", "humanHome", "UserHome", "Userhome", " userhome", "humanLocation", "userLocation", "UserLocation", "userhome", "humanhome"], "fileSeparator": ["fileDelatation", "fileDelatate", "fileDelatator", "fileSeparate", "fileSepparator", "fileSeparateator", "fileSeparateation", "fileSepparation", "fileDelarate", "fileSeparation", "fileSepparater", "fileDelatater", "fileDelarater", "fileSeparateater", "fileSeparater", "fileSepparate", "fileDelarator", "fileSeparateate", "fileSepatator", "fileDelaration", "fileSepatater", "fileSepatate", "fileSepatation"], "userOption": [" userOptions", "userEnd", "userOpt", "useOptions", "useOpt", "fileOption", " userEnd", " userOpt", "fileEnd", "fileOpt", "useOption", "fileOptions", "useEnd", "userOptions"], "folderTextFiles": ["folderInputSources", "folderEmptyParents", " folderTextSources", "folderReadFile", "folderTEXTFiles", " folderTextBooks", "folderTextBooks", "folderReadFiles", " folderInputBooks", " folderTextParents", "folderTextPages", "folderEmptyFiles", "folderTEXTPages", "FolderTextPages", "foldertextFiles", "folderInputPages", "folderTEXTBooks", " folderInputFiles", "folderInputItems", "folderReadPages", "folderTextParents", " folderInputItems", "FolderReadFile", " folderInputPages", "folderTEXTFile", "foldertextParents", "foldertextItems", "FolderTextFile", " folderTextfiles", " folderTextItems", "FolderReadFiles", " folderInputfiles", "folderTextSources", "folderInputFiles", " folderInputSources", "folderInputParents", " folderInputParents", "FolderTextFiles", "foldertextBooks", "folderEmptySources", "folderInputBooks", "foldertextSources", "folderTEXTItems", "folderInputfiles", " folderTextPages", "folderTextItems", "folderEmptyfiles", "FolderReadPages", "foldertextPages", "foldertextfiles", "folderTextfiles", "folderTextFile"], "folderRejectedFiles": ["folderPrejectedPages", "folderRejectedItems", "folderReceivedFile", "folderPrejectionFiles", "folderPreceivedItems", "folderRecludedFiles", "folderRejectionFiles", "folderReceivedItems", "folderReruptedFile", "folderPreceivedFile", "folderPrejectedFile", "folderReruptedItems", "folderPrejectionItems", "folderRejectionDocuments", "folderRecludedFile", "folderReceivedFiles", "folderReruptedDocuments", "folderReruptedFiles", "folderRejectionPages", "folderPreceivedPages", "folderPrejectionFile", "folderPrejectionDocuments", "folderPrejectedDocuments", "folderRecludedItems", "folderRejectedDocuments", "folderReruptedPages", "folderReceivedPages", "folderRejectedPages", "folderRejectionItems", "folderRecludedDocuments", "folderRejectionFile", "folderPrejectedItems", "folderPreceivedFiles", "folderRejectedFile", "folderPrejectedFiles"], "ignoredFiles": ["ignoveredParents", "colorableFolder", "ignoveredFiles", "ignouredParents", "ignorableFolder", "coloredFiles", "ignouredFiles", "colorableParents", "ignoredFolder", "coloredParents", "coloredFS", "ignoveredFS", "colorableFiles", "ignorableFS", "ignorableFiles", "ignoveredFolder", "ignorableParents", "ignouredFS", "ignouredFolder", "ignoredParents", "colorableFS", "coloredFolder", "ignoredFS"], "textFileFilter": ["textLineFilter", "classfileParser", "classFileHandler", "textFileParser", "classfileFilter", "textMessageFilter", "classFileFilter", "textFilesFilter", "classFileParser", "classfileManager", "textFilesHandler", "textMessageHandler", "textStringReader", "textLineManager", "TextFilesHandler", "textFileReader", "TextFilesReader", "textFilesExt", "TextFileReader", "textStringHandler", "textFileHandler", "classFileManager", "textFileExt", "TextFileFilter", "TextFileExt", "textfileHandler", "textLineHandler", "TextFilesExt", "textFilesManager", "TextFilesFilter", "TextFileHandler", "textLineParser", "textfileParser", "textStringFilter", "classfileHandler", "textFileManager", "textMessageExt", "textFilesReader", "textFilesParser", "textMessageReader", "textfileFilter", "textStringExt", "textfileManager"], "tokenizer": ["initializer", " tokenize", " tokenization", "tokenization", "Tokenized", "Tokenize", "tokenized", "Tokenizer", " tokenized", "initialized", "tokenize", "Tokenization", "initialize", "initialization"], "fileSource": ["FileResource", "collectionService", "FileSources", "selectionSource", "selectionResource", "FileService", "fileResource", "selectionService", "collectionSource", "collectionResource", "FileSource", "fileService", "collectionSources", "selectionSources", "fileSources"], "collectionDestination": ["collectionOrdribution", "collectionDestinator", "archiveDestribution", "collectionDestinate", "archiveOrdribution", "collectionOrdinator", "collectionHomeinator", "archiveDestinator", "archiveOrdinator", "collectionOrdinate", "collectionOrdination", "collectiondestinate", "collectiondestination", "collectionHomeination", "collectionDestribution", "archiveOrdinate", "archiveDestinate", "archiveOrdination", "collectiondestinator", "collectionHomeinate", "collectionHomeribution", "archiveDestination", "collectiondestribution"], "termHashMap": ["termHandMap", " termHandArray", "termChSet", "termHashSet", "termHashList", "TermMatMap", "termCacheSet", "termHashArray", "TermMatSet", "termChArray", "termHMap", "termMatList", "termHList", "termHandList", " termHashSet", "TermHashList", " termHandSet", "TermMatList", "TermMatArray", "termShSet", "termCacheMap", "TermHashSet", "TermHashArray", "termShMap", "termCacheList", "termMatSet", "termCacheArray", "termHSet", " termHandList", "termHandArray", " termHashList", " termHandMap", "termMatMap", "termChMap", "termChList", " termHashArray", "termShArray", "termMatArray", "termHandSet", "TermHashMap", "termShList", "termHArray"], "collectionIndex": ["collIndex", "containerIndex", " collectionId", "collectionAddress", "collId", "containerindex", "containerAddress", " collectionindex", "collindex", "collectionindex", "collAddress", " collectionAddress", "collectionId", "containerId"], "documentTermMaxFrequency": ["documentTermLimitFraction", "documentTermLimitFrequent", "documentTermLimitRepidelity", "documentTermMaxFrequent", "documentTermMaxWidelity", "documentTermMaxFraction", "documentTermLimitReprequency", "documentTermMaxWrequency", "documentTermMaxfraction", "documentTermLimitReprequent", "documentTermMaxfidelity", "documentTermLimitRepraction", "documentTermMaxfrequent", "documentTermMaxfrequency", "documentTermMaxRepidelity", "documentTermMaxReprequency", "documentTermMaxReprequent", "documentTermMaxRepraction", "documentTermMaxFidelity", "documentTermMaxWraction", "documentTermMaxWrequent", "documentTermLimitFrequency", "documentTermLimitFidelity"], "currentTermFrequency": ["currentWordFreshold", "currentTermPrequently", "currentWordRefrance", "currentTermPrance", "currentTermFrance", "currentTermRefrequently", "currentTermPreshold", "currentWordRefrequently", "currentTermPrequency", "currentTermRefreshold", "currentWordFrance", "currentTermRefrance", "currentWordRefreshold", "currentWordRefrequency", "currentTermBFrequency", "currentTermRefrequency", "currentTermBFrequently", "currentWordFrequently", "currentTermBFrance", "currentTermBFreshold", "currentTermFreshold", "currentWordFrequency", "currentTermFrequently"], "folderFile": ["draftChild", "folderImage", " folderFolder", "FolderFile", "draftF", "directoryFolder", "draftFile", "containerFiles", "archiveFolder", "archiveLine", "folderFolder", "projectFolder", "folderLine", "containerfile", "projectChild", "Folderfile", "containerImage", "flatfile", "folderF", "archiveFile", "directoryfile", "archiveFiles", " folderFiles", "folderChild", "directoryLine", "flatFile", "draftFolder", "projectF", "archiveChild", "FolderFiles", "FolderImage", "archivefile", "directoryFile", "folderfile", "flatFolder", "archiveF", "projectFile", "directoryLocal", " folderImage", "folderLocal", " folderLine", " folderLocal", "directoryFiles", " folderfile", "containerFile", "flatLocal", "folderFiles"], "selectedFile": ["selectionPage", "copyFile", "copyFiles", " selectedDocument", "currentDocument", "copyFolder", " selectedFiles", " selectedPage", "copyDocument", "selectionFolder", "currentFolder", "currentFile", "selectionFiles", "currentPage", "selectedDocument", "selectionDocument", "selectedPage", "selectionFile", "selectedFiles"]}}
{"id1": "458662", "id2": "7427550", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public void process(int branch, int level) {\n        Pattern p1 = Pattern.compile(\"<DIV class=\\\"treeline\\\">([^<]*)\");\n        Pattern p = Pattern.compile(\"<a href=\\\"javascript:checkBranch\\\\(([0-9]+), 'true'\\\\)\\\">([^<]*)</a>\");\n        Matcher m, m1;\n        URL url;\n        HttpURLConnection conn;\n        try {\n            url = new URL(\"http://cri-srv-ade.insa-toulouse.fr:8080/ade/standard/gui/tree.jsp?branchId=\" + branch + \"&expand=false&forceLoad=false&reload=false&scroll=0\");\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setRequestProperty(\"Cookie\", sessionId);\n            BufferedReader i = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            boolean doAdd = false;\n            while ((line = i.readLine()) != null) {\n                m1 = p1.matcher(line);\n                m = p.matcher(line);\n                if (m1.find()) {\n                    if (m1.group(1).equals(createIdent(level))) {\n                        doAdd = true;\n                    } else {\n                        doAdd = false;\n                    }\n                }\n                if (m.find()) {\n                    if (doAdd) {\n                        trainee.add(new Node(Integer.parseInt(m.group(1)), m.group(2)));\n                        System.out.println(m.group(1) + \" - \" + m.group(2));\n                    }\n                }\n            }\n            url = new URL(\"http://cri-srv-ade.insa-toulouse.fr:8080/ade/standard/gui/tree.jsp?branchId=\" + branch + \"&expand=false&forceLoad=false&reload=false&scroll=0\");\n        } catch (Exception e2) {\n            e2.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "id", "link", "connection", "feed", "buffer", "xml", "ll", "io", "l", "http", "lr", "fr", "base", "f", "loader", "loc", "href", "ref", "resource", "server", "address", "config", "el", "name", "filename", "ur", "ob", "bel", "sl", "string", "path", "image", "rl", "html", "uri", "file", "ssl", "URL", "service", "Url", "www", "null", "location"], "in": ["source", "reader", "id", "input", "inc", "din", "token", "xml", "min", "io", "nin", "conn", "con", "out", "this", "val", "part", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "resource", "serv", "config", "isin", "inner", "init", "ins", "gin", "ini", "a", "ex", "m", "image", "impl", "socket", "file", "c", "i", "IN", "err", "ssl", "or", "inn", "inside", "rin", "is", "cms", "bin"]}}
{"id1": "14677081", "id2": "15814327", "code1": "    protected void findPackages(Set<String> packages, ClassLoader classLoader) throws IOException {\n        Enumeration<URL> resources = classLoader.getResources(META_INF_SERVICES);\n        while (resources.hasMoreElements()) {\n            URL url = resources.nextElement();\n            String path = url.getPath();\n            if (!visitedURIs.contains(path)) {\n                visitedURIs.add(path);\n                LOG.debug(\"Loading file {} to retrieve list of packages, from url: {}\", META_INF_SERVICES, url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                try {\n                    while (true) {\n                        String line = reader.readLine();\n                        if (line == null) {\n                            break;\n                        }\n                        line = line.trim();\n                        if (line.startsWith(\"#\") || line.length() == 0) {\n                            continue;\n                        }\n                        tokenize(packages, line);\n                    }\n                } finally {\n                    IOHelper.close(reader, null, LOG);\n                }\n            }\n        }\n    }\n", "code2": "    private static void loadParentProperties(Properties props, ClassLoader cl) throws IOException {\n        String pName = props.getProperty(PARENT_PROPERTIES);\n        if (pName == null) {\n            return;\n        }\n        URL url = cl.getResource(pName);\n        if (url == null) {\n            return;\n        }\n        InputStream is = url.openStream();\n        if (is != null) {\n            Properties tmpProps = new Properties();\n            tmpProps.load(is);\n            is.close();\n            loadParentProperties(tmpProps, cl);\n            Iterator itr = tmpProps.entrySet().iterator();\n            while (itr.hasNext()) {\n                Map.Entry entry = (Map.Entry) itr.next();\n                if (!props.containsKey(entry.getKey())) {\n                    props.put(entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"packages": ["classes", "tests", "strings", "reports", "lines", "packs", "steps", "items", "bugs", "types", "photos", "products", "codes", "objects", "archives", "groups", "users", "plugins", "pages", "locks", "requires", "names", "versions", "roots", "scripts", "features", "apps", "projects", "files", "tags", "ids", "services", "modules", "packed", "assets"], "classLoader": ["baseLayer", "baseLoad", "fileLoad", "classLoad", "resourceLayer", "ClassLoad", "ClassLayer", "fileLoader", "ClassLoader", "classloader", "baseloader", "resourceLoader", "ClassLoading", "classLoading", "classLayer", "resourceloader", "Classloader", " classloader", " classLoading", "baseLoader", "resourceLoad", "fileloader", " classLoad", "fileLoading"], "resources": ["classes", "relations", "works", "reports", "links", "errors", "events", "lines", "items", "http", "types", "loader", "issues", "blocks", "bytes", "resource", "objects", "server", "ources", "qs", "archives", "groups", "users", "results", "Resources", "images", "pages", "rules", "roots", "rows", "docs", "features", "ips", "apps", "details", "times", "files", "projects", "fires", "services", "uploads", "reads"], "url": ["source", "page", "route", "id", "user", "browser", "feed", "connection", "pull", "download", "xml", "l", "http", "fr", "base", "loader", "f", "layer", "stream", "r", "resource", "server", "address", "element", "name", "gl", "full", "log", "api", "bel", "found", "text", "location", "li", "string", "il", "image", "load", "uri", "file", "i", "ssl", "or", "URL", "service", "Url", "www", "blog", "web", "str", "coll", "sl", "entry"], "path": ["source", "next", "folder", "host", "route", "id", "link", "user", "xml", "plugin", "http", "PATH", "request", "object", "Path", "part", "root", "base", "p", "data", "resource", "prefix", "child", "ath", "alias", "name", "filename", "method", "dir", "full", "pattern", "log", "api", "text", "key", "col", "string", "image", "pointer", "file", "uri", "str", "location", "type"], "reader": ["read", "upper", "input", "rar", "rx", "Reader", "feed", "buffer", "iter", "ser", "ro", "io", "keeper", "ry", "ler", "driver", "lr", "f", "loader", "worker", "oder", "stream", "r", "resource", "handler", "server", "editor", "writer", "inner", "er", "rer", "e", "per", "reading", "bird", "parser", "dr", "ri", "pointer", "i", "or", "rr", "ner"], "line": ["source", "page", "plus", "link", "write", "pe", "lf", "lines", "co", "message", "l", "letter", "one", "definition", "out", "in", "char", "LINE", "cell", "column", "Line", "row", "base", "model", "on", "data", "profile", "no", "inline", "style", "response", "strip", "el", "sync", "word", "part", "ge", "unit", "log", "cl", "non", "text", "lc", "job", "le", "string", "rule", "frame", "point", "pass", "parse", "error", "code", "file", "header", "item", "valid", "block", "character", "lin", "look", "str", "ip", "sl", "entry"]}}
{"id1": "19515832", "id2": "20409303", "code1": "    private static String calcReturnKey(String key) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        String text = new String();\n        byte[] sha1hash = new byte[20];\n        text = key + GUUI;\n        md.update(text.getBytes(), 0, text.length());\n        sha1hash = md.digest();\n        return (Helper.getBASE64(sha1hash));\n    }\n", "code2": "    private String md5(String input) {\n        MessageDigest md5Digest;\n        try {\n            md5Digest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new UserException(\"could not get a md5 message digest\", e);\n        }\n        md5Digest.update(input.getBytes());\n        return new String(md5Digest.digest());\n    }\n", "label": 1, "substitutes": {"key": ["source", "id", "hash", "input", "msg", "token", "keys", "message", "sign", "k", "char", "part", "base", "number", "data", "phrase", "Key", "hex", "match", "pair", "sum", "address", "KEY", "x", "word", "name", "password", "temp", "path", "cert", "seed", "code", "secret", "block", "value", "type"], "md": ["ad", "hash", "bf", "d", "mb", "cm", "dig", "dd", "ld", " MD", "message", "mm", "ma", "pd", "sm", "wd", "vd", "cmd", "ms", "mode", "po", "data", "mac", "mo", "bd", "bm", "hm", "mu", "mand", "editor", "mag", "meta", "mc", "sha", "body", "mp", "dm", "mod", "ME", "rm", "MD", "mt", "m", "M", "df", "mail", "od", "pm", "km", "mg", "code", "mad", "manager", "valid", "Cmd", "metadata", "amd", "nm", "me", "cmp"], "text": ["source", "translation", "contract", "url", "input", "TEXT", "txt", "binary", "token", "feed", "connection", "not", "buff", "username", "message", "output", "letter", "object", "char", "Text", "data", "hex", "match", "sum", "editor", "tx", "config", "inner", "element", "word", "name", "method", "body", "transfer", "ui", "pattern", "password", "post", "string", "path", "image", "ut", "font", "code", "context", "struct", "test", "str", "ext"], "sha1hash": ["sha4block", "sha3hash", "a5hash", "sha5hex", "a5hex", "sha4hash", "sha2Hash", "sha5hash", "a1sum", "a1hex", "sha5Hash", "ha1hex", "sha5sum", "alpha1hash", "sha2hash", "ha1key", "ha1Hash", "a1hash", "sha256Hash", "sha2hex", "sha2sum", "ha256hash", "ha256key", "ha1hash", "ha256hex", "sha1sum", "alpha4hash", "sha5key", "sha1Hash", "sha3hex", "sha256hex", "sha4Hash", "alpha1Hash", "alpha4block", "sha5block", "sha256hash", "a5sum", "sha2block", "alpha1block", "sha3sum", "sha1key", "a5key", "sha1hex", "a1key", "sha256key", "ha256Hash", "alpha4Hash", "sha3key", "sha1block", "sha2key"]}}
{"id1": "22975613", "id2": "5936410", "code1": "    public ZipViewdataReader(ZipInputStream stream) throws IOException {\n        ZipEntry ze;\n        while ((ze = stream.getNextEntry()) != null) {\n            File temp = File.createTempFile(\"spool.\", \".synu\");\n            temp.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(temp);\n            byte[] buffer = new byte[1024 * 1024];\n            int length;\n            while ((length = stream.read(buffer)) != -1) fos.write(buffer, 0, length);\n            fos.close();\n            String name = ze.getName();\n            String[] parts = name.split(\"[\\\\\\\\/]\");\n            this._file_hash.put(parts[parts.length - 1], temp);\n        }\n        stream.close();\n        for (String key : this._file_hash.keySet()) if (key.endsWith(\"Viewdata\")) {\n            File f = this._file_hash.get(key);\n            FileReader fr = new FileReader(f);\n            this._viewdata = new BufferedReader(fr);\n            break;\n        }\n        if (this._viewdata == null) throw new FileNotFoundException(\"No Viewdata found in ZIP file.\");\n    }\n", "code2": "    public void run() {\n        try {\n            String getter = null;\n            String str, targetHost = \"\", httpHeader = \"\";\n            int targetPort = 80;\n            while (true) {\n                str = fromBrowser.readLine();\n                if (str.startsWith(\"GET\") || str.startsWith(\"DESCRIBE\") || str.startsWith(\"POST\") || str.startsWith(\"HEAD\")) {\n                    getter = str;\n                }\n                if (str.startsWith(\"Accept-Encoding: gzip\")) {\n                    str = \"Accept-Encoding: identity\";\n                }\n                httpHeader += str + \"\\r\\n\";\n                if (str.startsWith(\"Host: \")) {\n                    targetHost = str.substring(6);\n                } else if (str.startsWith(\"DESCRIBE\")) {\n                    targetPort = 554;\n                    targetHost = str.substring(str.indexOf(\"//\") + 2);\n                    targetHost = targetHost.substring(0, targetHost.indexOf(\"/\"));\n                }\n                if (str.length() == 0) {\n                    break;\n                }\n            }\n            String target = targetHost;\n            if (targetHost.indexOf(\":\") > -1) {\n                try {\n                    targetPort = Integer.parseInt(targetHost.substring(targetHost.indexOf(\":\") + 1));\n                } catch (NumberFormatException nfe) {\n                }\n                target = targetHost.substring(0, targetHost.indexOf(\":\"));\n            }\n            logger.trace(\"[PROXY] Connect to: \" + target + \" and port: \" + targetPort);\n            socketToWeb = new Socket(InetAddress.getByName(target), targetPort);\n            InputStream sockWebInputStream = socketToWeb.getInputStream();\n            toWeb = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socketToWeb.getOutputStream())), true);\n            toWeb.println(httpHeader);\n            toWeb.flush();\n            StringTokenizer st = new StringTokenizer(getter, \" \");\n            st.nextToken();\n            String askedResource = st.nextToken();\n            askedResource = askedResource.substring(askedResource.indexOf(targetHost) + targetHost.length());\n            logger.trace(\"[PROXY] Asked resource: \" + askedResource);\n            String directoryResource = askedResource.substring(0, askedResource.lastIndexOf(\"/\"));\n            directoryResource = getWritableFileName(directoryResource);\n            String fileResource = askedResource.substring(askedResource.lastIndexOf(\"/\") + 1);\n            fileResource = getWritableFileName(fileResource);\n            fileResource = fileResource + \".cached\";\n            String fileN = \"proxycache/\" + target + \"/\" + directoryResource;\n            File directoryResourceFile = new File(fileN);\n            if (writeCache) {\n                directoryResourceFile.mkdirs();\n            }\n            File cachedResource = new File(directoryResourceFile, fileResource);\n            byte[] buffer = new byte[8192];\n            boolean resourceExists = cachedResource.exists() || this.getClass().getResource(\"/\" + fileN) != null;\n            boolean inMemory = writeCache && !resourceExists;\n            FileOutputStream fOUT = null;\n            if (resourceExists) {\n                logger.trace(\"[PROXY] File is cached: \" + cachedResource.getAbsolutePath());\n                sockWebInputStream.close();\n                if (cachedResource.exists()) {\n                    sockWebInputStream = new FileInputStream(cachedResource);\n                } else {\n                    sockWebInputStream = this.getClass().getResourceAsStream(\"/\" + fileN);\n                }\n            } else if (writeCache) {\n                logger.trace(\"[PROXY] File is not cached / Writing in it: \" + cachedResource.getAbsolutePath());\n                fOUT = new FileOutputStream(cachedResource, false);\n            }\n            OutputStream baos = null;\n            if (inMemory) {\n                baos = new ByteArrayOutputStream();\n            } else {\n                baos = toBrowser;\n            }\n            long total_read = 0;\n            int bytes_read;\n            long CL = 10000000000L;\n            while (total_read < CL && (bytes_read = sockWebInputStream.read(buffer)) != -1) {\n                if (!resourceExists) {\n                    if (10000000000L == CL) {\n                        String s = new String(buffer, 0, bytes_read);\n                        int clPos = s.indexOf(\"Content-Length: \");\n                        if (clPos > -1) {\n                            CL = Integer.parseInt(s.substring(clPos + 16, s.indexOf(\"\\n\", clPos)).trim());\n                            logger.trace(\"Found Content Length: \" + CL);\n                        }\n                    }\n                    if (bytes_read >= 7) {\n                        byte end[] = new byte[7];\n                        System.arraycopy(buffer, bytes_read - 7, end, 0, 7);\n                        if (new String(end).equals(\"\\r\\n0\\r\\n\\r\\n\")) {\n                            System.out.println(\"end of transfer chunked\");\n                            CL = -1;\n                        }\n                    }\n                    if (writeCache) {\n                        fOUT.write(buffer, 0, bytes_read);\n                    }\n                }\n                baos.write(buffer, 0, bytes_read);\n                total_read += bytes_read;\n            }\n            if (inMemory) {\n                baos.close();\n                toBrowser.write(((ByteArrayOutputStream) baos).toByteArray());\n            }\n            if (writeCache && fOUT != null) {\n                fOUT.close();\n            }\n            socketToWeb.close();\n            toBrowser.close();\n        } catch (IOException e) {\n        } finally {\n            try {\n                if (toWeb != null) {\n                    toWeb.close();\n                }\n                if (toBrowser != null) {\n                    toBrowser.close();\n                }\n                socket.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"stream": ["source", "plus", "read", "reader", "draft", "url", "input", "trans", "user", "pe", "feed", "Stream", "result", "iter", "engine", "pipe", "output", "io", "src", "view", "from", "iterator", "flash", "sw", "object", "this", "http", "loop", "loader", "data", "zip", "response", "resource", "server", "writer", "steam", "iver", "body", "e", "cont", "log", "wave", "v", "path", "pool", "cache", "file", "ssl", "context", "form", "stack", "sample", "sl", "entry"], "ze": ["pe", "zes", "za", "fee", "ee", "xe", "ez", "zy", "ane", "fe", "ine", "zip", "zi", "zen", "he", "ffe", "el", "zone", "zo", "ne", "ge", "liner", "e", "de", "ae", "cel", "ve", "oe", "kel", "je", "zz", "se", "le", "sle", "ke", "zer", "ZE", "pse", "frame", "zed", "zie", "ses", "ele", "ce", "fle", "kee", "z", "te", "entry", "sl", "ie"], "temp": ["source", "folder", "tmp", "py", "txt", "ht", "cf", "porary", "iter", "now", "pipe", "io", "flat", "w", "thread", "out", "fp", "fake", "this", "fd", "part", "base", "tem", "zip", "clean", "tx", "template", "wrap", "Temp", "dest", "full", "cel", "ph", "v", "path", "pool", " temporary", "cache", "file", "c", "emp", "lock", "flo", "current", "local", "form", "empty", "test", "copy", "dat", "null", "p"], "fos": ["los", "Foos", "infOS", "fose", " fo", " flos", "flos", "fo", " fOS", "Fos", "daos", "infos", "Fo", "Flos", "fios", "dos", " fis", " fios", "info", "lo", "Faos", "doos", "Fis", "FOS", "infis", "Fose", "fOS", "faos", "foos", "laos", "loos", "fis", "infios", "infose", "Fios", "inflos", " fose"], "buffer": ["read", "size", "reader", "url", "queue", "memory", "binary", "input", "feed", "reference", "buff", "result", "Buffer", "limit", "request", "b", "layer", "base", "data", "bytes", "resource", "server", "raw", "address", "uffer", "shape", "transfer", "null", "batch", "bb", "flush", "wave", "uf", "buf", "offset", "slice", "string", "count", "document", "window", "border", "cache", "fb", "array", "header", "position", "duration"], "length": ["language", "shift", "left", "size", "en", "url", "pe", "last", "len", "feed", "range", "right", "limit", "from", "view", "ength", "l", "end", "part", "row", "number", "loc", "data", "match", "sequence", "shape", "depth", "full", "flow", "max", "partial", "time", "offset", "slice", "string", "count", "index", "before", "close", "load", "lock", "Length", "code", "width", "character", "array", "block", "total", "level", "position", "form", "value", "line", "duration", "type"], "name": ["ame", "id", "size", "url", "Name", "not", "one", "object", "part", "base", "number", "data", "no", "named", "version", "n", "info", "x", "word", "body", "na", "s", "non", "names", "string", "path", "file", "code", "str", "entry", "type"], "parts": ["states", "ks", "strings", "split", "ings", "points", "pieces", "lines", "keys", "parents", "params", "ns", "ars", "part", "base", "as", "data", "Parts", "bytes", "places", "objects", "es", "qs", "groups", "component", "xs", "ins", "s", "patch", "members", "values", "names", "Part", "words", "string", "ops", "ands", "parse", "details", "pos", "arts", "is", "bits", "ps", "str", "p", "airs"], "key": ["str", "id", "ame", "hash", "link", "pe", "fee", "co", "keys", "k", "sign", "char", "cell", "part", "row", "base", "data", "Key", "r", "work", "pair", "ie", "child", "match", "info", "KEY", "section", "x", "word", "full", "e", "ace", "exp", "step", "ph", "ch", "lc", "ke", "col", "string", "lock", "file", "code", "q", "item", "lease", "type", "field", "ck", "value", "ip", "entry"], "f": ["rf", "feed", "cf", "k", "fo", "fc", "l", "fs", "fp", "inf", "sf", "fd", "b", "data", "fe", "ref", "r", "info", "er", "e", "o", "fn", "F", "fl", "df", "v", "j", "c", "file", "i", "fb", "raf", "fm", "form", "fa", "p", "fx"], "fr": ["reader", "rf", "gr", "bf", "arr", "cf", "range", "br", "l", "fs", "fp", "sf", "Fr", "lr", "fe", "r", "ur", "fer", "sr", "pr", "ch", "fl", " dr", "dr", "tr", "vr", "yr", "FR", "fb", "err", "rr", "fm", "fin", "kr", "str", "rb", "wr", "fx"], "_viewdata": ["_featurepartial", "_facename", "_faceData", " _viewData", "_viewreader", "_viewpartial", "_featuredata", "_featurename", "_Viewdata", "_viewsData", "_viewname", "_facedata", "_facepartial", "_featureData", " _viewreader", "_viewData", "_viewsdata", "_Viewreader", "_viewsreader", "_ViewData"]}}
{"id1": "22237326", "id2": "19002156", "code1": "    public QDataSet doRead(URL url, URLConnection connect) throws IOException, ParserConfigurationException, SAXException {\n        codebase = url;\n        InputStream in;\n        if (connect != null) {\n            in = connect.getInputStream();\n        } else {\n            in = url.openStream();\n        }\n        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        InputSource source = new InputSource(in);\n        Document document = builder.parse(source);\n        in.close();\n        QDataSet result = null;\n        NodeList kids = document.getChildNodes();\n        for (int i = 0; i < kids.getLength(); i++) {\n            Node n = kids.item(i);\n            if (n.getNodeName().equals(\"netcdf\")) {\n                result = netcdf(n);\n            }\n        }\n        return result;\n    }\n", "code2": "    private String jarDiagnostics(Throwable throwable, File[] files) throws IOException {\n        File home = new File(System.getProperty(\"user.home\"));\n        File jar_file = File.createTempFile(\"nuages-diagnostic.\", \".jar\", home);\n        FileOutputStream fos = new FileOutputStream(jar_file);\n        JarOutputStream jos = new JarOutputStream(fos);\n        ZipEntry ze = new ZipEntry(\"Exception\");\n        jos.putNextEntry(ze);\n        PrintStream ps = new PrintStream(jos);\n        throwable.printStackTrace(ps);\n        for (File file : files) if ((file != null) && file.exists()) {\n            ze = new ZipEntry(file.getName());\n            jos.putNextEntry(ze);\n            byte[] buffer = new byte[65536];\n            FileInputStream fis = new FileInputStream(file);\n            int len;\n            while ((len = fis.read(buffer)) > 0) jos.write(buffer, 0, len);\n            fis.close();\n        }\n        jos.close();\n        return jar_file.getPath();\n    }\n", "label": 0, "substitutes": {"url": ["host", "id", "link", "connection", "feed", "xml", "buffer", "download", "build", "ll", "conn", "l", "http", "object", "b", "base", "loc", "href", "resource", "server", "contact", "address", "config", "name", "ob", "log", "api", "string", "path", "image", "file", "uri", "ssl", "URL", "service", "Url", "proxy", "web", "str", "sl"], "connect": ["select", "contract", "link", "connection", "open", "download", "build", "bind", "conn", "ct", "control", "con", "client", "request", "object", "union", "connected", "login", "serv", "config", "contact", "call", "condition", "exec", "access", "init", "log", "text", "Connect", "syn", "cli", "session", "close", "path", "graph", "don", "socket", "ssl", "struct", "construct", "process", "Conn", "port"], "codebase": ["coderef", "pagebase", "Codeline", "pageref", " codeBase", "codeline", " coderef", "Coderef", "pageBase", " codeline", "Codebase", "CodeBase", "pageline", "codeBase"], "in": ["get", "reader", "id", "input", "inc", "en", "token", "win", "connection", "nin", "conn", "src", "con", "out", "b", "login", "f", "as", "base", "data", "In", "pin", "stream", "again", "serv", "isin", "inner", "init", "it", "ins", "gin", "ini", "a", "m", "ex", "cli", "kin", "image", "cin", "lock", "socket", "file", "uri", "IN", "like", "ssl", "inn", "is", "lin", "bin"], "builder": ["reader", "sb", "wrapper", "connection", "buffer", "build", "keeper", "pb", "l", "definition", "driver", "b", "client", "object", "row", "base", "f", "loader", "builders", "config", "info", "writer", "creator", "Builder", "container", "parser", "instance", "api", "v", "building", "library", "db", "built", "context", "or", "manager", "hub", "construct", "s", "entry"], "source": ["reader", "input", "connection", "io", "src", "from", "out", "driver", "Source", "client", "this", "base", "data", "stream", "storage", "resource", "raw", "inner", "ins", "parser", "text", "ource", "string", "parse", "uri", "context", "file", "inn", "service", "start", "proxy", "s"], "document": ["page", "parent", "office", "connection", "Document", "xml", "build", "doc", "l", "root", "f", "base", "number", "data", "directory", "response", "tree", "resource", "config", "element", "container", "json", "parser", "text", "content", " documentation", "docs", "media", "node", "graph", "record", "context", "parse", "ocument", "person", "music", "concept", "database", "project", "copy", "collection", "null"], "result": ["page", "parent", "folder", "value", "successful", "compl", "default", "term", "success", "dict", "Result", "range", "division", "function", "product", "complete", "grade", "card", "out", "root", "data", "future", "include", "response", "r", "resource", "match", "ret", "feature", "info", "event", "results", "report", "runner", "instance", "found", "transform", "df", "cache", "obj", "replace", "error", "load", "err", "search", "uri", "array", "current", "valid", "rate", "test", "res", "use"], "kids": ["works", "los", "cells", "ks", "nice", "girls", "events", "things", "pieces", "dad", "lines", "parents", " kid", "stuff", "pins", "bars", "okers", "idd", "poly", "ilies", "lins", "Kid", "oi", "child", "fam", "children", "js", "devices", "rooms", "ods", "kind", "kas", "cs", "boys", "inos", "iq", "nos", "done", "roots", "cats", "les", "ops", "ours", "Kids", " Kids", "ku", "jobs", "pots", "ids", "ds", "holes", "kid", "bits"], "i": ["id", "si", "d", "abi", "multi", "qi", "iu", "hi", "phi", "io", "yi", "y", "b", "f", "di", "bi", "mu", "I", "oi", "ti", "ai", "gi", "info", "x", "ix", "ui", "ci", "u", "o", "e", "eni", "ini", "a", "li", "v", "xi", "ri", "index", "slice", "wei", "j", "c", "uri", "ori", "ii", "pi", "z", "mi", "me", "ip", "ie"], "n": ["Node", "none", "an", "ln", "d", "net", "nn", "not", "k", "l", "y", "cdn", "b", "ns", "f", "no", "rn", "r", "child", "dn", "adj", "cn", "nor", "name", "ne", "na", "u", "o", "e", "nt", "gn", "non", "fn", "t", "syn", "nu", "ann", "N", "node", "c", "nb", "ng", "sn", "z", "nc", "ner", "p"]}}
{"id1": "5159006", "id2": "4265804", "code1": "    public InputStream start(String classname, String jarFileURI, String... params) throws IOException {\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n\n            @Override\n            public void run() {\n                terminate();\n            }\n        });\n        System.out.println(\"loading jar file \" + jarFileURI + \" ...\");\n        URL url = new URL(jarFileURI);\n        InputStream is = url.openStream();\n        jarFile = QAUtil.createTempfile();\n        FileOutputStream fos = new FileOutputStream(jarFile);\n        byte[] buffer = new byte[4096];\n        int bytes_read;\n        while ((bytes_read = is.read(buffer)) != -1) {\n            fos.write(buffer, 0, bytes_read);\n        }\n        fos.close();\n        is.close();\n        String[] args = new String[params.length + 4];\n        args[0] = \"java\";\n        args[1] = \"-cp\";\n        args[2] = jarFile.getAbsolutePath();\n        args[3] = classname;\n        System.arraycopy(params, 0, args, 4, params.length);\n        StringBuilder sb = new StringBuilder();\n        for (String arg : args) {\n            sb.append(arg + \" \");\n        }\n        System.out.println(\"execute \" + sb);\n        ProcessBuilder pb = new ProcessBuilder(args);\n        p = pb.start();\n        return p.getInputStream();\n    }\n", "code2": "    private static ArrayList<String> YahooSearch(String query) {\n        ArrayList<String> yahooSearchResults = new ArrayList<String>();\n        try {\n            String request = \"http://boss.yahooapis.com/ysearch/web/v1/\" + URLEncoder.encode(\"Java example for \" + query, \"UTF-8\") + \"?appid=zfau5aPV34ETbq9mWU0ui5e04y0rIewg1zwvzHb1tGoBFK2nSCU1SKS2D4zphh2rd3Wf\" + \"&format=xml&count=30&type=-msoffice,-pdf\";\n            URL url = new URL(request);\n            System.out.println(\"Host : \" + url.getHost());\n            url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            String finalContents = \"\";\n            while ((inputLine = reader.readLine()) != null) {\n                finalContents += \"\\n\" + inputLine;\n            }\n            Document doc = Jsoup.parse(finalContents);\n            Elements eles = doc.getElementsByTag(\"url\");\n            for (Element ele : eles) {\n                yahooSearchResults.add(ele.text());\n                System.out.println(\"YahooResult: \" + ele.text());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return yahooSearchResults;\n    }\n", "label": 0, "substitutes": {"classname": ["CLASSpath", "CLASSName", " classpath", "classpath", " className", "CLASSNAME", "ClassName", " classNAME", "ClassNAME", "className", "Classname", "classNAME", "CLASSname", "Classpath"], "jarFileURI": ["jarFilesuri", "jarDiruri", "jarStringURL", "jarClassURI", "jarFileuri", "jarfileName", "jarClassuri", "jarDirURL", "jarFilesURL", "Jarfileuri", "JarfileName", "JarFileuri", "jarStringURI", "jarFilesURI", "JarfilePath", "JarFileURL", "jarfileuri", "jarDirURI", "jarFilePath", "jarfileURL", "jarStringName", "jarfileURI", "JarFilePath", "jarClassPath", "jarClassURL", "JarfileURI", "jarFilesPath", "jarfilePath", "JarFileURI", "JarFileName", "jarFilesName", "JarfileURL", "jarFileName", "jarFileURL", "jarStringuri"], "params": ["options", "resources", "source", "none", "series", "Args", "points", "plugin", "settings", "Param", "pipe", "properties", "pins", "request", "gs", "css", "types", "ars", "http", "afi", "changes", "config", "par", "plugins", "results", "target", "param", "json", "spec", "values", "requires", "names", "ls", "rules", "words", "Par", "string", "list", "sp", "parse", "uri", "Parameters", "array", "files", "parts", "services", "ams", "ps", "ip"], "url": ["source", "host", "page", "id", "connection", "ll", "io", "l", "ul", "http", "base", "loader", "f", "loc", "stream", "zip", "resource", "server", "address", "el", "ur", "api", "fl", "ls", "string", "path", "il", "image", "file", "uri", "ssl", "i", "URL", "Url", "web", "str", "jar", "sl"], "is": ["get", "id", "ils", "isa", "io", "ais", "http", "isl", "out", "in", "as", "was", "are", "iss", "stream", "os", "ris", "serv", "ai", "info", "es", "ir", "has", "isi", "it", "ui", "iris", "IS", "api", "abs", "ri", "il", "ios", "ops", "ori", "uri", "its", "i", "im", "or", "us", "bis", "Is", "iso", "ps", "s", "ip", "ib", "ie"], "jarFile": [" jarDir", "javafile", " jarFiles", "jarFiles", "javaFile", "JarFile", "jarfile", "JarDir", "Jarfile", " jarfile", "JarFiles", "jarDir", "javaDir", "javaFiles"], "fos": ["sfos", "bops", "fus", " foes", "baos", "foss", " fops", "sfaos", "fops", "bos", "fios", "hoes", " fios", "boss", " faos", " fus", "hus", "hos", "hops", "faos", "hoss", "bus", "bios", "sfops", "hios", "sfoss", " foss", "foes", "boes"], "buffer": ["page", "read", "reader", "queue", "memory", "binary", "feed", "reference", "buff", "iter", "Buffer", "limit", "layer", "channel", "base", "data", "number", "phrase", "bytes", "address", "writer", "pad", "uffer", "shape", "sequence", "padding", "transfer", "null", "batch", "length", "flush", "wave", "buf", "offset", "slice", "border", "seed", "cache", "header", "block"], "bytes_read": ["bytes_size", "byteslexwrite", "flows_need", "bytes_led", " bytes_size", "byteslexsize", "bytes64readable", "bytes64need", " bytes_write", "bytesSreads", "byteslexride", "bytes_reads", "flows_reads", "bytes_need", "bytes64reads", "bytes_ride", "bytes_Read", "bytes_readable", "flows_read", "bytesSneed", "byteslexread", " bytes_Read", "bytes64read", "bytesSreadable", "flows_readable", "bytesSread", "bytes_write", " bytes_led", " bytes_ride"], "sb": ["lp", "su", "nl", "bf", "si", "bh", "mb", "sth", "buff", "sg", "bg", "sbm", "src", "bps", "pg", "b", "sf", "bc", "kb", "bm", "stab", "abb", "bs", "obb", "ub", "sup", "bj", "SB", "bb", "ob", "zb", "buf", "ls", "gb", "xb", "string", "eb", "bsp", "ab", "db", "bt", "wb", "fb", "sq", "lab", "lb", "rb", "bp"], "arg": ["entry", "attr", "str", "input", "arr", "argument", "result", "in", "val", " argument", "cell", "as", "data", "arm", "Arg", "class", "style", "enc", "ass", "role", "par", "var", "use", "exec", "name", "method", "event", "ace", "param", "arc", "v", "key", "string", "parse", "err", "or", "g", "ar", "ig", "option", "value", "jar", "pass"], "pb": ["lp", "bp", "py", "cb", "proc", "pkg", "PB", "jp", "pd", "fc", "fp", "pg", "b", "cp", "rob", "ctx", "dp", "wp", "pc", "pa", "hp", "mp", "vp", "tp", "prot", "pid", "gp", "api", "pr", "pm", "pro", "db", "np", "fb", "pp", "lab", "ps", "rb"], "p": ["lp", "bp", "py", "tmp", "cb", "proc", "P", "pkg", "jp", "fp", "b", "pg", "po", "cp", "r", "ctx", "dp", "wp", "pc", "exec", "tp", "hp", "pa", "e", "pid", "per", "t", "parser", "m", "pm", "sp", "c", "j", "pp", "q", "pi", "process", "op"]}}
{"id1": "10839253", "id2": "15605423", "code1": "    public static String getWebContent(String remoteUrl, String encoding) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            java.net.URL url = new java.net.URL(remoteUrl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            String line;\n            while ((line = in.readLine()) != null) {\n                sb.append(line);\n            }\n            in.close();\n        } catch (Exception e) {\n            logger.error(\"\u83b7\u53d6\u8fdc\u7a0b\u7f51\u5740\u5185\u5bb9\u5931\u8d25 - \" + remoteUrl, e);\n        }\n        return sb.toString();\n    }\n", "code2": "    private static void generateGIF(Connection con, String category, String area_code, String topic_code, String timeseries, String diff_timeseries, Calendar time, String area_label, String raster_label, String image_label, String note, Rectangle2D bounds, Rectangle2D raster_bounds, String source_filename, String diff_filename, String legend_filename, String output_filename, int output_maximum_size) throws SQLException, IOException {\n        System.out.println(\"ImageCropper.generateGIF begin\");\n        MapContext map_context = new MapContext(\"test\", new Configuration());\n        try {\n            Map map = new Map(map_context, area_label, new Configuration());\n            map.setCoordSys(ProjectionCategories.default_coordinate_system);\n            map.setPatternOutline(new XPatternOutline(new XPatternPaint(Color.white)));\n            String type = null;\n            RasterLayer rlayer = getRasterLayer(map, raster_label, getLinuxPathEquivalent(source_filename), getLinuxPathEquivalent(diff_filename), type, getLinuxPathEquivalent(legend_filename));\n            map.addLayer(rlayer, true);\n            map.setBounds2DImage(bounds, true);\n            Dimension image_dim = null;\n            image_dim = new Dimension((int) rlayer.raster.getDeviceBounds().getWidth() + 1, (int) rlayer.raster.getDeviceBounds().getHeight() + 1);\n            if (output_maximum_size > 0) {\n                double width_factor = image_dim.getWidth() / output_maximum_size;\n                double height_factor = image_dim.getHeight() / output_maximum_size;\n                double factor = Math.max(width_factor, height_factor);\n                if (factor > 1.0) {\n                    image_dim.setSize(image_dim.getWidth() / factor, image_dim.getHeight() / factor);\n                }\n            }\n            map.setImageDimension(image_dim);\n            map.scale();\n            image_dim = new Dimension((int) map.getBounds2DImage().getWidth(), (int) map.getBounds2DImage().getHeight());\n            Image image = null;\n            Graphics gr = null;\n            image = ImageCreator.getImage(image_dim);\n            gr = image.getGraphics();\n            try {\n                map.paint(gr);\n            } catch (Exception e) {\n                Debug.println(\"map.paint error: \" + e.getMessage());\n            }\n            String gif_filename = \"\";\n            try {\n                gif_filename = formatPath(category, timeseries, output_filename);\n                new File(new_filename).mkdirs();\n                new GifEncoder(image, new FileOutputStream(gif_filename)).encode();\n            } catch (IOException e) {\n                Debug.println(\"ImageCropper.generateGIF e: \" + e.getMessage());\n                throw new IOException(\"GenerateGIF.IOException: \" + e);\n            }\n            PreparedStatement pstmt = null;\n            try {\n                String delete_raster = \"delete raster_layer where \" + \"label='\" + gif_name.trim() + \"' and category='\" + category.trim() + \"' and area_code=' \" + area_code.trim() + \"'\";\n                pstmt = con.prepareStatement(delete_raster);\n                boolean del = pstmt.execute();\n                pstmt.close();\n                String insert_raster = \"insert into RASTER_LAYER \" + \"values(RASTER_LAYER_ID.nextval, ?, ?, ?, \" + \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \" + \"SYSDATE, ?)\";\n                pstmt = con.prepareStatement(insert_raster);\n                pstmt.setString(1, gif_name);\n                pstmt.setString(2, category);\n                pstmt.setString(3, area_code);\n                pstmt.setString(4, topic_code);\n                if (time == null) {\n                    pstmt.setNull(5, java.sql.Types.DATE);\n                } else {\n                    pstmt.setDate(5, new java.sql.Date(time.getTimeInMillis()));\n                }\n                pstmt.setString(6, timeseries);\n                pstmt.setString(7, gif_filename);\n                pstmt.setNull(8, java.sql.Types.INTEGER);\n                pstmt.setNull(9, java.sql.Types.INTEGER);\n                pstmt.setDouble(10, raster_bounds.getX());\n                pstmt.setDouble(11, raster_bounds.getY());\n                pstmt.setDouble(12, raster_bounds.getWidth());\n                pstmt.setDouble(13, raster_bounds.getHeight());\n                pstmt.setString(14, note);\n                int sequence = 0;\n                if (gif_name.endsWith(\"DP\")) {\n                    sequence = 1;\n                } else if (gif_name.endsWith(\"DY\")) {\n                    sequence = 2;\n                } else if (gif_name.endsWith(\"DA\")) {\n                    sequence = 3;\n                }\n                pstmt.setInt(15, sequence);\n                pstmt.executeUpdate();\n            } catch (SQLException e) {\n                Debug.println(\"SQLException occurred e: \" + e.getMessage());\n                con.rollback();\n                throw new SQLException(\"GenerateGIF.SQLException: \" + e);\n            } finally {\n                pstmt.close();\n            }\n        } catch (Exception e) {\n            Debug.println(\"ImageCropper.generateGIF e: \" + e.getMessage());\n        }\n        System.out.println(\"ImageCropper.generateGIF end\");\n    }\n", "label": 0, "substitutes": {"remoteUrl": [" remoteurl", "newPage", "RemoteUrl", "Remoteurl", "externalurl", "externalUrl", "remoteURL", "RemoteURL", "networkURL", " remotePage", "RemotePage", "remotePage", "externalURL", "networkUr", "remoteurl", "newurl", "RemoteUr", "externalUr", " remoteURL", "newUrl", "networkUrl", "remoteUr", "newURL", "networkurl"], "encoding": ["Encocol", "coded", "encasing", "Encoder", "decasing", "encoded", "decocol", "decoder", "locoding", "cocol", "Encasing", "Encale", "encocol", "decoding", "encoder", "coding", "Encoding", "coder", "locale", "casing", "cale", "encale", "Encoded", "locasing", "locoded"], "sb": ["cb", "sa", "bf", "si", "bh", "nn", "binary", "buffer", "sth", "sg", "ws", "sm", "pb", "BB", "src", "usb", "bg", "bps", "fp", "b", "sf", "bc", "bm", "abb", "bs", "obb", "ub", "sup", "bb", "SB", " SB", "sv", "ls", "buf", "gb", "eb", "ib", "sk", "bsp", "ssl", "bt", "db", "vm", "wb", "fb", "sq", "nb", "lb", "rb", "bp"], "url": ["source", "queue", "user", "connection", "open", "buffer", "ll", "l", "lib", "http", "out", "client", "b", "this", "f", "base", "channel", "stream", "remote", "r", "org", "resource", "server", "ur", "log", "bel", "ls", "job", "string", "rl", "socket", "file", "uri", "ssl", "err", "URL", "service", "Url", "blog", "gl", "sl"], "in": ["af", "read", "reader", "h", "id", "input", "inc", "din", "cf", "min", "nin", "l", "con", "out", "b", "client", "fr", "login", "f", "In", "stream", "again", "r", "isin", "inner", "er", "init", "ins", "e", "gin", "ini", "kin", "impl", "ssl", "i", "IN", "err", "fb", "inn", "rin", "is", "ar", "lin", "bin", "s", "ac"], "line": ["source", "page", "reader", "id", "nl", "link", "user", "pe", "connection", "feed", "lf", "lines", "l", "letter", "one", "object", "char", "end", "LINE", "cell", "column", "Line", "row", "L", "f", "base", "data", "ine", "part", "inline", "n", "response", "style", "el", "name", " inline", "e", "cl", "text", "comment", "content", "lc", "status", "le", "key", "string", "pass", "c", "file", "code", "i", "character", "block", "lin", "str", " Line", "sl", "entry"]}}
{"id1": "6812441", "id2": "10447014", "code1": "    Bitmap downloadBitmap(String url) {\n        final int IO_BUFFER_SIZE = 4 * 1024;\n        final HttpClient client = (mode == Mode.NO_ASYNC_TASK) ? new DefaultHttpClient() : AndroidHttpClient.newInstance(\"Android\");\n        final HttpGet getRequest = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(getRequest);\n            final int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n                Log.w(\"ImageDownloader\", \"Error \" + statusCode + \" while retrieving bitmap from \" + url);\n                return null;\n            }\n            final HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream inputStream = null;\n                try {\n                    inputStream = entity.getContent();\n                    return BitmapFactory.decodeStream(new FlushedInputStream(inputStream));\n                } finally {\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                    entity.consumeContent();\n                }\n            }\n        } catch (IOException e) {\n            getRequest.abort();\n            Log.w(LOG_TAG, \"I/O error while retrieving bitmap from \" + url, e);\n        } catch (IllegalStateException e) {\n            getRequest.abort();\n            Log.w(LOG_TAG, \"Incorrect URL: \" + url);\n        } catch (Exception e) {\n            getRequest.abort();\n            Log.w(LOG_TAG, \"Error while retrieving bitmap from \" + url, e);\n        } finally {\n            if ((client instanceof AndroidHttpClient)) {\n                ((AndroidHttpClient) client).close();\n            }\n        }\n        return null;\n    }\n", "code2": "    public void chmod(String remoteFile, String mode) {\n        String remotePath = connector.getRemoteDirectory();\n        remotePath += PATH_SEPARATOR + remoteFile;\n        FTPClient ftp = new FTPClient();\n        try {\n            String hostname = connector.getUrl().getHost();\n            ftp.connect(hostname);\n            log.info(\"Connected to \" + hostname);\n            log.info(ftp.getReplyString());\n            boolean loggedIn = ftp.login(connector.getUsername(), connector.getPassword());\n            if (loggedIn) {\n                String parameters = \"chmod \" + mode + \" \" + remotePath;\n                ftp.site(parameters);\n                ftp.logout();\n            }\n            ftp.disconnect();\n        } catch (SocketException e) {\n            log.error(\"File chmod failed with message: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"File chmod failed with message: \" + e.getMessage());\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "route", "size", "id", "site", "connection", "feed", "buffer", "download", "rel", "ll", "src", "l", "view", "http", "request", "fr", "base", "loc", "layer", "data", "href", "f", "stream", "bytes", "remote", "resource", "email", "server", "org", "address", "config", "el", "filename", "name", "method", "ur", "bb", "ob", "text", "sl", "timeout", "ls", "lc", "string", "path", "image", "rule", "file", "uri", "ssl", "URL", "service", "Url", "gl", "str", "location", "type"], "IO_BUFFER_SIZE": ["IO_BUFFERINGNAME", "IO_BUER_NAME", "IO_BUFFERECSIZE", "IO_BUER_SIZE", "IO_BUFFERECsize", "IO_BUFFER_size", "IO_BUFFER_NAME", "IO_BUFFERECNAME", "IO_BUFFERPSIZE", "IO_BUFFERPNAME", "IO_BUER_Size", "IO_BUFFERPSize", "IO_BUERECSize", "IO_BUFFER_Size", "IO_BUFFERINGSize", "IO_BUER_size", "IO_BUFFERPsize", "IO_BUFFERECSize", "IO_BUERECNAME", "IO_BUFFERINGSIZE", "IO_BUERECSIZE", "IO_BUERECsize", "IO_BUFFERINGsize"], "client": ["source", "get", "host", "queue", "connection", "phone", "plugin", "io", "conn", "http", "con", "request", "app", "console", "channel", "application", "https", "remote", "resource", "handler", "server", "call", "config", "child", "address", "force", "method", "event", "project", "per", "container", "tc", "api", "instance", "google", "Client", "cli", "session", "media", "image", "pool", "cache", "c", "socket", "ssl", "uri", "secure", "service", "manager", "ce", "ip", "proxy", "port"], "getRequest": ["googleRa", "putThread", "getThread", "googleResult", " getMessage", " getClient", "getMessage", "googlerequest", "putAttempt", "pullResponse", "GETrequest", "Getrequest", "GetRequest", "getClient", " setRe", " getThread", "GetRe", " getResponse", "getRe", "getrequest", " setRequest", " getRe", "GETMessage", "GetClient", "getAttempt", " setResponse", "pullResult", " getrequest", " getResult", "pullRequest", "GETRa", "googleResponse", "googleMessage", " getRa", "googleRequest", "getRa", "putRequest", "GetAttempt", " getAttempt", " setrequest", "GetThread", "putClient", "getResult", "GetResponse", "pullrequest", "GetResult", "getResponse", "GETRequest"], "response": ["page", "successful", "respond", "connection", "success", "feed", "buffer", "reply", "ception", "result", "output", "message", "http", "request", "object", "channel", "application", "data", "version", "stream", "resource", "handler", "server", "body", "full", "report", "json", "api", "initial", "wave", "status", "Response", "image", "document", "file", "error", "resp", "service", "received", "value"], "statusCode": [" statuscode", "exitCode", "responseCode", "StatusCode", "sourcecode", "statusCount", "responseCount", " statusMessage", "exitMessage", "statusText", "sourceCode", " statusType", "responseType", "StatusText", "StatusType", "successType", "sourceType", "successCode", "successLine", "StatusCount", "Statuscode", " statusText", "statuscode", "StatusMessage", "exitText", "responseLine", "statusMessage", "successCount", "statusType", "StatusLine", "statusLine"], "entity": ["source", "page", "translation", "parent", "site", "ent", "connection", "xml", "result", "game", "output", "conn", "ity", "object", "description", "model", "environment", "application", "data", "resource", "email", "server", "el", "element", "component", "body", "event", "e", "Entity", "json", "api", "instance", "content", "issue", "media", "image", "document", "node", "company", "file", "cache", "attribute", "error", "person", "service", "item", "ilo", "ce", "form", "em", "collection", "line", "coll"], "inputStream": [" inputContent", "outputSteam", "rawstream", "outputStream", " inputChannel", "inputSteam", "InputForm", "rawStream", "outputSt", "inForm", "rawSteam", "inputContent", " inputstream", " inputForm", "inputForm", "inputstream", " inputView", "InputStream", "inputSt", " inputSteam", "outputContent", "InputView", "inSteam", "outputstream", "inputView", "inSt", "inView", "outputChannel", "inputChannel", "InputChannel", "Inputstream", "inStream", "instream", "InputSteam", " inputSt", "InputContent"]}}
{"id1": "23115934", "id2": "18208567", "code1": "    private String fetch(URL url) {\n        StringBuilder body = new StringBuilder();\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                body.append(inputLine);\n            }\n            in.close();\n            return body.toString();\n        } catch (Exception e) {\n            debug(\"Error: fetch: Exception reading URL: \" + e);\n        }\n        return null;\n    }\n", "code2": "    public void createPdf(final String eventURI) throws IOException, DocumentException {\n        createSections(eventURI);\n        even = false;\n        final Document document = new Document(Dimensions.getDimension(even, Dimension.MEDIABOX));\n        final PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(MyProperties.getOutput()));\n        writer.setViewerPreferences(PdfWriter.PageLayoutTwoColumnRight);\n        writer.setCropBoxSize(Dimensions.getDimension(even, Dimension.CROPBOX));\n        writer.setBoxSize(\"trim\", Dimensions.getDimension(even, Dimension.TRIMBOX));\n        writer.setBoxSize(\"bleed\", Dimensions.getDimension(even, Dimension.BLEEDBOX));\n        final EventBackgroundAndPageNumbers event = new EventBackgroundAndPageNumbers();\n        writer.setPageEvent(event);\n        document.open();\n        final PdfContentByte content = writer.getDirectContent();\n        event.setTabs(Index.INFO.getTab());\n        importPages(document, content, new PdfReader(Index.INFO.getOutput()), Index.INFO.getTitle());\n        importPages(document, content, MyProperties.getBefore(), event);\n        addAdPage(document, content);\n        PdfReader reader = new PdfReader(Presentations.INFO.getOutput());\n        String[] titles = { \"\", \"\" };\n        for (int i = 1; i <= reader.getNumberOfPages(); i++) {\n            titles = index.getSubtitle(titles, i);\n            event.setTabs(titles[0].toLowerCase());\n            addTitleLeft(content, Dimensions.getTitleArea(even), titles[0], MyFonts.TITLE);\n            addTitleRight(content, Dimensions.getTitleArea(even), titles[1], MyFonts.DATE);\n            content.addTemplate(writer.getImportedPage(reader, i), Dimensions.getOffsetX(even), Dimensions.getOffsetY(even));\n            document.newPage();\n            even = !even;\n        }\n        addAdPage(document, content);\n        importPages(document, content, MyProperties.getAfter(), event);\n        int total = writer.getPageNumber() - 1;\n        event.setNoMorePageNumbers();\n        event.setTabs(Schedules.INFO.getTab());\n        reader = new PdfReader(Schedules.INFO.getOutput());\n        for (int i = 1; i <= reader.getNumberOfPages(); i++) {\n            addTitleLeft(content, Dimensions.getTitleArea(even), Schedules.INFO.getTitle(), MyFonts.TITLE);\n            content.addTemplate(writer.getImportedPage(reader, i), Dimensions.getOffsetX(even), Dimensions.getOffsetY(even));\n            document.newPage();\n            even = !even;\n        }\n        document.close();\n        final File file = new File(MyProperties.getOutput());\n        final byte[] original = new byte[(int) file.length()];\n        final FileInputStream f = new FileInputStream(file);\n        f.read(original);\n        reader = new PdfReader(original);\n        final List<Integer> ranges = new ArrayList<Integer>();\n        for (int i = 1; i <= total; i++) {\n            ranges.add(i);\n            if (i == total / 2) {\n                for (int j = total + 1; j <= reader.getNumberOfPages(); j++) {\n                    ranges.add(j);\n                }\n            }\n        }\n        reader.selectPages(ranges);\n        final PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(MyProperties.getOutput()));\n        stamper.close();\n    }\n", "label": 0, "substitutes": {"url": ["source", "id", "user", "feed", "connection", "buffer", "plugin", "l", "http", "object", "client", "this", "b", "f", "base", "resource", "org", "server", "config", "address", "name", "ur", "job", "string", "rule", "image", "uri", "file", "ssl", "URL", "service", "Url", "proxy", "gl", "str", "sl", "entry"], "body": ["source", "h", "line", "binary", "connection", "dict", "buffer", "iter", "function", "lines", "message", "output", "http", "out", "Body", "b", "object", "this", "loop", "part", "base", "data", "response", "tree", "resource", "handler", "inner", "e", "bb", "ob", "json", "log", "content", "job", "key", "string", "html", "file", "db", "i", "code", "builder", "header", "block", "web", "foot", "null"], "in": ["source", "read", "reader", "h", "id", "input", "inc", "din", "win", "buffer", "min", "nin", "conn", "con", "out", "b", "client", "login", "f", "as", "data", "In", "into", "stream", "again", "r", "inner", "init", "ins", "e", "gin", "ini", "kin", "rec", "file", "i", "IN", "err", "inside", "inn", "is", "bin", "s"], "inputLine": ["tempLine", " inputText", " inputLINE", "InputLine", "outputline", "inputline", "outputLine", " inputFile", "accessText", " inputL", "tempData", "rawLine", "InputL", "inputText", " inputData", " inputline", "Inputline", "outputLINE", "accessline", "inputData", "accessLINE", "templine", "InputFile", "rawline", "outputText", "rawL", "accessLine", "inputL", "inputFile", "rawFile", "inputLINE", "InputData"]}}
{"id1": "7990228", "id2": "615902", "code1": "    public static InputStream gzip(final InputStream inputStream) throws IOException {\n        Assert.notNull(inputStream, \"inputStream\");\n        InputOutputStream inputOutputStream = new InputOutputStream();\n        GZIPOutputStream gzipOutputStream = new GZIPOutputStream(inputOutputStream);\n        IOUtils.copy(inputStream, gzipOutputStream);\n        gzipOutputStream.close();\n        return inputOutputStream.getInputStream();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"inputStream": ["outputSteam", "regularSteam", "outputStream", "inputSteam", "audioFile", "InputSt", "inFile", "regularStream", "regularREAM", "InputSource", " inputstream", " inputSource", "inputstream", "InputStream", "inputSt", " inputSteam", "outputREAM", "inputREAM", "audioSteam", "inputStreamer", "InputREAM", "inSteam", "outputstream", "audioStream", "InputFile", " inputStreamer", "Inputstream", "inStream", "inputSource", "InputStreamer", "audioSt", "InputSteam", "outputSource", "regularstream", "inputFile", "outputStreamer", "inSt"], "inputOutputStream": ["inputResponseStream", "inputResponsePass", "inputInputObject", "inputConnectionStream", "inputResponseSteam", "inputOperationStreamer", "inputConnectionObject", "rawOutputPass", "outputInputSteam", "inputOutputStreamer", "outputInputObject", "currentOutputPoint", "inputInputPoint", "inputoutputPass", "inputOutputObject", "currentInputStreamer", "inputResponseFile", "outputOutputStreamer", "currentOutputStream", "outputInputStream", "inputOutStream", "inputInputStream", "outputOutputObject", "outputInputStreamer", "inputoutputFile", "rawOutputFile", "inputOutputPass", "outputOutputSteam", "currentInputSteam", "inputConnectionStreamer", "currentOutputStreamer", "inputoutputStream", "inputOutputFile", "outputOutputStream", "rawoutputPass", "inputConnectionSteam", "inputOperationStream", "inputOutObject", "inputoutputSteam", "currentInputPoint", "currentOutputSteam", "inputInputPass", "rawoutputFile", "currentInputStream", "inputOutputPoint", "rawOutputSteam", "rawoutputStream", "inputInputStreamer", "inputOutSteam", "rawoutputSteam", "rawOutputStream", "inputOperationPoint", "inputInputSteam", "inputOutStreamer", "inputOperationSteam", "inputOutputSteam", "inputInputFile"], "gzipOutputStream": ["gzOutputThread", "gzipoutputStreamer", "gzipGroupThread", "gzipOutputSteam", "gzipUnitStream", "gzipoutputStream", "gzipInputThread", "gzipWriteSteam", "gzipInputSteam", "gzipoutputSteam", "gzInputSteam", "gzOutputStream", "gzOutputChannel", "gzipInputChannel", "gzipOutputChannel", "gzipWriteThread", "gzipUnitThread", "gzipoutputThread", "gzOutputStreamer", "gzipGroupSteam", "gzipWriteStream", "gzipUnitSteam", "gzipUnitStreamer", "gzipGroupStream", "gzOutputSteam", "gzInputChannel", "gzipOutputThread", "gzInputStream", "gzipOutputStreamer", "gzipInputStreamer", "gzInputStreamer", "gzipInputStream", "gzipGroupStreamer", "gzipoutputChannel", "gzipWriteChannel", "gzInputThread"]}}
{"id1": "6795580", "id2": "19395766", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static String encodePassword(String password) {\n        try {\n            MessageDigest messageDiegest = MessageDigest.getInstance(\"SHA-1\");\n            messageDiegest.update(password.getBytes(\"UTF-8\"));\n            return Base64.encodeToString(messageDiegest.digest(), false);\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"Ha habido un error mientras se almacenaba la clave de acceso.\");\n            throw new Error(e);\n        } catch (UnsupportedEncodingException e) {\n            log.error(\"Ha habido un error mientras se almacenaba la clave de acceso.\");\n            throw new Error(e);\n        }\n    }\n", "label": 1, "substitutes": {"secure": ["host", "active", "require", "deep", "safe", "secondary", "pure", "security", "Secure", "stable", "https", "remote", "zip", "smart", "server", "config", "external", "random", "force", "depth", "relative", " insecure", "allow", "sr", "exclusive", "timeout", "session", "sec", "confirmed", "seed", "encrypted", "debug", "ssl", "sensitive", "quiet", "service", "secret", "unsigned", "proxy", "weak", "use"], "md5": ["mand3", " md64", "MDito", "md3", "md64", "mp2", " md256", " MD2", "mand2", "MD5", "mand5", " mdito", " MD5", "mdito", "mp5", " md56", "mand56", "MD512", " MDito", "MD3", "md512", "md256", "mand256", "mp64", "mand512", "MD2", "MD56", " MD3", "md2", " md2", " md512", "MD64", " md3", "md56", "MD256", "mp3"], "sbValueBeforeMD5": ["sbValueBeforemd85", "sbValueBeforeMet5", "sbValueBeforeMD3", "sbValueBeforeMC512", "sbValueWithoutSHA3", "sbValueBeforeML68", "sbValueAfterMD85", "sbValueBeforeMD1", "sbValueBeforeMP9", "sbValueBeforeMD53", "sbValueAfterMSLink", "sbValueBeforeMS3", "sbValueWithoutSHA512", "sbValueBeforemd512", "sbValueBeforeAST512", "sbValueBeforeAMDFive", "sbValueBesidesMD68", "sbValueAfterMD53", "sbValueBeforeMPFive", "sbValueBeforeSHA5", "sbValueBeforeMCLink", "sbValueBeforeML3", "sbValueBeforeMSLink", "sbValueBeforeMF5", "sbValueBeforeAMD3", "sbValueWithoutMD1", "sbValueAfterMD5", "sbValueBeforeMP1", "sbValueBeforeMDFive", "sbValueBeforeSHA512", "sbValueBeforeAMD512", "sbValueBeforeML5", "sbValueAfterMD3", "sbValueBeforeAST3", "sbValueWithoutSHA1", "sbValueAfterMS5", "sbValueBeforeMD512", "sbValueBeforeM3", "sbValueBeforeMP25", "sbValueBeforeMD8", "sbValueBeforeMAC1", "sbValueBesidesMD8", "sbValueBeforeAMD85", "sbValueBeforeML8", "sbValueBeforeMAC5", "sbValueBeforeAMD1", "sbValueBeforeMP3", "sbValueWithoutMD3", "sbValueBeforemd3", "sbValueBeforeMet9", "sbValueBeforeMD25", "sbValueAfterAMD512", "sbValueAfterMP3", "sbValueBeforeMS53", "sbValueWithoutMD5", "sbValueBeforeM512", "sbValueBeforeMet25", "sbValueBeforeAST85", "sbValueAfterMS53", "sbValueBeforeMD68", "sbValueBeforeMC1", "sbValueBeforeMC5", "sbValueBeforeMF512", "sbValueAfterMDFive", "sbValueAfterMP1", "sbValueBeforeM5", "sbValueAfterAMD85", "sbValueBeforeAMD5", "sbValueBeforeMD9", "sbValueBeforemd53", "sbValueBeforeMF85", "sbValueWithoutMD512", "sbValueBeforeMACFive", "sbValueBeforeAST5", "sbValueBeforeM1", "sbValueBeforeMS5", "sbValueBeforeMD85", "sbValueBeforeMS85", "sbValueAfterMPFive", "sbValueAfterAMD3", "sbValueBeforeMF3", "sbValueBeforeSHA3", "sbValueAfterMDLink", "sbValueBeforeMDLink", "sbValueBeforeSHA1", "sbValueAfterMS3", "sbValueBeforeMC53", "sbValueBeforeMC3", "sbValueBeforeMS512", "sbValueAfterAMD5", "sbValueAfterMD512", "sbValueBeforeMS68", "sbValueBeforeMS8", "sbValueBeforemdLink", "sbValueBeforemd5", "sbValueBeforeMP5", "sbValueAfterMP5", "sbValueBeforeMet3", "sbValueAfterMD1", "sbValueBesidesMD3", "sbValueWithoutSHA5", "sbValueBeforeMAC3", "sbValueBesidesMD5"], "time": ["host", "size", "id", "user", "hour", "race", "year", "counter", "tim", "tz", "clock", "mode", "loc", "sleep", "version", "serial", "ime", "random", "etime", "depth", "name", "event", "length", "cost", "money", "timeout", "count", "seed", "delay", "live", "error", "times", "speed", "date", "TIME", "Time", "start", "timer", "rate", "value", "port", "month", "duration", "type"], "rand": ["id", "rar", "rank", "win", "year", "mid", "range", "right", "ro", "dev", "winner", "root", "bug", "gen", "loc", "version", "serial", "r", "clean", "round", "rage", "random", "depth", "rc", "pattern", "patch", "length", "max", "rh", "raid", "bit", "index", "rule", "count", "seed", "reg", "delay", "error", "live", "rr", "q", "order", "ng", "rate", "Rand", "alpha", "pick", "type"], "valueBeforeMD5": ["valueBeforeAMD2", "valueAfterMP3", "valueBeforeMC3", "valueBeforeMF25", "valueAfterMP2", "valueAfterMP50", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAfterMD25", "valueBeforeMP50", "valueBeforeAMD3", "valueBeforeMF2", "valueBeforeMP2", "valueBeforeME5", "valueAfterMD3", "valueBeforeMD3", "valueBeforeMD25", "valueBeforeME3", "valueBeforeAMD50", "valueBeforeAMD5", "valueBeforeMD50", "valueBeforeMF3", "valueAfterMP5", "valueBeforeMC2", "valueBeforeMF5", "valueAfterMD50", "valueBeforeME2", "valueAfterMD2", "valueBeforeMC5", "valueBeforeMC25", "valueBeforeME50"], "array": ["hash", "queue", "binary", "our", "Array", "arr", "range", "arrow", "function", "result", "message", "audio", "view", "object", "app", "ray", "number", "data", "r", "integer", "pair", "archive", "feature", "address", "angle", "shape", "element", "section", "batch", "allow", "api", "instance", "a", "area", "abc", "index", "string", "image", "list", "record", "error", "expression", "map", "database", "value", "collection", "sample"], "sb": ["sa", "cb", "bf", "mb", "bh", "si", "binary", "buffer", "sth", "buff", "usb", "sg", "pb", "src", "sf", "bc", "lr", "kb", "bm", "ruby", "abb", "bs", "obb", "rob", "erb", "bj", "bb", "SB", " SB", "ob", "sl", "sv", "zb", "buf", "gb", "xb", "eb", "ib", "orb", "bsp", "ab", "db", "bt", "wb", "fb", "sq", "lab", "nb", "lb", "s", "rb", "bp", "bl"], "j": ["jj", "num", "d", "ind", "br", "J", "jp", "k", "l", "y", "jo", "ja", "part", "aj", "f", "ij", "n", "ji", "adj", "js", "x", "bj", "o", "e", "uj", "dj", "length", "pr", "ch", "job", "li", "v", "key", "dy", "index", "obj", "c", "i", "ii", "im", "jl", "oj", "q", "z", "p", "ie"], "b": ["cb", "bf", "d", "mb", "be", "br", "k", "BB", "pb", "l", "y", "f", "p", "n", "bs", "x", "e", "bb", "ob", "bit", "bar", "job", "a", "B", "eb", "orb", "c", "ab", "db", "i", "obj", "wb", "fb", "nb", "lb", "bin", "rb", "ib"], "valueAfterMD5": ["valueAfterMP3", "valueAfterMP2", "valueAfterMDType", "valueBeforeMP3", "valueBeforeMP5", "valueBeforeMD2", "valueAftermd2", "valueAfterAMD3", "valueBeforeMP2", "valueAftermd3", "valueAfterMD3", "valueAfterMPType", "valueAfterAMD5", "valueBeforeMD3", "valueAftermdType", "valueAfterMP5", "valueAfterAMD2", "valueBeforeMDType", "valueAfterMD2", "valueBeforeMPType", "valueAfterAMDType", "valueAftermd5"]}}
{"id1": "17044784", "id2": "473797", "code1": "    private void process(String zipFileName, String directory, String db, boolean quiet) throws SQLException {\n        ArrayList<String> list = FileLister.getDatabaseFiles(directory, db, true);\n        if (list.size() == 0) {\n            if (!quiet) {\n                printNoDatabaseFilesFound(directory, db);\n            }\n            return;\n        }\n        zipFileName = FileUtils.normalize(zipFileName);\n        if (FileUtils.exists(zipFileName)) {\n            FileUtils.delete(zipFileName);\n        }\n        OutputStream fileOut = null;\n        try {\n            fileOut = FileUtils.openFileOutputStream(zipFileName, false);\n            ZipOutputStream zipOut = new ZipOutputStream(fileOut);\n            String base = \"\";\n            for (String fileName : list) {\n                if (fileName.endsWith(Constants.SUFFIX_PAGE_FILE)) {\n                    base = FileUtils.getParent(fileName);\n                    break;\n                } else if (fileName.endsWith(Constants.SUFFIX_DATA_FILE)) {\n                    base = FileUtils.getParent(fileName);\n                    break;\n                }\n            }\n            for (String fileName : list) {\n                String f = FileUtils.getAbsolutePath(fileName);\n                if (!f.startsWith(base)) {\n                    Message.throwInternalError(f + \" does not start with \" + base);\n                }\n                if (FileUtils.isDirectory(fileName)) {\n                    continue;\n                }\n                f = f.substring(base.length());\n                f = BackupCommand.correctFileName(f);\n                ZipEntry entry = new ZipEntry(f);\n                zipOut.putNextEntry(entry);\n                InputStream in = null;\n                try {\n                    in = FileUtils.openFileInputStream(fileName);\n                    IOUtils.copyAndCloseInput(in, zipOut);\n                } catch (FileNotFoundException e) {\n                } finally {\n                    IOUtils.closeSilently(in);\n                }\n                zipOut.closeEntry();\n                if (!quiet) {\n                    out.println(\"Processed: \" + fileName);\n                }\n            }\n            zipOut.closeEntry();\n            zipOut.close();\n        } catch (IOException e) {\n            throw Message.convertIOException(e, zipFileName);\n        } finally {\n            IOUtils.closeSilently(fileOut);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"zipFileName": ["zipfileInfo", "sqlFileLine", "zipLogSize", "zipFilename", "Path", "zipFullSize", "zipQueueDir", "zipDirPath", "zipFileInfo", "zipTypename", " zipQueuename", "zipFileLocation", "zipPathInfo", "patchTypePath", "zipTablename", "archiveFileName", "archiveFullPath", "zipBaseFile", "zipFilePath", "zipfileName", "archiveFilePath", "secureStringLocation", "patchTypename", "zipFileLine", "zipPathLine", "zipTypeNames", " zipFilename", "zipFullNames", "zipFullname", "zipFileNames", "sqlFileInfo", "zipfilename", "patchFilePath", "zipFullName", "zipFullType", "secureFileName", "zipBaseName", "patchTypeName", "zipBasename", "zipTableName", "URL", "sqlfileTime", "Url", "zipfileFile", "zipQueueFile", "zipLogName", "zipDirPart", "secureFilePath", "zipfileSize", "zipBaseDir", "zipFullInfo", "url", "archiveFullType", "zipFileSize", "archiveFullName", "New", "sqlfileLine", "this", "patchFilename", "zipStringLocation", "zipQueueName", "archiveFilePart", "zipTableNames", "patchTypeNames", "zipFullLine", "_", "archiveFullSize", "zipTypePath", "zipfileDir", "sqlFileName", "secureStringName", "zipFileDir", " zipQueueDir", "zipPathTime", "zipQueuename", "zipFilePart", "zipFullPart", "s", "zipfilePath", "zipFullPath", "zipfileLine", "zipStringPath", "zipDirName", "zipFileFile", "archiveFullPart", "zipFileTime", "patchFileName", "sqlfileInfo", " zipQueueName", "archiveFileType", "sqlFileTime", "zipDirSize", "zipLogPath", "zipfileTime", "zipFullLocation", "zipTablePath", " zipFileFile", "patchFileNames", "zipfileType", "zipPathName", " zipQueueFile", "archiveFileSize", "zipStringName", "secureStringPath", "zipFileType", "zipFullTime", "sqlfileName", "zipTypeName", "Error", "secureFileLocation", "zipDirType", " zipFileDir", "zipLogPart"], "directory": ["language", "source", "folder", "url", "d", "office", "connection", "output", "Directory", "python", "dump", "description", "root", "mode", "environment", "data", "table", "storage", "tree", "archive", "server", "config", "dn", "module", "machine", "filename", "volume", "dir", "direction", "category", "path", "document", "library", "uri", "manager", "database", "position", "domain", "project", "store", "collection", "location"], "db": ["dl", "id", "url", "sb", "sql", "bf", "d", "user", "connection", "dict", "bind", "username", "b", "fd", "DB", "model", "Db", "loc", "table", "data", "storage", "address", "config", "where", "name", "filename", "dir", "query", "bb", "dm", "log", "path", "library", "live", "file", "database", "hub", "ds", "domain", "type"], "quiet": ["dirty", "nice", "disable", "deep", "respect", "laugh", "iet", "echo", "interrupted", " quietly", "optional", "slow", "quick", "sleep", "hard", "always", "remote", "print", "thin", "smart", "negative", "doctor", "force", "tty", "printf", "report", "flush", "disabled", "aggressive", "comment", "cli", "timeout", "avoid", "quit", "global", "secure", "delay", "lock", "misc", "sensitive", "like", "local", "sudo", "question", "qt", "english", "QUI", "soft", "qa", "neutral", "shell", "friendly", "severe"], "list": ["source", "dl", "queue", "LIST", "not", "range", "chain", "result", "l", "view", "pre", "ist", "val", "part", "L", "table", "n", "set", "tree", "conf", "stack", "name", "batch", "see", "cont", "log", "we", "cl", "lists", "cli", "lc", "listed", "li", "ls", "all", "string", "path", "load", "record", "code", "file", "array", "www", "add", "test", "collection", "null", "coll", "pl", "bl"], "fileOut": ["logout", " fileUrl", "zipout", "logIn", "zipIndex", "zipUrl", "fileUrl", "fileWriter", "zipOUT", " fileWriter", " fileout", "fileIndex", "fileOUT", "fileIn", "Fileout", "FileIn", "fileout", "logOut", "pullIn", " fileOUT", " fileIndex", "pullOUT", "FileWriter", " fileIn", "pullOut", "pullIndex", "zipWriter", "zipIn", "logUrl", "FileOut"], "zipOut": ["zipFile", "zipObj", "archiveObj", "zipout", "zoneOutput", "writeOUT", "zipOutside", "lockOut", "ZipIn", "fileFile", "archiveOutside", "archiveOutput", "zoneObj", " zipout", "zipOUT", " zipZone", "lockIn", " zipObj", "writeIn", "zipZone", "fileIn", "zout", "archiveFile", "fileout", "writeout", " zipOutside", "zOut", "zoneout", " zipOUT", "lockOutside", "archiveZone", "writeOut", "zipOutput", "ZipOUT", " zipFile", "archiveIn", "zoneIn", "zipIn", "Zipout", "zIn", "zoneOut", "lockZone", "archiveOut", " zipIn", "ZipOut", " zipOutput", "zOutput", "archiveout"], "fileName": [" fileAlias", "FileInfo", "placeInfo", "urlPath", "fileType", "FILEType", "fileHome", "fileSpec", "fileAlias", "fInstance", "imagePart", "urlEl", "fileInfo", "letterAlias", "fileString", "queueType", " fileSpec", "placeName", "FileName", "queueName", "FileEl", " fileInstance", "basePart", "FILESpec", "FileSpec", " fileTime", "basePath", "urlPart", " fileHome", "FilePath", "ileName", "baseTime", "fileInstance", "ileTime", "fType", "FILEInstance", "imageNum", "fHome", "queueNum", "FILEName", "FILEInfo", "fileTime", "ileHome", "letterPart", "fileEl", "imageName", "placeOut", "baseName", "fPart", "FilePart", "fileNum", "placePath", "filePath", "FileString", " filePart", "baseString", "imageType", " fileEl", "FileAlias", "filePart", " fileNum", "fName", "ileNum", "ileType", "fInfo", " fileType", " fileString", "FileType", " filePath", "letterInfo", "ilePart", "FileTime", "letterName", " fileInfo", "fTime", "fNum", "urlName", "FileOut"], "base": ["bas", "absolute", "plus", "parent", "site", "id", "url", "bf", "pe", "buffer", "range", "core", "space", "extra", "real", "flat", "l", "http", "joined", "home", "b", "based", "root", "part", "normal", "re", "bi", "basic", "resource", "handler", "tree", "prefix", "server", "info", "name", "body", "full", "bare", "u", "api", "a", "bar", "temp", "area", "key", "back", "family", "path", "cache", "c", "uri", "file", "i", "support", "fixed", "start", "Base", "bin", "line", "ip", "p", "unit"], "f": ["xf", "af", "h", "rf", "url", "bf", "d", "feed", "lf", "cf", "flat", "fo", "l", "format", "fs", "fc", "fp", "b", "sf", "inf", "fd", "fr", "tf", "fe", "ref", "r", "feature", "info", "fun", "x", "name", "u", "e", "framework", "fn", "t", "F", "m", "fold", "v", "path", "j", "c", "file", "i", "fb", "g", "fen", "field", "form", "s", "fa", "p", "fx"], "entry": ["next", "parent", "reader", "input", "pe", "ent", "connection", "result", "ry", "card", "out", "this", "cell", "row", "data", "zip", "r", "system", "her", "archive", "child", "server", "info", "ie", "element", "event", "ge", "e", "exp", "cel", "enter", "lc", "key", "entity", "obj", "file", "record", "or", "Entry", " Entry", "line"], "in": ["source", "get", "reader", "id", "tin", "input", "inc", "din", "token", "win", "min", "nin", "con", "out", "b", "login", "as", "on", "data", "In", "pin", "again", "n", "r", "inas", "thin", "isin", "inner", "init", "ins", "ax", "vin", "zin", "gin", "ini", "ex", "m", "kin", "rec", "index", "cin", "c", "i", "IN", "err", "inn", "rin", "is", "lin", "bin", "copy"]}}
{"id1": "11608926", "id2": "21462052", "code1": "    void ProcessRequests(DataInputStream in, PrintStream out) {\n        String sQuery;\n        while (true) {\n            try {\n                sQuery = in.readLine();\n                if (sQuery == null) return;\n                if (sQuery.startsWith(\"select\")) {\n                    ProcessQuery(sQuery, out);\n                } else if (sQuery.startsWith(\"insert\")) {\n                    Statement stmt = con.createStatement();\n                    stmt.executeUpdate(sQuery);\n                } else if (sQuery.startsWith(\"update\")) {\n                    Statement stmt = con.createStatement();\n                    stmt.executeUpdate(sQuery);\n                } else if (sQuery.startsWith(\"commit\")) {\n                    con.commit();\n                } else if (sQuery.startsWith(\"autocommit true\")) {\n                    con.setAutoCommit(true);\n                } else if (sQuery.startsWith(\"autocommit false\")) {\n                    con.setAutoCommit(false);\n                } else if (sQuery.startsWith(\"delete\")) {\n                    Statement stmt = con.createStatement();\n                    stmt.executeUpdate(sQuery);\n                } else if (sQuery.startsWith(\"rollback\")) {\n                    con.rollback();\n                } else {\n                    out.println(\"What ?\");\n                }\n                out.println(\">\");\n            } catch (SQLException ex) {\n                out.println(\"\\n*** SQLException caught ***\\n\");\n                while (ex != null) {\n                    out.println(\"SQLState: \" + ex.getSQLState());\n                    out.println(\"Message:  \" + ex.getMessage());\n                    out.println(\"Vendor:   \" + ex.getErrorCode());\n                    ex = ex.getNextException();\n                    out.println(\"\");\n                }\n            } catch (java.lang.Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public int deleteRecord(String uuid) throws SQLException, CatalogIndexException {\n        Connection con = null;\n        boolean autoCommit = true;\n        PreparedStatement st = null;\n        ResultSet rs = null;\n        int nRows = 0;\n        boolean cancelTask = false;\n        StringSet fids = new StringSet();\n        if (cswRemoteRepository.isActive()) {\n            StringSet uuids = new StringSet();\n            uuids.add(uuid);\n            fids = queryFileIdentifiers(uuids);\n        }\n        try {\n            con = returnConnection().getJdbcConnection();\n            autoCommit = con.getAutoCommit();\n            con.setAutoCommit(false);\n            String sSql = \"SELECT COUNT(*) FROM \" + getResourceTableName() + \" WHERE DOCUUID=? AND PROTOCOL_TYPE IS NOT NULL AND PROTOCOL_TYPE<>''\";\n            logExpression(sSql);\n            st = con.prepareStatement(sSql);\n            st.setString(1, uuid);\n            rs = st.executeQuery();\n            if (rs.next()) {\n                cancelTask = rs.getInt(1) > 0;\n            }\n            closeStatement(st);\n            sSql = \"DELETE FROM \" + getResourceTableName() + \" WHERE DOCUUID=?\";\n            logExpression(sSql);\n            st = con.prepareStatement(sSql);\n            st.setString(1, uuid);\n            nRows = st.executeUpdate();\n            closeStatement(st);\n            sSql = \"DELETE FROM \" + getResourceDataTableName() + \" WHERE DOCUUID=?\";\n            logExpression(sSql);\n            st = con.prepareStatement(sSql);\n            st.setString(1, uuid);\n            st.executeUpdate();\n            CollectionDao colDao = new CollectionDao(this.getRequestContext());\n            if (colDao.getUseCollections()) {\n                closeStatement(st);\n                sSql = \"DELETE FROM \" + colDao.getCollectionMemberTableName() + \" WHERE DOCUUID=?\";\n                logExpression(sSql);\n                st = con.prepareStatement(sSql);\n                st.setString(1, uuid);\n                st.executeUpdate();\n            }\n            con.commit();\n        } catch (SQLException ex) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw ex;\n        } finally {\n            closeResultSet(rs);\n            closeStatement(st);\n            if (con != null) {\n                con.setAutoCommit(autoCommit);\n            }\n        }\n        CatalogIndexAdapter indexAdapter = getCatalogIndexAdapter();\n        if (indexAdapter != null) {\n            indexAdapter.deleteDocument(uuid);\n            if (cswRemoteRepository.isActive()) {\n                if (fids.size() > 0) cswRemoteRepository.onRecordsDeleted(fids);\n            }\n        }\n        if (cancelTask && getRequestContext() != null) {\n            getRequestContext().getApplicationContext().getHarvestingEngine().cancel(getRequestContext(), uuid);\n        }\n        return nRows;\n    }\n", "label": 1, "substitutes": {"in": ["reader", "url", "input", "inc", "win", "connection", "min", "conn", "con", "b", "this", "login", "as", "data", "In", "pin", "stream", "again", "r", "re", "raw", "inner", "exec", "conf", "ins", "ini", "up", "cin", "cache", "c", "lock", "i", "IN", "err", "inn", "rin", "is", "lin", "bin", "s"], "out": ["page", "parent", "str", "user", "write", "buffer", "down", "extra", "co", "io", "output", "outer", "conn", "view", "w", "con", "dump", "object", "this", "ou", "client", "part", "gen", "as", "base", "In", "OUT", "Out", "print", "outs", "again", "clean", "sum", "raw", "writer", "inner", "pre", "off", "exec", "name", "query", "full", "o", "report", "exp", "log", "cli", "bar", "post", "up", "key", "session", "string", "re", "pool", "list", "obj", "cache", "c", "error", "lock", "err", "IN", "group", "bin", "res", "line"], "sQuery": ["SFlow", "osSQL", "sOnce", "cquery", "sQueue", "sslUpdate", " sDb", " sQu", "cStatement", " sString", " sScan", "cScan", "sForm", "sesQuery", " sSource", "pQ", "sqlDb", " sCondition", "sesSQL", "setsQuestion", "SSQL", "wsExp", "dsQuery", "stringInstall", "SQuestion", "Squery", "dsQuestion", " sQ", "osQuery", "sQ", "sslQuery", " sCommand", "sesInstall", "sqlStatement", "wsOnce", "sScan", "suStatement", "sInstall", "sesStatement", "wsUpdate", "YourSQL", "sDb", "dsInstall", "osLimit", "YourQuery", "nsUser", "symQuery", "sslQuestion", "sslquery", "dsStatement", "osQuestion", "suQuery", "sesQu", "cQuery", "southStatement", " sStatement", "sportsQuery", "southQuery", "sCondition", "sUpdate", "sStatement", "SQu", "SCondition", "sslCondition", "sExp", "wsQuery", "nsQuery", " sOnce", "suquery", "symInstall", " squery", "sUser", "sCommand", "nsSQL", "nsForm", "YourFlow", "sqlQuery", "pQuery", "sString", "wsStatement", "dsSQL", "nsSource", "stringThrow", "southThrow", "sesQueue", "setsQu", "siteQuery", "symStatement", "pquery", "YourCondition", "sslExp", "wsDb", "sportsSQL", "sportsLimit", "SQ", "sSQL", " sUser", "sqlOnce", "pQu", "siteQuestion", "dsQu", "sSource", "sThrow", "setsSQL", " sQueue", "SString", " sSQL", "setsStatement", "setsQuery", " sQuestion", "sFlow", "siteStatement", "SQuery", "sQu", " sForm", "stringQuery", "nsStatement", "sportsQuestion", "suScan", "sLimit", "nsCommand", "sQuestion", "stringStatement", "squery", "southInstall"], "stmt": ["tmut", " stmr", "Stmr", "Stmo", "strmd", "Stmm", "stmn", "tmt", "strnt", "stMT", "stmm", "StMT", "Stmi", "Stmb", "stnt", " stmd", "structmut", "strmb", " statt", "strMT", "stmd", "strmr", "stmo", " stMT", "playatt", "Stnt", " stmo", "playmi", "stmr", " stmi", "statt", "strdo", "stmb", "Stmn", " stmm", "strmm", " stnt", "tnt", " stmn", "strmt", "playmt", " stdo", "playmn", " stmut", "tmn", "stmut", "stdo", "structnt", "structmn", "structmt", " stmb", "Stdo", "stmi", "strmo", "Stmt", "Stmd", "Statt"], "ex": ["expl", "su", "ru", "en", "nex", "none", "rx", "uc", "ception", "rex", " exception", "extra", "Ex", " exc", "ry", "example", "io", "con", "app", "tex", "Exc", "aux", "diff", "used", "def", "exc", "pex", "hex", "fe", "again", "re", "ticket", "tx", "sex", "el", "x", "crit", "six", "ix", "event", "e", "de", "ax", "exp", "act", "cl", "log", "temp", "status", "up", "com", "se", "EX", "obj", "pass", "error", "fail", "err", "lex", "Exception", "ignore", "test", "exit", "null", "except", "ext"]}}
{"id1": "13510171", "id2": "7767320", "code1": "        private String readCreditsHtml(IApplication app) {\n            final URL url = app.getResources().getCreditsURL();\n            StringBuffer buf = new StringBuffer(2048);\n            if (url != null) {\n                try {\n                    BufferedReader rdr = new BufferedReader(new InputStreamReader(url.openStream()));\n                    try {\n                        String line = null;\n                        while ((line = rdr.readLine()) != null) {\n                            String internationalizedLine = Utilities.replaceI18NSpanLine(line, s_stringMgr);\n                            buf.append(internationalizedLine);\n                        }\n                    } finally {\n                        rdr.close();\n                    }\n                } catch (IOException ex) {\n                    String errorMsg = s_stringMgr.getString(\"AboutBoxDialog.error.creditsfile\");\n                    s_log.error(errorMsg, ex);\n                    buf.append(errorMsg + \": \" + ex.toString());\n                }\n            } else {\n                String errorMsg = s_stringMgr.getString(\"AboutBoxDialog.error.creditsfileurl\");\n                s_log.error(errorMsg);\n                buf.append(errorMsg);\n            }\n            return buf.toString();\n        }\n", "code2": "    private String executeUpload(String urlStr, String specification, String filename, String sessionHandle) {\n        StringBuffer result = new StringBuffer();\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"YAWLSessionHandle\", sessionHandle);\n            connection.setRequestProperty(\"filename\", filename);\n            connection.setRequestProperty(\"Content-Type\", \"text/xml\");\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.print(specification);\n            out.flush();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                result.append(inputLine);\n            }\n            in.close();\n            out.close();\n            connection.disconnect();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            InterfaceBWebsideController.logContactError(e, _backEndURIStr);\n        }\n        String msg = result.toString();\n        return stripOuterElement(msg);\n    }\n", "label": 1, "substitutes": {"app": ["page", "user", "plug", "xml", "admin", "plugin", "doc", "APP", "request", "client", "this", "model", "base", "application", "data", "App", "resource", "server", "config", "info", "conf", "e", "report", "api", "session", "install", "html", "sp", "db", "i", "apps", "support", "pp", "manager", "service", "img", "self", "android", "project", "web", "p"], "url": ["source", "host", "page", "user", "feed", "connection", "buffer", "download", "ll", "io", "l", "http", "object", "lr", "f", "base", "loc", "data", "channel", "ref", "resource", "email", "server", "org", "address", "ur", "rc", "log", "fl", "location", "job", "string", "path", "image", "rl", "html", "file", "ssl", "uri", "err", "URL", "service", "hub", "Url", "www", "web", "sl"], "buf": ["cb", "sb", "tmp", "queue", "msg", "bf", "la", "bh", "proc", "uc", "buffer", "buff", "cmp", "result", "br", "Buffer", "bg", "pb", "src", "cas", "fp", "b", "aux", "bc", "fd", "cv", "fw", "ctx", "box", "Buff", "bb", "log", "uf", "bag", "gb", "port", "pool", "ab", "db", "err", "wb", "fb", "raf", "array", "conv", "nb", "img", "ff", "lb", "bu", "str", "rb", "null", "coll"], "rdr": ["fdrs", "rdl", "rf", "vdtr", "rdrs", "rtrs", "rtb", "ldb", "rtw", "ldrs", "rrw", "vdf", "rn", "RDn", "rdn", "rtr", "rrtr", "rdb", "rrr", "rdf", "fdf", "rrf", "RDr", "ldr", "rl", "ldf", "rttr", "rtn", "RDf", "rdw", "rdtr", "rr", "fdr", "RDl", "rtf", "fdb", "rtl", "vdw", "vdr"], "line": ["source", "page", "value", "split", "link", "feed", "lf", "lines", "result", "message", "l", "letter", "object", "char", "end", "LINE", "cell", "Line", "row", "f", "part", "base", "data", "number", "inline", "style", "response", "word", "name", "ge", "unit", "log", "text", "comment", "content", "lc", "key", "le", "string", "rule", "point", "rl", "pass", "file", "error", "code", "err", "parse", "header", "character", "lin", "str", "sl", "entry"], "internationalizedLine": ["internationalizeCode", "internationalizedCode", "internationalizableLine", "internationalizeBlock", " internationalisedline", "internationalizableBlock", "internationalizeLine", "internationalisedCode", " internationalizedline", "internationalisedline", "internationalisedLine", " internationalisedLine", " internationalisedCode", "internationalisedBlock", "internationalizedBlock", "internationalizeline", "internationalizedline", " internationalisedBlock", " internationalizedCode", " internationalizedBlock", "internationalizableCode", "internationalizableline"], "errorMsg": ["infoMsg", "errSm", " errorStr", " errorObj", "rorMessage", "rormsg", "errMessage", "ErrorMessage", " errormsg", "errmsg", "progressMessage", "bugMail", "rorLog", "infoLog", "errorLog", " errorLog", "errorStr", "bugMs", "errLog", "errMs", "rorMail", "bugMessage", "noMsg", "rorStr", "ErrorLog", "errorMail", "errorMs", "infoMessage", "rorObj", "progressSm", "Errormsg", "ErrorMsg", "rorMsg", "errorSm", " errorMessage", "nomsg", " errorSm", "ErrorStr", "infomsg", "errorObj", "errMsg", "ErrorMs", "ErrorObj", " errorMail", "errormsg", "rorMs", "bugMsg", "errorMessage", "progressMs", "noLog", "progressMsg", " errorMs"]}}
{"id1": "14807299", "id2": "23413733", "code1": "    public void testRetrieve() throws DigitalObjectManager.DigitalObjectNotFoundException, URISyntaxException, IOException {\n        DigitalObjectManager man = new FedoraObjectManager(\"fedoraAdmin\", \"fedoraAdminPass\", \"http://localhost:7910/fedora\");\n        DigitalObject r = man.retrieve(new URI(\"demo:dc2mods.1\"));\n        String title = r.getTitle();\n        List<Metadata> met = r.getMetadata();\n        InputStream content = r.getContent().read();\n        StringWriter theString = new StringWriter();\n        IOUtils.copy(content, theString);\n        assertNotNull(theString.toString(), \"Content should not be null\");\n        assertNotNull(title, \"The title should be set\");\n        assertNotNull(met.get(0).getContent(), \"There should be some metadata\");\n    }\n", "code2": "    public static void copyFile(File from, File to) throws Exception {\n        if (!from.exists()) return;\n        FileInputStream in = new FileInputStream(from);\n        FileOutputStream out = new FileOutputStream(to);\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int bytes_read;\n        while (true) {\n            bytes_read = in.read(buffer);\n            if (bytes_read == -1) break;\n            out.write(buffer, 0, bytes_read);\n        }\n        out.flush();\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"man": ["iman", "h", "an", "mann", "d", "Man", "erman", "admin", "ana", "min", "sm", "mm", "w", "eman", "client", "age", "men", "di", "work", "mand", "sam", "hand", "nav", "managed", "monkey", "mult", "per", "mod", "mot", "MAN", "m", "M", "ann", "session", "pm", "mage", "person", "manager", "fm", "woman", "md", "Manager"], "r": ["reader", "h", "gr", "rar", "d", "admin", "director", "result", "R", "right", "br", "l", "w", "http", "this", "b", "fr", "reb", "f", "data", "re", "response", "resource", "ir", "er", "rc", "e", "o", "u", "rs", "t", "sr", "rh", "m", "dr", "hr", "cr", "rw", "c", "i", "mr", "rd", "err", "g", "rr", "ar", "res", "p"], "title": ["page", "url", "term", "the", "theme", "doc", "l", "format", "license", "properties", "description", "data", "version", "summary", "resource", "prefix", "meta", "template", " titles", "section", "filename", "name", "body", "target", "t", "text", "string", "media", "company", "artist", "html", "note", "property", "label", "itle", "header", "details", "itles", "Title", "subject", "metadata", "domain", "project", "detail", "series", "chapter", "type"], "met": ["mon", "htm", "not", "ht", "mat", "material", "mm", "mem", "params", "meet", "idd", "summary", "mand", "hand", "adata", "meta", "crit", "method", "mp", "member", "mun", "param", "imet", "mot", "metal", "m", "df", "Met", "present", "MET", "att", "miss", "required", "md", "mont", "metadata", "et", "follow", "dat"], "content": ["source", "page", "parent", "reader", "input", "write", "txt", "connection", "cm", "xml", "Content", "result", "message", "output", "format", "object", "data", "stream", "response", "resource", "handler", "raw", "address", "meta", "ontent", "body", "cont", "json", "text", "comment", "temp", "media", "string", "image", "document", "load", "c", "file", "html", "code", "metadata", "copy"], "theString": ["TheWriter", " theWriter", " theStream", "TheStream", "thestring", "THEString", "theWriter", " theArray", "fromContent", "THEstring", "theSingle", "thisString", "theStream", "theirContent", " theSingle", " thestring", "THEStream", "theirArray", "TheArray", "thisSingle", "fromWriter", "thisWriter", "thisstring", "fromString", "TheContent", "Thestring", "THEArray", "TheSingle", "theArray", "theContent", "TheString", "theirString", "fromArray", "theirWriter"]}}
{"id1": "7990228", "id2": "10895680", "code1": "    public static InputStream gzip(final InputStream inputStream) throws IOException {\n        Assert.notNull(inputStream, \"inputStream\");\n        InputOutputStream inputOutputStream = new InputOutputStream();\n        GZIPOutputStream gzipOutputStream = new GZIPOutputStream(inputOutputStream);\n        IOUtils.copy(inputStream, gzipOutputStream);\n        gzipOutputStream.close();\n        return inputOutputStream.getInputStream();\n    }\n", "code2": "    private DefaultMutableTreeNode parseTree() {\n        try {\n            DefaultMutableTreeNode root;\n            URL url = RebusHelp.class.getResource(\"/org/olga/rebus/gui/help/html/content.xml\");\n            InputStream is = url.openStream();\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(true);\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            Document document = parser.parse(is);\n            NodeList elements = document.getElementsByTagName(\"help\");\n            Element element = (Element) elements.item(0);\n            root = createTreeContent(element);\n            is.close();\n            return root;\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n            return null;\n        } catch (ParserConfigurationException e1) {\n            System.out.println(e1.getMessage());\n            return null;\n        } catch (org.xml.sax.SAXException e2) {\n            System.out.println(e2.getMessage());\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"inputStream": ["outputSteam", "regularSteam", "outputStream", "inputSteam", "audioFile", "InputSt", "inFile", "regularStream", "regularREAM", "InputSource", " inputstream", " inputSource", "inputstream", "InputStream", "inputSt", " inputSteam", "outputREAM", "inputREAM", "audioSteam", "inputStreamer", "InputREAM", "inSteam", "outputstream", "audioStream", "InputFile", " inputStreamer", "Inputstream", "inStream", "inputSource", "InputStreamer", "audioSt", "InputSteam", "outputSource", "regularstream", "inputFile", "outputStreamer", "inSt"], "inputOutputStream": ["inputResponseStream", "inputResponsePass", "inputInputObject", "inputConnectionStream", "inputResponseSteam", "inputOperationStreamer", "inputConnectionObject", "rawOutputPass", "outputInputSteam", "inputOutputStreamer", "outputInputObject", "currentOutputPoint", "inputInputPoint", "inputoutputPass", "inputOutputObject", "currentInputStreamer", "inputResponseFile", "outputOutputStreamer", "currentOutputStream", "outputInputStream", "inputOutStream", "inputInputStream", "outputOutputObject", "outputInputStreamer", "inputoutputFile", "rawOutputFile", "inputOutputPass", "outputOutputSteam", "currentInputSteam", "inputConnectionStreamer", "currentOutputStreamer", "inputoutputStream", "inputOutputFile", "outputOutputStream", "rawoutputPass", "inputConnectionSteam", "inputOperationStream", "inputOutObject", "inputoutputSteam", "currentInputPoint", "currentOutputSteam", "inputInputPass", "rawoutputFile", "currentInputStream", "inputOutputPoint", "rawOutputSteam", "rawoutputStream", "inputInputStreamer", "inputOutSteam", "rawoutputSteam", "rawOutputStream", "inputOperationPoint", "inputInputSteam", "inputOutStreamer", "inputOperationSteam", "inputOutputSteam", "inputInputFile"], "gzipOutputStream": ["gzOutputThread", "gzipoutputStreamer", "gzipGroupThread", "gzipOutputSteam", "gzipUnitStream", "gzipoutputStream", "gzipInputThread", "gzipWriteSteam", "gzipInputSteam", "gzipoutputSteam", "gzInputSteam", "gzOutputStream", "gzOutputChannel", "gzipInputChannel", "gzipOutputChannel", "gzipWriteThread", "gzipUnitThread", "gzipoutputThread", "gzOutputStreamer", "gzipGroupSteam", "gzipWriteStream", "gzipUnitSteam", "gzipUnitStreamer", "gzipGroupStream", "gzOutputSteam", "gzInputChannel", "gzipOutputThread", "gzInputStream", "gzipOutputStreamer", "gzipInputStreamer", "gzInputStreamer", "gzipInputStream", "gzipGroupStreamer", "gzipoutputChannel", "gzipWriteChannel", "gzInputThread"]}}
{"id1": "3463983", "id2": "23190614", "code1": "        @Override\n        public long getLastModified(final Resource arg0) {\n            try {\n                final ServletContext context = CContext.getInstance().getContext();\n                final URL url = context.getResource(arg0.getName());\n                final URLConnection conn = url.openConnection();\n                final long lm = conn.getLastModified();\n                try {\n                    conn.getInputStream().close();\n                } catch (final Exception ignore) {\n                    ;\n                }\n                return lm;\n            } catch (final Exception e) {\n                return 0;\n            }\n        }\n", "code2": "    public void _jspService(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException, ServletException {\n        PageContext pageContext = null;\n        HttpSession session = null;\n        ServletContext application = null;\n        ServletConfig config = null;\n        JspWriter out = null;\n        Object page = this;\n        JspWriter _jspx_out = null;\n        PageContext _jspx_page_context = null;\n        try {\n            response.setContentType(\"text/html;charset=UTF-8\");\n            pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);\n            _jspx_page_context = pageContext;\n            application = pageContext.getServletContext();\n            config = pageContext.getServletConfig();\n            session = pageContext.getSession();\n            out = pageContext.getOut();\n            _jspx_out = out;\n            _jspx_resourceInjector = (org.apache.jasper.runtime.ResourceInjector) application.getAttribute(\"com.sun.appserv.jsp.resource.injector\");\n            out.write(\"\\n\");\n            out.write(\"\\n\");\n            out.write(\"\\n\");\n            String username = \"test\";\n            String password = \"test\";\n            int providerId = 1;\n            if (request.getParameter(\"providerId\") != null) providerId = Integer.parseInt(request.getParameter(\"providerId\"));\n            String thisPageContextAddress = \"http://localhost:8080/\" + request.getContextPath();\n            String thisPageServingAddress = thisPageContextAddress + \"/index.jsp\";\n            String token = \"\";\n            String token_timeout = (String) request.getParameter(\"token_timeout\");\n            String referer = request.getHeader(\"Referer\");\n            if (token_timeout != null && token_timeout.equals(\"true\")) {\n                System.out.println(\"token timeout for referer\" + referer);\n                if (referer != null) {\n                    if (request.getSession().getServletContext().getAttribute(\"token_timeout_processing_lock\") == null) {\n                        request.getSession().getServletContext().setAttribute(\"token_timeout_processing_lock\", true);\n                        byte[] buff = null;\n                        BufferedInputStream bis = null;\n                        URL url = new URL(thisPageContextAddress + \"/ServerAdminServlet?action=login&username=\" + username + \"&password=\" + password);\n                        URLConnection urlc = url.openConnection();\n                        int length = urlc.getContentLength();\n                        InputStream in = urlc.getInputStream();\n                        buff = new byte[length];\n                        int bytesRead = 0;\n                        while (bytesRead < length) {\n                            bytesRead += in.read(buff, bytesRead, in.available());\n                        }\n                        token = new String(buff);\n                        token = token.replaceAll(\"[\\\\r\\\\f]\", \"\");\n                        token = token.trim();\n                        request.getSession().getServletContext().setAttribute(\"token\", token);\n                        out.println(token);\n                        request.getSession().getServletContext().removeAttribute(\"token_timeout_processing_lock\");\n                    } else out.println(\"token_timeout_processing_lock\");\n                }\n            } else {\n                if (request.getSession().getServletContext().getAttribute(\"token\") == null || request.getSession().getServletContext().getAttribute(\"token\").equals(\"\")) {\n                    byte[] buff = null;\n                    BufferedInputStream bis = null;\n                    URL url = new URL(thisPageContextAddress + \"/ServerAdminServlet?action=login&username=\" + username + \"&password=\" + password);\n                    URLConnection urlc = url.openConnection();\n                    int length = urlc.getContentLength();\n                    InputStream in = urlc.getInputStream();\n                    buff = new byte[length];\n                    int bytesRead = 0;\n                    while (bytesRead < length) {\n                        bytesRead += in.read(buff, bytesRead, in.available());\n                    }\n                    token = new String(buff);\n                    token = token.replaceAll(\"[\\\\r\\\\f]\", \"\");\n                    token = token.trim();\n                    request.getSession().getServletContext().setAttribute(\"token\", token);\n                }\n                out.write(\"<html>\\n\");\n                out.write(\"  <head>\\n\");\n                out.write(\"    <title>AJAX test </title>\\n\");\n                out.write(\"    <script type=\\\"text/javascript\\\" src=\\\"OpenLayers-2.8/OpenLayers.js\\\"></script>\\n\");\n                out.write(\"    <script type=\\\"text/javascript\\\">\\n\");\n                out.write(\"\\n\");\n                out.write(\"        function init(){\\n\");\n                out.write(\"\\n\");\n                out.write(\"            var token = \\\"\");\n                out.print(request.getSession().getServletContext().getAttribute(\"token\"));\n                out.write(\"\\\";\\n\");\n                out.write(\"\\n\");\n                out.write(\"            var options = {\\n\");\n                out.write(\"                            maxExtent: new OpenLayers.Bounds(-600, -300, 0, 400),\\n\");\n                out.write(\"                            maxResolution: 4.77730, minRezolution: 78271.517, numZoomLevels: 15, units: 'm'\\n\");\n                out.write(\"                          }\\n\");\n                out.write(\"\\n\");\n                out.write(\"\\n\");\n                out.write(\"            var map = new OpenLayers.Map('map', options);\\n\");\n                out.write(\"            var layer = new OpenLayers.Layer.TMS(\\\"TMS\\\", \\\"/WebGISTileServer/TMSServletProxy/\\\" + token + \\\"/7/\\\",\\n\");\n                out.write(\"                                                { layername: 'TMS', type: 'png' });\\n\");\n                out.write(\"            map.addLayer(layer);\\n\");\n                out.write(\"            map.addControl(new OpenLayers.Control.MousePosition());\\n\");\n                out.write(\"            map.setCenter(new OpenLayers.LonLat(-300, 120), 4);\\n\");\n                out.write(\"        }\\n\");\n                out.write(\"    </script>\\n\");\n                out.write(\"  </head>\\n\");\n                out.write(\"  <body onload=\\\"init()\\\">\\n\");\n                out.write(\"      <H1>TeleAtlas map with TMS</H1>\\n\");\n                out.write(\"      <div id=\\\"map\\\" style=\\\"width:100%; height:90%\\\"></div>\\n\");\n                out.write(\"  </body>\\n\");\n                out.write(\"</html>\");\n            }\n        } catch (Throwable t) {\n            if (!(t instanceof SkipPageException)) {\n                out = _jspx_out;\n                if (out != null && out.getBufferSize() != 0) out.clearBuffer();\n                if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);\n            }\n        } finally {\n            _jspxFactory.releasePageContext(_jspx_page_context);\n        }\n    }\n", "label": 0, "substitutes": {"arg0": ["args4", " arg4", "args1", "argk", "Arg4", "args2", "Arg2", "arg2", " argk", "arg4", "Arg0", "arg1", "Arg1", " arg1", "args0", "argsk", " arg2", "Argk"], "context": ["connection", "xml", "cf", "cas", "request", "app", "client", "bc", "loc", "exc", "ctx", "resource", "server", "contact", "tx", "config", "info", "cur", "component", "event", "rc", "container", "tc", "kernel", "instance", "temp", "path", "c", "focus", "support", "Context", "current", "service", "ce", "cms", "env", "concept", "coll"], "url": ["host", "connection", "open", "ll", "l", "http", "con", "client", "b", "object", "lr", "f", "loc", "base", "data", "channel", "resource", "org", "server", "config", "address", "name", "ur", "gl", "log", "bel", "ch", "fl", "string", "path", "connect", "impl", "c", "file", "uri", "ssl", "socket", "URL", "Url", "blog", "web", "sl"], "conn": ["cb", "dc", "connection", "open", "cf", "co", "ct", "con", "Conn", "channel", "loc", "cp", "n", "enc", "ctx", "serv", "cn", "pc", "cur", "exec", "sync", "conf", "ci", "rc", "nt", "coll", "act", "ch", "cli", "lc", "ann", "close", "col", "connect", "c", "ssl", "rt", "conv", "Connection", "ca", "nc", "ad"], "lm": ["olpm", "ulms", "lbm", "lfm", "LM", "lM", "olfm", "ulm", "ulM", " lcm", "lcm", "olbm", "lpm", "slm", "llbm", "llfm", "ulcm", "llpm", "llm", "slfm", "Lcm", " lms", " lM", "lms", "Lm", "slpm", "slbm", "Lms", "olm"]}}
{"id1": "6150059", "id2": "9307757", "code1": "    private void nioBuild() {\n        try {\n            final ByteBuffer buffer = ByteBuffer.allocateDirect(1024 * 4);\n            final FileChannel out = new FileOutputStream(dest).getChannel();\n            for (File part : parts) {\n                setState(part.getName(), BUILDING);\n                FileChannel in = new FileInputStream(part).getChannel();\n                while (in.read(buffer) > 0) {\n                    buffer.flip();\n                    written += out.write(buffer);\n                    buffer.clear();\n                }\n                in.close();\n            }\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            clearTables(stmt);\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Minimal Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 0, "substitutes": {"buffer": ["source", "size", "reader", "value", "read", "input", "queue", "binary", "feed", "buff", "result", "iter", "Buffer", "output", "message", "limit", "b", "loop", "base", "layer", "channel", "data", "loader", "resource", "server", "config", "writer", "address", "pad", "uffer", "null", "transfer", "padding", "batch", "bb", "flow", "length", "wave", "capacity", "buf", "temp", "timeout", "up", "offset", "slice", "document", "border", "seed", "cache", "pool", "fb", "header", "position", "bin", "copy", "pause"], "out": ["source", "parent", "size", "inc", "line", "connection", "io", "output", "outer", "w", "b", "client", "this", "channel", "f", "base", "to", "on", "layer", "OUT", "Out", "again", "outs", "server", "external", "writer", "inner", "off", "exec", "dest", "sync", "o", "copy", "up", "point", "cache", "obj", "file", "c", "i", "err", "bin", "s", "null", "p"], "part": ["source", "parent", "connection", "from", "one", "pre", "object", "piece", "state", "base", "channel", "f", "data", "version", "sector", "po", "layer", "pair", "fat", "section", "element", "name", "component", "zone", "body", "per", "patch", "unit", "Part", "ch", "partial", "art", "PART", "key", "up", "path", "point", " Part", "file", "pos", "block", "parts", "start", "group", "p", "type"], "in": ["source", "reader", "url", "input", "inc", "din", "d", "token", "win", "connection", "pull", "iter", "nin", "conn", "l", "con", "b", "client", "diff", "login", "f", "layer", "on", "data", "In", "pin", "n", "again", " input", "inner", "pc", "exec", "init", "it", "ins", "e", "per", " inside", "up", "c", "i", "IN", "err", " din", "or", "inn", "bin", "s", "p"], "written": ["wrote", "left", "write", "len", "sent", "output", "weight", "updated", "w", "sized", "Written", "used", "won", "writer", "started", "checked", "writ", "done", "width", "printed", "modified", "signed", "initialized", "locked", "writing", "ended", "unit"]}}
{"id1": "21682040", "id2": "20215222", "code1": "    public void extractFrinika() throws Exception {\n        FileInputStream fis = new FileInputStream(frinikaFile);\n        progressBar.setIndeterminate(true);\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry ze = zis.getNextEntry();\n        while (ze != null) {\n            showMessage(\"Extracting: \" + ze.getName());\n            File file = new File(installDirName + \"/\" + ze.getName());\n            if (ze.isDirectory()) file.mkdir(); else {\n                FileOutputStream fos = new FileOutputStream(file);\n                byte[] b = new byte[BUFSIZE];\n                int c;\n                while ((c = zis.read(b)) != -1) fos.write(b, 0, c);\n                fos.close();\n            }\n            ze = zis.getNextEntry();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String in = \"/Users/laemmel/svn/shared-svn/projects/120multiDestPeds/floor_plan/boundaries.shp\";\n        String out = \"/Users/laemmel/svn/shared-svn/projects/120multiDestPeds/floor_plan/boundaries_closed.shp\";\n        ShapeFileReader reader = new ShapeFileReader();\n        reader.readFileAndInitialize(in);\n        QuadTree<Coordinate> quad = new QuadTree<Coordinate>(reader.getBounds().getMinX(), reader.getBounds().getMinY(), reader.getBounds().getMaxX(), reader.getBounds().getMaxY());\n        for (Feature ft : reader.getFeatureSet()) {\n            MultiLineString ml = (MultiLineString) ft.getDefaultGeometry();\n            for (int i = 0; i < ml.getNumGeometries(); i++) {\n                LineString ls = (LineString) ml.getGeometryN(i);\n                Point start = ls.getStartPoint();\n                checkIt(start, quad);\n                Point end = ls.getEndPoint();\n                checkIt(end, quad);\n            }\n        }\n        ShapeFileWriter.writeGeometries(reader.getFeatureSet(), out);\n    }\n", "label": 1, "substitutes": {"fis": ["lbs", "afiss", "lais", "piss", "Fiss", "Fos", "fiss", "fais", "afos", "afis", "fios", "pbs", " fios", "Fis", "fbs", "pis", "lis", "liss", "afios", "Fios", " fais", " fbs", " fiss", "pais"], "zis": [" zins", " zos", "zais", "zas", " ziss", " zIS", "zipos", " zas", "zeiss", "zips", "zisa", "zenisa", "zipips", "zipis", "zenins", "zipais", "zipisi", "zeIS", " zips", "zenis", "zeniss", "ZIS", "zenisi", "zenos", "ziss", " zisi", "Zas", "zos", "zenips", "zIS", "zeas", "zenIS", "Zins", "zeis", "Ziss", "Zis", "zenais", "zisi", " zisa", "zins", "zipisa", " zais"], "ze": ["forge", "ice", "ette", "ipe", "zes", "za", "isse", "ld", "cf", "ee", "one", "ez", "que", "jo", "zy", "model", "ane", "lde", "ise", "fe", "ine", "zi", "zip", "zen", "ie", "ffe", "he", "el", "element", "zone", "zo", "ge", "ne", "liner", "e", "ace", "de", "ide", "ve", "cel", "oe", "sl", "kel", "je", "zz", "se", "ke", "zer", "ZE", "frame", "sk", "note", "code", "zed", "lex", "zie", "ede", "zee", "ce", "aze", "kee", "sea", "z", "lane", "te", "line", "ele", "entry"], "file": ["get", "folder", "parent", "die", "ile", "pe", "place", "feed", "connection", "cf", "function", "File", "l", "letter", "http", "out", "fp", "object", "f", "base", "fe", "data", "directory", "future", "zip", "single", "resource", "work", "force", "name", "dir", "it", "full", "e", "log", "jar", "le", "book", "up", "path", "cache", "files", "local", "FILE", "line", "unit"], "fos": ["Foos", "infOS", "infoss", "Fio", " foos", "foss", " fOS", "Fos", "Foss", "bos", "afos", "infos", "fios", " fios", "boss", "fio", "infoos", "FOS", "afoss", "fOS", "infio", "infis", "foos", "infios", "afios", "Fios", "bis", " fio", "afOS", " foss", "bOS"], "b": ["sb", "cb", "bf", "d", "mb", "buffer", "be", "buff", "br", "pb", "l", "bc", "f", "base", "bd", "bytes", "r", "bs", "abb", "x", "e", "bb", "ob", "a", "buf", "v", "ba", "gb", "xb", "eb", "ib", "emb", "B", "ab", "db", "i", "wb", "nb", "boot", "lb", "rb", "p", "bl"], "c": ["size", "dc", "id", "d", "uc", "cy", "cm", "cu", "cf", "k", "fc", "l", "w", "con", "bc", "f", "ec", "cp", "n", "r", "enc", "xc", "sc", "ac", "pc", "x", "ci", "e", "o", "esc", "cl", "a", "m", "lc", "col", "count", "cr", "code", "i", "ce", "cc", "nc", "p", "C"]}}
{"id1": "7495800", "id2": "19972831", "code1": "    public static void copyFile(File fromFile, File toFile) throws IOException {\n        FileReader from = new FileReader(fromFile);\n        FileWriter to = new FileWriter(toFile);\n        char[] buffer = new char[4096];\n        int bytes_read;\n        while ((bytes_read = from.read(buffer)) != -1) {\n            to.write(buffer, 0, bytes_read);\n        }\n        to.flush();\n        to.close();\n        from.close();\n    }\n", "code2": "    public static int[] simplex_reverse_sort(int[] vertices) {\n        if (vertices.length <= 1) return vertices;\n        for (int j = vertices.length - 1; j > 0; j--) {\n            for (int i = 0; i < j; i++) {\n                if (vertices[i + 1] > vertices[i]) {\n                    int dummy = vertices[i];\n                    vertices[i] = vertices[i + 1];\n                    vertices[i + 1] = dummy;\n                }\n            }\n        }\n        return vertices;\n    }\n", "label": 0, "substitutes": {"fromFile": ["orfile", "toDirectory", "fromSourceFile", " fromDirectory", "FromFile", "FromSourceFile", "fromfile", "orSourceFile", " fromFiles", "FromFiles", " fromSourceFile", " fromfile", "FromDirectory", "Fromfile", "fromDirectory", "fromFiles", "tofile", "orFile", "orDirectory", "toFiles"], "toFile": ["ToFile", "Tofile", "toDirectory", "toFolder", " toFolder", " toFilename", " tofile", " toPath", " toDir", "etoFilename", "ToFolder", "toFilename", "etofile", "ToFilename", "ToDirectory", "etoPath", "ToPath", "toDir", "targetFolder", "targetFile", "ToDir", "targetDirectory", "targetDir", "toPath", "etoFile", "tofile", " toDirectory"], "from": ["source", "get", "left", "read", "parent", "url", "link", "with", "range", "after", "io", "one", "original", "out", "this", "client", "end", "of", "in", "part", "normal", "f", "base", "From", "fe", "by", "data", "r", "u", "o", "old", "per", "a", "se", "up", "c", "parse", "file", "or", "ce", "start", "self", "form", "who", "so"], "to": ["via", "size", "write", "token", "with", "after", "co", "io", "TO", "one", "http", "thro", "out", "client", "b", "To", "f", "as", "po", "by", "into", "no", "auto", "data", "storage", "writer", "sync", "o", "target", "per", "api", "copy", "temp", "too", "socket", "file", "flo", "or", "who", "two", "so"], "buffer": ["source", "read", "reader", "url", "queue", "memory", "input", "binary", "feed", "reference", "buff", "repeat", "iter", "result", "Buffer", "limit", "layer", "number", "channel", "data", "base", "bytes", "available", "resource", "server", "raw", "address", "pad", "uffer", "transfer", "null", "batch", "flush", "length", "buf", "timeout", "slice", "count", "document", "border", "seed", "cache", "character", "position", "ip", "duration"], "bytes_read": [" bytes_valid", "bytes_load", " bytes_pass", "bytesIDvalid", "bytesIDload", "bytes_valid", " bytes_write", "bytes_pass", "bytes_length", " bytes_set", " bytes_length", "bytes_set", "bytes_in", " bytes_in", " bytes_load", "bytes_write", "bytesIDpass", "bytesIDread"]}}
{"id1": "15171197", "id2": "22724697", "code1": "    private static Pattern getBotPattern() {\n        StringBuilder sb = new StringBuilder();\n        try {\n            Enumeration<URL> urls = AbstractPustefixRequestHandler.class.getClassLoader().getResources(CONFIG);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                InputStream in = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in, \"utf8\"));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    line = line.trim();\n                    if (!line.startsWith(\"#\") && !line.equals(\"\")) {\n                        if (sb.length() > 0) sb.append(\"|\");\n                        sb.append(\"(\").append(line).append(\")\");\n                    }\n                }\n                in.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error reading bot user-agent configuration\", e);\n        }\n        return Pattern.compile(sb.toString());\n    }\n", "code2": "    private Bitmap getBitmap(String imageUrl) {\n        URL url;\n        InputStream input = null;\n        try {\n            url = new URL(address + imageUrl);\n            input = url.openStream();\n            return BitmapFactory.decodeStream(input);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (input != null) {\n                try {\n                    input.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sb": ["lp", "cb", "sa", "split", "bf", "si", "txt", "binary", "bh", "mb", "buffer", "sth", "lines", "usb", "ws", "sg", "pb", "BB", "bg", "src", "sm", "fp", "b", "sf", "bc", "lr", "bm", "kb", "bd", "ruby", "storage", "abb", "bs", "bi", "obb", "rob", "bj", " SB", "SB", "bb", "ob", "sv", "zb", "ls", "job", "gb", "eb", "ib", "orb", "bsp", "sp", "ssl", "bt", "db", "ab", "wb", "fb", "sq", "nb", "amb", "lb", "rb", "bp"], "urls": [" urlies", " urlses", "collses", "URLses", "Urlws", "Urls", "urllines", "colls", "urlls", "URLlines", " urlws", "urlset", "https", "httpset", "urlws", "URLws", "collls", "URLs", "Urlls", "httplines", "urlses", "URLset", " urlls", "httpls", "URLies", " urlset", " urllines", "URLls", "urlies", "Urlies"], "url": ["source", "page", "id", "input", "link", "browser", "feed", "connection", "download", "pull", "plugin", "l", "http", "out", "b", "f", "base", "stream", "r", "resource", "server", "config", "address", "element", "update", "name", "ur", "bel", "location", "job", "string", "path", "image", "cert", "socket", "uri", "file", "i", "ssl", "URL", "Url", "account", "blog", "sl", "entry"], "in": ["source", "read", "input", "inc", "din", "trans", "connection", "buffer", "io", "conn", "out", "b", "client", "fr", "login", "f", "loader", "data", "In", "stream", "again", "r", "resource", "serv", "ac", "writer", "inner", "er", "ins", "ini", "a", "image", "impl", "socket", "file", "lock", "i", "err", "IN", "inn", "is", "lin", "bin", "s", "ic"], "reader": ["ner", "read", "input", "rar", "rx", "Reader", "feed", "buffer", "iter", "ro", "io", "iterator", "l", "ler", "f", "loader", "worker", "oder", "stream", "r", "handler", "editor", "server", "writer", "inner", "er", "rer", "rc", "e", "reading", "per", "rot", "bird", "parser", "ino", "ri", "i", "err", "rr"], "line": ["source", "page", "id", "split", "value", "link", "pe", "lf", "plugin", "range", "lines", "message", "l", "letter", "one", "definition", "home", "char", "val", "LINE", "cell", "end", "Line", "row", "f", "base", "model", "data", "no", "part", "inline", "style", "auto", "zip", "strip", "el", "word", "sync", "name", "shell", "ge", "e", "unit", "log", "non", "cl", "text", "comment", "content", "lc", "job", "le", "key", "li", "string", "rule", "point", "frame", "pass", "file", "error", "code", "parse", "label", "header", "block", "lin", "look", "str", "ip", "sl", "entry"]}}
{"id1": "20369681", "id2": "746544", "code1": "    @Override\n    public InputStream getInputStream() throws IOException {\n        if (dfos == null) {\n            int deferredOutputStreamThreshold = Config.getInstance().getDeferredOutputStreamThreshold();\n            dfos = new DeferredFileOutputStream(deferredOutputStreamThreshold, Definitions.PROJECT_NAME, \".\" + Definitions.TMP_EXTENSION);\n            try {\n                IOUtils.copy(is, dfos);\n            } finally {\n                dfos.close();\n            }\n        }\n        return dfos.getDeferredInputStream();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"deferredOutputStreamThreshold": ["deferredOutputFileThresh", "deferredOutputStreamShresh", "deferredOutputStreamShreshold", "deferredOutputStreamThocol", "deferredOutputStreamShocol", "deferredOutputFileThocol", "deferredOutputstreamThreshold", "deferredOutputStreamFreshold", "deferredOutputFileTholerance", "deferredOutputStreamFocol", "deferredOutputStreamSholerance", "deferredOutputStreamMetategy", "deferredOutputStreamThresh", "deferredOutputstreamTholerance", "deferredOutputStreamthocol", "deferredOutputStreamthresh", "deferredOutputStreamThategy", "deferredOutputStreamTholerance", "deferredOutputstreamThategy", "deferredOutputStreamMetocol", "deferredOutputStreamthreshold", "deferredOutputStreamMetreshold", "deferredOutputStreamMetolerance", "deferredOutputstreamThocol", "deferredOutputStreamtholerance", "deferredOutputStreamFategy", "deferredOutputStreamFolerance", "deferredOutputFileThreshold"], "dfos": ["lfos", "DFoS", "dfops", " dfas", " dfios", "fsoS", "ufos", "DFs", "dfas", "fdops", "deboss", "dfoS", "lfops", "foss", "fo", "dfds", "fdos", "fs", "ufs", " dfoss", "fsops", "fsos", "dfios", "fds", "lfoS", "dsos", "dfs", "lfs", "ufo", " dfops", "dfoss", "DFo", "dsnos", "fdios", " dfs", "dss", "DFios", "debos", "DFops", " dfo", " dfnos", "fss", "DFds", "debo", "dfnos", "DFnos", "fos", "ufds", "DFos", "dso", "debas", "fas", "dfo"]}}
{"id1": "5317659", "id2": "15136801", "code1": "    public String hash(String clearPassword) {\n        if (osalt == 0) return null;\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new AssertionError(\"Can't find the SHA1 algorithm in the java.security package\");\n        }\n        String saltString = String.valueOf(osalt);\n        md.update(saltString.getBytes());\n        md.update(clearPassword.getBytes());\n        byte[] digestBytes = md.digest();\n        StringBuffer digestSB = new StringBuffer();\n        for (int i = 0; i < digestBytes.length; i++) {\n            int lowNibble = digestBytes[i] & 0x0f;\n            int highNibble = (digestBytes[i] >> 4) & 0x0f;\n            digestSB.append(Integer.toHexString(highNibble));\n            digestSB.append(Integer.toHexString(lowNibble));\n        }\n        String digestStr = digestSB.toString();\n        return digestStr;\n    }\n", "code2": "    public static String readUrl(String urlString) {\n        try {\n            java.net.URL url = new java.net.URL(urlString);\n            BufferedReader br = null;\n            if (url != null) {\n                br = new BufferedReader(new InputStreamReader(url.openStream()));\n            }\n            StringBuffer fileString = new StringBuffer();\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                fileString.append(line + \"\\n\");\n            }\n            return fileString.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"clearPassword": ["cleanPass", " clearpassword", "passwordPassword", "newSecret", "resetpassword", "newpassword", "newPass", "newPassword", "clearString", " clearSecret", "cleanString", "clearpassword", "resetString", "resetPassword", "clearPass", "passwordpassword", "resetPass", "cleanpassword", "clearSecret", "passwordString", " clearString", "cleanPassword", "passwordSecret", "newString"], "md": ["ad", "msg", "cd", "d", "mb", " Md", "alg", "dd", "ld", "sm", " MD", "mm", "ma", "pd", "mem", "am", "wd", "gd", "cmd", "ms", "f", "mo", "mac", "bd", "di", "hm", "mand", "mag", "meta", "mc", "sha", "mp", "dm", "rm", "mod", "dh", "MD", "mt", "m", "M", "df", "dr", "od", "mail", "pm", "j", "mg", "code", "Cmd", "grad", "metadata", "amd", "dig", "amp", "cmp", "pkg"], "saltString": ["sassInt", "saltArray", "sALTInt", "sodiumStr", "saultString", "ssaultstring", " saltArray", "saultBuffer", "sALTString", "ssaltString", "saledBuffer", " sassStr", " sassInt", "ssaltstring", "ssaultString", "ssaltBytes", "saultstring", "saltBytes", "sassArray", "sassStr", "saltStr", " sassString", " sassArray", "saledstring", "saledBytes", "saltBuffer", "ssaultBuffer", "sodiumString", "ssaultBytes", "saledString", "sassString", "sodiumArray", "sodiumInt", "ssaltBuffer", "saltInt", "saltstring", " saltStr", "sALTArray", "sALTStr", " saltInt", "saultBytes"], "digestBytes": [" digestBlocks", "digerBlocks", "digestedParts", "digesterByte", "digesterBitcoin", " digestParts", "digseByte", "digestbytes", " digestbytes", "signestedBytes", "diggestByte", "diggestCharacters", "digerbytes", "signestByte", "signestedBitcoin", "signestBitcoin", "digestBlocks", " digesterBytes", "digesterBlocks", "digestBitcoin", " digseBytes", "digerParts", "digesterBytes", "digesterbytes", "digesterParts", "signestedParts", "signesterByte", "signesterCharacters", "signestParts", " digesterParts", " digestByte", " digesterBlocks", "signestedByte", "digestedBlocks", " digseByte", "digestedbytes", "digestCharacters", "digsebytes", "digesterCharacters", "signestBytes", "digestedBitcoin", "digseParts", "diggestBytes", "signesterParts", "diggestParts", "digestByte", "digseBytes", " digsebytes", "signestCharacters", "digestedByte", "digerBytes", "digestedCharacters", "digestedBytes", "diggestBitcoin", "digestParts", " digseParts", "signesterBytes", " digesterbytes"], "digestSB": ["digESTBB", " digestsb", " digestedBL", " digestBuffer", " digestLB", " digESTBF", "digestsb", " digESTBB", "digestBB", "digestedBL", "digessBL", "digesterLB", "digesterNB", "digestedNB", " digestedBF", "digestedBuffer", "digestingBB", "digestedsb", " digestBB", "digessBB", "digestersb", " digESTSB", "digestBF", " digestedBuffer", "digessSB", "digESTSB", "digESTBF", "digesterBF", " digESTNB", "digestingsb", " digestedSB", "digesterBuffer", "digesterSB", "digestBuffer", "digestedBB", "digestedSB", "digessBF", "digestLB", " digestBF", " digESTLB", " digestedBB", "digESTLB", "digesterBB", " digestNB", "digestedBF", "digestedLB", " digestBL", "digestBL", "digestNB", "digestingBuffer", "digesterBL", "digESTNB", " digestedsb", "digestingSB"], "i": ["id", "si", "qi", "d", "multi", "abi", "uli", "iu", "phi", "io", "l", "b", "part", "f", "di", "bi", "n", "mu", "I", "ti", "oi", "ai", "gi", "ji", "info", "x", "ix", "it", "ui", "ci", "e", "u", "o", "length", "t", "ini", "lc", "li", "v", "key", "xi", "index", "ri", "slice", "j", "c", "uri", "ii", "pi", "fi", "uni", "ip", "p"], "lowNibble": ["lowNodeuckle", "lowNiece", "lowFiece", "lowNipple", "highNiece", "oldNaffle", "highFiece", "lowCNNipple", "oldnaffle", "oldniece", "oldnipple", "oldNibble", "oldNipple", "lowFette", "highFibble", "oldnibble", "highNette", "highFette", "lowCNNaffle", "lowCNNiece", "lownibble", "lownipple", "lowniece", "lownaffle", "lowFibble", "lowCNNibble", "highNuckle", "lowNuckle", "lowNaffle", "highFuckle", "lowNette", "lowFipple", "lowFaffle", "lowNodeiece", "oldNiece", "lowNodeette", "lowFuckle", "lowNodeibble"], "highNibble": ["highnomination", "largeNiece", "lowNiece", "highNiece", "largeNitty", "highniece", "highNitty", "highFitty", "highFiece", "largeNomination", "largenibble", "highFibble", "highNomination", "largeniece", "highCNNibble", "highNoibble", "highCNNitty", "highNoiece", "highNoie", "largenitty", "largenomination", "lowNumeric", "highnibble", "highNumeric", "highNoumeric", "highCNNiece", "highCNNomination", "highNie", "lowNie", "highnitty", "largeNibble", "highFomination"], "digestStr": [" digesterString", "signesterstr", "digESTBr", "digestedBr", "digESTString", " digesterSt", "signestBr", "signestString", "digestsStr", "digestedString", "digestingString", "digesterstr", "digestBr", "digestsString", "digestingSt", " digesterStr", "digesterStr", "digestedSt", "digestsstr", "digeststr", " digestBr", " digestSt", "digesterSt", "signesterStr", "signeststr", "digesterString", "digESTstr", "digestString", "signesterBr", "digestingStr", "digestedStr", "signesterString", "digestSt", "digestingBr", "signestStr", "digESTStr", "digesterBr", "digestsBr", " digesterBr", " digestString"]}}
{"id1": "18348099", "id2": "10415388", "code1": "    public static void copyFileToFile(File srcFile, File dstFile, boolean deleteOriginals, boolean forceDelete) throws FileNotFoundException, IOException {\n        if (srcFile.exists() && srcFile.isFile()) {\n            boolean copied = false;\n            if (deleteOriginals && (!forceDelete || srcFile.canWrite())) {\n                copied = srcFile.renameTo(dstFile);\n            }\n            if (!copied) {\n                Throwable thrownException = null;\n                File parent = dstFile.getParentFile();\n                if (!parent.exists() && !parent.mkdirs()) {\n                    throw new IOException(\"Failed to create the directory \" + parent + \".\");\n                }\n                FileInputStream in = new FileInputStream(srcFile);\n                try {\n                    FileChannel srcChannel = in.getChannel();\n                    try {\n                        FileOutputStream out = new FileOutputStream(dstFile);\n                        try {\n                            FileChannel dstChannel = out.getChannel();\n                            try {\n                                dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                            } catch (Throwable t) {\n                                thrownException = t;\n                            } finally {\n                                dstChannel.close();\n                            }\n                        } catch (Throwable t) {\n                            if (thrownException == null) {\n                                thrownException = t;\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } catch (Throwable t) {\n                        if (thrownException == null) {\n                            thrownException = t;\n                        }\n                    } finally {\n                        srcChannel.close();\n                    }\n                } catch (Throwable t) {\n                    if (thrownException == null) {\n                        thrownException = t;\n                    }\n                } finally {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        if (thrownException == null) {\n                            thrownException = e;\n                        }\n                    }\n                }\n                if (deleteOriginals && (srcFile.canWrite() || forceDelete)) {\n                    if (!srcFile.delete()) {\n                        throw new IOException(\"Failed to delete \" + srcFile + \".\");\n                    }\n                }\n                if (thrownException != null) {\n                    if (thrownException instanceof IOException) {\n                        throw (IOException) thrownException;\n                    } else if (thrownException instanceof Error) {\n                        throw (Error) thrownException;\n                    } else {\n                        throw (RuntimeException) thrownException;\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFileNIO(String src, String dst) {\n        try {\n            FileChannel srcChannel = new FileInputStream(src).getChannel();\n            FileChannel dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"srcFile": ["sourceDir", "rcfile", "srcFiles", " srcPath", "srcfile", "srcFolder", "rcDir", "srcPage", "stFolder", "rcDirectory", "rcFiles", " srcUnit", " srcDirectory", " srcfile", "rcFolder", "srcDirectory", "sourcefile", "stFile", "sourceFile", "surFilename", " srcFiles", "rcFilename", "instfile", "instUnit", "rcPage", "surFile", "sourceFiles", "stDir", " srcFilename", "instDir", "sslFolder", "surFiles", " srcDir", "srcFilename", "sourceUnit", "stFiles", "rcFile", "instFile", " srcFolder", " srcPage", "rcPath", "sourcePage", "sslFile", "sslFiles", "sourceDirectory", "sslDir", "srcUnit", "surPath", "srcDir", "rcUnit", "srcPath"], "dstFile": ["dstsPage", "ddestChannel", " dstfile", "drcFilename", "drcPage", "drdfile", " dndDirectory", " dndFile", "dostfile", "dostFiles", "fdestFile", "drcfile", "dstfile", "ddestPage", " dstDirectory", "dstPage", "dspfile", "drcFiles", "fstfile", "dostFile", "fdestChannel", " dndPath", "Drcfile", "dputfile", "fostFile", "drcFile", "dstsFiles", "dspFile", "fstPage", "DstFilename", "dstPath", "fostfile", "dstsFile", "dputFile", "dstFilename", "dspFiles", "drdFiles", "drdFilename", " dstPath", "DrcFilename", "DstFile", "Dstfile", "dndPath", "DstFiles", " dndfile", "dndDirectory", "dputFiles", "dspDirectory", "drcPath", "fstFile", "dstsChannel", "drcDirectory", "dstDirectory", "dostDirectory", "fostFiles", "ddestFile", "DrcFile", "fstFiles", "drcChannel", "fdestFiles", "fdestPage", "dputFilename", "fstChannel", "dndfile", "ddestFiles", "drdFile", "fstDirectory", "dndFile", "ddestfile", "fostDirectory", "ddestPath", "ddestDirectory", "dstFiles", "DrcFiles"], "deleteOriginals": ["deleteOrdinally", "deleteLocinators", " deleteorigains", "deletePriminals", "deleteoriginally", "deleteOriginalinally", "deleteOrdinators", "deleteASCinals", "deleteLocins", "deleteorigatives", "deleteOrigatives", " deleteoriginals", "deleteASCatives", "copyOriginally", "deleteoriginal", "deleteOriginalins", "copyOriginal", "deletePrimins", "deleteorigains", "deleteOriginalinators", "deleteOrigains", " deleteOrigains", "copyoriginals", "copyOriginals", "deleteOrdinal", "copyorigins", "deleteOriginalinals", "deleteOriginators", "deleteOriginally", "deleteOriginal", "deleteoriginators", "copyoriginators", "copyoriginal", "copyoriginally", "deleteOriginalinal", "deleteLocinal", " deleteorigatives", "deletePrimatives", "copyOriginators", "copyOrigins", "deleteOrigins", "deleteoriginals", "deleteLocinals", " deleteOrigins", "deleteorigins", "deletePrimains", " deleteOrigatives", "deleteOrdinals", " deleteorigins", "deleteASCins", "deleteASCains"], "forceDelete": ["forcedelete", "forcedCopy", "forcedWrite", "hardDelete", "forceddelete", "hardCopy", "forceWrite", "forceCopy", "ForceDel", "forcedDel", " forceCopy", "hardDel", "forcedDelete", " forcedelete", "forceDel", "harddelete", " forceWrite", " forceDel", "ForceCopy", "ForceWrite", "ForceDelete"], "copied": [" Copies", " copie", " Copied", "replies", "partied", "Copied", "copipped", "rotied", " copying", "rotried", "Copowed", "Copying", "copie", "Copies", "copyying", "partipped", "partried", "copying", " Copie", " copies", "copowed", "rotided", "replying", " copipped", "replied", "copies", "Copie", " copided", " copried", "partided", "copided", "copried", "copyies", "replowed", "copyied", " Copying", "copyowed", "rotipped"], "thrownException": ["threwEntity", "threatedOption", "sthookedAlias", "threatedEx", "thornedception", "sthanedOption", "thratedApplication", "sthanedEvent", "thookedInformation", "frownException", "sthaughtEvent", "thrownPosition", "ThrewError", "thrawnEvent", "thiedException", "athrownException", "fainedInformation", "thratedInformation", "sthrewString", "thawedPosition", "thrawnEntity", "fainedException", "thrownception", "threwception", " threatedException", "thuredApplication", "thownAmount", "phrownOption", "thrownExperience", "threwExperience", "sthrownEx", "thrownInformation", "sthrewException", "thlledUnless", "threatedInformation", "threwAlias", "threwError", "thrownAlias", "thuredString", "thookedAlias", "sthookedApplication", " threatedception", "thrownEx", " thrownception", "thanedEvent", "ThrownConfiguration", "thrownError", "ThrewParameter", " thrownExperience", "thookedException", "threwInformation", "thredConfiguration", "sthrownString", "phrewUnless", "ThrownError", "threwApplication", "sthanedException", "rethrownAlias", "thornedInformation", " threatedApplication", "rethrewAlias", "thrawnEx", "thrownEntity", "thaughtException", "thaughtEvent", "thookedApplication", "theredException", "rethrownException", "threatedception", "ThrownException", "threwConfiguration", "thornedAlias", "thrownInstance", "thainedInformation", "thownUnless", " threwEvent", "thrawnApplication", "threatedApplication", "theredAlias", "thanedException", "thookedEvent", "threatedEvent", "ThrewConfiguration", "thawedInstance", "thraisedAlias", "thrownAmount", "thornedEvent", "thppedInstance", "sthrewApplication", " thrownEvent", "theredEvent", "sthrawnEntity", "thookedOption", "thrownConfiguration", "thwnApplication", "thawedException", "thrownEvent", "threwParameter", "threwUnless", "phrewException", "sthookedInformation", "threwEvent", "thrownApplication", " threwException", "thraisedException", "thainedException", " threwApplication", "threwException", "sthrawnEx", "sthrownEntity", "thaughtApplication", "phrewOption", "thaughtEntity", "thawedApplication", "rethrewEvent", " threatedEntity", "thrawnException", "sthaughtApplication", "threwAmount", "thornedException", "thredException", "athrownPosition", "thratedAlias", "sthrownApplication", "phrownAmount", "athwnApplication", "sthanedApplication", "thppedApplication", "ThrewException", "rethrewException", " thrownEntity", "athwnPosition", "threwEx", " thrownApplication", "thrawnOption", "threatedExperience", "thrownString", "sthrownInformation", "sthrownOption", "thiedEvent", "rethrewApplication", "thrownOption", "rethrownEvent", "threatedException", "thppedException", "sthrawnEvent", "phrewAmount", "phrownException", "thwnPosition", "threatedString", "phrownUnless", "sthaughtException", "thredParameter", "sthrownException", "sthrownAlias", "thlledOption", "thornedApplication", "ThrownParameter", "athrownInstance", "thanedApplication", "thownException", "thlledError", "threwOption", "thredError", "thlledAmount", "thuredException", "thraisedApplication", "thwnInstance", "athrownApplication", "sthrownEvent", "thwnException", "threatedEntity", "thiedApplication", "threwString", "rethrownApplication", "frownInformation", "thlledParameter", "thratedException", "thrownParameter", "thlledConfiguration", "thrownUnless", "thrawnInformation", " threwExperience", "thornedEntity", "athwnException", "thraisedInformation", "thppedPosition", "sthrawnException", "theredApplication", "athwnInstance", "thiedExperience", "sthookedException", "sthaughtEntity", "thlledException", "thownOption", "sthrewInformation", "thanedOption"], "parent": ["Parent", "folder", "plain", "id", "test", "anc", "inc", "connection", "director", "complete", "parents", "home", "fp", "client", "any", "father", "root", "part", "guard", "base", "loc", "p", "to", "directory", "layer", "cover", "remote", "po", "master", "ctx", "server", "child", "fat", "name", "filename", "null", "pa", "ppa", "full", "target", "container", "api", "content", "temp", "key", "up", "path", "point", "pool", "pointer", "cache", "file", "prev", "current", "paren", "fork", "port", "line", "ip", "location", "unit"], "in": ["source", "get", "reader", "h", "url", "input", "inc", "din", "token", "win", "connection", "pull", "conn", "l", "src", "con", "b", "client", "part", "login", "f", "on", "by", "In", "pin", "again", "n", "r", "config", "inner", "exec", "init", "it", "ins", "cl", "gin", "up", "image", "lock", "c", "file", "socket", "i", "IN", "inside", "ssl", "inn", "bin", "s", "p"], "srcChannel": ["sourceConnection", "srcchannel", "rcContext", "sourceChan", "rcChan", " srcChan", "sourceContext", " srcConnection", "sourceFile", "rcchannel", "srcChan", "rcChannel", "srcContext", "rcConnection", "rcFile", " srcContext", " srcchannel", "sourcechannel", "sourceChannel", "srcConnection"], "out": ["source", "plain", "inc", "user", "token", "connection", "net", "io", "output", "outer", "conn", "lib", "b", "client", "part", "channel", "to", "n", "Out", "OUT", "outs", "again", "child", "call", "writer", "external", "inner", "config", "exec", "sync", "name", "o", "container", "copy", "v", "up", "all", "image", "cache", "socket", "file", "ssl", "i", "err", "or", "at", "bin", "s"], "dstChannel": ["dbtChan", "dstQueue", "ddestManager", "druChan", "fsrcManager", "dslChan", "dspChannel", "dstStream", "dostChannel", "ddestChannel", "drcChannel", "dslStream", "dostChan", "dspChan", "fsrcStream", "dostQueue", "drcUnit", "drcChan", "fstchannel", "dslChannel", "dsrcManager", "druChannel", "ddestConnection", " DstChannel", "fspStream", "druchannel", "fsrcChannel", "dbtUnit", "fstConnection", "dslManager", "fstChannel", "dsrcConnection", " DostUnit", "dstChan", " DostChannel", " DostQueue", "drcQueue", " DstQueue", " DostChan", "fstChan", "dsrcChannel", "fspChan", "dspchannel", "dbtQueue", "dbtChannel", "dstUnit", "dslConnection", "dostUnit", " DstUnit", "fstStream", "ddestStream", "dstManager", " DstChan", "druStream", "fstManager", "dstchannel", "dspStream", "dstConnection", "fspChannel", "dslchannel", "fsrcConnection", "dsrcStream", "fspchannel"]}}
{"id1": "22991420", "id2": "19434890", "code1": "    public void notifyIterationEnds(final IterationEndsEvent event) {\n        log.info(\"moving files...\");\n        File source = new File(\"deqsim.log\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"deqsim.log\"));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move deqsim.log to its iteration directory.\");\n            }\n        }\n        int parallelCnt = 0;\n        source = new File(\"deqsim.log.\" + parallelCnt);\n        while (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"deqsim.log.\" + parallelCnt));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move deqsim.log.\" + parallelCnt + \" to its iteration directory.\");\n            }\n            parallelCnt++;\n            source = new File(\"deqsim.log.\" + parallelCnt);\n        }\n        source = new File(\"loads_out.txt\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"loads_out.txt\"));\n            try {\n                IOUtils.copyFile(source, destination);\n            } catch (FileNotFoundException e) {\n                log.info(\"WARNING: Could not copy loads_out.txt to its iteration directory.\");\n            } catch (IOException e) {\n                log.info(\"WARNING: Could not copy loads_out.txt to its iteration directory.\");\n            }\n            destination = new File(\"loads_in.txt\");\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move loads_out.txt to loads_in.txt.\");\n            }\n        }\n        source = new File(\"linkprocs.txt\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"linkprocs.txt\"));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move linkprocs.txt to its iteration directory.\");\n            }\n        }\n    }\n", "code2": "    public RequestLogger() {\n        Server.getScheduler().register(\"Request Log Rotator\", new SchedulerInterface() {\n\n            public int getScheduleRate() {\n                return 0;\n            }\n\n            public void handle() {\n                if (requestCounter == 0) {\n                    requestCounter++;\n                    return;\n                }\n                requestCounter++;\n                Iterator it = loggerTimeouts.keySet().iterator();\n                while (it.hasNext()) {\n                    String host = (String) it.next();\n                    String timeout = (String) loggerTimeouts.get(host);\n                    int timeoutVal = Integer.parseInt(timeout);\n                    if (timeoutVal > 0) {\n                        timeoutVal /= 10;\n                    }\n                    int timeoutMod = (requestCounter % timeoutVal);\n                    if (timeoutMod == 0) {\n                        Object loggerFile = loggerFiles.get(host);\n                        Object loggerFilenameObject = loggerFilenames.get(host);\n                        Object loggerDestObject = loggerDests.get(host);\n                        Object loggerCompressObject = loggerCompresses.get(host);\n                        Object loggerDayObject = loggerDays.get(host);\n                        Object loggerArchiveObject = loggerArchives.get(host);\n                        Object loggerDeleteObject = loggerDeletes.get(host);\n                        boolean rotateCompress = false;\n                        boolean rotateDelete = false;\n                        String rotateDest = null;\n                        String logFile = null;\n                        String rotateArchive = null;\n                        int rotateDays = 0;\n                        if (loggerCompressObject != null && ((String) loggerCompressObject).equalsIgnoreCase(\"true\")) {\n                            rotateCompress = true;\n                        }\n                        if (loggerDeleteObject != null && ((String) loggerDeleteObject).equalsIgnoreCase(\"true\")) {\n                            rotateDelete = true;\n                        }\n                        if (loggerDestObject != null) {\n                            rotateDest = (String) loggerDestObject;\n                        }\n                        if (loggerFilenameObject != null) {\n                            logFile = (String) loggerFilenameObject;\n                        }\n                        if (loggerArchiveObject != null) {\n                            rotateArchive = (String) loggerArchiveObject;\n                        }\n                        if (loggerDayObject != null) {\n                            rotateDays = Integer.parseInt((String) loggerDayObject);\n                        }\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                                buf = null;\n                                out = null;\n                                in = null;\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"' to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                destChannel = null;\n                                srcChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data from file '\" + logFile + \"' to '\" + destOutFile + \"' for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete) {\n                            try {\n                                ((PrintStream) loggerFile).close();\n                            } catch (Exception e) {\n                            }\n                            (new File(logFile)).delete();\n                            loggerFiles.remove(host);\n                            addLogger(host, logFile);\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            fileList = null;\n                            format1 = null;\n                            archive = null;\n                        }\n                    }\n                }\n                it = null;\n            }\n\n            public String identString() {\n                return \"Request Log Rotator\";\n            }\n        });\n    }\n", "label": 1, "substitutes": {"event": ["events", "expected", "result", "ee", "message", "vent", "ev", "this", "f", "exc", "data", "ec", "re", "ctx", "el", "exec", "x", "e", "other", "ex", "Event", "change", "context", "g", "start", "nd", "test", "ext"], "source": ["input", "wrapper", "result", "src", "channel", "storage", "zip", "style", "resource", "archive", "info", "name", "scope", "ource", "missing", "slice", "image", "secure", "file", "position", "option", "project", "folder", "site", "id", "reference", "object", "table", "remote", "slave", "handler", "force", "component", "see", "instance", "sin", "key", "parse", "database", "scene", "start", "figure", "plus", "parent", "left", "size", "url", "core", "function", "grade", "base", "element", "section", "text", "comment", "string", "service", "subject", "sample", "use", "ie", "select", "reader", "connection", "from", "view", "driver", "Source", "root", "layer", "tree", "feature", "inner", "body", "target", "session", "SOURCE", "rule", "document", "seed", "uri", "ce", "form", "proxy", "unit"], "destination": ["variinator", " destinated", " destinator", "variribution", "descinated", "deinator", "defaultination", "targetification", "destinate", "Desturation", "Destinated", "defaulturation", "desturation", "deruction", " destruction", "destinated", "descuration", "homeinate", "deification", "Destinate", "sequination", "sequinated", "suffinated", "destification", "describution", "variination", "Destension", " destension", "extinate", "gesturation", "Destinator", "gestination", "destruction", "descension", "homeuration", "extinated", "continated", "descinator", "contination", "continator", " destribution", "exturation", " desturation", "suffribution", "targetination", "destension", "suffination", "extination", "deination", "defaultinated", "gestinator", "descinate", "sequinate", "targetruction", "targetinator", "continate", "destinator", "defaultribution", "extinator", "destribution", "homeinated", "variuration", " destification", "descination", "gestinated", "sequinator", "suffinator", "variinated", "homeination", "Destination", "Destribution"], "parallelCnt": ["paranoCnn", "parallelcn", "paranoScment", "parasiCnt", "parallelJCnt", "paranoCount", "parallelFct", "parallelScnc", "parallelRrt", "parascalNner", "parallelcnc", "parallelPnd", "parallelDount", "parallelChct", "parallelCount", "parallelCn", "parascalNNT", "parallelLNT", "parallelFn", "parallelNn", "parallelDnt", "parasiFnc", "parallelFth", "parallelRct", "paranoScNT", "parascalCnt", "parallelPNT", "parasiCth", "parascalCner", "parallelcment", "parallelcNT", "parallelCcount", "parallelPpt", "parallelRnt", "parallelcount", "parallelDment", "parasiCct", "parallelCnd", "parallelScnd", "parasiCn", "parallelFrt", "parallelLnn", "parallelFnc", "paranoScpt", "paranoAcnt", "paranoCnd", "parallelCct", "parallelSccount", "parasiRnt", "parallelScount", "paranoCpt", "parallelCth", "parallelScNT", "paranoScnt", "parallelChn", "parallelScn", "parallelScpt", "parascalCNT", "parallelScment", "parallelChrt", "parallelccount", "parallelRn", "parallelScth", "parallelcnt", "parallelCner", "parallelcnd", "paranoAcNT", "parallelChnt", "paranoAcnn", "parallelAcnn", "parascalNn", "paranoScount", "parallelPn", "parasiFn", "parallelAcn", "parallelFnt", "parascalNnt", "parallelLnd", "parallelJCnd", "parallelcth", "parallelAcnt", "parallelcnn", "parallelJCpt", "parallelNnt", "paranoCNT", "parallelAcner", "parasiRrt", "parasiCrt", "parasiFnt", "paranoCment", "paranoScnd", "paranoCcount", "paranoAcnd", "parallelCrt", "parasiFth", "parallelAcNT", "parasiRct", "paranoSccount", "parallelPnt", "paranoCnt", "parasiRn", "parallelCnn", "parallelLnt", "parallelCment", "parallelCNT", "parasiCnc", "parallelAcnd", "parallelCnc", "parallelDcount", "parallelNner", "parallelNNT", "parallelJCNT", "parallelPner", "parascalCn", "parallelCpt", "parallelScnt"]}}
{"id1": "19002156", "id2": "1274215", "code1": "    private String jarDiagnostics(Throwable throwable, File[] files) throws IOException {\n        File home = new File(System.getProperty(\"user.home\"));\n        File jar_file = File.createTempFile(\"nuages-diagnostic.\", \".jar\", home);\n        FileOutputStream fos = new FileOutputStream(jar_file);\n        JarOutputStream jos = new JarOutputStream(fos);\n        ZipEntry ze = new ZipEntry(\"Exception\");\n        jos.putNextEntry(ze);\n        PrintStream ps = new PrintStream(jos);\n        throwable.printStackTrace(ps);\n        for (File file : files) if ((file != null) && file.exists()) {\n            ze = new ZipEntry(file.getName());\n            jos.putNextEntry(ze);\n            byte[] buffer = new byte[65536];\n            FileInputStream fis = new FileInputStream(file);\n            int len;\n            while ((len = fis.read(buffer)) > 0) jos.write(buffer, 0, len);\n            fis.close();\n        }\n        jos.close();\n        return jar_file.getPath();\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            if (args.length < 2) {\n                System.err.println(\"usage: test [src] [dest]\");\n                return;\n            }\n            FileInputStream in = new FileInputStream(args[0]);\n            FileOutputStream out = new FileOutputStream(args[1]);\n            FileChannel src = in.getChannel();\n            FileChannel channel = out.getChannel();\n            long pos = 0, len = src.size(), ret;\n            while (len > 0) {\n                if ((ret = channel.transferFrom(src, pos, len)) < 0) break;\n                len -= ret;\n                pos += ret;\n            }\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"throwable": [" throwabe", "Throwble", "reportble", "throwback", "throwables", "Throwables", " throwative", "Throwable", " throwble", "throwble", "Throwative", "reportable", "rownable", "rownative", "throwabe", " throwables", " throwback", "reportabe", "rownables", "reportback", "rownabe", "Throwback", "throwative", "Throwabe"], "files": ["balls", "Files", "resources", "classes", "tests", "reports", "errors", "xml", "lines", "keys", "steps", "lib", "fs", "items", "books", "types", "sheets", "blocks", "objects", "flows", "assets", "sites", "models", "children", "groups", "boxes", "users", "plugins", "dir", "results", "images", "pages", "locks", "names", "ls", "iles", "apps", "projects", "uploads"], "home": ["host", "folder", " HOME", "parent", "tmp", "h", "default", "user", "build", "space", "wd", "out", "this", "root", "base", "directory", "mac", "house", "storage", "Home", "name", "dir", "huge", "log", "bar", "location", "area", "up", "book", "path", "HOME", "library", "cache", "hub", "self", "www", "proxy", "bin", "project", "store", "pkg"], "jar_file": [" jar_name", " jar_path", " jar_files", "jar_File", "jar_files", "jar_path", "jar_source", "zip_db", "jar_name", "jar_dir", "jar_fe", "zip_fe", "zip_files", "zip_file", "zip_File", "jar_db", "zip_source", "zip_dir"], "fos": ["Foes", "Foos", "infOS", "go", " fo", "gos", " foes", "infoes", "fo", "Fos", "joos", "jo", "gis", "infos", "jis", "infoos", "FOS", "fOS", "foos", "joes", "jOS", "goes", "foes"], "jos": [" joes", "xos", " jops", "ajoes", "foss", "fo", "jo", "xoss", "zoes", "joss", " jis", "zros", " jo", "Joses", " joses", "Jaos", "jros", "ajos", "xis", "jis", "ajo", "jops", "ajis", "zo", "zos", "zaos", "Jos", "ajros", "Jops", " jaos", "xo", "joes", " jros", "zoses", "Jis", " joss", "jaos", "zops", "zis", "joses", "foes", "Jo"], "ze": ["die", "ette", "sem", "pe", "zes", "za", "fee", "ee", "ez", "que", "jo", "zy", "ja", "lde", "ane", "fe", "ine", "zip", "zi", "zen", "he", "ffe", "zone", "zo", "ne", "ge", "ide", "liner", "ite", "de", "see", "cel", "ject", "ae", "ve", "oe", "je", "se", "pse", "ke", "sle", "zer", "ZE", "le", "ede", "fle", "zee", "ce", "aze", "kee", "sea", "z", "te", "ele", "ie"], "ps": ["ks", "py", "pe", "ap", "pes", "ss", "fs", "ns", "ros", "ms", "po", "p", "ups", "os", "bs", "par", "pc", "eps", "ppa", "pa", "per", "pps", "cs", "rs", "PS", "pr", "ls", "Ps", "pse", "se", "sp", "ips", "pp", "pos", "aps", "ras", "pers", "ds", "ts", "pl"], "file": ["source", "play", "folder", "page", "parent", "get", "ile", "url", "pe", "be", "iter", "File", "true", "l", "letter", "one", "lib", "out", "fp", "b", "object", "http", "part", "model", "f", "base", "fe", "no", "future", "class", "zip", "single", "resource", "style", "handler", "info", "name", "filename", "it", "full", "dir", "e", "flow", "unit", "per", "log", "le", "string", "path", "image", "il", "document", "load", "rule", " File", "cache", "or", "type", "FILE", "line", "use", "entry"], "buffer": ["page", "read", "size", "reader", "url", "queue", "input", "binary", "feed", "reference", "buff", "iter", "Buffer", "message", "limit", "b", "layer", "base", "data", "fe", "bytes", "resource", "address", "pad", "uffer", "shape", "transfer", "null", "batch", "bb", "length", "flush", "wave", "uf", "buf", "slice", "string", "document", "border", "seed", "cache", "block", "position", "bin", "rate", "stack", "value", "entry"], "fis": ["fris", " fbis", "affis", "bisl", "fbis", "Fos", "Fiss", "fiss", " fists", "affos", "fios", "fists", "fisl", "biss", " fios", "bris", " fisl", "infiss", "Fis", "affists", "infis", " fris", "infbis", "lis", "liss", "lisl", "affiss", "bbis", "infios", "bios", "lris", "bis", " fiss", "Fists"], "len": ["dl", "size", "id", "en", "num", "ln", "lf", "ind", "iter", "limit", "l", "pre", "ler", "end", "val", "f", "base", "Len", "data", "ref", "n", "elt", "el", "fun", "name", "body", "bb", "nt", "per", "length", "fn", "fl", "span", "li", "lc", "le", "count", "rev", "db", "err", "pos", "lin", "fin", "bin", "line", "sl", "bl"]}}
{"id1": "9830267", "id2": "15416858", "code1": "            public void run() {\n                final SimpleMessageListener listener = new SimpleMessageListener() {\n\n                    public final boolean accept(final String from, final String recipient) {\n                        return true;\n                    }\n\n                    public final void deliver(final String from, final String recipient, final InputStream data) throws TooMuchDataException, IOException {\n                        System.out.println(\"FROM: \" + from);\n                        System.out.println(\"TO: \" + recipient);\n                        final File tmpDir = new File(System.getProperty(\"java.io.tmpdir\"));\n                        final File file = new File(tmpDir, recipient);\n                        final FileWriter fw = new FileWriter(file);\n                        try {\n                            IOUtils.copy(data, fw);\n                        } finally {\n                            fw.close();\n                        }\n                    }\n                };\n                final SMTPServer smtpServer = new SMTPServer(new SimpleMessageListenerAdapter(listener));\n                smtpServer.start();\n                System.out.println(\"Started SMTP Server\");\n            }\n", "code2": "    private void download(File archive, File timestamp, URL url, IProgressMonitor monitor) throws IOException {\n        monitor.subTask(\"download \" + url.toString());\n        InputStream in = null;\n        FileOutputStream out = null;\n        URLConnection conn = null;\n        try {\n            conn = url.openConnection();\n            Writer writer = null;\n            try {\n                Date date = new Date(conn.getLastModified());\n                writer = new FileWriter(timestamp);\n                writer.write(this.FORMAT.format(date));\n            } catch (IOException e) {\n                timestamp.delete();\n            } finally {\n                IOUtils.closeQuietly(writer);\n            }\n            in = conn.getInputStream();\n            out = new FileOutputStream(archive);\n            IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 1, "substitutes": {"listener": ["listencer", "contener", "addter", "lockender", "contter", "addender", "conteners", "listner", "listender", "filencer", "addner", "lockener", "addener", "adderver", "addeners", "fileners", "listter", "contencer", "filener", "istener", "istner", "isterver", "listeners", "lockner", "addencer", "listerver", "istender", "filter", "lockerver"], "from": ["source", "route", "size", "url", "en", "about", "user", "connection", "range", "with", "origin", "message", "client", "end", "char", "without", "part", "base", "normal", "From", "by", "to", "channel", "resource", "email", "contact", "address", "send", "name", "component", "ender", "text", "mail", "pro", "uri", "error", "or", "ce", "addr", "subject", "start", "who", "form", "author", "entry"], "recipient": ["reciever", " recceiver", "regipt", "encipt", "encipient", "Reciever", "previent", "RECider", "recient", "recenter", "regider", " recaddress", " recip", "Recient", "recipt", "RECipt", "recward", "RECenter", "Recaddress", "recider", "RECipient", " recender", "encider", "recip", "regient", "prevender", "reliever", "Recceiver", "relward", "RECient", "RECender", "preventer", "recaddress", " recenter", "regipient", "encip", "Recward", "Recipient", "recender", " recward", "encceiver", "recceiver", "reladdress", "previpient", "Recip", " recient", "relipient", "encient", " reciever"], "data": ["source", "reader", "input", "queue", "feed", "buffer", "result", "message", "output", "audio", "dump", "this", "request", "client", "loader", "ata", "stream", "bytes", "response", "resource", "work", "handler", "raw", "address", "writer", "info", "send", "body", "DATA", "results", "json", "api", "content", "temp", "session", "media", "cache", "video", "start", "empty"], "tmpDir": ["tempPath", "tmpFolder", "mpPath", " tmpdir", " tmpPath", "tmpdir", "tmpDirectory", "mpFolder", "mpDirectory", "tempDirectory", "mpdir", "tempDir", " tmpFolder", "tempdir", "mpDir", " tmpDirectory", "tmpPath", "tempFolder"], "file": ["source", "folder", "parent", "reader", "connection", "buffer", "cf", "function", "File", "io", "w", "out", "fp", "sf", "fd", "part", "model", "f", "base", "fe", "stream", "work", "handler", "child", "writer", "wrap", "force", "filename", "dir", "framework", "flow", "up", "path", "cache", "lock", "db", "files", "self", "fi", "store", "unit"], "fw": ["die", "rf", "hw", "nw", "cf", "ht", "io", "fo", "fc", "wx", "w", "wd", " FW", "fp", "ew", "sf", "fd", "lv", "fr", "f", "tf", "fe", "work", "writer", "wrap", "wp", "force", "wt", "aw", "fly", "flow", "wl", "ow", "FH", "rw", "flo", "wb", "fb", "war", "FW", "raf", "ww", "fi", "ff", "iw", "wr", "cow", "fx"], "smtpServer": ["smphSer", "smpService", "smTPserver", "SMtpService", "smpSer", "smtapServer", "smtapService", "mmtpSer", "smtpSer", "mmpProxy", "smpserver", "smwtServer", "mmtpserver", "SMpService", "SMpserver", "smpProxy", "smtpService", "smTPClient", "smtapserver", "mmtpServer", "smtpClient", "mmpServer", "smwtserver", "SMpServer", "mmtpProxy", "smtapClient", "SMtpServer", "smpClient", "smwtProxy", "SMtpClient", "smtpserver", "smwtSer", "smpServer", "smphServer", "smphserver", "smTPService", "mmpSer", "smTPServer", "SMtpserver", "SMpClient", "smtpProxy", "mmpserver", "smphProxy"]}}
{"id1": "115129", "id2": "7169985", "code1": "    public static void bubbleSort(String[] a) {\n        Collator myCollator = Collator.getInstance();\n        boolean switched = true;\n        for (int pass = 0; pass < a.length - 1 && switched; pass++) {\n            switched = false;\n            for (int i = 0; i < a.length - pass - 1; i++) {\n                if (myCollator.compare(a[i], a[i + 1]) > 0) {\n                    switched = true;\n                    String temp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "code2": "    public static String connRemote(JSONObject jsonObject, String OPCode, List<NameValuePair> nameValuePair) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "label": 0, "substitutes": {"a": ["sa", "an", "input", "A", "la", "d", "events", "another", "ma", "audio", "l", "am", "y", "ga", "alpha", "in", "b", "wa", "aux", "as", "f", "data", "ata", "to", "n", "auto", "work", "ast", "address", "from", "x", "sup", "ama", "pa", "na", "u", "e", "o", "ack", "ae", "password", "transform", "m", "area", "missing", "v", "all", "string", "c", "aaa", "array", "aa", "at", "form", "empty", "z", "s", "p", "va"], "myCollator": ["myCollation", "yourCollate", "yourcoller", " myCollation", "mycoller", "mycollator", "myColation", "myColler", "mycollate", "mycollation", "myColator", "yourCollation", "yourcollate", "myColoder", " myColloder", " myColler", "myColloder", "yourCollator", "myColer", "yourcollation", "myCollate", "yourcollator", "mycolloder", "yourColler"], "pass": ["next", "id", "phase", "last", "feed", "ss", "ride", "weight", "effect", "sw", "object", "PASS", "diff", "row", "skip", "r", "sc", "ass", "push", "strip", "stage", "use", "element", "sync", "pa", "cross", "old", "flow", "step", "Pass", "act", "allow", "password", "post", "scan", "asses", "se", "run", "all", "index", "path", "j", "c", "parse", "prev", "fail", "pos", "aa", "array", "process", "level", " bypass", "test", "acc", "exit", "line", "p"], "switched": ["witching", "switching", "swifted", "swored", " swipped", "wipped", "Switches", "wored", "swipped", "wifted", "twitching", "Switching", "blifted", "switches", "witched", "Switched", "rewitched", "twifted", "Swipped", "blitched", "witches", "rewitches", "rewipped", "blitching", "twitched", " switches", "blored", " swifted", "twored", " switching", "rewifted"], "i": ["ei", "id", "ki", "si", "qi", "multi", "iu", "phi", "io", "k", "l", "b", "f", "di", "bi", "zi", "I", "ni", "oi", "ai", "gi", "ti", "ji", "adi", "x", "ix", "ui", "u", "ci", "e", "o", "eni", "api", "ski", "ini", "cli", "li", "xi", "v", "index", "slice", "ri", "j", "ori", "uri", "c", "ii", "pi", "is", "start", "z", "s", "ip", "p"], "temp": ["source", "tmp", "none", "input", "txt", "safe", "porary", "result", "iter", "extra", "output", "flat", "pure", "out", "fake", "this", "diff", "stable", "pack", "base", "f", "data", "clean", "shared", "Temp", "adj", "old", "tc", "t", "copy", "v", "key", "lc", "j", "c", "emp", "modified", "current", "local", "self", "empty", "test", "str", "null", "p"]}}
{"id1": "3023702", "id2": "2021569", "code1": "    static HashSet<ScriptEngineFactory> lookup(ClassLoader loader, String name) {\n        HashSet<ScriptEngineFactory> factories = new HashSet<ScriptEngineFactory>();\n        try {\n            Enumeration<URL> urls = loader.getResources(name);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if ((line = trim(line)) != null) {\n                        try {\n                            Class<ScriptEngineFactory> clazz = (Class<ScriptEngineFactory>) Class.forName(line, true, loader);\n                            ScriptEngineFactory factory = clazz.newInstance();\n                            factories.add(factory);\n                        } catch (java.lang.UnsupportedClassVersionError error) {\n                            if (DEBUG) {\n                                System.err.println(line + \": version mismatch - ignore\");\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (IOException ex) {\n            throw new ScriptException(ex);\n        } finally {\n            return factories;\n        }\n    }\n", "code2": "    public boolean getFile(String local, String remote) throws IOException {\n        boolean result = false;\n        GridFTP ftp = new GridFTP();\n        ftp.setDefaultPort(port);\n        System.out.println(this + \".getFile \" + remote);\n        try {\n            ftp.connect(host);\n            ftp.login(username, password);\n            int reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                System.err.println(\"FTP server refused connection.\");\n                return false;\n            }\n            ftp.get(local, remote);\n            ftp.logout();\n            result = true;\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        System.out.println(this + \".getFile return \" + result);\n        return result;\n    }\n", "label": 0, "substitutes": {"loader": ["resources", "processor", "buffer", "io", "driver", "loop", "layer", "data", "worker", "class", "system", "zip", "resource", "handler", "server", "config", "module", "er", "framework", "scope", "log", "cl", "runner", "parser", "instance", "Loader", "path", "library", "load", "cache", "file", "context", "lock", "builder", "loading", "location"], "name": ["source", "NAME", "entry", "parent", "size", "id", "Name", "connection", "plugin", "definition", "part", "base", "data", "version", "named", "class", "resource", "prefix", "match", "address", "alias", "filename", "filter", "comment", "names", "content", "key", "time", "string", "path", "load", "file", "search", "block", "type"], "factories": ["formions", "actilies", "Facturers", "acturers", "combors", "fories", "formories", "factors", "combores", "factlections", "formors", "formilies", "fors", "anchories", "factores", "actories", "Factors", "flections", "factilies", "Factores", "anchions", "comblections", "actors", "configores", "anchilies", "Factories", "fores", "formurers", "Factions", "configlections", "formores", "configories", "facturers", "factions", "combories", "anchores", "configors", "Factilies"], "urls": ["urles", "pathls", "URLsl", "websl", "URLes", "pathes", "Urls", "urlls", "urlcs", "https", "pathsl", "urlsl", "pathions", "URLs", "webs", "Urlls", "httpions", "URLions", "urlions", "paths", " urlls", "httpes", "httpls", "URLcs", " urlcs", "URLls", "Urlcs", "webls"], "url": ["source", "input", "user", "feed", "connection", "buffer", "pull", "rel", "l", "http", "client", "b", "f", "base", "data", "channel", "stream", "r", "resource", "server", "address", "element", "er", "instance", "job", "string", "path", "image", "file", "uri", "i", "ssl", "URL", "service", "Url", "gl", "sl", "entry"], "reader": ["ner", "read", "input", "rar", "rx", "Reader", "feed", "buffer", "iter", "io", "l", "ler", "in", "driver", "client", "row", "f", "worker", "oder", "stream", "r", "resource", "handler", "editor", "server", "writer", "inner", "er", "rer", "reading", "per", "parser", "instance", "ri", "file", "i", "builder", "rr", "entry"], "line": ["source", "page", "sel", "split", "link", "write", "pe", "connection", "lf", "lines", "message", "l", "letter", "definition", "object", "end", "lined", "LINE", "cell", "lr", "Line", "row", "base", "f", "part", "data", "model", "inline", "class", "style", "el", "lo", "sync", "e", "log", "cl", "text", "comment", "content", "job", "lc", "key", "le", "li", "string", "rule", "pass", "file", "error", "code", "parse", "fail", "label", "header", "block", "lin", "look", "lane", "str", "sl", "entry"], "clazz": ["clclass", "plunk", "clactory", "Clactory", "slasse", "classe", "plazz", "Clazz", "clunk", " classe", "klclass", "slazz", " clactory", "klactory", "slunk", " cluster", " clclass", " clunk", "Clclass", "Cluster", "kluster", "pluster", "klazz", "sluster", "cluster", "plasse"], "factory": ["defactory", "hixture", "mula", "factoker", "fixture", "fault", "defoker", "mault", "ifula", "defixture", "ifault", "infula", "hactory", "focol", "hocol", "fula", "mactory", "defocol", "infactory", "infault", "ifixture", "factactory", "factixture", "ifactory", "infixture", "foker", "factocol", "mixture", "hoker"]}}
{"id1": "9830267", "id2": "11750117", "code1": "            public void run() {\n                final SimpleMessageListener listener = new SimpleMessageListener() {\n\n                    public final boolean accept(final String from, final String recipient) {\n                        return true;\n                    }\n\n                    public final void deliver(final String from, final String recipient, final InputStream data) throws TooMuchDataException, IOException {\n                        System.out.println(\"FROM: \" + from);\n                        System.out.println(\"TO: \" + recipient);\n                        final File tmpDir = new File(System.getProperty(\"java.io.tmpdir\"));\n                        final File file = new File(tmpDir, recipient);\n                        final FileWriter fw = new FileWriter(file);\n                        try {\n                            IOUtils.copy(data, fw);\n                        } finally {\n                            fw.close();\n                        }\n                    }\n                };\n                final SMTPServer smtpServer = new SMTPServer(new SimpleMessageListenerAdapter(listener));\n                smtpServer.start();\n                System.out.println(\"Started SMTP Server\");\n            }\n", "code2": "    public static LinkedList<String> read(URL url) throws IOException {\n        LinkedList<String> data = new LinkedList<String>();\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String input = \"\";\n        while (true) {\n            input = br.readLine();\n            if (input == null) break;\n            data.add(input);\n        }\n        br.close();\n        return data;\n    }\n", "label": 0, "substitutes": {"listener": ["listencer", "contener", "addter", "lockender", "contter", "addender", "conteners", "listner", "listender", "filencer", "addner", "lockener", "addener", "adderver", "addeners", "fileners", "listter", "contencer", "filener", "istener", "istner", "isterver", "listeners", "lockner", "addencer", "listerver", "istender", "filter", "lockerver"], "from": ["source", "route", "size", "url", "en", "about", "user", "connection", "range", "with", "origin", "message", "client", "end", "char", "without", "part", "base", "normal", "From", "by", "to", "channel", "resource", "email", "contact", "address", "send", "name", "component", "ender", "text", "mail", "pro", "uri", "error", "or", "ce", "addr", "subject", "start", "who", "form", "author", "entry"], "recipient": ["reciever", " recceiver", "regipt", "encipt", "encipient", "Reciever", "previent", "RECider", "recient", "recenter", "regider", " recaddress", " recip", "Recient", "recipt", "RECipt", "recward", "RECenter", "Recaddress", "recider", "RECipient", " recender", "encider", "recip", "regient", "prevender", "reliever", "Recceiver", "relward", "RECient", "RECender", "preventer", "recaddress", " recenter", "regipient", "encip", "Recward", "Recipient", "recender", " recward", "encceiver", "recceiver", "reladdress", "previpient", "Recip", " recient", "relipient", "encient", " reciever"], "data": ["source", "reader", "input", "queue", "feed", "buffer", "result", "message", "output", "audio", "dump", "this", "request", "client", "loader", "ata", "stream", "bytes", "response", "resource", "work", "handler", "raw", "address", "writer", "info", "send", "body", "DATA", "results", "json", "api", "content", "temp", "session", "media", "cache", "video", "start", "empty"], "tmpDir": ["tempPath", "tmpFolder", "mpPath", " tmpdir", " tmpPath", "tmpdir", "tmpDirectory", "mpFolder", "mpDirectory", "tempDirectory", "mpdir", "tempDir", " tmpFolder", "tempdir", "mpDir", " tmpDirectory", "tmpPath", "tempFolder"], "file": ["source", "folder", "parent", "reader", "connection", "buffer", "cf", "function", "File", "io", "w", "out", "fp", "sf", "fd", "part", "model", "f", "base", "fe", "stream", "work", "handler", "child", "writer", "wrap", "force", "filename", "dir", "framework", "flow", "up", "path", "cache", "lock", "db", "files", "self", "fi", "store", "unit"], "fw": ["die", "rf", "hw", "nw", "cf", "ht", "io", "fo", "fc", "wx", "w", "wd", " FW", "fp", "ew", "sf", "fd", "lv", "fr", "f", "tf", "fe", "work", "writer", "wrap", "wp", "force", "wt", "aw", "fly", "flow", "wl", "ow", "FH", "rw", "flo", "wb", "fb", "war", "FW", "raf", "ww", "fi", "ff", "iw", "wr", "cow", "fx"], "smtpServer": ["smphSer", "smpService", "smTPserver", "SMtpService", "smpSer", "smtapServer", "smtapService", "mmtpSer", "smtpSer", "mmpProxy", "smpserver", "smwtServer", "mmtpserver", "SMpService", "SMpserver", "smpProxy", "smtpService", "smTPClient", "smtapserver", "mmtpServer", "smtpClient", "mmpServer", "smwtserver", "SMpServer", "mmtpProxy", "smtapClient", "SMtpServer", "smpClient", "smwtProxy", "SMtpClient", "smtpserver", "smwtSer", "smpServer", "smphServer", "smphserver", "smTPService", "mmpSer", "smTPServer", "SMtpserver", "SMpClient", "smtpProxy", "mmpserver", "smphProxy"]}}
{"id1": "11677415", "id2": "14710191", "code1": "    @Test\n    public void behaveTest() {\n        InputStream is = this.getClass().getResourceAsStream(\"safetyCaseTest.mdf\");\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to read mdf\", e);\n        }\n        TrafficSimulationEngine engine = new TrafficSimulationEngine();\n        TrafficModelDefinition def = MDFReader.read(out.toByteArray());\n        engine.init(def);\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(0);\n        linkSegments.put(0, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        engine.setFrameProperties(frameProperties);\n        RegularVehicle vehicle = (RegularVehicle) engine.getDynamicObjects().iterator().next();\n        CompositeDriver driver = (CompositeDriver) vehicle.getDriver();\n        driver.drive(0.1f);\n        SafetyCase safety = new SafetyCase(driver);\n        RectangleCCRange ccRange = (RectangleCCRange) safety.behave(0.1f);\n        HandRange turnRange = ccRange.getTurnRange();\n        HandRange probeRange = new HandRange();\n        probeRange.remove(Hand.Left);\n        assertTrue(turnRange.equals(probeRange));\n        assertTrue(ccRange.getPriority() == Priority.SafetyCase);\n    }\n", "code2": "    public void testImageDataField() {\n        PropertySet propertySet = fetchPropertySet();\n        try {\n            ImageDataField dataField = propertySet.getDataField(PropertySetTestStruct.TESTBLOCK_IMAGE, ImageDataField.class);\n            URL url = getClass().getResource(\"JFire_Test.gif\");\n            if (url == null) return;\n            InputStream in = url.openStream();\n            try {\n                dataField.loadStream(in, \"JFire_Test.gif\", \"image/gif\");\n            } finally {\n                in.close();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Setting image of ImageDataField failed\", e);\n        }\n        try {\n            propertySet.deflate();\n            getPropertyManager().storePropertySet(propertySet, true, FETCH_GROUPS, FETCH_DEPTH);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Storing PropertySet with ImageDataField failed\", e);\n        }\n    }\n", "label": 0, "substitutes": {"is": ["si", "isa", "src", "fs", "ais", "in", "as", "iss", "stream", "os", "bs", "ris", "serv", "ai", "info", "es", "ir", "init", "ins", "ui", "needs", "iris", "IS", "api", "ios", "ours", "its", "i", "or", "us", "bis", "Is", "iso", "ps", "s", "ip", "does"], "out": ["source", "page", "size", "plain", "input", "buffer", "result", "io", "output", " in", "conn", "in", "object", "dump", "this", "client", "base", "data", "In", "OUT", "Out", "again", "outs", "sum", "clean", "auto", "prefix", "writer", "o", "aos", "a", "ex", "copy", "up", "image", "pool", "obj", "cache", "file", "error", "i", "err", "lock", "array", "at", "bin", "store", "s", "line"], "engine": ["d", "connection", "core", "dev", "io", "output", "Engine", "example", "definition", "object", "model", "mode", "f", "loader", "environment", "stream", "di", "system", "her", "server", "he", "config", "writer", "editor", "element", "force", "exec", "module", "project", "e", "de", "exp", "flow", "instance", "express", "se", "ENG", "agent", "graph", "image", "cache", "drive", "builder", "service", "manager", "eng", "development", "river", "design", "proxy", "env", "sl", "unit"], "def": ["DEF", "reader", "default", "d", "feed", "guide", "result", "dev", "gd", "definition", "define", "model", "f", "base", "data", "ref", "di", "class", "config", "info", "conf", "sup", "init", "de", "flow", "spec", "ef", "Def", "df", " definition", "pro", "file", "i", "raf", "dist", "Definition", "defined", "dom", "design", "entry"], "linkSegments": ["linkSecles", " linkSegment", " linkIncrement", "linkFragles", "linkGeles", "linkMeasureings", "linkFragment", " linkIncrelements", " linkIncreles", "lineSeggments", "linkSecments", "linkIncreles", "inkSegings", "linkIncrements", "linkSeclements", "linkFragments", "linkgmentgments", "linkSegings", "inkMeasurements", "linkgmentments", "linkSeggments", "linkMeasureles", "linkGeings", "linkMeasurement", "linkFraglements", "linkFraggments", "linkSegment", "lineFragment", "lineFragles", "inkSegments", "linkGements", "linkFragings", " linkSeglements", " linkIncrements", "lineFraggments", "linkIncrelements", "lineSegments", "inkMeasureles", "linkSeglements", " linkSegles", "linkSecment", "linkIncrement", "inkSegment", "linkMeasurements", "lineSegment", "inkMeasureings", "linkSegles", "lineSegles", "linkgmentment", "lineFragments", "linkIncregments", "linkGement", "inkSegles", "inkMeasurement", "linkgmentles"], "segments": ["segs", "Segles", "mentments", "idements", "gements", "Seggments", "Seggment", "sements", "gegment", "idegments", " sements", "pements", "gegments", "mentles", "segements", "psegements", "schegs", "schegments", "schegements", "psegs", "pegements", " segs", "geles", "mentgment", "schements", " segements", "idegements", "pegs", "idegs", "psements", "mentgments", "seles", "psegments", "segment", "Segments", "pegments"], "frameProperties": ["Frameproams", "framePoperties", "Frameproproperties", "frameproperty", "frameproproperties", "framePoproperties", "frameprops", " frameproperty", "frameProperty", " frameProproperties", "FrameProperties", "Frameprops", "framePropperties", "frameProams", "framePoperty", "frameproperties", " frameProps", " frameproperties", "FrameProams", " frameprops", "framePropps", "framePops", "FrameProproperties", "Frameproperties", " frameProperty", "framePropproperties", "frameproams", "framePropams", "FrameProps", " frameproproperties", "frameProproperties", "frameProps"], "vehicle": ["vehly", "configicle", "Vehment", " vehocol", "Vehicle", "vehie", "vehicles", "caricles", " cubicle", "Vehly", " cubie", "carie", " cubicles", " cubment", "carment", "vehocol", " vehly", "Vehicles", "caricle", "Vehocol", "configicles", "Vehie", "configocol", " vehicles", "vehment", "configly"], "driver": ["draw", "host", "wrapper", "d", "browser", "stick", "connection", "director", "wheel", "car", "ride", "keeper", "Driver", "object", "root", "roller", "di", "handler", "server", "shield", "config", "der", "drivers", "force", "component", "crew", "runner", "dr", "dri", "docker", "graph", "image", "veh", "cache", "drive", "ssl", "driving", "bus", "builder", "service", "tube", "manager", "dist", "river", "design", "proxy", "ctor", "device"], "safety": ["fare", "wrapper", "race", "feed", "afety", "facing", "guide", "gravity", "safe", "space", "extra", "real", "review", "http", "security", "flash", "bearing", "ray", "afe", "guard", "are", "storage", "shadow", "role", "sharing", "testing", "Safe", "Safety", "facebook", "protection", "danger", "family", "pro", "ops", "ssl", " stability", "support", "square", " Safety", "saf", "proxy", "series"], "ccRange": ["CCBlock", "mcRegion", "mcrange", "ckRegion", "rcRegion", "accRange", "accRegion", "accBlock", "ckRange", "CCrange", " ccrange", "rcRange", "handRange", "mcRange", "ccRegion", "CCRegion", "CCRange", "handRegion", " ccBlock", "rcrange", " ccRegion", "handrange", "ckrange", "ccBlock", "ccrange", "accrange"], "turnRange": ["rollRange", " turnrange", "turnrange", "rollRing", " turnPage", "turnPage", "TurnRing", "TurnRange", "craftLine", "travelRing", "turnRing", "craftRange", "travelArea", "TurnArea", "handPage", "rollArea", "handRange", "turnGroup", "turnLine", "handLine", "TurnGroup", "craftPage", "travelRange", "handrange", "turnArea", "craftrange", " turnLine", "rollGroup", "travelGroup"], "probeRange": ["probRule", "probeRule", " probleGate", "proveChain", "ProbeRule", "ProbeRange", "probChain", "preberange", "problerange", "prostrateRegion", "probleGate", "proveMode", "prohideRule", "preblerange", "prohideRange", " probeRegion", "probeRing", " probleRegion", "ProveRule", "ProbeChain", "probeMode", "probleLine", "prebleLine", "probeRegion", "probleRange", "probleRing", " probeRing", "prebeLine", "ProveRange", "probleRegion", "proveRule", "proverange", "prohideMode", "prebeRange", "probeGate", "probeLine", "probeChain", "probRange", "prostrateGate", "proberange", "ProveChain", "ProbeMode", "prebleRange", " probeGate", "proveRange", "ProveMode", " probleRange", "prooseRange", "prostrateRing", "probMode", "prohideChain", "prostrateRange", "proveLine", "prooseRing", "prooseRegion", " probleRing", "prooseGate"]}}
{"id1": "5162897", "id2": "22958786", "code1": "    public void testDefaultHeadersRedirect() throws Exception {\n        String host = \"localhost\";\n        int port = this.localServer.getServicePort();\n        this.localServer.register(\"*\", new BasicRedirectService(host, port));\n        DefaultHttpClient client = new DefaultHttpClient();\n        HttpContext context = new BasicHttpContext();\n        List<Header> defaultHeaders = new ArrayList<Header>(1);\n        defaultHeaders.add(new BasicHeader(HTTP.USER_AGENT, \"my-test-client\"));\n        client.getParams().setParameter(ClientPNames.DEFAULT_HEADERS, defaultHeaders);\n        HttpGet httpget = new HttpGet(\"/oldlocation/\");\n        HttpResponse response = client.execute(getServerHttp(), httpget, context);\n        HttpEntity e = response.getEntity();\n        if (e != null) {\n            e.consumeContent();\n        }\n        HttpRequest reqWrapper = (HttpRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);\n        assertEquals(HttpStatus.SC_OK, response.getStatusLine().getStatusCode());\n        assertEquals(\"/newlocation/\", reqWrapper.getRequestLine().getUri());\n        Header header = reqWrapper.getFirstHeader(HTTP.USER_AGENT);\n        assertEquals(\"my-test-client\", header.getValue());\n    }\n", "code2": "    public JGroundStationBrowser(Frame parent) {\n        this.parent = parent;\n        initComponents();\n        topTreeNode = new DefaultMutableTreeNode(\"Ground Stations\");\n        treeModel = new DefaultTreeModel(topTreeNode);\n        groundStationTree.setModel(treeModel);\n        String currentSecondaryNodeName = null;\n        DefaultMutableTreeNode currentSecondaryNode = null;\n        try {\n            BufferedReader gsReader = null;\n            if (new File(groundStationDB).exists()) {\n                File gsFile = new File(groundStationDB);\n                FileReader gsFileReader = new FileReader(gsFile);\n                gsReader = new BufferedReader(gsFileReader);\n            } else {\n                URL url = new URL(\"http://www.gano.name/shawn/JSatTrak/\" + groundStationDB);\n                URLConnection c = url.openConnection();\n                InputStreamReader isr = new InputStreamReader(c.getInputStream());\n                gsReader = new BufferedReader(isr);\n            }\n            String nextLine = null;\n            int gsCount = 0;\n            while ((nextLine = gsReader.readLine()) != null) {\n                String[] elements = nextLine.split(\",\");\n                if (elements.length == 5) {\n                    String network = elements[0];\n                    String stationName = elements[1];\n                    double stationLat = Double.parseDouble(elements[2]);\n                    double stationLon = Double.parseDouble(elements[3]);\n                    double stationAlt = Double.parseDouble(elements[4]);\n                    gsHash.put(stationName, new double[] { stationLat, stationLon, stationAlt });\n                    if (!network.equalsIgnoreCase(currentSecondaryNodeName)) {\n                        currentSecondaryNode = new DefaultMutableTreeNode(network);\n                        topTreeNode.add(currentSecondaryNode);\n                        currentSecondaryNodeName = network;\n                    }\n                    currentSecondaryNode.add(new DefaultMutableTreeNode(stationName));\n                    gsCount++;\n                }\n            }\n            gsReader.close();\n            if (new File(groundStationCustomDB).exists()) {\n                File gsFile = new File(groundStationCustomDB);\n                FileReader gsFileReader = new FileReader(gsFile);\n                gsReader = new BufferedReader(gsFileReader);\n                customSecondaryNode = new DefaultMutableTreeNode(\"Custom\");\n                topTreeNode.add(customSecondaryNode);\n                while ((nextLine = gsReader.readLine()) != null) {\n                    String[] elements = nextLine.split(\",\");\n                    if (elements.length == 5) {\n                        String network = elements[0];\n                        String stationName = elements[1];\n                        double stationLat = Double.parseDouble(elements[2]);\n                        double stationLon = Double.parseDouble(elements[3]);\n                        double stationAlt = Double.parseDouble(elements[4]);\n                        gsHash.put(stationName, new double[] { stationLat, stationLon, stationAlt });\n                        customSecondaryNode.add(new DefaultMutableTreeNode(stationName));\n                        gsCount++;\n                    }\n                }\n                gsReader.close();\n            } else {\n                customSecondaryNode = new DefaultMutableTreeNode(\"Custom\");\n                topTreeNode.add(customSecondaryNode);\n            }\n            statusTextField.setText(\"Total Ground Stations loaded: \" + gsCount);\n            groundStationTree.expandRow(0);\n        } catch (Exception e) {\n            System.out.println(\"ERROR IN GROUND STATION READING POSSIBLE FILE FORMAT OR MISSING FILES:\");\n            e.printStackTrace();\n            JOptionPane.showMessageDialog(parent, \"Error Loading Ground Station Data. Check data.\\n\" + e.toString(), \"Data LOADING ERROR\", JOptionPane.ERROR_MESSAGE);\n        }\n        groundStationTree.setTransferHandler(new TreeGroundStationTransferHandler(gsHash));\n        groundStationTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n    }\n", "label": 0, "substitutes": {"host": ["site", "h", "url", "id", "Host", "connection", "format", "http", "home", "base", "hello", "prefix", "server", "address", "name", "method", "target", "localhost", "key", "string", "path", "node", "uri", "code", "service", "addr", "domain", "proxy", "value", "null", "ip", "location", "type"], "port": ["url", "PORT", "phone", "limit", "end", "age", "version", "server", "address", "Port", "pc", "ports", "name", "target", "per", "password", "ort", "length", "pr", "timeout", "path", "point", "pool", "file", "service", "priority", "pos", "pi", "position", "proxy", "value", "line", "ip", "p", "type"], "client": ["parent", "default", "url", "wrapper", "queue", "connection", "plugin", "conn", "http", "con", "request", "app", "this", "base", "application", "https", "resource", "handler", "server", "contact", "config", "pc", "project", "container", "cl", "api", "Client", "cli", "session", "connect", "secure", "c", "ssl", "socket", "service", "ce", "proxy"], "context": ["options", "translation", "source", "reader", "wrapper", "connection", "xml", "result", "settings", "view", "request", "driver", "state", "environment", "channel", "exc", "ctx", "resource", "server", "contact", "config", "handler", "section", "component", "event", "acl", "scope", "container", "cl", "kernel", "parser", "text", "instance", "session", "path", "document", "cache", "c", "support", "Context", "service", "current", "ce", "subject", "self", "proxy"], "defaultHeaders": ["defaultHeaderings", "passHEADer", " defaultHosters", "defaultHostlers", "passHeader", " defaultHostings", " defaultHEADers", "defaultHoster", " defaultHEADERS", "defaultHostings", " defaultHEADlers", "passHeaders", " defaultHeader", "defaultHeadERS", "defaultHeadlers", "defaultHEADlers", "defaultHEADer", " defaultHeadlers", "defaultHosters", "passHeadlers", "passHEADlers", "defaultHEADERS", " defaultHeadERS", "defaultHeadings", " defaultHoster", "defaultHeaderers", "passHEADers", " defaultHeadings", "defaultHeaderERS", " defaultHostlers", "defaultHeaderlers", "defaultHEADers", "defaultHeader", "defaultHeaderer", "defaultHostERS", "defaultHEADings", " defaultHEADer", "passHEADings", "passHeadings"], "httpget": ["httpsend", "HttpGet", " httpfind", "ttpset", "ttpfind", "Httpfind", " httpGET", "httpGet", "httpset", "ttpGET", "phpget", "httpGET", "ttpget", "phpge", "ttpsend", "ttpGet", "phpGET", "httpge", " httpset", " httpge", "ttpge", " httpGet", "phpset", " httpsend", "Httpget", "Httpsend", "httpfind"], "response": ["page", "parent", "respond", "site", "en", "connection", "success", "feed", "reply", "ception", "result", "message", "output", "view", "http", "request", "object", "environment", "model", "f", "application", "onse", "data", "channel", "resource", "handler", "server", "method", "body", "full", "json", "api", "status", "v", "Response", "session", "document", "entity", "image", "error", "err", "resp", "service", "received", "res"], "e": ["ea", "en", "pe", "result", "ee", "l", "ev", "environment", "f", "E", "fe", "ec", "data", "r", "esi", "es", "el", "element", "er", "body", "ne", "ge", "u", "Entity", "o", "de", "ae", "oe", "enter", "m", "content", "je", "se", "eb", "entity", "c", "i", "ele", "ce", "eu", "et", "em", "s", "line", "p", "ie"], "reqWrapper": ["httpWrapped", " reqUpping", " requestWrape", "httpWraper", " requestWraple", "reqHopped", "reqHopper", " requestWrapper", "reqCoipper", "reqWebpe", " reqUper", "reqCopper", "reqWarpped", "reqUper", " reqUpped", "httpWrapper", "httpWarper", " reqWrapping", "reqUpping", "reqCopped", "reqCoper", "httpWarpped", "reqWebple", "reqwrapper", "reqPopped", "reqWraple", "reqWebpper", "reqWarper", "reqUpped", "httpWraipper", " requestWraper", "reqWebper", "reqWrapped", "reqwraper", "reqWraper", "reqHoper", "reqPopper", "reqWraipper", "reqHoipper", " reqWrapped", "reqWarpping", "reqWaripper", "reqWarpper", "reqwrape", "reqWrape", "reqPopping", "httpWarpper", "httpWaripper", " reqUpper", "reqwraple", "reqUpper", " reqWraper", "reqPoper", "reqWrapping"], "header": ["head", "entry", "h", "ker", "user", "token", "director", "band", "result", "player", "message", "man", "request", "column", "f", "layer", "data", "version", "cover", " Header", "her", "server", "handler", "config", "info", "feature", "writer", "er", "name", "body", "event", "Header", "per", "filter", "dr", "content", "v", "kin", "key", "back", "string", "headers", "prev", "attribute", "person", "line", "type"]}}
{"id1": "10735044", "id2": "16389677", "code1": "    public static byte[] getBytes(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        int contentLength = connection.getContentLength();\n        ByteArrayOutputStream tmpOut;\n        if (contentLength != -1) {\n            tmpOut = new ByteArrayOutputStream(contentLength);\n        } else {\n            tmpOut = new ByteArrayOutputStream(16384);\n        }\n        byte[] buf = new byte[512];\n        while (true) {\n            int len = in.read(buf);\n            if (len == -1) {\n                break;\n            }\n            tmpOut.write(buf, 0, len);\n        }\n        in.close();\n        tmpOut.close();\n        byte[] array = tmpOut.toByteArray();\n        return array;\n    }\n", "code2": "    public void extract(CabFolder cabfolder, File outputFolder) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        File file;\n        byte[] buffer = new byte[2048];\n        int read, remain, maxread = buffer.length;\n        in = new CabFileInputStream(cabfolder);\n        CabEntry[] cabentries = this.getEntries();\n        for (int i = 0; i < cabentries.length; i++) {\n            if (cabentries[i].getCabFolder() == cabfolder) {\n                file = new File(outputFolder, cabentries[i].getName().replace('\\\\', '/'));\n                FileUtils.createParents(file);\n                out = new FileOutputStream(file);\n                remain = cabentries[i].getInflatedSize();\n                while (remain != 0 && (read = in.read(buffer, 0, maxread)) != -1) {\n                    out.write(buffer, 0, read);\n                    remain -= read;\n                    if (buffer.length > remain) maxread = remain; else maxread = buffer.length;\n                }\n                in.close();\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "id", "user", "open", "download", "plugin", "conn", "l", "http", "client", "object", "request", "bug", "loc", "base", "loader", "remote", "resource", "server", "config", "address", "name", "cli", "string", "rule", "image", "path", "cache", "c", "file", "uri", "ssl", "or", "URL", "Url", "position", "proxy", "str", "sl"], "connection": ["source", "cone", "general", "open", "between", "io", "output", "conn", "l", "communication", "http", "con", "out", "b", "client", "connected", "loc", "application", "channel", "directory", "resource", "ctx", "server", "org", "config", "condition", "inner", "tc", "password", "relation", "lc", "cli", "session", "image", "connect", "lock", "socket", "c", "uri", "context", "URL", "database", "conv", "Connection", "proxy", "use"], "in": ["reader", "id", "input", "inc", "din", "conn", "http", "con", "out", "b", "client", "login", "as", "data", "In", "into", "stream", "pin", "inner", "init", "ins", "ini", "m", "kin", "cin", "socket", "c", "uri", "i", "IN", "file", "err", "inn", "is", "ilo", "start", "lin", "bin", "ie"], "contentLength": ["ContentType", "codelength", " contentId", "ContentLen", "contentLen", " contentType", "responsePath", " contentLevel", "codeBuffer", "responseType", "ContentSize", "Contentlength", "loadLength", "loadLen", "contentId", " contentlength", "contentPath", "loadId", "contentBuffer", "contentLevel", "ContentId", "ContentBuffer", "ContentLength", "responseLength", " contentLen", "ContentPath", "contentSize", "codeLength", "loadSize", "contentlength", " contentBuffer", "contentType", "ContentLevel", " contentPath", " contentSize", "responseLevel"], "tmpOut": ["vtOut", "cmpout", " tmpout", " tmpOUT", "tempOut", "txtOutput", "tmpOUT", "apiout", "cmpOutput", "tmpIn", " tmpObj", "apiOUT", "mpIn", "tmpout", " tmpOutput", "tempObj", "tempout", " tmpIn", "cmpIn", "txtOut", "tempOUT", "vtOUT", "cmpOut", "tmpOutput", "apiIn", "tempIn", "tempOutput", "txtout", "mpOutput", "tmpObj", "mpOut", "apiOut", "vtObj", "vtout", "mpout"], "buf": ["cb", "tmp", "queue", "la", "uc", "buffer", "buff", "cf", "br", "cat", "Buffer", "src", "cas", "b", "cmd", "bc", "fd", "val", "loc", "base", "data", "bd", "ctx", "box", "raw", "pad", "func", "rc", "length", "seq", "wave", "uf", "cap", "bag", "lc", "count", "border", "cache", "vec", "wb", "fb", "pos", "header", "ff", "bin", "bu", "rb"], "len": ["size", "en", "num", "ln", "la", "lit", "lf", "iter", "limit", "l", "ler", "val", "end", "part", "loc", "lan", "Len", "data", "n", "elt", "el", "body", "nt", "length", "seq", "fl", "lc", "ls", "li", "ann", "le", "count", "c", "rev", "i", "pos", "lin", "fin", "bin", "str", "line", "coll", "ie"], "array": ["Array", "arr", "buffer", "range", "ception", "result", "message", "out", "object", "ray", "val", "channel", "data", "bytes", "response", "r", "pair", "raw", "air", "address", "var", "section", "length", "instance", "wave", "area", "content", "book", "all", "string", "image", "list", "load", "record", "map", "addr", "ar", "value", "collection"]}}
{"id1": "324677", "id2": "5926761", "code1": "    public boolean import_pieces(String filename) {\n        int pieceId;\n        int i;\n        int n;\n        int[] color;\n        boolean byurl = true;\n        e2piece temppiece;\n        color = new int[4];\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            while (true) {\n                String lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                StringTokenizer tok = new StringTokenizer(lineread, \" \");\n                n = tok.countTokens();\n                if (n == 2) {\n                } else {\n                    for (i = 0; i < 4; i++) {\n                        color[i] = Integer.parseInt(tok.nextToken());\n                    }\n                    pieceId++;\n                    System.out.println(\"Read Piece : \" + pieceId + \":\" + color[0] + \" \" + color[1] + \" \" + color[2] + \" \" + color[3]);\n                    temppiece = new e2piece(pieceId, color[0] + 1, color[1] + 1, color[2] + 1, color[3] + 1);\n                    allpieces.add_piece(temppiece);\n                    unplacedpieces.add_piece(temppiece);\n                }\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (feedbackView.getText().length() <= 0) return;\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                }\n\n                public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                }\n            } };\n            try {\n                SSLContext sc = SSLContext.getInstance(\"SSL\");\n                sc.init(null, trustAllCerts, new java.security.SecureRandom());\n                HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n            } catch (Exception e3) {\n                e3.printStackTrace();\n            }\n            feedback = \"\";\n            addLine(\"Type            : \" + feedbackView.getType());\n            addLine(\"User            : \" + HIRuntime.getManager().getCurrentUser().getLastName() + \", \" + HIRuntime.getManager().getCurrentUser().getFirstName() + \" (\" + HIRuntime.getManager().getCurrentUser().getUserName() + \") \" + HIRuntime.getManager().getCurrentUser().getEmail());\n            addLine(\"Project         : P\" + HIRuntime.getManager().getProject().getId() + \" - \" + MetadataHelper.findValue(HIRuntime.getManager().getProject(), HIRuntime.getManager().getProject().getDefaultLanguage().getLanguageId()));\n            addLine(\"Client Version  : \" + HIRuntime.getClientVersion());\n            addLine(\"Service URL     : \" + HIRuntime.getManager().getServerURL());\n            try {\n                addLine(\"Service Version : \" + HIRuntime.getManager().getVersionID());\n            } catch (HIWebServiceException e1) {\n            }\n            addLine(\"Client OS       : \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\") + \" (\" + System.getProperty(\"os.arch\") + \")\");\n            addLine(\"Java Version    : \" + System.getProperty(\"java.version\") + \" (\" + System.getProperty(\"java.vendor\") + \")\");\n            if (HIRuntime.getGui().getLastWSError() == null) addLine(\"Last WS Error   : -none-\"); else {\n                HIWebServiceException lastWSError = HIRuntime.getGui().getLastWSError();\n                addLine(\"Last WS Error   : \" + lastWSError.getCause().getMessage() + \" (\" + lastWSError.getErrorType() + \")\");\n                addLine(\"\");\n                addLine(\"Stack Trace\");\n                addLine(\"-----------\");\n                ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n                PrintWriter writer = new PrintWriter(byteStream);\n                lastWSError.getCause().printStackTrace(writer);\n                writer.close();\n                addLine(new String(byteStream.toByteArray()));\n            }\n            addLine(\"\");\n            addLine(\"Message\");\n            addLine(\"-------\");\n            feedback = feedback + feedbackView.getText();\n            feedback = feedback + \"\\n\\n\";\n            feedback = URLEncoder.encode(feedback, \"UTF-8\");\n            URL url = new URL(\"https://hyperimage.cms.hu-berlin.de/2.0/wstart/provideFeedback.php\");\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setDoOutput(true);\n            PrintWriter writer = new PrintWriter(connection.getOutputStream());\n            writer.write(\"raw_fb=\" + feedback);\n            writer.close();\n            connection.connect();\n            String response = connection.getResponseMessage();\n            if (response.compareTo(\"OK\") == 0) {\n                HIRuntime.getGui().clearLastWSError();\n                HIRuntime.getGui().displayInfoDialog(\"Feedback gesendet\", \"Vielen Dank f\u00fcr Ihr Feedback!\\n\\nIhre Nachricht wurde an die HyperImage Entwickler gesendet.\");\n            } else HIRuntime.getGui().displayInfoDialog(\"Feedback Fehlgeschlagen\", \"Leider konnte Ihr Feedback aufgrund eines Systemfehlers nicht gesendet werden.\\n\" + \"Bitte versuchen Sie es sp\u00e4ter erneut.\\n\\n\" + \"Sollte das Problem bestehen bleiben wenden Sie sich bitte per mail an die Entwickler.\\n\\nVielen Dank!\");\n            connection.disconnect();\n        } catch (MalformedURLException e1) {\n            e1.printStackTrace();\n            HIRuntime.getGui().displayInfoDialog(\"Feedback Fehlgeschlagen\", \"Leider konnte Ihr Feedback aufgrund eines Systemfehlers nicht gesendet werden.\\n\" + \"Bitte versuchen Sie es sp\u00e4ter erneut.\\n\\n\" + \"Sollte das Problem bestehen bleiben wenden Sie sich bitte per mail an die Entwickler.\\n\\nVielen Dank!\");\n        } catch (IOException e2) {\n            e2.printStackTrace();\n            HIRuntime.getGui().displayInfoDialog(\"Feedback Fehlgeschlagen\", \"Leider konnte Ihr Feedback aufgrund eines Systemfehlers nicht gesendet werden.\\n\" + \"Bitte versuchen Sie es sp\u00e4ter erneut.\\n\\n\" + \"Sollte das Problem bestehen bleiben wenden Sie sich bitte per mail an die Entwickler.\\n\\nVielen Dank!\");\n        }\n        HIRuntime.getGui().deregisterComponent(this, false);\n    }\n", "label": 0, "substitutes": {"filename": ["utf", "source", "binary", "txt", "SourceFile", "buffer", "download", "dll", "username", "File", "fp", "f", "loader", "href", "directory", "data", "phrase", "Filename", "prefix", "kl", "word", "name", "length", "fn", "whatever", "string", "path", "document", "il", "file", "uri", "title", "that", "files", "database", "FILE", "which", "figure", "sheet", "nil", "location", "fil"], "pieceId": ["towerId", "pixelID", "workerCount", "copyid", "pieceID", "niceId", "knifeid", "caseId", "trialid", "quoteById", "towerid", "towerCount", "patchid", "workerID", "patchCount", "pixelById", "niceID", "pieceById", "quoteId", " pieceID", "copyID", "knifeID", "trialID", "wordId", "caseID", "quoteid", "knifeCount", "workerId", " pieceid", "ieceid", "workerid", "niceid", " pieceCount", "knifeId", "pixelId", "ieceCount", "pieceid", "ieceID", "wordid", "quoteID", "trialId", "trialById", "copyId", "patchId", "caseid", "ieceId", "patchID", "pieceCount", "pixelid", "towerID", "wordID"], "i": ["id", "d", "si", "qi", "multi", "mu", "ind", "iu", "phi", "k", "hi", "l", "y", "b", "f", "di", "r", "zi", "I", "bi", "ni", "oi", "ai", "ti", "gi", "inner", "info", "x", "ix", "init", "ui", "u", "e", "o", "ci", "eni", "t", "ini", "a", "m", "li", "v", "xi", "index", "slice", "ri", "j", "c", "uri", "ii", "pi", "is", "start", "chi", "z", "mi", "p"], "n": ["h", "en", "nl", "d", "nn", "k", "l", "y", "w", "b", "ns", "f", "number", "r", "ni", "x", "ne", "u", "e", "o", "fn", "t", "m", "nu", "v", "N", "j", "c", "g", "nat", "pn", "hn", "sn", "z", "s", "ner", "p"], "color": ["source", "pen", "parent", "size", "value", "id", "pixel", "token", "win", "year", "colored", "white", "fill", "scale", "with", "cat", "COLOR", "stroke", "digit", "olor", "char", "css", "state", "bug", "cell", "loc", "row", "number", "red", "pin", "style", "resource", "pal", "pair", "sum", "call", "ors", "yellow", "author", "word", "colour", "background", "ion", "length", "comment", "pr", "span", "cor", "gb", "col", "index", "blue", "key", "border", "gray", "c", "font", "like", "width", " colors", "or", "type", "level", "position", "black", "Color", "option", "gl", "alpha", "line", "arg", "theme"], "temppiece": ["temploint", "tempploint", "temppingoint", "temppliece", "temprice", "temppacket", "temporation", "temmpoint", "tempsoint", "typpediece", "tempppoint", "temppedpiece", " temppoint", " tempsoint", "temppedacket", "typpedacket", " temmpipe", "tempplierre", "tempsone", "typpiece", "templiece", "templpiece", "temppipe", "tempoint", "tempsiece", "tempacket", "temppediece", "typpedace", " tempprice", "tempppiece", "temppingoration", " temmporation", "tempace", " tempsrice", "tempprice", "typpacket", "temppppiece", "temppeiece", "temppingipe", "tempppierre", "temppedierre", "temppeacket", " temmpoint", "temmpipe", "temmporation", "tempiece", "typpedoint", "temppedace", "temspiece", "tempporation", "temmpiece", "typpace", "temsprice", "temppone", "temppierre", "typpoint", "temppingiece", " tempporation", "temppoint", " tempsone", "temspone", " temppipe", "temppace", " tempsiece", "temppeoint", "tempipe", "tempierre", "temppeace", "temppedoint", "temspoint", "templierre", " temmpiece", " temppone", "tempsrice", "tempone", "tempplpiece"], "entree": ["ntee", "artrees", "artrie", "astree", "ntrain", "entee", "ottry", "entrees", "ottrees", "astrees", "nttree", "cttree", "asttree", "Enttree", "ottree", "artreen", "artree", "arttree", "anttree", "ottreen", "antree", "ottrie", "ntree", "enttree", "ctree", "ctrie", "antrie", "ntrie", "etrie", "Entree", "ntry", "artry", "otttree", "ctee", "entrain", "etree", "ettree", "Entrie", "entreen", "astreen", "Entrain", "entrie", "entry", "etrain", "antee"], "byurl": ["byURL", "BYfile", "BYurl", " byURL", "Byfile", "byUrl", " bystr", " ByURL", "ByUrl", " BYfile", "Byurl", "bystr", " byfile", " byUrl", "BYUrl", "Bystr", "byfile", "BYstr", " Byfile", " BYstr", " BYURL", " BYurl", " Bystr", " Byurl"], "url": ["source", "page", "ball", "id", "link", "user", "browser", "connection", "open", "feed", "pull", "plug", "l", "http", "base", "f", "loader", "stream", "zip", "org", "server", "update", "ur", "gl", "log", "bel", "string", "path", "image", "file", "uri", "ssl", "URL", "hub", "Url", "www", "blog", "web", "sl"], "in": ["source", "reader", "id", "h", "input", "inc", "din", "win", "connection", "nin", "con", "out", "b", "fr", "login", "f", "as", "data", "In", "fe", "r", "resource", "serv", "inner", "body", "init", "ins", "ini", "a", "c", "file", "IN", "err", "inn", "rin", "is", "ar", "bin", "s", "ac"], "lineread": ["pagereader", "lineRead", " linefind", "stringwrite", "rowraw", "linesreader", "linework", " lineRead", " lineraw", "linesread", "rowwork", "stringreader", "linefeed", "linraw", "stringRead", " linework", "pagefind", "stringread", "filereader", "rowwrite", "rowread", "linefind", "linesRead", "linwrite", "lineswrite", "linread", "filefind", "linwork", " linefeed", "lineraw", " linewrite", "pageread", "fileread", " linereader", "pagefeed", "filefeed", "linereader", "linewrite"], "tok": ["tong", "etaken", "woc", "token", "etok", "Tong", " tak", " tock", "taken", "otok", "toc", "wok", "ttaken", "otak", "ttak", "ttok", "etong", " toc", "wock", "otock", "atok", "atock", "atak", "Toc", "Taken", "wak", "Tock", "ttong", "Tok", "etak", "Tak", "tak", "otoken", "tock", "atoken", "Token"]}}
{"id1": "18288470", "id2": "15126545", "code1": "    public static void unzip(String zipfile, String outputDirectory) {\n        try {\n            byte[] buf = new byte[1024];\n            ZipInputStream zipinputstream = null;\n            ZipEntry zipentry;\n            zipinputstream = new ZipInputStream(new FileInputStream(zipfile));\n            zipentry = zipinputstream.getNextEntry();\n            while (zipentry != null) {\n                String entryName = zipentry.getName();\n                System.out.println(\"entryname \" + entryName);\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(entryName);\n                String directory = newFile.getParent();\n                if (directory == null) {\n                    if (newFile.isDirectory()) break;\n                }\n                fileoutputstream = new FileOutputStream(outputDirectory + entryName);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n                zipentry = zipinputstream.getNextEntry();\n            }\n            zipinputstream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void zipAndSendFiles(File[] logFiles) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        EmailSender emailSender = new EmailSender();\n        try {\n            File globalZipFile = new File(\"XeptoTileServer_Statistics_\" + sdf.format(new Date()) + \".zip\");\n            ZipOutputStream globalZos = new ZipOutputStream(new CheckedOutputStream(new FileOutputStream(globalZipFile), new Adler32()));\n            BufferedOutputStream globalOut = new BufferedOutputStream(globalZos);\n            globalZos.setComment(\"Statistics for all users from the XeptoTileServer.\");\n            File[] zipFiles = new File[usernames.length];\n            ZipOutputStream[] zipOutputStreams = new ZipOutputStream[usernames.length];\n            BufferedOutputStream[] bufferedZipStreams = new BufferedOutputStream[usernames.length];\n            for (File logFile : logFiles) {\n                int i;\n                for (i = 0; i < usernames.length; i++) {\n                    if (logFile.getName().substring(27, 28 + usernames[i].length()).equalsIgnoreCase(usernames[i] + \"_\")) break;\n                }\n                BufferedReader in = new BufferedReader(new FileReader(logFile.getPath()));\n                ZipEntry entry = new ZipEntry(logFile.getName());\n                globalZos.putNextEntry(entry);\n                if (i < usernames.length && emails[i] != null) {\n                    if (zipFiles[i] == null) {\n                        zipFiles[i] = new File(\"XeptoTileServer_Statistics_\" + usernames[i] + \"_\" + sdf.format(new Date()) + \".zip\");\n                        zipOutputStreams[i] = new ZipOutputStream(new CheckedOutputStream(new FileOutputStream(zipFiles[i]), new Adler32()));\n                        bufferedZipStreams[i] = new BufferedOutputStream(zipOutputStreams[i]);\n                        zipOutputStreams[i].setComment(\"Statistics for username \" + usernames[i] + \" from the XeptoTileServer.\");\n                    }\n                    zipOutputStreams[i].putNextEntry(entry);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        globalOut.write(c);\n                        bufferedZipStreams[i].write(c);\n                    }\n                } else {\n                    int c;\n                    while ((c = in.read()) != -1) globalOut.write(c);\n                }\n                in.close();\n                logFile.delete();\n            }\n            globalOut.close();\n            emailSender.send(java.util.ResourceBundle.getBundle(\"logsender_conf\").getString(\"e-mail\"), globalZipFile);\n            globalZipFile.delete();\n            for (int i = 0; i < zipFiles.length; i++) {\n                if (zipFiles[i] != null) {\n                    bufferedZipStreams[i].close();\n                    emailSender.send(emails[i], zipFiles[i]);\n                    zipFiles[i].delete();\n                }\n            }\n        } catch (IOException ex) {\n            System.out.println(\"Cannot create zip file.\");\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"zipfile": ["zipFile", "zFile", "zfilename", "archivefiles", "zfile", "zentry", "lockfiles", "zipfiles", "archivefilename", "lockfilename", " zipfiles", "archiveFile", "zipfilename", "lockFile", "archivefile", " zipFile", "lockfile", "archiveentry", "lockentry"], "outputDirectory": ["outputdirectory", "inputFolder", " outputdirectory", "imageFile", "targetCollection", "outputFile", "outputFolder", " outputDir", " outputFolder", "imageFolder", "outputCollection", "imageDirectory", "inputCollection", "OutputDirectory", "OutputDir", "targetFolder", "OutputFolder", "outputDir", "targetFile", "inputDirectory", "targetdirectory", "Outputdirectory", "targetDirectory", "imageCollection", "targetDir", "inputFile"], "buf": ["cb", "queue", "bf", "binary", "bh", "pkg", "uc", "la", "buffer", "buff", "br", "Buffer", "lim", "src", "cas", "que", "fp", "b", "cmd", "bc", "aux", "base", "cv", "data", "bd", "bytes", "pad", "Buff", "func", "batch", "rc", "bb", "seq", "uf", "bag", "gb", "ab", "uv", "vec", "wb", "fb", "conv", "img", "lb", "rb", "padding", "fab", "bp"], "zipinputstream": ["zipfileStream", " zipmainsteam", "zipinnersystem", "zipsourcethread", "fileinputStream", "zinputsystem", "zInputput", "zipcontrolstream", "archiveinputStream", "zipfilestream", "zipinputsem", "zipinputStream", "archiveinputstream", "zinputchannel", " zipinputStream", "zipInputsteam", "zipInputsem", "zipinputsteam", "zinputStream", "archiveInputstream", " zipmainStream", "zipInputloop", "zInputstream", "zipsourceStream", "zipcontrolStream", "zipbitstream", "zipmainStream", "zipbitchannel", "archiveInputStream", "fileoutputsem", "zinputstream", "zipinputchannel", "zipoutputloop", "zipfilesystem", "zinputput", "zipinputput", "zipoutputsem", "zipInputsystem", "zipinputsystem", "zipInputput", "zipfilethread", "zoutputStream", "fileinputstream", "zipinputthread", " zipmainstream", "zipcontrolput", "zipbitStream", "zipincludeStream", "zInputthread", "zInputsystem", "zipincludesem", "zipmainsteam", "zipInputchannel", "zipincludestream", "archiveInputloop", "fileoutputStream", "zipinnerthread", "zipimportloop", "zipoutputstream", "zipInputthread", "zipInputstream", "zoutputstream", "zipinnerStream", "zipoutputStream", "zipbitput", "zipsourcestream", "zoutputthread", "zipoutputsteam", "zipimportStream", "zipinnerstream", "fileinputsem", "zinputthread", "zipmainstream", "zoutputsystem", " zipinputsteam", "zInputStream", "zipimportstream", "zipInputStream", "zipinputloop", "zipoutputsystem", "archiveinputloop", "zipoutputthread", "zInputchannel", "zipcontrolchannel"], "zipentry": ["copEntry", "zipdata", "ziparchive", "zipletter", "zipEntry", "zelement", "zenter", "expEntry", "seaelement", "installarchive", " zipserver", "seaentry", "zipreader", "seaEntry", "copenter", "lexentry", "zeletter", " zipdata", "lexenter", "zentry", " zipenter", "downloadarchive", "zonedata", "expentry", "lexarchive", "downloadentry", "installentry", "lexdata", " zipletter", "zoneelement", "seaenter", "zoneenter", " ziparchive", " zipEntry", "zearchive", "zeserver", "installserver", "downloadelement", "zeentry", "zEntry", "copentry", "zipserver", " zipreader", "expenter", "zreader", "zipelement", "expelement", "downloadenter", "lexelement", "zonearchive", "zoneentry", "installletter", "zipenter", "copreader"], "entryName": ["entryType", "entryNAME", "zipname", "entityNames", "EntryYear", "zipName", "elementname", " entryYear", "entityType", "internalName", "stringname", "zipInfo", "entityname", " entryNames", "elementInfo", "entryYear", " entryInfo", "stringName", "elementNAME", "entryInfo", "Entryname", " entryNAME", "entryname", " entryType", "entityName", "entryNames", "stringYear", "elementType", "elementNames", "EntryType", "internalNAME", "internalname", " entryname", "EntryName", "stringType", "elementName", "zipType"], "n": ["none", "en", "num", "d", "nn", "len", "ind", "nr", "k", "l", "w", "out", "b", "ns", "f", "number", "no", "r", "x", "name", "ne", "na", "u", "e", "o", "nt", "t", "m", "nu", "v", "index", "N", "j", "c", "i", "g", "un", "pos", "nb", "nd", "ng", "sn", "z", "nc", "p"], "fileoutputstream": ["fileoutpath", "fileoutStream", " fileoutputStream", "fileinputsw", "fileimagestream", "fileinputmessage", "fileOutputstream", "fileresourceStream", "fileoutstream", "fileinputStream", "resourceinputStream", "fileOutputmessage", "zipoutputstream", "resourceinputsw", "resourceoutputsystem", "fileinputsystem", "fileoutputthread", "fileunitstream", "fileOutputthread", " fileunitthread", "resourceoutputsw", "fileresourcestream", "resourceinputpath", "zipoutputStream", "fileOutputsystem", "fileunitthread", "fileoutputsw", "fileinputpath", "fileoutputmessage", " fileunitStream", "fileinputthread", "resourceOutputstream", "fileoutputsystem", "fileOutputsw", "zipOutputstream", "resourceOutputstring", "fileresourcesystem", "fileoutputstring", "resourceoutputpath", "fileoutputpath", " fileoutputthread", "fileOutputpath", "zipoutputmessage", "fileinputstring", "resourceoutputstring", "fileOutputstring", "fileimagemessage", "fileimageStream", "fileinputstream", "resourceOutputsystem", "resourceoutputStream", "resourceinputstream", "fileoutsw", "fileunitStream", "resourceoutputstream", "fileOutputStream", "zipOutputmessage", "fileoutputStream", "fileresourcestring", "zipOutputStream", "resourceOutputStream", " fileunitstream"], "newFile": [" newDir", "NewPlace", "NewDir", "newfile", "newPlace", "addFile", "addDir", "fromFolder", "fromFile", "addFolder", " newPlace", "NewFile", "NEWDir", "newDir", "NEWFolder", "fromfile", "NewFolder", "addfile", "newFolder", " newfile", "Newfile", "NEWFile", "NEWPlace", " newFolder", "fromDir"], "directory": ["source", "folder", "parent", "url", "d", "office", "connection", "director", "division", "Directory", "python", "home", "description", "root", "class", "system", "tree", "prefix", "archive", "creator", "machine", "filename", "volume", "dir", "direction", "direct", "container", "length", "category", "path", "document", "uri", "manager", "database", "which", "project", "collection", "location"]}}
{"id1": "19395766", "id2": "21585427", "code1": "    public static String encodePassword(String password) {\n        try {\n            MessageDigest messageDiegest = MessageDigest.getInstance(\"SHA-1\");\n            messageDiegest.update(password.getBytes(\"UTF-8\"));\n            return Base64.encodeToString(messageDiegest.digest(), false);\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"Ha habido un error mientras se almacenaba la clave de acceso.\");\n            throw new Error(e);\n        } catch (UnsupportedEncodingException e) {\n            log.error(\"Ha habido un error mientras se almacenaba la clave de acceso.\");\n            throw new Error(e);\n        }\n    }\n", "code2": "    public static String hash(final String text) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] sha1hash = new byte[40];\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n            return Sha1.convertToHex(sha1hash);\n        } catch (final Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"password": ["hash", "input", "token", "auth", "sword", "result", "username", "message", "wd", "definition", "params", "PASS", "login", "data", "phrase", "prefix", "email", "address", "word", "name", " passwords", "pattern", "Pass", "text", "words", "key", "string", "path", "encrypted", "code", "secret", "database", "Password", "crypt", "account", "padding", "p", "pass"], "messageDiegest": ["messageDiegress", "messDiega", " messageDiecest", "messdiegent", " messageDiechant", "messageFineger", "messagediechant", " messageDiegent", " messageLettercest", "messagediegent", "messageDiechant", "MessageDieger", "messageExgress", "MessageLettergest", "messageFinegest", "messDiegest", "messDieger", "messageDeathcest", "messageDiega", "messagediegest", "messdiegest", "messageDieger", " messageLetterchant", "messageLettergress", "messDiegent", "MessageDiegest", "messageLettergent", "messageLetterchant", "MessageLettergent", "messageExger", "MessageDiegress", "messageDiecest", "messageLettergest", "messageExgent", " messageLettergest", "messagediecest", "messageDeathgest", "MessageDiegent", "MessageLettergress", "messdiega", "messageFinega", "MessageLetterger", "messageDiegent", "messageDeathgent", "messageLetterger", "messagediega", "messageExgest", "messageFinegress", "messageLettercest", "messageDeathchant", "messdieger", "messageFinegent", " messageLettergent", "messagedieger"]}}
{"id1": "13650581", "id2": "14196271", "code1": "    public static ChannelIF addChannel(String url) throws Exception {\n        ChannelIF channel = null;\n        try {\n            channel = FeedParser.parse(new ChannelBuilder(), url);\n            if (channel.getLocation() == null) channel.setLocation(new URL(url));\n        } catch (ParseException e) {\n            InputStream is = new URL(url).openStream();\n            InputStreamReader reader = new InputStreamReader(is);\n            channel = FeedParser.parse(new ChannelBuilder(), reader);\n            reader.close();\n            is.close();\n            if (channel.getLocation() == null) channel.setLocation(new URL(url));\n        }\n        DAOChannel.addChannel(channel);\n        DAOFavicon.addFaviconForChannel(channel);\n        return channel;\n    }\n", "code2": "    private synchronized File zipTempFile(File tempFile) throws BlogunityException {\n        try {\n            File zippedFile = new File(BlogunityManager.getSystemConfiguration().getTempDir(), tempFile.getName() + \".zip\");\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zippedFile));\n            byte[] readBuffer = new byte[2156];\n            int bytesIn = 0;\n            FileInputStream fis = new FileInputStream(tempFile);\n            ZipEntry anEntry = new ZipEntry(tempFile.getName());\n            zos.putNextEntry(anEntry);\n            while ((bytesIn = fis.read(readBuffer)) != -1) {\n                zos.write(readBuffer, 0, bytesIn);\n            }\n            fis.close();\n            zos.close();\n            return zippedFile;\n        } catch (Exception e) {\n            throw new BlogunityException(I18NStatusFactory.create(I18N.ERRORS.FEED_ZIP_FAILED, e));\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "route", "id", "link", "feed", "connection", "xml", "pull", "download", "rel", "ll", "br", "l", "ul", "http", "view", "fr", "loc", "f", "data", "href", "base", "stream", "style", "version", "resource", "server", "config", "address", "el", "name", "ur", "full", "large", "e", "text", "found", "location", "ls", "string", "path", "image", "html", "uri", "file", "i", "URL", "hub", "Url", "www", "gl", "str", "null", "coll", "sl"], "channel": ["contract", "an", "default", "cf", "fc", "console", "model", "loop", "resource", "bean", "rc", "log", "image", "type", "group", "wan", "feed", "plugin", "conn", "Channel", "part", "class", "handler", "component", "event", "instance", "category", "key", "cache", "c", "or", "video", "source", "page", "parent", "route", "queue", "user", "core", "player", "chan", "client", "bc", "base", "version", "sc", "server", "fat", "hel", "ch", "ann", "context", "service", "manager", "chron", "null", "language", "connection", "cm", "chain", "cat", "message", "view", "center", "layer", "config", "can", "inner", "member", "container", "ko", "chart", "course", "content", "session", "change", "socket", "db", "character", "cup", "unit"], "is": ["get", "id", "isa", "io", "rss", "src", "fs", "http", "ais", "out", "in", "app", "isl", "as", "was", "iss", "are", "stream", "os", "ris", "es", "ai", "info", "serv", "ir", "has", "isi", "it", "ui", "IS", "api", "ri", "isc", "ios", "its", "uri", "i", "im", "us", "bis", "Is", "ar", "iso", "s", "ip", "ie"], "reader": ["source", "read", "Reader", "feed", "iter", "ser", "ro", "io", "rss", "http", "in", "ler", "driver", "row", "f", "loader", "worker", "oder", "stream", "serial", "r", "resource", "handler", "server", "writer", "info", "inner", "er", "rc", "reading", "per", "iris", "parser", "ri", "i", "or", "builder", "rr", "ar", "entry"]}}
{"id1": "20282668", "id2": "4071091", "code1": "    public List<String> selectSynchrnServerFiles(SynchrnServerVO synchrnServerVO) throws Exception {\n        List<String> list = new ArrayList<String>();\n        try {\n            FTPClient ftpClient = new FTPClient();\n            ftpClient.setControlEncoding(\"euc-kr\");\n            if (!EgovWebUtil.isIPAddress(synchrnServerVO.getServerIp())) {\n                throw new RuntimeException(\"IP is needed. (\" + synchrnServerVO.getServerIp() + \")\");\n            }\n            InetAddress host = InetAddress.getByName(synchrnServerVO.getServerIp());\n            try {\n                ftpClient.connect(host, Integer.parseInt(synchrnServerVO.getServerPort()));\n                boolean isLogin = ftpClient.login(synchrnServerVO.getFtpId(), synchrnServerVO.getFtpPassword());\n                if (!isLogin) throw new Exception(\"FTP Client Login Error : \\n\");\n            } catch (SocketException se) {\n                System.out.println(se);\n                throw new Exception(se);\n            } catch (Exception e) {\n                System.out.println(e);\n                throw new Exception(e);\n            }\n            FTPFile[] fTPFile = null;\n            try {\n                ftpClient.changeWorkingDirectory(synchrnServerVO.getSynchrnLc());\n                fTPFile = ftpClient.listFiles(synchrnServerVO.getSynchrnLc());\n                for (int i = 0; i < fTPFile.length; i++) {\n                    if (fTPFile[i].isFile()) list.add(fTPFile[i].getName());\n                }\n            } catch (Exception e) {\n                System.out.println(e);\n            } finally {\n                ftpClient.logout();\n            }\n        } catch (Exception e) {\n            list.add(\"noList\");\n        }\n        return list;\n    }\n", "code2": "    public void execute(JobExecutionContext context) throws JobExecutionException {\n        log.info(\"FileMonitorJob - executing its JOB at \" + new Date() + \" by \" + context.getTrigger().getName());\n        FTPClient client = new FTPClient();\n        OutputStream outStream = null;\n        Calendar filterCal = Calendar.getInstance();\n        filterCal.set(Calendar.DAY_OF_MONTH, filterCal.get(Calendar.DAY_OF_MONTH) - 1);\n        Date aDayAgo = filterCal.getTime();\n        try {\n            Session session = CustomSystemSession.create(r);\n            client.connect(ftpHostname);\n            client.login(ftpUsername, ftpPassword);\n            FTPFile[] users = client.listFiles();\n            if (users != null) {\n                for (FTPFile user : users) {\n                    String userName = user.getName();\n                    client.changeWorkingDirectory(\"/\" + userName + \"/\");\n                    Node userNode = null;\n                    @SuppressWarnings(\"deprecation\") Query query = session.getWorkspace().getQueryManager().createQuery(\"/jcr:root/users/element(*, user)[\\n\" + \"  @alias = '\" + userName.replaceAll(\"'\", \"''\") + \"'\\n\" + \"]\\n\" + \"order by @lastModified descending\", Query.XPATH);\n                    NodeIterator results = query.execute().getNodes();\n                    if (results.hasNext()) {\n                        userNode = results.nextNode();\n                    } else if (session.getRootNode().hasNode(\"users/\" + userName)) {\n                        userNode = session.getRootNode().getNode(\"users/\" + userName);\n                    }\n                    FTPFile[] experiments = client.listFiles();\n                    if (experiments != null && userNode != null) {\n                        for (FTPFile experiment : experiments) {\n                            String experimentName = experiment.getName();\n                            client.changeWorkingDirectory(\"/\" + userName + \"/\" + experimentName + \"/\");\n                            FTPFile[] datasets = client.listFiles();\n                            if (datasets != null) {\n                                for (FTPFile dataset : datasets) {\n                                    String datasetName = dataset.getName();\n                                    client.changeWorkingDirectory(\"/\" + userName + \"/\" + experimentName + \"/\" + datasetName + \"/\");\n                                    Date collectionDate = dataset.getTimestamp().getTime();\n                                    if (collectionDate.after(aDayAgo)) {\n                                        FTPFile[] images = client.listFiles();\n                                        if (images != null) {\n                                            for (FTPFile image : images) {\n                                                processImage(userName, experimentName, datasetName, collectionDate, image, client, userNode, session);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            session.logout();\n            client.logout();\n        } catch (IOException ioe) {\n            log.info(\"Error communicating with FTP server.\");\n            log.error(\"Error communicating with FTP server.\", ioe);\n            ioe.printStackTrace();\n        } catch (RepositoryException ioe) {\n            log.info(\"Error communicating with repository.\");\n            log.error(\"Error communicating with repository.\", ioe);\n            ioe.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(outStream);\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                log.error(\"Problem disconnecting from FTP server\", e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"synchrnServerVO": ["synchrnFileBo", "synchrnClientMO", "synchrnClientSO", "synchronServerBo", "synchrnClientVL", "synchrinServerMO", "synchronServerTO", "synchrnClientVO", "synchrinServerVo", "synchronServerSO", "synchrnserverVo", "synchrnFileMO", "synchrinClientVO", "synchrnSystemVO", "synchrnClientRO", "synchrnSystemSO", "synchrnUserVO", "synchrnServerTO", "synchrnUserVo", "synchrnServiceSO", "synchronClientSO", "synchrnServerRO", "synchrnFileVO", "synchrinServerVO", "synchronClientTO", "synchrnServerVL", "synchrinClientVo", "synchronServerPO", "synchrnClientVo", "synchronClientBo", "synchrnClientPO", "synchronClientVO", "synchrnServicePO", "synchrnClientTO", "synchrnserverBo", "synchrnserverRO", "synchrnSystemTO", "synchrnserverVL", "synchrnserverSO", "synchrnFileVo", "synchrnServiceRO", "synchrnServiceVL", "synchrnUserSO", "synchrnserverVO", "synchrnServiceVO", "synchronClientVo", "synchrnServerPO", "synchronServerVO", "synchrnFileSO", "synchrnServerBo", "synchrnClientBo", "synchrnServerMO", "synchrnSystemRO", "synchronServerVL", "synchrinClientSO", "synchronServerRO", "synchrnServerSO", "synchronClientRO", "synchrnUserRO", "synchrinServerSO", "synchrnServerVo", "synchrnSystemVo", "synchrnServiceTO", "synchronClientVL", "synchronServerVo", "synchrnSystemPO", "synchrinClientMO", "synchrnServiceVo", "synchronClientPO"], "list": ["dl", "lp", "get", "value", "tmp", "test", "queue", "LIST", "chain", "result", "l", "view", "pre", "ist", "out", "object", "val", "diff", "st", "part", "loop", "L", "base", "p", "table", "data", "tree", "set", "server", "can", "x", "name", "member", "batch", "see", "we", "cl", "lists", "keep", "t", "a", "lc", "li", "listed", "v", "all", "string", "pool", "load", "live", "file", "cache", "search", "code", "array", "current", "detail", "str", "null", "ll", "bl", "type"], "ftpClient": ["ftpCl", "ftpcSession", "fltpServer", "ftcpCenter", "flpClient", "ftpcContext", "fcpClient", "fticlient", "ftcpClient", "ftiRemote", "ftpCan", "ftcpclient", "ftapiClient", "ftcContext", "fttpSession", "fpProxy", "fltpContainer", "ftpSession", "ftpCenter", "fpServer", "ftapiSession", "fpclient", "fttpCan", "ftpsClient", "fpContainer", "ftpclient", "ftcpServer", "ftcSession", "fttpCl", "fttpContext", "wdcpContext", "ftpnContainer", "flpContainer", "fapclient", "ftapclient", "ftcpHost", "ftcClient", "ftapServer", "ftcRemote", "flpCan", "wdcpRemote", "ftcpCan", "ftfclient", "ftcCenter", "ftiSession", "flpServer", "ftpsHost", "fttpServer", "wdcpSession", "wdpclient", "ftcpContainer", "wdpContext", "fpSession", "wdpClient", "fpClient", "ftpnCl", "fttpContainer", "wdcpclient", "ftcConnection", "ftpcclient", "ftcclient", "ftpContainer", "ftcpContext", "ftcHost", "fttpClient", "ftpHost", "wdpSession", "ftpConnection", "ftapClient", "wdpRemote", "fpCenter", "wdcpClient", "fcpCenter", "fttpclient", "ftpsConnection", "ftfCan", "fapClient", "ftpnClient", "ftpServer", "fapServer", "ftpProxy", "fpContext", "ftpcClient", "fcpHost", "ftfCenter", "ftpsProxy", "ftfHost", "fcpclient", "fltpCan", "ftfServer", "ftpContext", "fapContext", "ftapiCl", "ftapiContainer", "fltpClient", "fttpConnection", "fpCl", "ftapContext", "ftcpSession", "ftiClient", "ftpRemote", "ftfClient", "fpConnection", "fttpHost", "ftcProxy", "fttpProxy", "ftfContainer", "ftcpRemote", "ftpnSession", "fpHost"], "host": ["source", "parent", "h", "url", "user", "Host", "connection", "username", "format", "http", "home", "client", "driver", "base", "prefix", "server", "address", "name", "zone", "target", "pattern", "enter", "localhost", "path", "node", "socket", "service", "addr", "subject", "account", "group", "domain", "proxy", "port", "null", "ip", "location"], "isLogin": ["ISLogin", "issLog", "ISAuth", "islogin", "IsMail", "isMail", "isLog", "IsLogin", "isAuth", "isSync", "ISLog", "ISMail", "ISEmail", " isMail", "issSync", "IsAuth", " isSync", " isAuth", " islogin", "ISSync", "Islogin", " isEmail", " isLog", "ISlogin", "issLogin", "isEmail", "issEmail"], "fTPFile": ["fTFFiles", " fTCLine", " fTCFile", "fFPPlace", "fPTLine", "fBPfile", " fTCList", "fTCfile", " fFPFiles", "fTPList", "rfTPfile", "rfBPfile", " fFPPlace", "rfBPFiles", "fCPFile", " fCPfile", " fTPModel", "fTFFile", " fCPFiles", " fTPfile", "fTCFiles", "ftpfile", " fTCFiles", " fCPFile", "fTPModel", " fFPLine", "fFPLine", "fCPFiles", "fFPFile", "fTPPFiles", "rfTPFiles", "fMPFiles", "fMPModel", " fFPFile", "fCPfile", "rfTPFile", "fBPLine", "fBPByte", "fFPList", "fTPPList", "fTCLine", "fMPFile", "fPTFile", "fPTPlace", " fTPList", " fTPLine", "fBPFile", "fTFfile", " fTPFiles", "ftpModel", "rfTPByte", "fTCPlace", "fPTFiles", "fMPPlace", "ftpFiles", "fTPPfile", "fFPFiles", "fFPfile", " fTPPlace", "fTPPFile", "rfBPByte", "fTPPlace", " fTCPlace", "fBPFiles", "fMPfile", "fTPByte", "fTPPLine", "ftpFile", "fCPModel", "fTFByte", "fTPLine", "fBPPlace", "fTPfile", "fTPFiles", "fMPByte", " fTCfile", "fTCFile", " fCPModel", "fMPLine", "rfBPFile", "fTCList", "fTPPPlace"], "i": ["id", "h", "si", "d", "multi", "qi", "iu", "phi", "k", "io", "hi", "yi", "y", "in", "b", "part", "f", "di", "n", "bi", "mu", "I", "ti", "oi", "ai", "gi", "inner", "ji", "name", "init", "it", "ui", "ci", "u", "e", "o", "eni", "ix", "t", "m", "li", "v", "xi", "index", "ri", "slice", "j", "c", "uri", "ii", "g", "pi", "start", "field", "fi", "chi", "z", "ip", "p", "ie"]}}
{"id1": "7993946", "id2": "11540200", "code1": "    public void unsplit(String newFilename, File[] files) throws Exception {\n        FileOutputStream stream = new FileOutputStream(new File(newFilename));\n        for (int i = 0; i < files.length; i++) {\n            FileInputStream fin = new FileInputStream(files[i].getAbsolutePath());\n            DataInputStream din = new DataInputStream(fin);\n            while (din.available() > 0) {\n                stream.write(din.read());\n            }\n            din.close();\n            fin.close();\n        }\n        stream.close();\n    }\n", "code2": "    public File uploadImage(InputStream inputStream, String fileName, String sessionId) {\n        File file = new File(PathConfig.getInstance().sessionFolder(sessionId) + File.separator + fileName);\n        FileOutputStream fileOutputStream = null;\n        try {\n            FileUtils.touch(file);\n            fileOutputStream = new FileOutputStream(file);\n            IOUtils.copy(inputStream, fileOutputStream);\n        } catch (IOException e) {\n            logger.error(\"Save uploaded image to file occur IOException.\", e);\n            throw new FileOperationException(\"Save uploaded image to file occur IOException.\", e);\n        } finally {\n            try {\n                if (fileOutputStream != null) {\n                    fileOutputStream.close();\n                }\n            } catch (IOException e) {\n                logger.error(\"Close FileOutputStream Occur IOException while save a uploaded image.\", e);\n            }\n        }\n        return file;\n    }\n", "label": 1, "substitutes": {"newFilename": ["newSourceFile", "newfilename", " newFile", "Newfilename", "NewFile", "newFile", "oldfilename", "oldFilename", "oldSourceFile", " newSourceFile", "NewSourceFile", " newfilename", "oldFile", "NewFilename"], "files": ["balls", "Files", "classes", "resources", "cells", "opens", "strings", "tests", "links", "lines", "keys", "fs", "items", "pins", "books", "sheets", "f", "blocks", "scenes", "loaded", "bs", "objects", "flows", "models", "children", "stars", "filename", "users", "boxes", "plugins", "full", "results", "ins", "images", "pages", "names", "ls", "fits", "path", "thumbnails", "features", "file", "iles", "projects", "ids", "assets", "fil"], "stream": ["source", "reader", "draft", "input", "sem", "write", "upload", "feed", "Stream", "result", "pipe", "io", "output", "view", "w", "http", "out", "this", "in", "driver", "client", "fd", "f", "channel", "data", "zip", "enc", "clean", "usher", "server", "zen", "handler", "writer", "sync", "php", "per", "log", "keep", "transform", "temp", "path", "socket", "file", "ssl", "context", "raf", "self", "form", "stack", "coll", "standard"], "i": ["id", "si", "multi", "abi", "qi", "iu", "hi", "io", "phi", "in", "b", "f", "di", "bi", "zi", "n", "I", "mu", "ni", "ti", "oi", "ai", "gi", "inner", "ji", "x", "ix", "ui", "ci", "u", "o", "eni", "ini", "li", "v", "xi", "ri", "index", "j", "ori", "uri", "ii", "pi", "fi", "mi", "uni", "ip", "p", "ie"], "fin": ["bas", "tin", "rf", "ln", "Fin", "fine", "conn", "fs", "in", "fd", "fr", "f", "data", "pin", "di", "thin", "ris", "fat", "inner", "oin", "skin", "den", "init", "pid", "vin", "FIN", "fn", "ini", "ino", "sin", "kin", "ri", "done", "cin", "ori", "file", "flo", "raf", "fb", "inn", "fen", "front", "rin", "lin", "fi", "bin", "inv", "fa"], "din": ["tin", "su", "reader", "die", "uni", "uin", "nin", "udi", "in", "pin", "di", "bi", "thin", "pal", "ni", "gi", "inner", "oin", "den", "unin", "pid", "da", "ani", "vin", "zin", "eni", "gin", "ini", "fan", "ino", "sin", "kin", "ri", "dy", "done", "cin", "raf", "inn", "fen", "rin", "lin", "bin", "dra", "mini"]}}
{"id1": "19034719", "id2": "18354823", "code1": "    public static void fillTemplate(String sourceFileName, String targetFileName, Map<String, String> values) throws IOException {\n        File targetDirectory = new File(targetFileName.substring(0, targetFileName.lastIndexOf(File.separator)));\n        targetDirectory.mkdirs();\n        File file = new File(sourceFileName);\n        FileInputStream fis = new FileInputStream(file);\n        FileChannel fc = fis.getChannel();\n        int sz = (int) fc.size();\n        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);\n        Charset charset = Charset.forName(\"ISO-8859-15\");\n        CharsetDecoder decoder = charset.newDecoder();\n        CharBuffer cb = decoder.decode(bb);\n        String inString = cb.toString();\n        fis.close();\n        fc.close();\n        Set<String> keys = values.keySet();\n        for (Object k : keys) {\n            inString = inString.replace((String) k, escape(values.get(k)));\n        }\n        FileOutputStream fos = new FileOutputStream(targetFileName);\n        PrintStream ps = new PrintStream(fos);\n        ps.print(inString);\n        fos.close();\n    }\n", "code2": "    private String storeEditionFile(InputStream in) throws IOException {\n        String datadir = getCqPropertiesBeanSpring().getDatadir() + File.separator + \"attachments\" + File.separator;\n        File attachmentsDir = new File(datadir);\n        attachmentsDir.mkdirs();\n        File storedEditionFile = File.createTempFile(\"edition_import_\", \".tmp\", attachmentsDir);\n        FileOutputStream out = new FileOutputStream(storedEditionFile);\n        IOUtils.copyLarge(in, out);\n        IOUtils.closeQuietly(out);\n        IOUtils.closeQuietly(in);\n        return storedEditionFile.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"sourceFileName": ["sourceClassName", "sourceFilePath", "sourceFileNames", "sourceTemplatename", "targetFilename", "targetFileInfo", "targetTemplateName", "resourceSourceFileName", "sourceSourceFileName", "resourceFileNames", "resourceFileName", "sourceClassLocation", "resourceFileLocation", "sourceClassPath", "sourceTemplateInfo", "targetTemplatePath", "targetTemplateInfo", "sourceClassNames", "resourceSourceFilePath", "sourceClassname", "sourceSourceFileLocation", "sourceFilename", "sourceTemplateLocation", "resourceSourceFileLocation", "sourceTemplatePath", "sourceTemplateNames", "sourceSourceFileNames", "sourceTemplateName", "sourceSourceFilename", "sourceFileInfo", "sourceFileLocation", "resourceFilePath", "resourceSourceFileNames", "targetTemplatename", "sourceSourceFilePath", "sourceClassInfo", "targetFilePath", "sourceSourceFileInfo"], "targetFileName": ["targetClassInfo", "TargetDirectoryPath", "targetPlaceName", "targetClassName", "sourceFilePath", "targetPlaceUrl", "sourceFileNames", "targetFilesPath", "TargetFilePath", "targetFileSource", "targetFilesLine", "targetClassLine", "sourcePlacePath", "targetPlacePath", "TargetFileName", "TargetDirectorySource", "targetClassSource", "targetFileInfo", "targetDirectoryLine", "targetFileLine", "targetDirectoryName", "targetFilenameInfo", "sourceFilesInfo", "targetFilesName", "TargetFileInfo", "targetClassPath", "targetFilesInfo", "sourcePlaceUrl", "TargetFileNames", "sourceFilesName", "targetDirectoryPath", "TargetDirectoryInfo", "targetPlaceLocation", "targetDirName", "targetClassNames", "targetDirectoryInfo", "targetFilenameName", "sourcePlaceLocation", "TargetFileSource", "targetDirPath", "targetDirUrl", "targetDirLocation", "targetDirectorySource", "sourceFileInfo", "sourceFileUrl", "sourceFileLocation", "targetDirectoryNames", "sourceFilesPath", "targetDirectoryLocation", "TargetDirectoryNames", "TargetDirectoryLine", "targetFilenameNames", "targetFileUrl", "TargetDirectoryName", "TargetFileLine", "sourcePlaceName", "targetFilePath", "targetFileNames", "targetDirectoryUrl", "targetFilesNames", "targetFilenameSource", "targetFileLocation", "sourceFilesNames"], "values": ["options", "strings", "points", "events", "errors", "frames", "holders", "settings", "lines", "items", "properties", "params", "stores", "types", "styles", "blocks", "guards", "places", "objects", "flows", "models", "forms", "gets", "vs", "ports", "groups", "results", "names", "rules", "fields", "rows", "vals", "maps", "limits", "verts", "marks", "files", "ids", "services", "GV", "Values"], "targetDirectory": ["TargetDir", "sourceDir", "targetDir", " targetDir", "sourceFolder", "TargetDirectory", "TargetFile", " targetFile", "sourceFile", "targetFolder", "sourceDirectory", "targetFile", "TargetFolder", " targetFolder"], "file": ["source", "reader", "queue", "bf", "pe", "feed", "cf", "File", "io", "l", "fs", "http", "fp", "b", "sf", "fd", "bc", "f", "channel", "base", "fe", "directory", "stream", "resource", "handler", "filename", "dir", "fly", "framework", "fn", "book", "il", "rule", "pool", "document", "cache", "db", "fb", "files", "service", "FILE", "fa", "unit"], "fis": ["sfIS", "fris", "Fics", "fils", " fIs", "fsris", "hi", "Fiss", "FIS", "fiss", "fIS", "sfi", " fi", "sfis", "fsis", "fics", "Fils", "hIs", "Fris", "fIs", "fsils", "ci", "Fis", "his", "hiss", " fIS", " fris", " fils", " fics", "ciss", "fsics", "sfiss", "cIs", "cis", "Fi", "fi", " fiss"], "fc": ["af", "dc", "rf", "bf", "uc", "cf", "vc", "fs", "con", " FC", "fp", "sf", "bc", "fd", "f", "channel", "loc", "fe", "ec", "fw", "xc", "ctx", "sc", "RFC", "mc", "pc", "FC", "rc", "tc", "fn", "cs", "fl", "lc", "c", "flo", "fb", "raf", "fm", "cc", "fi", "ct", "nc", "fa", "ic", "fx"], "sz": ["szo", "lszo", "lsiz", " sza", "dsZ", " szi", "dszo", "lszi", "sza", " sZ", "lsza", "dsz", "siz", "lsz", "sze", " szo", "szi", "ssze", "lsZ", "ssz", "dsza", " sze", "sZ", "ssiz", "lsze", "sszi", " siz"], "bb": ["sb", "dc", "bf", "mb", "bh", "buffer", "buff", "cf", "ogg", "BC", "BB", "pb", "b", "bc", "base", "bm", "bd", "ref", "abb", "obb", "bs", "ob", "BBC", "buf", "ba", "gb", "abc", "xb", "eb", " BB", "db", "gg", "fb", "pp", "boot", "nb", "rb", "ib"], "charset": ["chodeset", "chARSet", "chaset", "chararset", "chasetter", "chodesET", "chARScript", "Charsetter", "chARSET", "charsET", "charsetter", "charARSet", "charARScript", "charscript", "chARSetter", "charARSetting", "chararscript", "chodescript", "chascript", "chARSetting", "chodesetting", "chararsetting", "charsetting", "Charsetting", "Charset", "chararsET", "chasET", "charARSET", "chasetting", "CharsET"], "decoder": ["Decoder", "encoded", "descoding", "deoding", "encoding", "Decode", "descode", "decode", "deoded", "decoding", "Decoded", "deoder", "Decoding", "decoded", "encoder", "Deccode", "enccode", "deccode", "desccode", "encode", "descoder", "deode"], "cb": ["sb", "dc", "cd", "bf", "cm", "buffer", "buff", "cf", "BB", "pb", "b", "bc", "cv", "cp", " bc", "obb", "xc", "abb", "CB", "ob", "BBC", "buf", "abc", "gb", "xb", "eb", "cr", "c", "db", "code", "fb", "ca", "cod", "nc", "rb", "bp"], "inString": ["outFile", " inFile", "inLine", "inFile", " inStream", "execStream", "insString", "inputLine", "sourceString", "sourceLine", "INStr", "execStr", "outText", "inFunction", "inStr", "outSingle", "execFunction", "insText", "INString", "inputString", " inSingle", " inArray", " inFunction", "execString", " inLine", "insStream", "InString", "sourceArray", "inArray", "inputArray", "inStream", "InFile", "insStr", "INStream", "inText", "INText", "InSingle", " inStr", "INFunction", "InText", " inText", "outString", "inSingle", "inputStream", "sourceStream"], "keys": ["states", "relations", "ks", "strings", "Keys", "errors", "pes", "settings", "items", "properties", "types", "ns", "appings", "codes", "xes", "objects", "qs", "ics", "vs", "groups", "ports", "xs", "boxes", "plugins", "ins", "images", "names", "fields", "rows", "key", "headers", "maps", "vals", "ips", "vers", "files", "kes", "ids", "obs", "ames"], "k": ["ks", " K", "id", "uk", "ik", "d", "task", "tk", "kk", "l", "b", "row", "f", "Key", "n", "r", "work", "x", "name", "ack", "it", "e", "o", "ok", "t", "ko", "a", "m", "v", "K", "key", "ke", "kn", "kin", "point", "sk", "j", "c", "i", "ek", "unk", "kat", "q", "kw", "kid", "ck", "acc", "p"], "fos": ["Foes", "bors", "dfops", "Foos", "Fops", " foses", "fose", "Fors", "infoses", "dfoes", " foos", "fo", " fops", "Fos", "fops", "bos", "po", "dfos", "fors", "infos", "Fo", "boses", "poes", "infoos", " fors", "Fose", "bose", "foos", "pops", "foses", "pos", "Foses", "foes", "infops", "dfo", " fose"], "ps": ["hs", "als", "ples", "ks", "py", "pe", "hes", "ons", "fs", "pg", "gs", "css", "ep", "p", "po", "ups", "os", "bs", "gets", "vs", "eps", "ppa", "pa", "pps", "cs", "rs", "PS", "pr", "amps", "ls", "Ps", "pse", "ops", "ips", "pp", "files", "aps", "ras", "pers", "ds", "pos", "ts", "pl"]}}
{"id1": "16474825", "id2": "6368581", "code1": "    public static void copyFile(String file1, String file2) {\n        File filedata1 = new java.io.File(file1);\n        if (filedata1.exists()) {\n            try {\n                BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file2));\n                BufferedInputStream in = new BufferedInputStream(new FileInputStream(file1));\n                try {\n                    int read;\n                    while ((read = in.read()) != -1) {\n                        out.write(read);\n                    }\n                    out.flush();\n                } catch (IOException ex1) {\n                    ex1.printStackTrace();\n                } finally {\n                    out.close();\n                    in.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private URLConnection getConnection(String url, int count) {\n        URLConnection conn = null;\n        try {\n            conn = new URL(url).openConnection();\n        } catch (IOException e) {\n            if (count < 5) {\n                System.out.println();\n                System.out.print(\"getConnection failed - \");\n                System.out.println(count);\n                System.out.println(\"Trying again ...\");\n                conn = this.getConnection(url, count++);\n            } else {\n                System.out.println(\"Giving up\");\n                throw new OntopiaRuntimeException(e);\n            }\n        }\n        return conn;\n    }\n", "label": 0, "substitutes": {"file1": ["f2", "FILE14", "file0", "FILE3", "f0", "FileOne", "FILE1", "FILE2", "f14", "File3", "File2", "f3", "file3", " fileOne", " file0", "fileOne", " file3", "File14", "fOne", "file14", "File1", "File0", "f1"], "file2": ["fileTo", "model1", "base2", "modelsecond", "filesecond", "file0", "base0", "FILEsecond", "FILE1", "FILE2", "FileTo", "model2", "baseTwo", "modelTo", "Filesecond", "File2", "fileTwo", "FILETo", " fileTwo", "FileTwo", " file0", "base1", "File1", "File0"], "filedata1": ["fledataOne", "filedadaFirst", "fledATA2", "filedATA2", "filedoca1", "fledataFirst", "fledATA1", "filedataOne", "filedadaOne", "filedATAStart", "filedtaOne", "fledATAOne", "filedoca2", "filedtaFirst", "filedocaStart", "filedATA1", "filedata2", "fledata1", "filedta1", "filedataStart", "filedocaOne", "filedataFirst", "fledata2", "filedada2", "fledATAFirst", "fledataStart", "fledATAStart", "filedtaStart", "filedATAFirst", "filedada1", "filedATAOne", "filedta2"], "out": ["source", "size", "inc", "write", "user", "net", "win", "io", "output", "conn", "w", "b", "client", "this", "base", "data", "In", "OUT", "Out", "os", "outs", "again", "writer", "off", "exec", "x", "sync", "name", "init", "o", "ax", "exp", "flush", "ex", "post", "temp", "up", "pool", "pass", "obj", "socket", "file", "error", "lock", "err", "bin", "copy", "line", "ext"], "in": ["source", "reader", "id", "url", "input", "inc", "din", "ic", "win", "connection", "nin", "conn", "con", "b", "login", "f", "In", "pin", "again", "stream", "r", "isin", "inner", "exec", "init", "ins", "o", "gin", "ini", "a", "m", "ex", "sin", "cin", "image", "c", "i", "IN", "err", "inn", "rin", "is", "lin", "bin", "ac", "pass"], "read": ["select", "get", "play", " write", "reader", "size", "input", "write", "line", "feed", "open", "buffer", "Read", "iter", "READ", "io", "ride", "reads", "end", "char", "loop", "f", "sleep", "skip", "data", "stream", "n", "r", "work", "raw", " Read", "exec", "send", "sync", "reading", "allow", "length", "text", "content", "run", "close", "index", "count", "pass", "load", "readable", "connect", "parse", "check", "current", "wait", "start", "add", "copy", "ip", "use", "type"]}}
{"id1": "15262412", "id2": "576704", "code1": "    String fetch_m3u(String m3u) {\n        InputStream pstream = null;\n        if (m3u.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), m3u);\n                } else {\n                    url = new URL(m3u);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + m3u);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            return line;\n        }\n        return null;\n    }\n", "code2": "    void testFileObject(JavaFileObject fo) throws Exception {\n        URI uri = fo.toUri();\n        System.err.println(\"uri: \" + uri);\n        URLConnection urlconn = uri.toURL().openConnection();\n        if (urlconn instanceof JarURLConnection) {\n            JarURLConnection jarconn = (JarURLConnection) urlconn;\n            File f = new File(jarconn.getJarFile().getName());\n            foundJars.add(f.getName());\n        }\n        try {\n            byte[] uriData = read(urlconn.getInputStream());\n            byte[] foData = read(fo.openInputStream());\n            if (!Arrays.equals(uriData, foData)) {\n                if (uriData.length != foData.length) throw new Exception(\"data size differs: uri data \" + uriData.length + \" bytes, fo data \" + foData.length + \" bytes\");\n                for (int i = 0; i < uriData.length; i++) {\n                    if (uriData[i] != foData[i]) throw new Exception(\"unexpected data returned at offset \" + i + \", uri data \" + uriData[i] + \", fo data \" + foData[i]);\n                }\n                throw new AssertionError(\"cannot find difference\");\n            }\n        } finally {\n            if (urlconn instanceof JarURLConnection) {\n                JarURLConnection jarconn = (JarURLConnection) urlconn;\n                jarconn.getJarFile().close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"m3u": ["m03ur", " m7e", " m3ui", "m3tu", "mthreefile", "m3cu", "m1u", "m1b", "m313uv", " m6b", "m33iu", "v3uv", " m6c", "m3ur", "v3u", "m33uv", "mryu", "m30p", "m1c", "m33b", "m6c", "m2u", " m33u", "m3ui", "m33p", "m2file", "m2b", "mthreee", "mthreeu", "m2c", "m30uv", " m3e", "mryc", "m6u", " m33c", " mryc", "m1ur", "v33u", "m39u", "v3p", "v33uv", " m3c", " m3b", " m3ur", "m3iu", "m3b", "m03u", "m3uv", " m6u", "m2ou", "m3c", "m7u", "m3file", "m39c", "m2e", "m3p", "m313p", "m39tu", " m33ou", "m7e", "m6b", " mryu", "m03c", " m3ou", " m3tu", "m7file", "m03ui", "m03b", "m313u", "v3iu", "m6ur", "m30iu", "v33iu", " m33b", "mthreecu", "v33p", "m33c", " m7file", "mrytu", "m2cu", " m7cu", "m03tu", "m30u", "mryui", "m03ou", "m3ou", " m3cu", " mrytu", " m6ur", "m7cu", " m3file", "m33ou", " m7u", "m313iu", "m39ui", "m33u", "m3e", " mryui"], "pstream": ["pplength", " pload", "upsrc", "upraw", "usrc", "pream", "lpStream", "Pack", "prow", "plength", "Pstream", "spstream", "upload", "spStream", "lpstream", "upStream", "fplength", "lpengine", "Prow", "pengine", "mStream", "fprow", "ustream", "upstream", "Pthread", "ppstream", "lpream", "Pfeed", "fpfeed", "psize", "pack", "Plength", "pStream", "fpstream", "usize", "Pload", "spengine", "Pengine", "pfeed", "ppfeed", "mack", "ufeed", " psrc", "psrc", "Pream", "praw", "upsize", " praw", " pack", " pfeed", "upfeed", "spream", "PStream", " pthread", "mthread", "Praw", " pStream", "pprow", "mstream", " psize", "pload", "pthread"], "url": ["host", "user", "connection", "feed", "rel", "pull", "open", "build", "ll", "plug", "conn", "l", "lib", "http", "client", "b", "bug", "base", "f", "loc", "channel", "resource", "org", "server", "address", "cur", "ur", "gl", "ob", "log", "api", "fl", "location", "string", "path", "image", "c", "file", "ssl", "uri", "URL", "service", "Url", "account", "www", "follow", "blog", "proxy", "web", "coll", "sl"], "urlc": ["URLC", "filech", "filef", "urlC", " urlC", "URLf", "URLp", "URLc", " urll", "urll", "filec", "feedl", "feedC", "urlp", "feedc", "feedci", "URLci", "webp", "filep", "webf", "webc", "URLch", "URLl", " urlci", "urlci", "urlf", "urlch", "webch"], "line": ["source", "page", "plain", "link", "term", "write", "ln", "lf", "lines", "message", "l", "letter", "object", "char", "end", "LINE", "cell", "lined", "Line", "row", "data", "no", "inline", "style", "response", "zip", "el", "sync", "name", "body", "ne", "e", "log", "text", "comment", "li", "le", "frame", "string", "pass", "lock", "file", "error", "code", "header", "block", "item", "lin", "str", "sl", "entry"]}}
{"id1": "6296285", "id2": "23677133", "code1": "    public static final String digest(String credentials, String algorithm, String encoding) {\n        try {\n            MessageDigest md = (MessageDigest) MessageDigest.getInstance(algorithm).clone();\n            if (encoding == null) {\n                md.update(credentials.getBytes());\n            } else {\n                md.update(credentials.getBytes(encoding));\n            }\n            return (convert(md.digest()));\n        } catch (Exception ex) {\n            tools.util.LogMgr.err(\"Crypto.digest \" + ex.toString());\n            return credentials;\n        }\n    }\n", "code2": "\tpublic static void BubbleSortInt1(int[] num) {\n\t\tboolean flag = true; // set flag to true to begin first pass\n\t\tint temp; // holding variable\n\n\t\twhile (flag) {\n\t\t\tflag = false; // set flag to false awaiting a possible swap\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1]) // change to > for ascending sort\n\t\t\t\t{\n\t\t\t\t\ttemp = num[j]; // swap elements\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tflag = true; // shows a swap occurred\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n", "label": 0, "substitutes": {"credentials": ["credws", "cargoentials", "crituration", "credlass", "critentials", "credeters", "cedentials", "criptws", "ccedentials", "cachedcs", "credential", "caredential", "Chedential", "encedpassword", "cedential", "Chedentials", "cryptlass", "Chedws", "cedpassword", "encedential", "cachedential", "cargoential", "Credentials", "Credences", "cryptentials", "Credential", "encredpassword", "chedpassword", "Creduration", "Chedences", "cachedws", "credences", "cargolass", "chedentials", "credpassword", "Credws", "ccedential", "criteters", "cryptential", "chedential", "Credeters", "cachedentials", "chedeters", "caredentials", "Cheduration", "criptcs", "Chedlass", "encedentials", "Credcs", "Credlass", "credcs", "careduration", "cryptences", "critential", "encredential", "Chedeters", "cheduration", "criptentials", "cargoences", "Chedcs", "chedlass", "chedences", "creduration", "chedws", "chedcs", "ccedpassword", "caredeters", "encredentials", "criptential"], "algorithm": ["ralgo", "Algo", "aliasgorithm", "encoded", "aliasoding", "aliasmology", "Almology", "Aloded", "encgorith", "Algorith", "raloded", "algo", "aloded", "Algorithm", "ralgorith", "Aloding", "encgo", "almology", "aloding", "encgorithm", "algorith", "encmology", "aliasgo", "ralgorithm"], "encoding": ["languageletter", "Encaging", "encasing", "Encoder", "engaging", "encoded", "languageode", "acoder", "Encosing", "engoding", "engoder", "encosing", "decoder", "encaging", "engasing", "Encasing", "equoded", "decoding", "equosing", "encletter", "encoder", "coding", "Encoding", "decaging", "coder", "acode", "equoder", "cletter", "languageoding", "acosing", "acoding", "code", "Encoded", "acoded", "languageoder", "acletter", "encode", "equoding", "decasing"], "md": ["dc", "id", "cd", "d", "mb", "cm", "dd", "ind", "ld", "hd", " MD", "mm", "doc", "pd", "gd", "vd", "ma", "wd", "cmd", "ms", "po", "mo", "mac", "bd", "di", "style", "mand", "mag", "meta", "mc", "der", "kg", "body", "da", "mod", "MD", "mt", "m", "df", "od", "pm", "mg", "mad", "metadata", "nd", "amd", "sd", "dig", "ad"]}}
{"id1": "12689310", "id2": "7891900", "code1": "    public HashMap<String, String> prepareDataFile(String fileName) {\n        File originalDataFile = new File(fileName);\n        String tableName = new String();\n        String line = new String();\n        BufferedReader br;\n        BufferedWriter bw;\n        long recordsNumber;\n        File tempDataFile;\n        HashMap<String, String> tableFileMap = new HashMap<String, String>();\n        String filePath = new String();\n        try {\n            br = new BufferedReader(new InputStreamReader(new FileInputStream(originalDataFile)));\n            if (br.ready()) {\n                if ((line = br.readLine()) != null) {\n                    do {\n                        tableName = \"temp_\" + getTableName(line);\n                        tempDataFile = new File(\"./Data/\" + tableName + \".txt\");\n                        tempDataFile.createNewFile();\n                        tableFileMap.put(tableName, tempDataFile.getCanonicalPath());\n                        recordsNumber = getRecordNumber(line);\n                        bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempDataFile)));\n                        for (long i = 0; i < recordsNumber; i++) {\n                            bw.write(br.readLine() + \"\\r\\n\");\n                        }\n                        bw.close();\n                    } while ((line = br.readLine()) != null);\n                }\n                br.close();\n                return tableFileMap;\n            }\n        } catch (Exception e) {\n            ExceptionHandler.handleExcptin(e);\n        }\n        return null;\n    }\n", "code2": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myUrl == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            InputStream in = myUrl.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileName": ["FileInfo", " fileTime", "FilePath", "fileType", "FILETime", "FileType", "FILEType", "resourcename", "Filename", "filename", "FileTime", "fileInfo", "resourceName", " fileInfo", "resourceType", "FileName", "FILEname", "FILEPath", "resourcePath", "FILEName", "FILEInfo", "fileTime"], "originalDataFile": ["originalTablePlace", "OriginalDataFiles", "OriginalDataFile", "originalFileFile", "originalTableFile", "origDataPage", "origTablePage", "originalDataPage", "OriginalFileFile", "OriginalFilePlace", "originalCacheLine", "originalFilePlace", "originalFilePage", "originalCacheFile", "OriginalFilePage", "originalFileFiles", "origDataLine", "origTableFiles", "originalFileLine", "originalDataPlace", "originalDataFiles", "originalCacheFiles", "originalCachePage", "origDataFile", "originalTableFiles", "origTableFile", "origDataFiles", "origTableLine", "OriginalFileFiles", "OriginalDataPage", "originalTableLine", "originalDataLine", "originalTablePage", "OriginalDataPlace"], "tableName": ["TABLEName", "sectionPath", "TableLine", "tableKey", "sectionName", "sectionPart", " tableType", " tableLine", "TableNumber", "TABLEname", "TABLEKey", "fileType", " tablePart", "fileKey", "TableName", " tableNumber", " tablename", "fileLine", "filename", "TableKey", "tablePath", " tablePath", "TableType", "tablename", "tableType", "modelType", " tableKey", "modelNumber", "TablePath", "TABLEType", "tableNumber", "modelPath", "tablePart", "modelName", "tableLine", "TablePart"], "line": ["page", "entry", "sel", "id", "nl", "url", "link", "user", "pe", "lf", "range", "lines", "message", "l", "letter", "one", "end", "val", "LINE", "description", "cell", "Line", "part", "row", "model", "base", "data", "ine", "no", "inline", "style", "lo", "word", "name", "log", "cl", "text", "comment", "job", "lc", "status", "time", "li", "le", "string", "frame", "rule", "day", "key", "load", "file", "parse", "code", "db", "error", "label", "date", "header", "block", "pos", "lin", "position", "str", " Line", "sl", "unit"], "br": ["HR", "ber", "ner", "brush", "reader", "cb", "gr", "bf", "oper", "bh", "browser", "arr", "be", "bg", "ger", "fore", "http", "Br", "b", "ler", "bc", "lr", "fr", "ver", "bm", "BR", " tr", "ref", "r", "rib", "nor", "ir", "er", "cur", "ur", "bridge", "sl", "pr", "hr", "bar", "dr", "sr", "tr", "ch", "vr", "cr", "obj", "sp", "j", "mr", "err", "yr", "fb", "mer", "bro", "img", "form", "fin", "str", "rb", "jar", "wr", "bl"], "bw": ["abw", "bbsw", "lbwt", "BW", "bsw", "bh", "brwb", " bwo", "Bh", "bwa", "Bwb", "bbw", "Bwo", "Biw", " bws", "bbwh", "abws", "bW", " bwh", "bbh", "bbW", "briw", "bwb", " biw", "absw", "bbwt", "lbwa", "Bws", " bwb", "abwh", " bsw", "Bw", "bbwa", "brwo", "bwo", "bwh", "bbws", " bwa", "bws", " bW", "bwt", " bwt", "lbws", "lbw", "brw", "biw", " bh"], "recordsNumber": ["recrecordNumber", "recordNumbers", "recordCount", "cordsNumber", "callsCollection", "increordnumber", "recordsnumber", "recowsnumber", "recordNum", "recordordsName", "recowsNumbers", "callsCount", "recowsNumber", "increordsCount", "recordrecordNumber", "increordCount", "recallsNumber", "increordsNumbers", "recallsNum", "recrecordName", "recipesCount", "increordsNumber", "recitionsNumber", "recordrecordName", "increordsnumber", "recitionsCount", "recrecordNum", "recallsCount", "recodesNumber", "recordsNumbers", "recipesNumbers", "cordsNum", "recordrecordCount", "cordsCount", "recordName", "recowsCount", "callsNum", "recordrecordNum", "recipesnumber", "recordsCount", "recallsName", "recipesNumber", "increordNumbers", "recordordsNum", "increordNumber", "recordsCollection", "recodesNum", "recordNumber", "recrecordCount", "callsNumber", "recallsCollection", "recordsName", "recordordsCount", "recordnumber", "recordsNum", "cordsCollection", "recitionsCollection", "recodesCount", "recordordsNumber", "recodesCollection", "recitionsNum"], "tempDataFile": [" tempDataStream", "tempFilePlace", "tempDatabaseF", "tempTableFolder", "tempFilePath", " tempCodeFile", " tempCodePlace", "temTableLine", " tempTableF", "TempDataPlace", "temDataPlace", "originalDataPlace", "tempDataPlace", "tempFileFile", "tempDataFolder", "temTablePlace", "temDataLine", "TempDataFile", " tempDataPlace", "tempActionPlace", "temDataDirectory", "tempInfoPlace", "tempInfoFile", "originalFileFile", "tempTablePath", "temDataFile", "tempFileLine", "tempFileDirectory", "temTableDirectory", " tempCodeStream", "tempCodePlace", "originalDataFILE", " tempDataF", " tempTableFile", "tempDataDirectory", "TempDataDirectory", " tempTablePlace", "tempCodePath", "tempTableStream", "tempDataLine", "tempFileF", "originalFileFolder", "tempDataFILE", "TempFileDirectory", "temTableFile", "originalFilePlace", "tempCodeFile", "tempDiskFILE", "tempActionFile", "tempActionFolder", "tempDiskPlace", "tempTableLine", "TempFilePlace", " tempDataPath", "tempFileStream", "tempTableF", "tempFileFolder", "tempDataF", " tempTableDirectory", "tempTableDirectory", " tempCodePath", "tempDataPath", "tempDataStream", "tempDiskFolder", "TempFileFolder", "tempActionFILE", "originalDataFolder", " tempDataDirectory", "originalFileFILE", "tempFileFILE", "tempTableFile", "TempFileFile", "tempTablePlace", "tempInfoDirectory", "tempDatabaseFile", "tempInfoFolder", "tempInfoLine", "TempDataFolder", "tempDatabasePlace", "tempDiskFile", "tempDatabaseDirectory", "tempCodeStream"], "tableFileMap": ["tableFileSet", "tableFileCache", "tableLineStore", "tableTableList", "tableLineList", "tableNameSet", "dataFileMaps", "tableNameCache", "tablePlaceArray", "tableTableArray", "dataFileArray", "tableTableHeader", "dataFileSet", "tableFormatMap", "tableMessageList", "tableNameMap", "dataFileMap", "tableFormatList", "dataFileCache", "tableTableCache", "dataTableArray", "tablePlaceSet", "tableMessageHeader", "dataLineCache", "tableFileHeader", "tableBodyStore", "dataFileHeader", "tableTableStore", "tableBodyMap", "dataTableMap", "tableTableMaps", "dataTableSet", "dataFileList", "tableTableMap", "dataTableHeader", "tableLineCache", "tableFormatMaps", "dataTableCache", "dataTableMaps", "tableMessageMap", "dataTableList", "tableLineMap", "tablePlaceMap", "dataLineList", "tableFileArray", "tableBodyList", "tableFileMaps", "tableMessageMaps", "dataLineMap", "tableFileStore", "tableFileList", "tableFormatHeader", "tableTableSet", "tableBodyCache", "tablePlaceCache", "dataFileStore", "tableNameArray", "dataLineStore"], "filePath": ["FileInfo", "filepath", "Filepath", " filepath", "tablepath", "tablePath", "fileInfo", "tableInfo", "FilePath", " fileInfo", "FileName"], "i": ["id", "h", "si", "multi", "qi", "uli", "hi", "phi", "io", "l", "y", "in", "b", "f", "di", "bi", "r", "zi", "I", "ti", "oi", "gi", "ai", "info", "x", "it", "ui", "u", "e", "ci", "o", "m", "li", "v", "xi", "key", "ri", "index", "j", "c", "uri", "ii", "vi", "pi", "fi", "chi", "z"]}}
{"id1": "7422454", "id2": "228865", "code1": "    public void run() {\n        if (name == null) {\n            System.err.println(\"Must set file name for retrieval\");\n            return;\n        }\n        if (handle == null) {\n            System.err.println(\"Must set CCNHandle\");\n            return;\n        }\n        if (htmlPane == null) {\n            System.err.println(\"Must set JEditorPane\");\n            return;\n        }\n        JFrame frame = new JFrame();\n        JFileChooser chooser = new JFileChooser();\n        File f = null;\n        chooser.setCurrentDirectory(null);\n        int returnVal = chooser.showSaveDialog(frame);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            f = chooser.getSelectedFile();\n        } else {\n            htmlPane.setText(\"Save File cancelled\");\n            return;\n        }\n        boolean overwrite = false;\n        try {\n            if (f.exists()) {\n                htmlPane.setText(\"Overwriting contents of \" + f.getPath());\n                overwrite = true;\n            } else {\n                f.createNewFile();\n            }\n            if (f.canWrite()) {\n            } else {\n                htmlPane.setText(\"The ContentExplorer is unable to write the content to the specified file.\");\n                return;\n            }\n        } catch (IOException e) {\n            System.err.println(\"could not create \" + f.getPath() + \" for saving content to filesystem\");\n            htmlPane.setText(\"could not create \" + f.getPath() + \" for saving content to filesystem\");\n        }\n        try {\n            if (!overwrite) htmlPane.setText(\"saving \" + name + \" to \" + f.getCanonicalPath()); else htmlPane.setText(\"overwriting contents of \" + f.getCanonicalPath() + \" to save \" + name);\n            CCNFileInputStream fis = new CCNFileInputStream(name, handle);\n            FileOutputStream output = new FileOutputStream(f);\n            byte[] buffer = new byte[readsize];\n            int readcount = 0;\n            int readtotal = 0;\n            while ((readcount = fis.read(buffer)) != -1) {\n                readtotal += readcount;\n                output.write(buffer, 0, readcount);\n                output.flush();\n            }\n            htmlPane.setText(\"Saved \" + name + \" to \" + f.getCanonicalPath());\n        } catch (Exception e) {\n            htmlPane.setText(\"Could not save \" + name + \" to \" + f.getPath() + \" This may be a prefix for an object or just may not be available at this time.\");\n            System.err.println(\"Could not retrieve file: \" + name);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"frame": ["next", "h", "frames", "cf", "flower", "panel", "view", "jo", "object", "b", "sf", "fp", "state", "fr", "fe", "ctx", "handler", "e", "framework", "flow", "fram", "iframe", "fl", "df", "v", "Frame", "up", "window", "close", "document", "image", "session", "j", "c", "file", "lock", "fb", "ce", "fi", "form", "coll", "p"], "chooser": ["poose", "closer", "Choosen", "quosen", "chosen", "quicer", "Choose", "quose", " choicer", "promoser", "pooser", " choosed", "clane", "choser", "closed", "promosen", "choane", " choose", "Choane", "poosed", "Choosed", "choosen", "choosed", "poosen", "promosed", "promose", "chose", " choosen", "close", "choose", "choicer", "closen", "quoser", "chane", "Chooser", "Choicer"], "f": ["folder", "h", "rf", "url", "bf", "d", "feed", "cf", "io", "fo", "l", "fs", "fc", "w", "fp", "b", "sf", "fd", "inf", "elf", "fr", "of", "tf", "this", "fe", "ref", "fw", "n", "r", "handler", "info", "el", "x", "conf", "name", "full", "e", "framework", "o", "fn", "t", "F", "a", "m", "df", "fold", "v", "path", "j", "c", "file", "i", "fb", "g", "fen", "field", "form", "s", "fa", "coll", "p", "fx"], "returnVal": ["resultval", " returnValue", " returnVAL", "replyValue", " returnval", "ReturnNum", "returnValue", "errorVol", "returnval", "returnNum", "errorVal", "returnVAL", " returnNum", "replyVol", "ReturnVal", "replyVal", "ReturnValue", "resultValue", "resultNum", "Returnval", "returnVol", "replyVAL", " returnVol", "resultVal", "errorVAL", "errorValue"], "overwrite": ["overcreate", "Overcreate", "oversync", "underwrite", " overwriting", "overwritten", "interwrite", "underflow", "underwriting", "overflow", "interflow", "interride", "broadwritten", " override", "underwritten", "underride", "Overwriting", " oversync", "Overwritten", "override", "Overwrite", "intersync", "broadcreate", "overwriting", "undercreate", " overflow", "undersync", "broadwrite", "interwriting", "broadwriting"], "fis": ["fileins", "fisi", " fisc", "fins", "pisi", "fileis", "Fiss", "pins", "fiss", "fios", " fios", "fileisi", "lios", "fileios", "Fis", "pios", "fisc", "pis", "bisi", "lis", "bins", "liss", "Fios", "bios", "lisc", "bis", " fiss", "Fisc"], "output": ["next", "page", "input", "write", "handle", "result", "control", "out", "data", "response", "resource", "config", "writer", "filename", "Output", "o", "flow", "prot", "m", "temp", "v", "path", "image", "pool", "file", "current"], "buffer": ["page", "read", "reader", "split", "memory", "queue", "reference", "buff", "iter", "Buffer", "message", "limit", "b", "channel", "layer", "number", "data", "table", "available", "server", "address", "pad", "uffer", "shape", "transfer", "batch", "bb", "length", "flush", "wave", "cap", "buf", "variable", "slice", "count", "document", "cache", "width", "header", "block", "total", "position"], "readcount": ["workcount", "readsize", "worksize", " readsize", "workCount", "Readcount", "writesize", "playCount", " readCount", "writeCount", "playtotal", "readCount", "writetotal", "playsize", "ReadCount", "writecount", "Readsize", "playcount"], "readtotal": ["tasksum", "url", "open", "io", "taskscale", "this", "worktotal", "config", "tasktotal", "edit", "worksum", "s", "_", " readscale", "readsum", " readsum", "window", "readscale", "process", "add", "copy", "workscale"]}}
{"id1": "20725036", "id2": "16474825", "code1": "    private static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(String file1, String file2) {\n        File filedata1 = new java.io.File(file1);\n        if (filedata1.exists()) {\n            try {\n                BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file2));\n                BufferedInputStream in = new BufferedInputStream(new FileInputStream(file1));\n                try {\n                    int read;\n                    while ((read = in.read()) != -1) {\n                        out.write(read);\n                    }\n                    out.flush();\n                } catch (IOException ex1) {\n                    ex1.printStackTrace();\n                } finally {\n                    out.close();\n                    in.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"sourceFile": ["sourceDir", "srcFiles", "sourceFolder", "srcfile", "srcFolder", "SourceFile", " sourceFiles", "SourceFolder", "sourcefile", "targetFiles", "targetfile", "sourceFiles", " sourceFolder", "targetFile", "Sourcefile", "srcFile", " sourcefile", "targetDir", " sourceDir", "srcDir", "SourceDir"], "destFile": ["sourceDir", "foreignPage", "srcFiles", "DestFiles", "DestPoint", "srcfile", "sourcePoint", "resultLine", "destFiles", " destFiles", "DestPage", "srcLine", "destDirectory", "destfile", "foreignFile", " destfile", "resultfile", "Destfile", " destPoint", "resultFile", "srcDirectory", "foreignDir", "DestDirectory", " destPage", "targetfile", "sourceFiles", "destDir", "destPoint", "srcDir", " destDirectory", "targetFile", "srcFile", "destLine", "foreignfile", "targetDir", " destDir", "destPage", "DestDir", "targetLine", "resultDir", "DestFile"], "source": ["get", "parent", "size", "id", "reader", "url", "input", "site", "route", "si", "connection", "reference", "core", "result", "iter", "output", "src", "from", "view", "this", "client", "Source", "object", "root", "channel", "table", "stream", "storage", "remote", "resource", "slave", "server", "ie", "config", "inner", "dest", "component", "scope", "target", "api", "ource", "session", "status", "SOURCE", "slice", "index", "sin", "image", "seed", "cache", "secure", "uri", "context", "file", "service", "current", "scene", "manager", "ce", "start", "proxy", "null", "use", "unit"], "destination": [" destinated", " destinator", "destinate", "domation", "Destinated", "distinated", "distruction", "distination", "identinating", "destinated", "dominator", "generinator", "generination", "Destinate", "partinated", " destion", "generruction", " destinate", "Destion", "Destinator", "identination", "Destruction", "destruction", "domination", "generinated", "identinator", " destruction", " destation", "partruction", "Destation", "destion", "destinating", "Destinating", "partination", "identinate", "destinator", " destinating", "distinator", "distion", "destation", "partinator", "dominated", "Destination"]}}
{"id1": "5123107", "id2": "20050668", "code1": "    private String getImageUrlForComicsJoke(Date date, String baseURL, String imageDefinition, int imagePathStart) throws JokeFinderException {\n        String imageUrl = null;\n        try {\n            imageUrl = getBaseImageComicsJoke(date, baseURL, imageDefinition, imagePathStart);\n            URL url = new URL(imageUrl);\n            url.openStream();\n        } catch (JokeFinderException e) {\n            logger.warn(\"Couldn't find base URL.\", e);\n            imageUrl = null;\n        } catch (IOException e) {\n            logger.warn(\"Couldn't find or open image base URL.\", e);\n            imageUrl = null;\n        }\n        if (imageUrl == null) {\n            throw new JokeFinderException(\"Couldn't find joke.\");\n        }\n        return imageUrl;\n    }\n", "code2": "    public static boolean insert(final PedidoSituacao pedidoSituacao) {\n        int result = 0;\n        final Connection c = DBConnection.getConnection();\n        PreparedStatement pst = null;\n        if (c == null) {\n            return false;\n        }\n        try {\n            c.setAutoCommit(false);\n            final String sql = \"insert into pedido_situacao (id_pedido, id_situacao, em, observacao, id_funcionario) \" + \"values (?, ? , now(), ?, ?) \";\n            pst = c.prepareStatement(sql);\n            pst.setInt(1, pedidoSituacao.getPedido().getCodigo());\n            pst.setInt(2, pedidoSituacao.getSituacao().getCodigo());\n            pst.setString(3, pedidoSituacao.getObservacao());\n            pst.setInt(4, pedidoSituacao.getFuncionario().getCodigo());\n            result = pst.executeUpdate();\n            c.commit();\n        } catch (final SQLException e) {\n            try {\n                c.rollback();\n            } catch (final SQLException e1) {\n                e1.printStackTrace();\n            }\n            System.out.println(\"[PedidoSituacaoDAO.insert] Erro ao inserir -> \" + e.getMessage());\n        } finally {\n            DBConnection.closePreparedStatement(pst);\n            DBConnection.closeConnection(c);\n        }\n        if (result > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"date": ["year", "complete", "build", "now", "days", "grade", "ate", "diff", "Date", "age", "state", "model", "bug", "resource", "contact", "module", "update", "tag", "name", "dt", "e", "atom", "today", "time", "day", "media", "string", "document", "image", "file", "due", "modified", "created", "database", "create", "start", "md", "dates", "design", "dat", "duration"], "baseURL": ["apiPath", " baseUrl", "BaseUrl", " basePath", "basePath", "BasePath", "apiURI", "baseURI", "bURI", " baseURI", "bPath", "BaseURL", "bUrl", "baseUrl", "bURL", "apiURL", "apiUrl", "BaseURI"], "imageDefinition": ["jobLocation", "jobdefinition", "pictureDef", "jobDefinition", "networkDef", "ImageDefinition", "networkDefinition", "jobDef", "imagedefinition", "picturedefinition", "imageLocation", "pictureDefinition", "filedefinition", "networkdefinition", "ImageLocation", "imageDef", "fileDef", "Imagedefinition", "ImageDef", "fileLocation", "fileDefinition"], "imagePathStart": ["imageLocationOffset", "imagepathSource", "imagepathEnd", " imagepathSource", "imagePATHEnd", "imagePathEnd", "imageTypeStart", " imagepathOffset", " imagepathEnd", "imageTypeEnd", " imagePathOffset", "imagepathstart", "imageLocationEnd", " imagePathstart", "imagePATHSource", "imagePathOffset", "imagepathStart", "imagePathSource", " imagepathstart", "imageLocationstart", "imageTypestart", "imagePATHStart", "imagePathstart", " imagePathEnd", " imagePathSource", " imagepathStart", "imageLocationStart", "imagePATHstart", "imageTypeOffset", "imagepathOffset"], "imageUrl": [" imageFile", "photourl", "ImageUrl", " imageLink", "photoURL", "basePath", "photoFile", "photoDir", "photoUrl", "imageFile", "fileURL", "fileUrl", " imageUr", "fileLog", "Imageurl", "imgLoader", "imgUrl", "photoLoader", "imgurl", "imgUr", "fileUr", "imageURL", "ImageURL", "baseLocation", "pictureDir", " imageLog", "pictureURL", "imageurl", "pictureFile", "photoLink", "imageLog", "photoUr", "ImageLog", " imageLocation", " imageURL", "imageLocation", "imgFile", "photoLocation", "imagePath", "ImageUr", "imageUr", "imageLink", "baseUrl", "imageDir", "pictureLocation", "photoPath", "picturePath", "pictureLink", "imageLoader", " imagePath", "pictureUr", "pictureUrl", " imageDir", "imgURL", " imageLoader"], "url": ["source", "page", "user", "feed", "xml", "pull", "build", "src", "l", "ul", "http", "object", "b", "client", "f", "loader", "data", "stream", "resource", "server", "address", "ur", "event", "gl", "u", "e", "log", "instance", "fl", "location", "string", "path", "image", "obj", "uri", "file", "ssl", "URL", "Url", "blog", "web", "sl"]}}
{"id1": "7847872", "id2": "7273182", "code1": "    public String encrypt(String text, String passphrase, int keylen) {\n        RC2ParameterSpec parm = new RC2ParameterSpec(keylen);\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passphrase.getBytes(getCharset()));\n            SecretKeySpec skeySpec = new SecretKeySpec(md.digest(), \"RC2\");\n            Cipher cipher = Cipher.getInstance(\"RC2/ECB/NoPadding\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, parm);\n            byte[] newBytes = encodeStringNew(text);\n            byte[] d = cipher.doFinal(newBytes);\n            return Base64.encodeBytes(d);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encrypt(String text) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        md.update(text.getBytes());\n        byte raw[] = md.digest();\n        String hash = \"\";\n        for (int i = 0; i < raw.length; i++) {\n            byte temp = raw[i];\n            String s = Integer.toHexString(new Byte(temp));\n            while (s.length() < 2) {\n                s = \"0\" + s;\n            }\n            s = s.substring(s.length() - 2);\n            hash += s;\n        }\n        return hash;\n    }\n", "label": 1, "substitutes": {"text": ["source", "value", "url", "input", "binary", "txt", "token", "TEXT", "buffer", "username", "message", "object", "Text", "data", "phrase", "bytes", "prefix", "address", "config", "sequence", "word", "filename", "name", "transfer", "pattern", "password", "length", "content", "key", "string", "path", "image", "seed", "encrypted", "code", "secret", "crypt", "str", "ext"], "passphrase": ["Passpassword", "asskey", "Passphrase", "passkey", "PassPassword", "workphrase", "asspassword", "assphrase", " passpassword", "password", " password", " passPassword", " passkey", "passPassword", "workword", "Password", "passpassword", "assword", "workpassword", "workPassword", "Passkey"], "keylen": [" keylength", "trustlen", " keyfun", "keyLen", "weightLen", "trustLength", "Keylength", "KeyLength", "weightlength", " keyLen", "trustLen", "KeyLen", "keyLength", "Keyfun", "trustlength", "Keylen", " keyLength", "weightfun", "keylength", "keyfun", "weightlen"], "parm": [" pparam", "Parp", "pparam", "lparm", "Parm", " pam", " pcm", " parp", "lparp", "lparms", "Parms", "parp", "pcm", "Pparam", "fparms", "fparm", "Pam", "fpam", "Pcm", "parms", "lpcm", "pam", " parms", "fpparam"], "md": ["dc", "cd", "mb", " Md", "cm", "dd", "ind", "hd", " MD", "sm", "mm", "pd", "ma", "vd", "gd", "wd", "cmd", "ms", "ym", "mac", "bd", "ud", "mand", "mag", "mc", "mp", "rpm", "dm", "mod", "rm", "dh", "MD", "mt", "m", "dr", "df", "od", "km", "mg", "mad", "Cmd", "ds", "amd", "sd", "mn"], "skeySpec": ["Sipherspec", " skeySPEC", "sKeyspec", " sipherSpec", "screamSch", "sipherSpec", "sipherSch", "sipherConfig", "SkeySpec", "skeySch", "skeyspec", "ssignConfig", "ssignSpec", "sipherSPEC", "SipherSpec", " skeyConfig", "sipherspec", "ssignSch", "screamSPEC", "sKeySpec", "skeyConfig", "Skeyspec", " skeySch", " sipherConfig", "screamSpec", "skeySPEC", "ssignSPEC", " sipherSPEC", "screamConfig", " sipherSch"], "cipher": ["Capter", "ncipher", " cryption", "cryption", "Cursor", " capter", "ecrypt", "encrypt", " cursor", " coder", "capter", "cursor", "ecctr", "ecipher", "encipher", "ncrypt", "ecryption", "Cairo", "ecapter", "cairo", "Coder", "ecoder", " cctr", "coder", "ncursor", " crypt", "encctr", "Cipher", "Crypt", "crypt", "ncairo", "encryption", " cairo", "cctr"], "newBytes": ["NewBlocks", "newParts", "rawBlocks", " newbytes", "Newbytes", " newBlocks", "newBlocks", "NewByte", "newbytes", " newParts", "rawbytes", "rawBytes", "NewParts", "NEWBytes", " newByte", "NewBytes", "newByte", "NEWbytes", "rawParts", "NEWByte"], "d": ["dl", "D", "dc", "did", "cd", "dict", "ded", "dd", "ld", "xd", "vd", "gd", "b", "fd", "f", "data", "bd", "di", "dos", "dn", "e", "da", "de", "dh", "m", "c", "db", "rd", "g", "ds", "nd", "sd", "dat", "ad", "p"]}}
{"id1": "10385564", "id2": "12289756", "code1": "    public SparqlQueryLoaderImpl() throws IOException {\n        ClassLoader loader = SparqlQueryLoaderImpl.class.getClassLoader();\n        URL url = loader.getResource(PROPERTIES_FILENAME);\n        InputStream stream = url.openStream();\n        properties.load(stream);\n        stream.close();\n        String names = getProperties().getProperty(NAMES_PARAMETER);\n        StringTokenizer st = new StringTokenizer(names, \",\");\n        while (st.hasMoreTokens()) {\n            String name = st.nextToken();\n            String value = readContents(String.format(\"sparql/%s.sparql\", name));\n            getName2Query().put(name, value);\n        }\n    }\n", "code2": "    public String loadURL(URL url) {\n        String retVal = \"\";\n        try {\n            InputStream inputStream = url.openStream();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            String line = bufferedReader.readLine();\n            retVal += line + \"\\n\";\n            while (line != null) {\n                System.out.println(line);\n                line = bufferedReader.readLine();\n                if (line != null) retVal += line + \"\\n\";\n            }\n            bufferedReader.close();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        } catch (IOException e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        } catch (Exception e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        }\n        return retVal;\n    }\n", "label": 0, "substitutes": {"loader": ["source", "folder", "reader", "CL", "l", "lib", "driver", "b", "root", "base", "loaded", "class", "r", "system", "resource", "server", "config", "module", "er", "cl", "log", "parser", "lc", "Loader", "up", "ls", "path", "pool", "library", "load", "cache", "file", "lock", "URL", "loading", "ll"], "url": ["source", "page", "reader", "user", "browser", "feed", "connection", "buffer", "l", "http", "properties", "client", "base", "resource", "server", "address", "log", "api", "found", "location", "string", "path", "image", "load", "file", "uri", "ssl", "URL", "Url", "web", "str", "jar", "sl"], "stream": ["source", "plus", "reader", "input", "trans", "upload", "feed", "Stream", "result", "output", "src", "flash", "out", "object", "sw", "client", "row", "channel", "f", "data", "progress", "serial", "response", "enc", "resource", "handler", "clean", "raw", "iv", "ob", "log", "cl", "transform", "temp", "string", "path", "pool", "image", "load", "socket", "file", "context", "ssl", "is", "form", "stack", "coll", "sl"], "names": ["classes", "str", "strings", "lines", "keys", "tools", "nets", "properties", "items", "params", "ns", "types", "styles", "data", "named", "n", "codes", "prefix", "groups", "users", "values", "fields", "words", "headers", "vals", "ans", "apps", "files", "beans", "ids", "parts", "tags", "s", "ames", "Names", "terms"], "st": ["first", "ST", "ost", "ld", "ss", "sw", "ist", "end", "fr", "ste", "est", "std", "sc", "ast", "sh", "stop", "sta", "s", "nt", "cl", "t", "tt", "sv", "St", "se", "pt", "ft", "string", "sts", "list", "sp", "rd", "start", "nd", "th", "stri", "sn", "ct", "stack", "str", "rest", "sl"], "name": ["NAME", "ame", "id", "size", "Name", "now", "object", "home", "part", "common", "base", "number", "f", "data", "no", "named", "n", "style", "prefix", "child", "info", "x", "word", "alias", "na", "member", "old", "key", "time", "up", "string", "path", "pass", "file", "i", "search", "label", "create", "start", "str", "null", "type"], "value": ["language", "default", "range", "dev", "message", "format", "object", "home", "val", "description", "model", "base", "data", "version", "VALUE", "style", "resource", "info", "element", "json", "values", "text", "sv", "content", "v", "key", "media", "string", "attribute", "search", "Value", "property", "type", "valid", "null", "entry"]}}
{"id1": "19641321", "id2": "7464995", "code1": "    public void testUnavailable() throws Exception {\n        URL url = null;\n        url = new URL(\"http://127.0.0.1:\" + connector.getLocalPort() + \"/test/dump/info?query=foo\");\n        assertTrue(IO.toString(url.openStream()).startsWith(\"<html>\"));\n        assertTrue(context.getServletHandler().isAvailable());\n        url = new URL(\"http://127.0.0.1:\" + connector.getLocalPort() + \"/test/dump/ex2/2\");\n        try {\n            IO.toString(url.openStream());\n        } catch (IOException e) {\n        }\n        assertFalse(context.getServletHandler().isAvailable());\n        Thread.sleep(4000);\n        assertTrue(context.getServletHandler().isAvailable());\n    }\n", "code2": "    @Override\n    public void excluir(QuestaoDiscursiva q) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"DELETE FROM questao WHERE id_questao=?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setInt(1, q.getIdQuestao());\n            stmt.executeUpdate();\n            conexao.commit();\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "route", "link", "browser", "connection", "feed", "buffer", "rel", "xml", "build", "ll", "result", "l", "lib", "http", "state", "bug", "lr", "base", "channel", "loader", "data", "loc", "f", "layer", "number", "resource", "org", "server", "address", "config", "ur", "gl", "event", "e", "bb", "ob", "log", "bel", "sl", "key", "string", "path", "image", "orb", "cache", "impl", "uri", "file", "ssl", "socket", "html", "URL", "service", "hub", "Url", "www", "blog", "proxy", "web", "str", "jar", "coll", "location", "entry"]}}
{"id1": "17568209", "id2": "20254498", "code1": "    private static boolean CopyFile(File srcFile, File tagFile) throws IOException {\n        if (srcFile == null || tagFile == null) {\n            return false;\n        }\n        int length = 2097152;\n        File dirFile = new File(getFileFolder(tagFile.getAbsolutePath()));\n        if (!dirFile.exists()) {\n            dirFile.mkdirs();\n        }\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(tagFile.getAbsolutePath());\n        FileChannel inC = in.getChannel();\n        FileChannel outC = out.getChannel();\n        int i = 0;\n        while (true) {\n            if (inC.position() == inC.size()) {\n                inC.close();\n                outC.close();\n                break;\n            }\n            if ((inC.size() - inC.position()) < 20971520) length = (int) (inC.size() - inC.position()); else length = 20971520;\n            inC.transferTo(inC.position(), length, outC);\n            inC.position(inC.position() + length);\n            i++;\n        }\n        return true;\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PrintStream filesTxt = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"temp/index/files.txt\")));\n        String[] files = new File(Constants.INDEX_PATH).list();\n        for (int i = 0; i < files.length; i++) {\n            String f = files[i];\n            if (f.equals(\"deletable\") || f.startsWith(\".\")) continue;\n            FileInputStream in = new FileInputStream(new File(Constants.INDEX_PATH, f));\n            FileOutputStream out = new FileOutputStream(new File(targetDir, f + \".t\"));\n            byte[] buf = new byte[16384];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n            in.close();\n            out.close();\n            filesTxt.println(f);\n        }\n        filesTxt.close();\n    }\n", "label": 1, "substitutes": {"srcFile": ["sourceDir", "sourceUrl", "rcfile", "inputFolder", "inputfile", "srcFiles", "srcfile", "srcFolder", "rcDir", "sourceFILE", "viewFile", "rcFiles", "srcUrl", "viewFILE", "viewUrl", " srcFILE", " srcfile", "rcFolder", "sourcefile", "sourceFile", " srcFiles", "rcFilename", " srcUrl", "sourceFiles", "inputFilename", " srcFilename", "srcFILE", " srcDir", "srcFilename", "rcFile", " srcFolder", "viewfile", "inputFile", "srcDir"], "tagFile": ["logFILE", "logPath", "TagFile", "outBase", "tagPath", "ownFILE", "outFile", " tagFILE", "srcfile", "ownPath", "logfile", "outDir", " tagfile", "catPath", "outFILE", "tagfile", "TagDir", "tagDir", "outfile", "logFile", "modDir", " tagDir", "modFILE", "TagPath", "catFile", "ownfile", " tagBase", "srcFILE", "modFile", "TagBase", "catDir", "modfile", "Tagfile", "tagFILE", "catfile", "tagBase", "ownFile", " tagPath", "srcPath"], "length": ["size", "id", "split", "url", "h", "feed", "len", "range", "with", "build", "weight", "limit", "l", "ength", "join", "end", "diff", "pack", "loc", "L", "data", "j", "style", "zip", " Length", "match", "work", "angle", "child", "ime", "sequence", "section", "shape", "depth", "distance", "filename", "name", "iv", "full", "cost", "capacity", "partial", "height", "li", "time", "slice", "string", "count", "path", "load", "delay", "uri", "lock", "Length", "width", "speed", "character", "total", "position", "form", "value", "sl", "duration", "type"], "dirFile": ["buildBook", " directoryFiles", "dirDirectory", "parentFile", "DIRBase", "locFile", "dirBook", " dirfile", "locType", "parentType", " dirBase", "buildfile", "dirfile", "directoryFolder", "DIRFiles", " directoryfile", "directoryBook", "poFile", "directoryfile", " directoryFile", "parentfile", " dirFiles", "DIRFile", "locfile", "dirFiles", "locDirectory", "directoryFile", "poType", "parentDirectory", "dirBase", "poDirectory", " dirBook", "DIRfile", "dirType", "buildFolder", "pofile", "buildFile", " dirFolder", "dirFolder", " directoryBase"], "in": ["plus", "reader", "h", "id", "en", "input", "inc", "din", "arin", "win", "io", "l", "con", "this", "login", "f", "as", "In", "into", "pin", "n", "r", "again", "inner", "init", "ins", "o", "vin", "a", "up", "image", "c", "IN", "inside", "inn", "is", "lin", "bin", "on", "ac"], "out": ["inc", "write", "net", "extra", "down", "io", "output", "outer", "conn", "one", "w", "this", "ou", "on", "to", "OUT", "Out", "auto", "outs", "again", "writer", "inner", "off", "exec", "sync", "name", "o", "other", "ex", "timeout", "up", "point", "file", "or", "outside", "bin", "working", "s", "line"], "inC": [" inVC", "INc", "inL", "inB", "inputVC", "inputc", "InVC", "INC", " inL", " inP", "inputC", "intoL", "INI", "incCL", "intoC", "intoI", "isinCL", "INB", "InCL", " inFile", "uninCL", "inCL", " inU", "incO", "inVC", " inI", "outB", "diffc", "diffC", "incc", "InB", "inO", "InFile", "outL", "inN", "outc", "outP", " inB", "uninC", "uninc", "inc", "isinVC", "INL", " inCL", "InC", "INCL", "diffI", "innC", "INU", "outVC", "uninU", "inP", "inU", "innc", "inputFile", "isinC", " inO", "outCL", "inFile", "diffCL", "innCL", "intoc", " inN", "INO", "outN", "INN", "INP", "incC", "Inc", "inI", " inc", "innL", "INVC"], "outC": ["outCC", " outCC", "tagCD", "inChannel", "againChannel", "inL", "tagC", "outCL", "inCL", " outL", "againL", " outCR", "againC", "OutL", "OutE", "tagE", " outCD", "OUTCD", " outCL", "OutCD", "OUTCC", "outCD", " outChannel", "OUTC", "OUTL", " outE", "outL", "tagCR", "outChannel", "outE", "OutCR", "outCR", "againCL", "OutC", "OutCC"], "i": ["id", "si", "qi", "multi", "ind", "uli", "phi", "l", "b", "f", "di", "n", "zi", "I", "ti", "ni", "ai", "info", "ji", "it", "ui", "ci", "u", "o", "e", "ini", "li", "xi", "index", "slice", "count", "j", "c", "uri", "strength", "ii", "ori", "pi", "z", "ip", "p", "type"]}}
{"id1": "6677391", "id2": "18208567", "code1": "    @Override\n    protected void doRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String reqPath = req.getPathInfo();\n        if (reqPath.startsWith(\"/\")) reqPath = reqPath.substring(1);\n        ZipEntry entry = zipInfo.get(reqPath);\n        if (entry == null) {\n            logger.debug(Utils.join(\"Requested path not found: [\", reqPath, \"]\"));\n            resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        logger.debug(Utils.join(\"Requested path: [\", reqPath, \"]\"));\n        ServletUtils.establishContentType(reqPath, resp);\n        InputStream in = null;\n        try {\n            in = new BufferedInputStream(zipFile.getInputStream(entry));\n            IOUtils.copy(in, resp.getOutputStream());\n            logger.debug(\"Rendered: \" + reqPath);\n        } catch (FileNotFoundException e) {\n            logger.error(\"zipped resource not found: \" + reqPath);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    public void createPdf(final String eventURI) throws IOException, DocumentException {\n        createSections(eventURI);\n        even = false;\n        final Document document = new Document(Dimensions.getDimension(even, Dimension.MEDIABOX));\n        final PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(MyProperties.getOutput()));\n        writer.setViewerPreferences(PdfWriter.PageLayoutTwoColumnRight);\n        writer.setCropBoxSize(Dimensions.getDimension(even, Dimension.CROPBOX));\n        writer.setBoxSize(\"trim\", Dimensions.getDimension(even, Dimension.TRIMBOX));\n        writer.setBoxSize(\"bleed\", Dimensions.getDimension(even, Dimension.BLEEDBOX));\n        final EventBackgroundAndPageNumbers event = new EventBackgroundAndPageNumbers();\n        writer.setPageEvent(event);\n        document.open();\n        final PdfContentByte content = writer.getDirectContent();\n        event.setTabs(Index.INFO.getTab());\n        importPages(document, content, new PdfReader(Index.INFO.getOutput()), Index.INFO.getTitle());\n        importPages(document, content, MyProperties.getBefore(), event);\n        addAdPage(document, content);\n        PdfReader reader = new PdfReader(Presentations.INFO.getOutput());\n        String[] titles = { \"\", \"\" };\n        for (int i = 1; i <= reader.getNumberOfPages(); i++) {\n            titles = index.getSubtitle(titles, i);\n            event.setTabs(titles[0].toLowerCase());\n            addTitleLeft(content, Dimensions.getTitleArea(even), titles[0], MyFonts.TITLE);\n            addTitleRight(content, Dimensions.getTitleArea(even), titles[1], MyFonts.DATE);\n            content.addTemplate(writer.getImportedPage(reader, i), Dimensions.getOffsetX(even), Dimensions.getOffsetY(even));\n            document.newPage();\n            even = !even;\n        }\n        addAdPage(document, content);\n        importPages(document, content, MyProperties.getAfter(), event);\n        int total = writer.getPageNumber() - 1;\n        event.setNoMorePageNumbers();\n        event.setTabs(Schedules.INFO.getTab());\n        reader = new PdfReader(Schedules.INFO.getOutput());\n        for (int i = 1; i <= reader.getNumberOfPages(); i++) {\n            addTitleLeft(content, Dimensions.getTitleArea(even), Schedules.INFO.getTitle(), MyFonts.TITLE);\n            content.addTemplate(writer.getImportedPage(reader, i), Dimensions.getOffsetX(even), Dimensions.getOffsetY(even));\n            document.newPage();\n            even = !even;\n        }\n        document.close();\n        final File file = new File(MyProperties.getOutput());\n        final byte[] original = new byte[(int) file.length()];\n        final FileInputStream f = new FileInputStream(file);\n        f.read(original);\n        reader = new PdfReader(original);\n        final List<Integer> ranges = new ArrayList<Integer>();\n        for (int i = 1; i <= total; i++) {\n            ranges.add(i);\n            if (i == total / 2) {\n                for (int j = total + 1; j <= reader.getNumberOfPages(); j++) {\n                    ranges.add(j);\n                }\n            }\n        }\n        reader.selectPages(ranges);\n        final PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(MyProperties.getOutput()));\n        stamper.close();\n    }\n", "label": 1, "substitutes": {"req": ["reader", "proc", "rx", "rel", "rep", "conn", "http", "request", "fr", "data", "ref", "re", "r", "response", "resource", "ctx", "zip", "serv", "info", "Request", "exec", "crit", "desc", "query", "e", "requ", "report", "job", "rec", "rw", "obj", "rt", "err", "Resp", "rr", "res", "rb", "jar", "pkg"], "resp": ["respond", "proc", "rel", "rep", "reply", "result", "jp", "conn", "http", "ev", "out", "request", "app", "wa", "client", "fr", "f", "exc", "red", "ref", "re", "response", "r", "ctx", "zip", "server", "serv", "ret", "conf", " response", "bb", "report", "exp", "rh", "job", "temp", "esp", "rec", "Response", "respons", "sp", "html", "rev", "obj", "prev", "err", "wb", "Resp", "rr", "res", "p", "Rec"], "reqPath": ["questpath", "requestName", "reqHandler", "questPart", "reqPart", " reqPart", "requName", "requestUrl", "requestCase", "reqpath", "reqUrl", " reqCase", "apppath", " reqName", "taskPart", "requestHome", "taskCase", " reqHandler", "requpath", "releaseName", "releasePart", "appName", "questPath", "requHandler", "requestpath", "requestPath", "requPart", "reqCase", "reqHome", "reqName", "requestPart", "appPath", "questUrl", " reqpath", "requPath", "releasePath", "taskPath", "questHandler", " reqHome", " reqUrl", "questHome", "requUrl", "taskpath"], "entry": ["source", "reader", " entries", "id", "inc", "si", "ent", "feed", "connection", "result", "ry", "jo", "object", "cell", "part", "ries", "row", "fr", "data", "auto", "zip", "response", "resource", "r", "ie", "archive", "address", "info", "serv", "element", "conf", "ge", "e", "nt", "report", "log", "found", "je", "se", "session", "index", "ri", "path", "image", "entity", "file", "record", "parse", "or", "uri", "Entry", "manager", "rr", "type", "service", " Entry", "jar"], "in": ["source", "reader", "tin", "id", "input", "inc", "din", "win", "min", "cgi", "nin", "con", "out", "b", "login", "f", "data", "In", "pin", "inas", "re", "r", "n", "resource", "again", "thin", "serv", "stream", "isin", "ac", "ins", "s", "ax", "vin", "zin", "gin", "ini", "ex", "m", "fe", "kin", "index", "cin", "c", "socket", "i", "IN", "err", "or", "inn", "rin", "is", "bin", "copy", "p"]}}
{"id1": "3352339", "id2": "20536507", "code1": "    public Long processAddCompany(Company companyBean, Long holdingId) {\n        PreparedStatement ps = null;\n        DatabaseAdapter dbDyn = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            CustomSequenceType seq = new CustomSequenceType();\n            seq.setSequenceName(\"seq_WM_LIST_COMPANY\");\n            seq.setTableName(\"WM_LIST_COMPANY\");\n            seq.setColumnName(\"ID_FIRM\");\n            Long sequenceValue = dbDyn.getSequenceNextValue(seq);\n            ps = dbDyn.prepareStatement(\"insert into WM_LIST_COMPANY (\" + \"\tID_FIRM, \" + \"\tfull_name, \" + \"\tshort_name, \" + \"\taddress, \" + \"\tchief, \" + \"\tbuh, \" + \"\turl, \" + \"\tshort_info, \" + \"   is_deleted\" + \")values \" + (dbDyn.getIsNeedUpdateBracket() ? \"(\" : \"\") + \"\t?,\" + \"\t?,\" + \"\t?,\" + \"\t?,\" + \"\t?,\" + \"\t?,\" + \"\t?,\" + \"\t?,\" + \"   0 \" + (dbDyn.getIsNeedUpdateBracket() ? \")\" : \"\"));\n            int num = 1;\n            RsetTools.setLong(ps, num++, sequenceValue);\n            ps.setString(num++, companyBean.getName());\n            ps.setString(num++, companyBean.getShortName());\n            ps.setString(num++, companyBean.getAddress());\n            ps.setString(num++, companyBean.getCeo());\n            ps.setString(num++, companyBean.getCfo());\n            ps.setString(num++, companyBean.getWebsite());\n            ps.setString(num++, companyBean.getInfo());\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of inserted records - \" + i1);\n            if (holdingId != null) {\n                InternalDaoFactory.getInternalHoldingDao().setRelateHoldingCompany(dbDyn, holdingId, sequenceValue);\n            }\n            dbDyn.commit();\n            return sequenceValue;\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) dbDyn.rollback();\n            } catch (Exception e001) {\n            }\n            String es = \"Error add new company\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    public void testSavepoint9() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.execute(\"CREATE TABLE #savepoint9 (data int)\");\n        stmt.close();\n        con.setAutoCommit(false);\n        Savepoint sp = con.setSavepoint();\n        PreparedStatement pstmt = con.prepareStatement(\"INSERT INTO #savepoint9 (data) VALUES (?)\");\n        pstmt.setInt(1, 1);\n        assertTrue(pstmt.executeUpdate() == 1);\n        pstmt.close();\n        stmt = con.createStatement();\n        ResultSet rs = stmt.executeQuery(\"SELECT SUM(data) FROM #savepoint9\");\n        assertTrue(rs.next());\n        assertTrue(rs.getInt(1) == 1);\n        assertTrue(!rs.next());\n        stmt.close();\n        rs.close();\n        con.commit();\n        con.rollback();\n        stmt = con.createStatement();\n        rs = stmt.executeQuery(\"SELECT SUM(data) FROM #savepoint9\");\n        assertTrue(rs.next());\n        assertTrue(\"bug [2021839]\", rs.getInt(1) == 1);\n        assertTrue(!rs.next());\n        stmt.close();\n        rs.close();\n        con.setAutoCommit(true);\n    }\n", "label": 1, "substitutes": {"companyBean": ["companyBoan", "serviceBeans", "serviceBEan", " companyBeann", "companyBEen", "companyColebean", "contactTeann", "companyTeann", " companyTean", "serviceBEen", "companyTean", "companyPean", "contactTea", "companyBelen", " companyBoean", "companyBoa", "companyNeann", " companyBeanc", "companyLocin", "companyBeean", "companyMean", "companyLocan", "serviceBeann", "companyPlann", "companyBein", "companyPeAN", "companyBEanc", "companyBeen", "companyColea", "companyPlean", "companyBEane", " companyBebean", "companyBeanc", "companyPeann", " companyTein", " companyPlen", "serviceBeen", "companyColean", "companyBEan", "companyLocanc", " companyPlan", "companyPlen", "companyBoAN", "companyBeAN", "companyBoean", "companyBelean", "companyMeean", "companyMeen", "companyBea", "companyBoin", " companyTeane", "companyBoen", " companyTeann", " companyBeean", "companyTeanned", "companyBeans", "companyTeean", " companyTeanned", "companyTeane", "companyPea", " companyBoank", "serviceBEanc", "companyLocbean", "companyMeank", "serviceBeanc", " companyBeank", "contactBeann", "companyBEanned", "companyTeanc", "companyTein", "companyNein", "companyBeane", "companyTebean", "companyBoann", "companyBobean", " companyTeanc", "companyBelan", "companyColeen", " companyBea", "companyBlane", "companyBEin", "companyBlanc", "companyBeank", "companyBoanc", " companyBoen", "contactBean", "companyBlan", "companyBlin", "companyTeen", "companyTeAN", "companyNeanned", "serviceBEbean", "contactBea", "companyBoans", "companyBEa", "companyNean", "serviceBEin", "companyBEbean", "serviceBein", "serviceBean", "companyBoank", "serviceBebean", " companyBoan", "serviceBEann", " companyTeen", "contactBeAN", "contactTeAN", "contactTean", "companyBebean", "serviceBEans", "companyBEans", " companyTebean", "companyTeans", " companyBeen", " companyPlann", " companyTea", "companyBeann", " companyBeane", "companyBelank", " companyBeanned", " companyPlean", "companyBeanned", "companyBEann", "companyPlan", "companyTea", " companyBein"], "holdingId": ["HoldUrl", "HoldID", "holdId", "heldID", "holdUrl", "HoldInfo", " holdingID", "holderID", "holdInfo", "heldInfo", "holderId", "holderInfo", "holdingUrl", "HoldId", "holdingID", " holdingInfo", "heldId", "holdID", "holdingInfo", " holdingUrl"], "ps": ["ils", "lines", "TS", "ns", "bs", "changes", "tx", "pc", "vs", "eps", "cs", "PS", "post", "ls", "pse", "pt", "rows", "pp", "files", "ts", "ys", "ples", "py", "pre", "bps", "css", "po", "os", "posts", "ins", "Ps", "sp", "ras", "pers", "pi", "res", "pl", "cop", "als", "points", "pe", "ss", "jp", "pb", "fs", "http", "gs", "ups", "qs", "js", "ports", "per", "rs", "pr", "ops", "ans", "ds", "s", "p", "ks", "P", "pes", "ws", "properties", "pg", "ms", "as", "ppa", "xs", "pa", "mp", "pps", "ips", "its", "details", "pos", "parts", "proxy"], "dbDyn": ["dbDouys", "dtDYN", "dtDeynam", " dbBsyn", " dbBys", " dbFynam", "databaseDYN", "dbVynam", "dbDoys", "cbCyn", "dbHyn", "databaseDyn", "cbDyn", " dbDYN", "dbDouyn", " dbDSyn", "dtDeill", "dbBys", "dbDsyn", "dbFynam", " dbBait", "dbDynam", "dbCgn", "dbCSyn", "dbDrelly", "dbVYN", "dbBYN", "cbDYN", "dbBsyn", "cbCys", " dbDait", "dbFYN", "dbDoill", "dbDogn", "dbGys", "dbDeYN", "dbDouYN", "dbDoYN", "dtDynam", " dbFyn", "dbByn", "dbDeill", "cbCYN", "dbDougn", "dbDoynam", "databaseDelly", "dbCynam", "dbDelly", " dbDys", "dbHys", "dbCYN", "dbDoyn", "cbDgn", "dbDryn", "cbDys", " dbDynam", "dbCys", " dbByn", "dbDeyn", "dbBait", "dbHsyn", "dbDSyn", "dbVSyn", "dbDYN", "dtDill", " dbFYN", "dbFSyn", "dbHait", "databaseDSyn", "databaseDys", "dbCyn", "dbBelly", "dtDeYN", "databaseDsyn", "dtDeyn", "dbVyn", " dbFSyn", "dbDys", "dbDgn", "dbFyn", "dbDrys", "cbCgn", "dbFill", "dbDeynam", "dtDyn", " dbDsyn", "dbBSyn", "dbDrsyn", "dbGyn", "dbDill", "dbGait", "dbDait", "dbGsyn"], "seq": ["next", "sel", "sequ", "cb", "sample", "queue", "sem", "proc", "pe", "txt", "la", "req", "iter", "pb", "cas", "val", "Sequ", "ctrl", "ec", "fast", "class", "zip", "ctx", "qq", " sequence", "info", "sequence", "generic", "sync", "na", "batch", "exp", "log", "cl", "fn", "ph", "iq", "lc", "cli", "pse", "sec", "buf", "frame", "col", "list", "vals", "seed", "lock", "code", "vec", "struct", "sq", "q", "Struct", "lex", "order", "proxy", "test", "acc", "coll", "pkg", "type"], "sequenceValue": ["seqVal", " sequenceValues", "seqNumber", "characterNumber", "enceValue", "seqType", " sequenceNumber", "enceVal", "enceType", "characterVal", "sequenceVal", "sequenceType", "enceValues", "sequenceValues", "seqValues", " sequenceVal", "seqValue", " sequenceType", "sequenceNumber", "characterValues", "characterValue"], "num": ["gap", "div", "hom", "su", "um", "inc", "mon", "multi", "nom", "nn", "success", "counter", "lang", "nov", "result", "nr", "lim", "ul", "uu", "con", "one", "loop", "gen", "loc", "number", "no", "hex", "gru", "n", "sum", "off", "cur", "name", "na", "mult", "nam", "nu", "temp", "NUM", "dim", "index", "norm", "orig", "Num", "done", "offset", "node", "four", "count", "numbered", "i", "check", "coord", "np", "oct", "un", "miss", "zero", "nb", "form", "ng", "dom", "uni", "mn", "unit"], "i1": ["uiOne", "ci6", "phi1", "pri_", "ui1", "i81", "ci1", "ti6", "ti1", "i6", "i_", "ui81", " i81", "iOne", "pri81", "ti81", "phi81", "ci81", "ciOne", "pri1", "phi_", "tiOne", "ui6", " i_"]}}
{"id1": "11095249", "id2": "698010", "code1": "    public void run() {\n        InputStreamReader in = null;\n        OutputStreamWriter out = null;\n        URL url = null;\n        File net_file = null;\n        long in_length = 0;\n        progress_bar.setValue(0);\n        progress_bar.setString(\"connecting!\");\n        progress_bar.setStringPainted(true);\n        if (sync_host_path_name.length() > 0) {\n            try {\n                try {\n                    if (protocol == Settings.protFTP) {\n                        url = new URL(\"ftp://\" + user_name + \":\" + password + \"@\" + sync_host_path_name);\n                        URLConnection connection = url.openConnection();\n                        in = new InputStreamReader(connection.getInputStream());\n                        in_length = connection.getContentLength();\n                    } else {\n                        net_file = new File(sync_host_path_name);\n                        in = new InputStreamReader(new FileInputStream(net_file), \"US-ASCII\");\n                        in_length = net_file.length();\n                    }\n                    progress_bar.setString(\"synchronising!\");\n                    EventMemory.get_instance(null).import_vCalendar(in, Math.max(in_length, 1), true, progress_bar);\n                    in.close();\n                } catch (Exception x) {\n                    progress_bar.setString(x.getMessage());\n                }\n                progress_bar.setValue(0);\n                progress_bar.setString(\"connecting!\");\n                if (protocol == Settings.protFTP) {\n                    URLConnection connection = url.openConnection();\n                    connection.setDoOutput(true);\n                    out = new OutputStreamWriter(connection.getOutputStream(), \"US-ASCII\");\n                } else if (protocol == Settings.protFile) {\n                    out = new OutputStreamWriter(new FileOutputStream(net_file), \"US-ASCII\");\n                }\n                progress_bar.setString(\"writing!\");\n                int[] i = new int[EventMemory.get_instance(null).get_size()];\n                for (int k = 0; k < i.length; k++) {\n                    i[k] = k;\n                }\n                progress_bar.setStringPainted(true);\n                EventMemory.get_instance(null).export_vCalendar(out, i, true, progress_bar, true);\n                out.close();\n                sync_dialog.sync_panel.unlock_input();\n                sync_dialog.dispose();\n            } catch (Exception e) {\n                progress_bar.setString(e.getMessage());\n                sync_dialog.sync_panel.unlock_input();\n            }\n        } else {\n            progress_bar.setString(\"enter a valid URL!\");\n            sync_dialog.sync_panel.unlock_input();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"in": ["source", "get", "reader", "id", "input", "inc", "din", "win", "buffer", "with", "min", "nin", "conn", "l", "con", "client", "part", "login", "f", "gen", "data", "In", "pin", "again", "n", "r", "resource", "serv", "config", "isin", "inner", "ac", "init", "query", "ins", "it", "gin", "ini", "a", "m", "ex", "kin", "index", "cin", "image", "c", "socket", "IN", "err", "or", "inn", "rin", "is", "lin", "bin", "copy", "p"], "out": ["parent", "size", "inc", "user", "write", "net", "with", "result", "extra", "io", "output", "doc", "conn", "w", "b", "client", "part", "login", "OUT", "Out", "again", "outs", "prefix", "resource", "work", "writer", "off", "exec", "name", "o", "ax", "password", "log", "ex", "m", "temp", "v", "up", "session", "string", "list", "cache", "socket", "file", "obj", "err", "error", "array", "bin", "copy", "line"], "url": ["source", "host", "page", "left", "id", "user", "link", "rel", "download", "director", "buffer", "pull", "ll", "conn", "l", "lib", "http", "cdn", "control", "client", "channel", "f", "loc", "r", "zip", "resource", "org", "server", "contact", "config", "address", "el", "use", "name", "ur", "gl", "ob", "log", "fl", "location", "ls", "il", "string", "image", "path", "rl", "impl", "socket", "file", "uri", "ssl", "URL", "service", "mount", "Url", "account", "blog", "web", "sl"], "net_file": ["rt_stream", "nt_handler", "netfname", "net_filename", "net_File", "net_files", "network_content", "nt_file", "net_name", " net_filename", "net_box", "rt_file", "netPoolcontent", "net_url", "nt_model", "net_cache", "netlandpath", "netlandmodel", "nt_path", "netlandfile", "net_content", "network_files", "netPoolfile", "netffile", "network_cache", "network_path", "net_path", "rt_url", "netffilename", " net_name", "netPoolcache", "net_stream", "net_handler", "rt_box", "network_File", "netlandhandler", "net_model", "network_file"], "in_length": [" in_duration", "in67position", "in_distance", "in_depth", "login64length", "in6distance", "in6slice", " in_width", "in67duration", "in_position", "in_filename", "in64len", "rin_slice", "login_length", "login64Length", "login_Length", "in67length", " in_depth", "in64Length", " in_file", "in_duration", "in_Length", "in64count", "in64length", "in67file", "in_slice", "rin_length", "login_count", "in_len", "rin_distance", "in6length", "login64len", " in_position", "rin_filename", "in_width", "in6filename", "in_file", "in_count", "login64count", "login_len"], "connection": ["source", "translation", "reader", "operation", "closure", "processor", "reference", "director", "function", "io", "message", "statement", "conn", "communication", "con", "client", "object", "driver", "description", "cell", "union", "connected", "channel", "application", "number", "version", "directory", " Connection", "response", "handler", "server", "config", "writer", "inner", "creator", "condition", "section", "volume", "component", "event", "action", "e", "selection", "ion", "instance", "relation", "job", "session", "index", "string", "document", "connect", "socket", "uri", "command", "or", "service", "character", "database", "manager", "which", "position", "Connection", "collection", "location", "entry"], "i": ["ki", "id", "si", "qi", "multi", "d", "iu", "phi", "ati", "io", "l", "data", "di", "n", "bi", "I", "ti", "ai", "info", "it", "ui", "ci", "u", "o", "ani", "api", "ini", "cli", "li", "xi", "v", "ri", "list", "j", "c", "uri", "ii", "vi", "pi", "idi", "ip", "p"], "k": ["ks", "ki", "id", "ik", "num", "uk", "ka", "d", "pull", "kick", "kk", "l", "f", "number", "n", "r", "work", "element", "x", "kh", "it", "kind", "u", "e", "o", "ok", "spec", "t", "ko", "ch", "m", "kn", "v", "K", "key", "ijk", "sk", "j", "c", "unk", "g", "ku", "q", "block", "kw", "kid", "dk", "ck", "z", "acc", "coll", "p"]}}
{"id1": "9613072", "id2": "22622804", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                SocketSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                SocketSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                SocketSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            start();\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    protected byte[] generateHashBytes() {\n        String s = createString(false);\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nsa) {\n            System.out.println(\"Can't get MD5 implementation \" + nsa);\n            throw new RuntimeException(\"DynanmicAddress2: Can't get MD5 implementation\");\n        }\n        if (m_key != null) md.update(m_key.getBytes(), 0, m_key.length());\n        md.update(s.getBytes(), 0, s.length());\n        byte[] hash = md.digest();\n        return hash;\n    }\n", "label": 1, "substitutes": {"mgr": ["immr", "immgr", " mtr", "mtr", " mru", "prr", "Mr", "Mgr", "pgr", "dmrr", "dmgr", " migr", " mmr", "Mtr", "dmmr", "dmru", "mru", "migr", "immtr", "pru", "mrr", "mr", "Migr", " mrr", "immigr", " mr", "mmr", "pmr"], "cfg": ["cb", "alg", "Conf", "cf", "chain", "mem", "conn", "gate", "gen", "bm", "config", "mc", "conf", " ssh", " cf", " chain", "gp", "password", " config", " img", "cache", "file", "db", " conf", "map", "g", "crypt", " cache", " configuration"], "sock": ["absib", "sink", "absocks", "gsock", "mysocket", "sib", " socket", "mysocked", "Socket", "gsocked", "absock", "absocket", "jsocked", "socks", "socked", "mysink", " socks", "Sib", "Sock", "jsock", "socket", "jsink", "Socks", "gsocket", "gsink", "mysock", " sib", "jsocket"], "_cman": ["_gMan", "_cgr", "_sMan", "_cMan", "_cfg", "_mman", "_sman", "_mMan", "_gman", "_gfg", "_mgr", "_mfg", "_ggr", "_sgr", "_sfg"], "_sock": ["_swport", "_ssock", "_Socket", "_Sdb", "_Sock", "_opensock", "_sesdb", " _sdb", "_csord", "_sort", " _socks", "_jsort", "_Sib", "_opensocks", "_fsdb", "_sord", "_csport", " _sip", "_psdb", "_opensib", "_opensip", "_sesip", "_Socks", "_ssocket", "_swock", "_fsocks", "_asdb", "_psock", "_socket", "_opensort", "_sib", " _sesocks", " _sesdb", "_asocks", "_psocket", "_jsocks", " _sesock", "_socks", "_sport", "_psocks", "_fsock", "_Sort", "_jsib", "_asock", "_sesock", "_swocket", "_csock", "_sip", "_ssport", "_sdb", "_sesocks", "_asip", " _sesip", "_csocket", "_fsocket", "_opensdb", "_jsock", "_sword", "_ssord"], "_sout": ["_sbst", "_sst", "_nout", "_sbio", "_Sout", "_Sio", "_nOut", "_sio", "_sOut", "_sbout", "_Sst", "_nio", "_nst", "_SOut", "_sbOut"], "_sinp": ["_sesop", "_sesc", "Jsinop", "_sinop", "Jsinh", "_inh", "_sesp", "_srcp", "Jinop", "_inc", "_sinh", "_sesh", "_srcc", "_inop", "_inp", "Jsinc", "_sinc", "Jinp", "Jinh", "Jsinp", "_srch", "Jinc", "_srcop"], "rand": ["div", "roll", "rar", "go", "wind", "win", "dd", "ind", "range", "chain", "right", "min", "winner", "gen", "r", "round", "der", "pad", "random", "gram", " random", "andi", "init", "pattern", "bird", "max", "rh", "dr", "cr", "reg", "err", "rr", "dist", "NG", "nd", "grad", "ng", "bot", "who", "Rand", "pick"], "i": ["h", "num", "si", "multi", "qi", "iu", "hi", "phi", "b", "f", "di", "bi", "r", "mu", "I", "zi", "ti", "oi", "gi", "ai", "ni", "x", "it", "ui", "ci", "u", "o", "e", "api", "ini", "a", "li", "v", "xi", "index", "ri", "count", "wei", "j", "c", "uri", "ii", "vi", "pi", "chi", "s", "ip", "p"], "hex": ["su", "token", "loop", "pack", " Hex", "zip", "tx", "chrom", "sync", "ph", "temp", "orig", "oct", "dig", "alpha", "ip", "mix", "id", "feed", "rex", "iter", "scale", "digit", "pex", "hit", "shape", "kh", "pattern", "exp", "length", "ex", "key", "zero", "url", "inc", "lit", "buff", "hook", "alph", "loc", "wh", "serial", "sum", "raw", "sex", "x", "text", "string", "hess", "secret", "rice", "null", "shift", "xf", "utf", "h", "num", "char", "data", "password", "transform", "rh", "check", "form", "bin", "test"], "seed": ["shift", "source", "size", "id", "url", "token", "feed", "theme", "flower", "prime", "iter", "scale", "root", "sleep", "phrase", "serial", "zip", "sum", "slave", "prefix", "shadow", "address", "pad", "finger", "random", "tty", "name", "kh", "pattern", "patch", "password", "cookie", "parser", "text", "eed", "key", "pse", "slice", "string", "index", "delay", "grain", "secret", "sudo", "ip", "order", "kid", "test", "alpha", "pick", "sample"], "pass": ["select", "host", "read", "proc", "task", "auth", "handle", "feed", "pull", "ss", "keeper", "ride", "sign", "rss", "flash", "PASS", "fix", "gen", "skip", "login", "ass", "push", "strip", "stage", "sync", "oss", "access", "cross", "report", "step", "Pass", "password", "allow", "ress", "post", "session", "run", "key", "path", "lock", "ask", "parse", "fail", "code", "oct", "check", "service", "secret", "press", "process", "test", "port", "line", "use"], "md5": ["sha5", "mp55", "mp512", "dig2", " md1", " MD512", " md25", " mdok", "md3", "mp2", " md4", "mdok", " MD2", "MD1", "MD5", " md55", "md55", " MD5", "MD55", "mag3", "mp5", "MD25", "md25", "MD512", "MD4", "md1", "sha1", "MD3", "MDok", "md512", "sha512", "sha4", "mag2", "mag5", "MD2", "sha3", " MD3", "mag25", "md2", "sha2", " md2", "digok", " md512", "dig5", " md3", "md4", "dig4"], "hash": ["ash", "h", "id", "url", "auth", "ha", "dig", "build", "fill", "hh", "ashes", "flash", "skip", "version", "ruby", "style", "print", "sum", "her", "sh", "work", "shadow", "match", "dash", "sha", "alias", "depth", "kh", "hed", "query", "json", "password", "rh", "height", "key", "carry", "string", "cache", "html", "lock", "check", "secret", "header", "database", "block", "Hash", "total", "gh", "alt", "square"], "banner": ["broadner", "hanner", "Banana", "binNER", "planer", "Banner", "scanning", "planning", "banana", "banker", " banana", "planground", "scanNER", "binning", "banNER", "hanker", "BanNER", "binner", "Banning", "broader", " banker", "Banker", "scanner", "hanNER", "broadground", "broadning", "biner", "hanana", " banNER", "baner", "banning", "scaner", "planner", "Banground", "banground", "Baner"], "txt": [" text", "reader", "tmp", "cb", "TEXT", "rx", "binary", "utt", "xml", "buff", "lines", "ws", "flat", "rss", "xt", "stuff", "Text", "git", "std", "data", "phrase", "bytes", "elt", "zip", "thin", "tx", "config", "info", "js", "tick", "tty", "desc", "fg", "nt", "json", "cont", "prot", "text", "xxx", "ut", "obj", "html", "file", "rt", "fb", "struct", "vt", "bot", "qt", "test", "str", "rb", "kt", "ext"], "items": ["opens", "cells", "events", "links", "ends", "pieces", "lines", "keys", "pins", "types", "styles", "data", "photos", "bytes", "products", "letters", "objects", "flows", "posts", "models", "qs", "Items", "js", "rooms", "groups", "boxes", "users", "owners", "plugins", "phones", "results", "images", "pages", "members", "bands", "values", "lists", "rows", "cats", "ops", "ips", "ants", "its", "apps", "cases", "details", "files", "aps", "item", "ids", "articles", "parts", "bits"], "sname": ["nsnames", " spackage", "ssparent", "ospass", "Snames", "oskey", "Sname", " smain", "smain", " skey", "Sparent", "sskey", "nspackage", "skey", " snames", "snames", "ssnames", "osname", "nsname", "sparent", "sspass", "sspackage", "nsmain", "ssmain", "ssname", "spackage", "osnames", "Skey", " sparent"], "spass": [" sposs", "spress", "ppasses", "ppass", "splasses", "ispass", "sluss", " spress", " spuss", "ispasses", " spad", "sposs", "ispuss", "spad", "ppad", "slasses", "pposs", " spasses", "slass", "spuss", "ispress", "slress", "sploss", "splad", "spasses", "splass"], "sseed": ["ssecret", "Ssecret", "gpassword", " sslave", "gsecret", "sslave", " sslice", "sessecret", "sespassword", " spassword", "sslice", "Srandom", "sesseed", "srandom", " ssecret", " sroot", "tseed", "pseed", "spassword", "Seed", "psroot", "psslice", "pslice", "psseed", "grandom", "tsecret", "tpassword", "Sseed", "seseed", "trandom", "sroot", "pslave", "Spassword", "proot", "psslave", "gseed"]}}
{"id1": "7273182", "id2": "6405249", "code1": "    public synchronized String encrypt(String text) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        md.update(text.getBytes());\n        byte raw[] = md.digest();\n        String hash = \"\";\n        for (int i = 0; i < raw.length; i++) {\n            byte temp = raw[i];\n            String s = Integer.toHexString(new Byte(temp));\n            while (s.length() < 2) {\n                s = \"0\" + s;\n            }\n            s = s.substring(s.length() - 2);\n            hash += s;\n        }\n        return hash;\n    }\n", "code2": "    public static String generateHexadecimalCodedString(String stringToBeCoded) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n        digest.update(stringToBeCoded.getBytes());\n        byte[] hashedKey = digest.digest();\n        final int radix = 16;\n        String result = \"\";\n        for (byte b : hashedKey) {\n            int unsignedByte = b + 128;\n            result += Integer.toString(unsignedByte, radix);\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"text": ["source", "contract", "url", "input", "TEXT", "txt", "binary", "token", "connection", "buffer", "core", "username", "message", "output", "rypt", "object", "Text", "data", "bytes", "prefix", "editor", "config", "sequence", "word", "transfer", "pattern", "password", "content", "key", "string", "path", "image", "seed", "encrypted", "font", "code", "context", "secret", "test", "str", "ext"], "md": ["dc", "cd", "d", "mb", "cm", "dd", "ind", "material", "hd", " MD", "mm", "sm", "mem", "pd", "gd", "wd", "vd", "cmd", "ms", "mo", "mac", "bd", "mu", "hm", "mand", "editor", "mag", "meta", "mc", "sha", "mp", "dm", "mod", "rm", "ph", "dh", "MD", "mt", "m", "df", "dr", "pm", "km", "mg", "mr", "Cmd", "metadata", "nd", "amd", "nm", "dig", "ad", "pkg"], "raw": ["draw", "input", "Raw", "buffer", "extra", "ws", "outer", "original", "flash", "custom", "row", "def", "hex", "stream", "remote", "serial", "clean", "rew", "inner", "strip", "wrap", "random", "word", "full", "json", "instance", "initial", "partial", "post", "missing", "unknown", "words", "string", "load", "seed", "RAW", "array", "local", "block", "unsigned", "form", "ng", "empty", "packed", "small", "clear"], "i": ["h", "id", "si", "d", "multi", "abi", "qi", "hi", "io", "phi", "k", "l", "b", "end", "f", "di", "n", "zi", "r", "I", "ti", "oi", "ai", "gi", "x", "ix", "init", "ui", "ci", "u", "e", "o", "it", "length", "t", "ini", "m", "li", "v", "xi", "index", "slice", "ri", "j", "c", "uri", "ii", "q", "pi", "fi", "z", "ip", "p", "ie"], "temp": ["source", "size", "id", "tmp", "input", " Temp", "iter", "now", "flat", "fake", "stable", "const", "base", "f", "small", "data", "hex", "enc", "shared", "Temp", "dest", "x", " tmp", "length", "t", "partial", "content", "v", "lc", "string", " temporary", "c", "emp", "current", "unsigned", "packed", "empty", "test", "str", "p", "unit"], "s": ["source", "su", "str", "strings", "site", "size", "si", "d", "sb", "sg", "ss", "ws", "ashes", "l", "fs", "ps", "less", "ns", "css", "f", "p", "n", "os", "bytes", "es", "second", "shared", "js", "sym", "xs", "full", "u", "e", "o", "spec", "cs", " ss", "t", "a", "abs", "ls", "se", "v", "string", "ops", "its", "ssl", "c", "sol", "signed", " parts", "parts", "is", "ds", "ts", "S", "small", "sl"], "hash": ["ash", "h", "id", "url", "abi", "result", "message", "ashes", "base", "f", "hex", "version", "mac", "style", "r", "phrase", "sum", "sh", "ashed", "sha", "kh", "hed", "full", "password", "length", "height", "rh", "content", "key", "history", "string", " hashes", "html", "cache", "error", "search", "array", "header", "block", "secret", "Hash", "total", " hex", "str", "null", "square", "p"]}}
{"id1": "5621039", "id2": "15037259", "code1": "    public ScriptInfoList getScriptList() {\n        ScriptInfoList scripts = null;\n        try {\n            URL url = new URL(SCRIPT_URL + \"?customer=\" + customerID);\n            ObjectInputStream ois = new ObjectInputStream(url.openStream());\n            scripts = (ScriptInfoList) ois.readObject();\n            ois.close();\n            System.out.println(\"got script list\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return scripts;\n    }\n", "code2": "    public void testJob() {\n        try {\n            URL url = new URL(\"http://rickysql.gotoip3.com/mapp/admin/admin.do\");\n            url.openConnection();\n            url.getContent();\n            System.out.print(\"00\");\n        } catch (Exception e) {\n            System.out.print(\"Daily data update exception:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"scripts": ["comments", "resources", "tests", "events", "sections", "packages", "settings", "lines", "ss", "lib", "items", "properties", "params", "types", "styles", "javascript", "codes", "os", "objects", "outs", " plugins", "js", "script", "eps", "xs", "plugins", "ins", "results", "pages", "lists", "ls", "ops", "obj", "ips", "cases", "files", "ses", "ds", "videos", "ents", "s", "assets", "notes"], "url": ["source", "id", "user", "browser", "connection", "open", "xml", "director", "io", "l", "http", "article", "out", "object", "b", "channel", "stream", "zip", "resource", "org", "server", "e", "o", "bb", "ob", "sl", "ls", "location", "path", "uri", "ssl", "URL", "hub", "Url", "www", "cms", "web", "ll"], "ois": ["mobi", "oni", "otes", "oid", "oko", "ivo", "co", "ico", "odi", "ais", "oise", "ou", "po", "asi", "os", "org", "oi", "oco", "js", "oin", "cus", "oga", "oss", "oos", "o", "aos", "tis", "ott", "ko", "roc", "od", "lis", "obj", "ox", "opus", "flo", "oci", "obo", "ogi", "is", "cos", "bis", "obs", "osi", "iso"]}}
{"id1": "6285921", "id2": "5675397", "code1": "    public IsbnToBibConverter() {\n        URLConnection conn = null;\n        try {\n            URL url = new URL(libraryUrl);\n            conn = url.openConnection();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        String cookie = extractCookie(conn);\n        cookieValue = extractCookieValue(cookie);\n        sessionId = extractSessionId(cookieValue);\n    }\n", "code2": "    private void delete(String location) throws Exception {\n        URL url = new URL(location);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"DELETE\");\n        conn.connect();\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK && responseCode != HttpURLConnection.HTTP_NO_CONTENT) {\n            String response = \"location \" + location + \" responded: \" + conn.getResponseMessage() + \" (\" + responseCode + \")\";\n            fail(response);\n        }\n    }\n", "label": 0, "substitutes": {"conn": ["cb", "dc", "connection", "open", "uc", "ct", "http", "con", "fp", "client", "cmd", "Conn", "loc", "channel", "po", "cp", "n", "enc", "ctx", "serv", "ai", "mc", "cn", "conf", "exec", "ci", "rc", "bb", "nt", "ch", "cli", "ann", "session", "connect", "c", "ssl", "rt", "socket", "err", "db", "conv", "addr", "cc", "Connection", "ca", "nc", "ad"], "url": ["host", "page", "browser", "connection", "open", "download", "feed", "l", "lib", "http", "client", "b", "bc", "fr", "channel", "f", "loc", "enc", "resource", "server", "config", "ob", "sl", "ch", "fl", "ls", "path", "image", "cache", "c", "file", "ssl", "uri", "URL", "Url", "blog", "web", "ll"], "cookie": ["ookie", "str", "id", "cb", "dc", "token", "browser", "connection", "cook", "cat", "cdn", "cell", "login", "data", "enc", "server", "config", "gi", "cn", "name", "zone", "cel", "text", "content", "session", "key", "cca", "string", "path", "cache", "c", "uri", "code", "URL", "secret", "ce", "cos", "ct", "sid", "jar", "coll", "C", "type"], "cookieValue": ["commentVal", "commentvalue", " cookieString", "commentValue", "ookieValue", "cachevalue", "tokenValue", "ookieVal", "tokenString", "tokenVal", " cookieVal", "cookievalue", " cookievalue", "cacheVal", "commentString", "cookieVal", "cookieString", "ookieString", "cacheString", "cacheValue"], "sessionId": ["SessionId", " sessionInfo", "SessionPath", " sessionPath", "sessionInfo", "sessionName", "essionName", "sessionPath", "essionInfo", "essionId", "essionPath", "SessionName", " sessionName", "SessionInfo"]}}
{"id1": "7317602", "id2": "8581121", "code1": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static String hexHash(Object obj) {\n        String toHash = obj.toString();\n        try {\n            MessageDigest dg = MessageDigest.getInstance(\"MD5\");\n            dg.update(toHash.getBytes(\"UTF-8\"));\n            return bytesToHex(dg.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error while hashing string: \" + toHash, e);\n        }\n    }\n", "label": 1, "substitutes": {"text": ["source", "translation", "contract", "value", "url", "input", "test", "TEXT", "txt", "token", "connection", " TEXT", "message", "output", "format", "letter", "object", "in", "this", "Text", "number", "data", "hex", "version", "class", "editor", "config", "template", "word", "name", "pattern", "password", "EXT", "content", "key", "string", "path", "image", "obj", "font", "code", "struct", "secret", " Text", "str", "ext"], "md": ["ad", "hash", "cd", "bf", "d", "mb", "dig", "dd", "ind", "ld", "hd", "message", " MD", "mm", "ma", "pd", "sm", "wd", "gd", "vd", "am", "cmd", "ms", "mode", "data", "mac", "mo", "di", "bd", "mand", "editor", "mag", "meta", "mc", "sha", "body", "mp", "dm", "mod", "rm", "MD", "mt", "m", "df", "od", "pm", "mg", "code", "map", "mad", "valid", "Cmd", "metadata", "amd", "nm", "me", "mn"], "sha1hash": ["SHA2hash", "sha5copy", "wa1sum", "wa1hash", "sha5hex", "sha1copy", "sha4hash", "wa1copy", "sha2Hash", "sha5hash", "sha64sum", "sha4sha", "SHA1sum", "wa1hex", "sha4h", "SHA2sum", "SHA2h", "sha4copy", "sha4hex", "sha5sum", "sha2hash", "SHA2Hash", "wa5copy", "sha256Hash", "sha2sha", "sha4sum", "SHA1hash", "sha2sum", "sha256sum", "sha1sum", "SHA1sha", "sha64copy", "wa5hash", "sha1Hash", "sha4Hash", "wa5sum", "sha64hash", "sha1h", "sha11hash", "sha256hash", "sha11sum", "SHA2sha", "sha64hex", "sha11sha", "sha1sha", "sha1hex", "wa5hex", "sha256h", "SHA1Hash", "sha2h", "SHA1h"]}}
{"id1": "22804259", "id2": "9170572", "code1": "    private void streamFileFromFileSystem(File file, HttpServletResponse response) throws ServletException, IOException {\n        ServletOutputStream out = null;\n        InputStream in = null;\n        if (file.isDirectory() || !file.canRead()) {\n            logger.debug(\"File does not exist: \" + file.getAbsolutePath());\n            response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        String mimeType = getServletContext().getMimeType(file.getAbsolutePath());\n        if (mimeType == null) {\n            mimeType = WikiFile.UNKNOWN_MIME_TYPE;\n        }\n        try {\n            response.setContentType(mimeType);\n            response.setContentLength((int) file.length());\n            out = response.getOutputStream();\n            in = new FileInputStream(file);\n            IOUtils.copy(in, out);\n            out.flush();\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static Observacion load() {\n        Observacion obs = new Observacion(new Date());\n        FTPClient f = new FTPClient();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd\");\n        final String datestamp = sdf.format(new Date());\n        String pathname = String.format(PATHNAME_PATTERN, datestamp);\n        try {\n            InetAddress server = InetAddress.getByName(HOST);\n            f.connect(server);\n            f.login(USERNAME, PASSWORD);\n            FTPFile[] files = f.listFiles(pathname, new FTPFileFilter() {\n\n                @Override\n                public boolean accept(FTPFile file) {\n                    return file.getName().startsWith(datestamp);\n                }\n            });\n            FTPFile file = files[files.length - 1];\n            f.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            boolean download = false;\n            String remote = pathname + \"/\" + file.getName();\n            if (download) {\n                File out = new File(\"/home/randres/Desktop/\" + file.getName());\n                FileOutputStream fout = new FileOutputStream(out);\n                fout.flush();\n                fout.close();\n            } else {\n                GZIPInputStream gzipin = new GZIPInputStream(f.retrieveFileStream(remote));\n                LineNumberReader lreader = new LineNumberReader(new InputStreamReader(gzipin, \"Cp1250\"));\n                String line = null;\n                while ((line = lreader.readLine()) != null) {\n                    obs.addEstacion(AemetRetriever.processLine(line));\n                }\n                lreader.close();\n            }\n            f.disconnect();\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Cannot retrieve data from FTP\", e);\n        }\n        return obs;\n    }\n", "label": 0, "substitutes": {"file": ["source", "get", "folder", "parent", "page", "reader", "url", "input", "queue", "binary", "pe", "user", "connection", "buffer", "File", "io", "message", "from", "view", "http", "fp", "object", "request", "part", "model", "f", "base", "loader", "data", "directory", "by", "stream", "class", "single", "resource", "handler", "server", "zip", "info", "module", "force", "filename", "name", "body", "dir", "full", "it", "e", "per", "log", "picture", "content", "up", "string", "path", "image", "document", "rule", "uri", "files", "service", "local", "FILE", "line", "use", "type"], "response": ["next", "page", "translation", "respond", "site", "connection", "feed", "success", "reply", "result", "message", "output", "http", "request", "object", "client", "description", "model", "application", "onse", "data", "version", "re", "tree", "resource", "server", "serv", "writer", "body", "report", " Response", "json", "content", "status", "session", "Response", "index", "image", "document", "pool", "error", "err", "resp", "uri", "service", "res", "location"], "out": ["source", "page", "inc", "write", "user", "result", "io", "output", "outer", "conn", "view", "w", "object", "client", "this", "app", "part", "f", "version", "OUT", "Out", "resource", "r", "outs", "serv", "again", "writer", "server", "inner", "null", "query", "full", "o", "other", "report", "log", "flush", "ex", "temp", "up", "index", "string", "image", "pool", "obj", "socket", "error", "i", "err", "IN", "builder", "bin", "copy", "line", "pass"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "connection", "pull", "min", "io", "nin", "conn", "l", "con", "b", "login", "f", "data", "In", "pin", "again", "n", "r", "resource", "ac", "isin", "inner", "el", "x", "init", "ins", "o", "ini", "m", "session", "kin", "up", "path", "image", "c", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "lin", "bin", "line", "p", "pass"], "mimeType": ["MIMEName", "mureName", "modeSize", "mpeName", "moseSize", "mIMEName", "moneWidth", "mpePatch", "mIMEPatch", "moseStyle", "MIMEType", "mimeStyle", "MimeLength", " mimeSize", " moseType", "Mimetype", "MIMELength", " moseSet", "mIMELength", "mypeName", " mIMEtype", "mimeWidth", "mypetype", "mypeType", "mpetype", " mIMEPatch", "mimetype", "mIMEtype", " mimetype", "mIMEWidth", " moseSize", "mIMESize", "mypeLength", "murePatch", " mIMEName", "modeSet", " mimeStyle", "mIMESet", "MimeWidth", "mimeName", "moetype", "mpeType", "MIMEtype", "MimeType", "monetype", "modeType", "mIMEStyle", " mimeSet", "moeType", "mpeLength", " mIMEType", "mimeSet", "MIMEWidth", " mimeName", " moseStyle", "mimeSize", "mimeLength", "modeStyle", " mimePatch", "moseSet", "moneType", "moeName", "moneName", "mimePatch", "moseType", "mIMEType", "muretype", "mureType", "moeWidth", "MimeName"]}}
{"id1": "23402248", "id2": "5410594", "code1": "    public boolean actualizarEstadoEliminacion(int idTorneo) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo \" + \" SET  terminado = 3 WHERE idTorneo= \" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    @Override\n    public void insert(Connection conn) throws SQLException {\n        PreparedStatement objectInsert = null;\n        String sqlString = null;\n        int newID = 0;\n        try {\n            conn.setAutoCommit(false);\n            sqlString = \"SELECT NEXTVAL(OBJ_SEQ) AS NEXTVAL\";\n            objectInsert = conn.prepareStatement(sqlString);\n            ResultSet r = objectInsert.executeQuery(sqlString);\n            newID = r.getInt(\"NEXTVAL\");\n            sqlString = \"INSERT INTO OBJECTS\" + \"(\" + \"OBJ_ID,\" + \"OBJ_NAME,\" + \"OBTY_CDE\" + \")\" + \"VALUES\" + \"(\" + \"?,\" + \"?,\" + \"?\" + \")\" + \"\";\n            objectInsert = conn.prepareStatement(sqlString);\n            objectInsert.setInt(1, newID);\n            objectInsert.setString(2, getRoomKey());\n            objectInsert.setString(3, \"ROOM\");\n            objectInsert.executeUpdate();\n            sqlString = \"INSERT INTO ROOMS\" + \"(\" + \"\";\n            conn.commit();\n        } catch (SQLException e) {\n            e.printStackTrace();\n            if (conn != null) {\n                try {\n                    System.err.print(\"Transaction is being rolled back\");\n                    conn.rollback();\n                } catch (SQLException excep) {\n                    excep.printStackTrace();\n                }\n            }\n        } finally {\n            if (objectInsert != null) {\n                objectInsert.close();\n            }\n            conn.setAutoCommit(true);\n        }\n    }\n", "label": 1, "substitutes": {"idTorneo": ["idFornos", "idCorneo", "idForni", "idTenseO", "idTornO", "idTorei", "idTordeoa", "idTendono", "idCorneos", "idCornei", "idTorno", "idCoreos", "idTornos", "idTornoa", "idTensei", "idTordei", "idCorei", "idForneO", "idTorni", "idToreo", "idCoreoa", "idFornei", "idTendoni", "idTenseos", "idTorneO", "idForno", "idTorneos", "idCorneoa", "idTendonO", "idCoreo", "idFornO", "idTenseo", "idForneo", "idTordeo", "idForneos", "idTordeos", "idToreoa", "idTornei", "idTorneoa", "idTendonos", "idToreos"], "intResult": ["interresult", "interResult", "etRes", "IntResponse", "integerresult", "etResult", "integerRes", "ltDefault", "IntResult", "intresult", "stringResult", "stringRes", "integerResult", "etDefault", "intRes", "integerResults", " intResults", "Intresult", "IntDefault", " intresult", "IntReturn", " intRes", "ltResult", "interResults", "intDefault", "stringresult", "etResponse", "ltResponse", "intResponse", "IntRes", "intResults", "intReturn", "stringReturn", "ltRes", " intReturn", "interRes"], "sql": ["select", "dl", "su", "id", "url", "conn", "params", "pg", "cmd", "base", "zip", "repl", "serv", "ql", "where", "sync", "shell", "action", "eps", "body", "query", "s", "printf", "QL", "log", "spec", "comment", "SQL", "job", "ls", "string", "seed", "install", "lock", "ssl", "db", "sq", "q", "database", " SQL", "str", "sl", "pass"], "connection": ["select", "BC", "function", "conn", "communication", "con", "client", "pg", "bc", "connected", "environment", "loc", "application", "table", "cp", "ctx", "server", "condition", "config", "writer", "mc", "section", "ongo", "sync", "query", "event", "container", "tc", "ion", "log", "relation", "lc", "session", "index", "port", "pool", "document", "connect", "cache", "socket", "c", "db", "context", "error", "lock", "manager", "database", "position", "cond", "Connection", "proxy", "collection", "coll", "unit"], "ps": ["cop", "relations", "ks", "processor", "proc", "pe", "settings", "ss", "conn", "params", "gs", "pg", "ns", "ms", "po", "ups", "cp", "os", "bs", "par", "posts", "qs", "pc", "vs", "eps", "ports", "ppa", "pa", "ins", "mp", "pps", "cs", "PS", "pr", "syn", "ls", "Ps", "pse", "sp", "ips", "details", "cases", "pos", "pp", "pi", "ds", "ts", "proxy", "p"]}}
{"id1": "10415388", "id2": "12728035", "code1": "    public static void copyFileNIO(String src, String dst) {\n        try {\n            FileChannel srcChannel = new FileInputStream(src).getChannel();\n            FileChannel dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "sb", "url", "input", "req", "upload", "download", "sit", "core", "conn", "http", "cdn", "loc", "href", "ruby", "stream", "sc", "archive", "config", "dest", "sub", "sup", "iv", "filename", "rc", "inst", "rs", "ls", "gb", "slice", "ssl", "sq", "dist", "conv", "img", "rb", "sl", "sci"], "dst": ["dsst", "datbl", "destop", "datset", "datstop", "dstop", "dub", "datsp", "dsstop", "dbset", "dest", "deput", "dbub", "dbst", "dbl", "dset", "dput", " dsp", "datub", "dsput", "datst", "dbsp", "debl", "dsbl", "dsp", " dset", " dub", "datput"], "srcChannel": ["instConnection", "instChannel", "srcchannel", "rcContext", "sourceChan", "rcChan", "destChan", " srcChan", "sourceContext", "instchannel", " srcConnection", "destchannel", "rcchannel", "srcChan", "rcChannel", "srcContext", "instChan", "destConnection", "rcConnection", "destChannel", " srcContext", " srcchannel", "sourcechannel", "sourceChannel", "srcConnection"], "dstChannel": ["dstsConnection", "ddestChan", "dstsChan", "ddestchannel", "Destchannel", "Ddestchannel", "dostChannel", "ddestChannel", "DstConnection", "drdChannel", "destChan", "ddestContext", "DstChan", "dostChan", "drestChannel", "dstContext", "DstChannel", "dostchannel", "ddestConnection", "destContext", "destchannel", "drdchannel", "dstChan", "DestContext", "DestConnection", "drestchannel", "DestChannel", "drdChan", "dstschannel", "drestContext", "drestChan", "destConnection", "DestChan", "DstContext", "destChannel", "Dstchannel", "DdestChan", "DdestChannel", "dstConnection", "dstchannel", "dstsChannel"]}}
{"id1": "18208567", "id2": "20177902", "code1": "    public void createPdf(final String eventURI) throws IOException, DocumentException {\n        createSections(eventURI);\n        even = false;\n        final Document document = new Document(Dimensions.getDimension(even, Dimension.MEDIABOX));\n        final PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(MyProperties.getOutput()));\n        writer.setViewerPreferences(PdfWriter.PageLayoutTwoColumnRight);\n        writer.setCropBoxSize(Dimensions.getDimension(even, Dimension.CROPBOX));\n        writer.setBoxSize(\"trim\", Dimensions.getDimension(even, Dimension.TRIMBOX));\n        writer.setBoxSize(\"bleed\", Dimensions.getDimension(even, Dimension.BLEEDBOX));\n        final EventBackgroundAndPageNumbers event = new EventBackgroundAndPageNumbers();\n        writer.setPageEvent(event);\n        document.open();\n        final PdfContentByte content = writer.getDirectContent();\n        event.setTabs(Index.INFO.getTab());\n        importPages(document, content, new PdfReader(Index.INFO.getOutput()), Index.INFO.getTitle());\n        importPages(document, content, MyProperties.getBefore(), event);\n        addAdPage(document, content);\n        PdfReader reader = new PdfReader(Presentations.INFO.getOutput());\n        String[] titles = { \"\", \"\" };\n        for (int i = 1; i <= reader.getNumberOfPages(); i++) {\n            titles = index.getSubtitle(titles, i);\n            event.setTabs(titles[0].toLowerCase());\n            addTitleLeft(content, Dimensions.getTitleArea(even), titles[0], MyFonts.TITLE);\n            addTitleRight(content, Dimensions.getTitleArea(even), titles[1], MyFonts.DATE);\n            content.addTemplate(writer.getImportedPage(reader, i), Dimensions.getOffsetX(even), Dimensions.getOffsetY(even));\n            document.newPage();\n            even = !even;\n        }\n        addAdPage(document, content);\n        importPages(document, content, MyProperties.getAfter(), event);\n        int total = writer.getPageNumber() - 1;\n        event.setNoMorePageNumbers();\n        event.setTabs(Schedules.INFO.getTab());\n        reader = new PdfReader(Schedules.INFO.getOutput());\n        for (int i = 1; i <= reader.getNumberOfPages(); i++) {\n            addTitleLeft(content, Dimensions.getTitleArea(even), Schedules.INFO.getTitle(), MyFonts.TITLE);\n            content.addTemplate(writer.getImportedPage(reader, i), Dimensions.getOffsetX(even), Dimensions.getOffsetY(even));\n            document.newPage();\n            even = !even;\n        }\n        document.close();\n        final File file = new File(MyProperties.getOutput());\n        final byte[] original = new byte[(int) file.length()];\n        final FileInputStream f = new FileInputStream(file);\n        f.read(original);\n        reader = new PdfReader(original);\n        final List<Integer> ranges = new ArrayList<Integer>();\n        for (int i = 1; i <= total; i++) {\n            ranges.add(i);\n            if (i == total / 2) {\n                for (int j = total + 1; j <= reader.getNumberOfPages(); j++) {\n                    ranges.add(j);\n                }\n            }\n        }\n        reader.selectPages(ranges);\n        final PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(MyProperties.getOutput()));\n        stamper.close();\n    }\n", "code2": "    public void execute(HttpServletRequest req, HttpServletResponse res, HttpServlet parent) throws Exception {\n        String path = req.getParameter(\"path\");\n        path = URLDecoder.decode(path, \"UTF-8\");\n        String name = req.getParameter(\"name\");\n        name = new String(name.getBytes(), \"UTF-8\");\n        String contentType = req.getParameter(\"contentType\");\n        if (path == null) {\n            NullPointerException e = new NullPointerException(\"The path attribute cannot be retrieved.\");\n            LOG.error(e);\n            throw e;\n        }\n        URL url = new URL(path);\n        InputStream inStream = null;\n        try {\n            inStream = URLUtils.getFileContent(url, req.getSession().getId());\n            res.setContentType(contentType);\n            res.addHeader(\"Content-Disposition\", \"attachment;filename=\\\"\" + name + \"\\\"\");\n            ServletOutputStream out = res.getOutputStream();\n            IOUtils.copy(inStream, out);\n            res.flushBuffer();\n        } finally {\n            if (inStream != null) {\n                inStream.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"eventURI": ["objectPI", "objecturi", "eventuri", "eventPath", "documentURI", "documentPath", "EventURL", "EventPath", " eventURL", "contentURI", "documentURL", "objectURI", "Eventuri", "eventPI", "documenturi", "EventURI", "objectURL", "contentPI", "contenturi", " eventPath", " eventuri", "eventURL", "contentURL", "EventPI"], "document": ["language", "paragraph", "page", "parent", "program", "url", "write", "office", "connection", "Document", "xml", "director", "layout", "function", "material", "output", "doc", "message", "object", "request", "console", "layer", "application", "data", "directory", "system", "feature", "server", "element", "word", "null", "image", "container", "instance", "initial", "session", "index", "media", "window", "node", "graph", "central", "html", "context", "expression", "ocument", "command", "addin", "header", "database", "valid", "video", "design", "sheet", "collection", "author"], "even": ["later", "month", "fall", "down", "now", "seven", "number", "multiple", "other", "company", "central", "numbered", "width", "only", "odd", "position", "one", "owner", "diff", "part", "below", "straight", "breaking", "pair", "update", "until", "mult", "four", "each", "floor", "zero", "self", "figure", "www", "existing", "except", "plus", "left", "none", "complete", "material", "ven", "common", "well", "section", "yet", "instead", "own", "record", "also", "front", "individual", "Even", "two", "correct", "output", "again", "single", "zen", "wrong", "production", "large", "initial", "enter", "character", "current", "west", "author", "high", "standard"], "writer": ["draw", "source", "page", "write", "layout", "office", "connection", "xml", "director", "buffer", "wire", "player", "function", "engine", "ws", "output", "widget", "format", "w", "driver", "client", "object", "layer", "data", "fe", "writers", "worker", "style", "work", "riter", "handler", "editor", "server", "creator", "resource", "element", "er", "script", "word", "e", "report", "parser", "instance", "Writer", "temp", "book", "window", "index", "context", "builder", "manager", "service", "design", "wan", "writing", "author", "wr", "journal", "entry"], "event": ["source", "page", "input", "user", "inc", "events", "layout", "connection", "xml", "player", "function", "ee", "message", "doc", "view", "format", "actual", "vent", "object", "driver", "request", "this", "age", "data", "stream", "class", "style", "resource", "handler", "archive", "config", "external", "inner", "info", "element", "update", "component", "e", "other", "instance", "comment", "index", "Event", "change", "image", "list", "node", "entity", "context", "attribute", "callback", "press", "type", "ce", "self", "form", "author", "entry"], "content": ["source", "page", "write", "layout", "connection", "cm", "xml", "Content", "player", "message", "output", "conn", "example", "view", "format", "client", "object", "css", "description", "driver", "request", "model", "console", "javascript", "loader", "layer", "data", "remote", "response", "resource", "ctx", "child", "handler", "condition", "server", "config", "activity", "section", "script", "component", "null", "body", "report", "pages", "cont", "container", "text", "comment", "lc", "temp", "session", "index", "media", "path", "image", "load", "context", "code", "current", "header", "cms", "value", "author", "entry"], "reader": ["source", "parent", "read", " read", "url", "input", "rar", " Reader", "Reader", "buffer", "director", " reading", "io", " library", " instance", "ler", "client", "driver", "row", "loader", "data", "r", "resource", "handler", "editor", "server", "info", "inner", "x", "er", "rer", " r", "rc", "report", "reading", "container", "parser", "df", "book", "index", "image", "uri", "context", "builder", " readers", "collection", "author", "entry"], "i": ["page", "id", "input", "url", "si", "d", "multi", "qi", "uli", "iu", "phi", "hi", "io", "k", "yi", "l", "di", "bi", "zi", "n", "I", "mu", "ti", "oi", "ai", "info", "gi", "ji", "x", "r", "name", "init", "it", "ui", "ci", "u", "t", "ini", "a", "m", "li", "v", "xi", "ri", "index", "count", "slice", "image", "pointer", "c", "uri", "ii", "pi", "is", "fi", "chi", "z", "mini", "ip", "p", "type"], "titles": ["tystrings", "tyributes", "ttsections", " tstrings", "intps", "tps", "tycriptions", "inttitle", " tumbers", "ttails", "Tasks", " ttitle", "intls", " tsections", "Tls", "Titles", "tsections", "Tstrings", " tales", "ttels", "ttitles", "pales", "ttrees", "pasks", "tappings", " tps", "tyitles", "ttributes", "ttappings", "ytels", "tls", "ytacters", "intstrings", "tales", " trees", "Ttitle", "intumbers", "sels", "tacters", "tumbers", "sappings", "ytappings", "pls", "ytails", " tls", "intitles", "sails", "Tales", "ytps", " tasks", " tributes", " tcriptions", "trees", " tacters", "tstrings", "Trees", "tasks", "tcriptions", "ttstrings", "pitles", "intacters", "ttitle", "sitles", "tails", "ytitles", "ytumbers", "ttcriptions", "tributes", "tels", "Tsections", "ttls"]}}
{"id1": "19641321", "id2": "16885088", "code1": "    public void testUnavailable() throws Exception {\n        URL url = null;\n        url = new URL(\"http://127.0.0.1:\" + connector.getLocalPort() + \"/test/dump/info?query=foo\");\n        assertTrue(IO.toString(url.openStream()).startsWith(\"<html>\"));\n        assertTrue(context.getServletHandler().isAvailable());\n        url = new URL(\"http://127.0.0.1:\" + connector.getLocalPort() + \"/test/dump/ex2/2\");\n        try {\n            IO.toString(url.openStream());\n        } catch (IOException e) {\n        }\n        assertFalse(context.getServletHandler().isAvailable());\n        Thread.sleep(4000);\n        assertTrue(context.getServletHandler().isAvailable());\n    }\n", "code2": "    private static void getClasses(Collection<Class<?>> classes, String... packageNames) throws ClassNotFoundException {\n        boolean recursive = true;\n        for (String packageName : packageNames) {\n            if (StringUtil.isEmpty(packageName)) continue;\n            String packageDirName = packageName.replace('.', '/');\n            Enumeration<URL> dirs = null;\n            try {\n                dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);\n                while (dirs.hasMoreElements()) {\n                    URL url = dirs.nextElement();\n                    String protocol = url.getProtocol();\n                    if (\"file\".equals(protocol)) {\n                        String filePath = URLDecoder.decode(url.getFile(), DECODING);\n                        getClassesByPackageFile(packageName, filePath, recursive, classes);\n                    } else if (\"jar\".equals(protocol)) {\n                        JarFile jar = null;\n                        try {\n                            jar = ((JarURLConnection) url.openConnection()).getJarFile();\n                            Enumeration<JarEntry> entries = jar.entries();\n                            while (entries.hasMoreElements()) {\n                                JarEntry entry = entries.nextElement();\n                                String name = entry.getName();\n                                if (name.charAt(0) == '/') {\n                                    name = name.substring(1);\n                                }\n                                if (name.startsWith(packageDirName)) {\n                                    int idx = name.lastIndexOf('/');\n                                    if (idx != -1) {\n                                        packageName = name.substring(0, idx).replace('/', '.');\n                                    }\n                                    if ((idx != -1) || recursive) {\n                                        if (name.endsWith(JAVA_CLASS_SUFFIX) && !entry.isDirectory()) {\n                                            String className = name.substring(packageName.length() + 1, name.length() - 6);\n                                            classes.add(loadClass(packageName + '.' + className));\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (IOException e) {\n                            LOG.error(\"IOException when loading files from : \" + url, e);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                LOG.error(\"IOException when get classes from : \" + packageName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "route", "link", "browser", "connection", "feed", "buffer", "rel", "xml", "build", "ll", "result", "l", "lib", "http", "state", "bug", "lr", "base", "channel", "loader", "data", "loc", "f", "layer", "number", "resource", "org", "server", "address", "config", "ur", "gl", "event", "e", "bb", "ob", "log", "bel", "sl", "key", "string", "path", "image", "orb", "cache", "impl", "uri", "file", "ssl", "socket", "html", "URL", "service", "hub", "Url", "www", "blog", "proxy", "web", "str", "jar", "coll", "location", "entry"]}}
{"id1": "17306198", "id2": "19347071", "code1": "        private File createWorkingCopy(File _originalRawDataFile) {\n            File fOriginalRawDataFile = _originalRawDataFile;\n            File fWorkingCopy;\n            System.gc();\n            try {\n                fWorkingCopy = File.createTempFile(\"MZmine\", null);\n                FileChannel sourceChannel = new FileInputStream(fOriginalRawDataFile).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(fWorkingCopy).getChannel();\n                long sourceChannelPos = 0;\n                long sourceChannelSize = sourceChannel.size();\n                long maxReadSize = 5 * 1024 * 1024;\n                long targetChannelPos = 0;\n                while (sourceChannelPos < sourceChannelSize) {\n                    long transferAmount = maxReadSize;\n                    if (transferAmount > (sourceChannelSize - sourceChannelPos)) {\n                        transferAmount = sourceChannelSize - sourceChannelPos;\n                    }\n                    sourceChannel.transferTo(sourceChannelPos, transferAmount, destinationChannel);\n                    sourceChannelPos += transferAmount;\n                }\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (Exception ekse) {\n                Logger.put(\"NODE WORKER THREAD: ERROR - Failed to create working copy!\");\n                Logger.put(ekse.toString());\n                return null;\n            }\n            return fWorkingCopy;\n        }\n", "code2": "    private static List<String> loadServicesImplementations(final Class ofClass) {\n        List<String> result = new ArrayList<String>();\n        String override = System.getProperty(ofClass.getName());\n        if (override != null) {\n            result.add(override);\n        }\n        ClassLoader loader = ServiceLib.class.getClassLoader();\n        URL url = loader.getResource(\"META-INF/services/\" + ofClass.getName());\n        if (url == null) {\n            return result;\n        }\n        InputStream inStream = null;\n        InputStreamReader reader = null;\n        BufferedReader bReader = null;\n        try {\n            inStream = url.openStream();\n            reader = new InputStreamReader(inStream);\n            bReader = new BufferedReader(reader);\n            String line;\n            while ((line = bReader.readLine()) != null) {\n                if (!line.matches(\"\\\\s*(#.*)?\")) {\n                    result.add(line.trim());\n                }\n            }\n        } catch (IOException iox) {\n            LOG.log(Level.WARNING, \"Could not load services descriptor: \" + url.toString(), iox);\n        } finally {\n            finalClose(bReader);\n            finalClose(reader);\n            finalClose(inStream);\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"_originalRawDataFile": ["_originalRawdataFile", "_originalRawMetaFiles", "_originalInputInputFile", "_originalRawDataFiles", "_originalInputInputSource", "_originalRawdataPath", "_originalRawMetaSource", "_originalRawPartModel", "_originalInputInputFiles", "_originalRawPartFiles", "_originalRawDataSource", "_originalRawInputPath", "_originalInputDataFile", "_originalRawMetaFile", "_originalInputDataSource", "_originalInputInputPath", "_originalRawdataModel", "_originalRawPartFile", "_originalRawPartPath", "_originalInputDataPath", "_originalRawInputSource", "_originalRawMetaPath", "_originalRawDataPath", "_originalRawInputFile", "_originalRawInputFiles", "_originalRawdataFiles", "_originalInputDataFiles", "_originalRawDataModel"], "fOriginalRawDataFile": ["fOriginalRawByteFiles", "fOriginalOriginalRawFile", "fOriginalRawByteFile", "fOriginalRawPartStream", "fOriginalRawByteDirectory", "fOriginalRawPartFile", "fOriginalOriginalDataStream", "fOriginalRawMemoryStream", "fOriginalRawDataFiles", "fOriginalRawMemoryDirectory", "fOriginalRawByteStream", "fOriginalOriginalRawPlace", "fOriginalRawDataStream", "fOriginalOriginalDataFile", "fOriginalRawDataDirectory", "fOriginalRawMemoryFile", "fOriginalRawRawStream", "fOriginalRawPartPlace", "fOriginalOriginalRawStream", "fOriginalRawRawFiles", "fOriginalRawDataPlace", "fOriginalRawRawPlace", "fOriginalOriginalDataPlace", "fOriginalOriginalDataFiles", "fOriginalRawMemoryFiles", "fOriginalOriginalRawFiles", "fOriginalRawRawFile", "fOriginalRawPartFiles"], "fWorkingCopy": ["fRunningCopy", "fWorkcopy", "fworkingcopy", " fWorkingTransfer", "FWorkingTransfer", "fWorkCop", "fReadingTransfer", "fPlayingTransfer", "fPlayingCopy", "fCallingCopy", "fworkingCopy", "fWorkingTransfer", " fWorkingFile", "fReadingcopy", "fCallingTransfer", "fRunningCop", "fPowerCop", "FWorkingCopy", "fReadingCopy", "FworkingCopy", " fWorkingCop", " fworkingTransfer", "fWorkCopy", "fRunningTransfer", "fWorkingFile", "fPlayingcopy", " fworkingCop", "fPowercopy", "fCallingcopy", "Fworkingcopy", "fReadingCop", " fWorkingcopy", "fWorkFile", "fworkingCop", "fworkingTransfer", "fPowerCopy", "fworkingFile", "fCallingCop", "fWorkTransfer", "FWorkingcopy", "FworkingTransfer", "fPowerFile", " fworkingFile", "fRunningcopy", "fWorkingCop", "fWorkingcopy", " fworkingcopy", " fworkingCopy"], "sourceChannel": ["sourceConnection", " sourceStream", "targetStream", "ourceService", "SourceSocket", " sourceChan", " sourceService", "sourceChan", "ourceConnection", "resourceChannel", "Sourcechannel", "sourceSocket", " sourceConnection", "srcChan", "ourceChan", "SourceService", "targetChan", "targetConnection", "resourceConnection", "targetchannel", "ourceChannel", "SourceConnection", "srcChannel", "resourceSocket", "ourceSocket", "SourceChan", "resourceChan", "srcStream", "sourceService", "sourcechannel", "srcConnection", "targetService", "sourceStream", "SourceChannel", " sourcechannel", "targetChannel"], "destinationChannel": ["destructionConnection", "destinatorChannel", "destiningChan", "destationConnection", "destructionChannel", "destationChannel", "destinationConnection", "destinationchannel", "destinatingFile", "DestinatorChan", "DestinatingChannel", "DestinationFile", "destructionChan", "destributionConnection", "destinationFile", "DestinationChan", "DestinatorChannel", "destiningConnection", "destributionchannel", "destributionFile", "DestinationChannel", "destinatorChan", "DestinationConnection", "Destinationchannel", "destiningChannel", "DestinatingFile", "DestinatingConnection", "destinatingConnection", "destributionChan", "destinatorConnection", "destinatorFile", "destributionChannel", "Destinatingchannel", "destinatingChan", "destationChan", "DestinatorConnection", "destinatingChannel", "destinatingchannel", "destiningchannel", "DestinatingChan", "destinationChan"], "sourceChannelPos": ["targetChanpos", "sourceChanPosition", "sourceStreamSize", "sourceCharPos", "sourceChanPos", "sourceStreamDef", "sourceChannelOffset", "targetChanPosition", "sourceChanLen", "sourceLineOffset", "sourceLinePosition", "sourceQueueSize", "sourcechannelSize", "targetChannelLen", "sourcechannelLength", "targetChanSource", "targetchannelLength", "targetChannelPort", "targetChannelpos", " sourceChannelDef", "sourceQueueLength", "sourceQueuePosition", " sourceQueuePos", "sourceChannelDef", "sourceChannelSource", "sourceStreamLen", "sourceCharPosition", "sourceChannelPort", " sourceQueueLen", "sourcechannelSource", "targetchannelPos", "targetchannelOffset", "sourceChanpos", "sourceBytePos", "sourceQueueLen", "sourceContextPosition", "sourceChannelLen", "targetChannelPosition", "sourcechannelPos", "sourceChannelpos", "sourceCharSize", "targetchannelSize", "sourceCharOffset", " sourceQueueDef", "targetChanSize", "sourceChanSource", "sourceChannelPosition", " sourceChannelLen", "sourceQueuePos", "sourceContextOffset", "sourceStreamLength", "targetChanLen", "sourcechannelOffset", "targetchannelPosition", "sourceChannelLength", "targetchannelPort", "sourceContextPos", "sourceStreamPos", "sourceChanDef", " sourceQueuePosition", "sourceChanOffset", "targetChanOffset", "sourceQueueDef", "sourcechannelpos", "sourceLinePos", "sourceContextPort", "sourceByteLen", "targetChannelOffset", "sourcechannelPort", "targetChannelSource", "targetChanPos", "sourceChanSize", "sourcechannelPosition", "sourceLineLen", "targetChannelLength", "sourceBytePosition", "sourceStreamPosition", "sourceByteOffset", "sourceChanPort", "targetChannelSize", " sourceChannelPosition"], "sourceChannelSize": ["sourceQueueLength", " sourcechannelNum", "sourceSectionPos", "sourceColumnPos", "sourceChanOffset", "targetQueueLen", "targetQueueLength", "sourceColumnSize", " sourceChanPos", "sourcechannelPos", "sourceSectionLen", " sourceChannelLength", "targetFileLength", "sourceChanPos", "sourceColumnOffset", "targetFileLen", "sourcechannelNum", " sourceChannelNum", "targetFileSize", "sourceChannelOffset", "sourcePagePos", " sourceChannelOffset", " sourceChannelLen", "targetQueueSize", "sourcePageSize", "sourceQueuePos", "sourceChanLen", " sourcechannelPos", "sourceQueueSize", "targetQueuePos", "sourceSectionLength", "sourceColumnLen", "targetFilePos", "sourceQueueOffset", " sourceChanLen", "sourcechannelSize", "sourceChanSize", " sourceChanSize", "sourceChanLength", "sourceChannelNum", "targetChannelLen", "sourceChanNum", " sourceChanOffset", "sourcechannelLength", "targetChannelLength", "sourceFileLength", "sourceChannelLength", " sourcechannelLength", "sourceQueueLen", "sourceFilePos", "sourcePageLength", "sourceSectionSize", "targetChannelSize", " sourcechannelSize", "sourceFileSize", "sourceChannelLen", "sourcePageLen", "sourceFileLen"], "maxReadSize": ["maxReadingCount", "maxReadLength", " maxWriteLength", "maxTransferCount", "maxReadingSize", " maxReadLength", "maxWriteCount", "maxReaderLen", "maxWriteSize", "maxreadLength", " maxReadingLength", " maxReadingLen", "maxReadLen", " maxReadingCount", "maxReaderSize", "maxReaderLength", " maxReadLen", "maxreadSize", "maxTransferLen", "maxWriteLength", "maxTransferTime", " maxWriteCount", " maxWriteTime", " maxReadCount", " maxWriteSize", "maxWriteTime", "maxReadingLen", " maxReadingSize", "maxTransferSize", " maxReadTime", "maxTransferLength", "maxReadCount", "maxreadTime", "maxReadingLength", "maxreadCount", "maxReaderCount", "maxReadTime"], "targetChannelPos": ["targetChannelPosition", "sourceConnectionPos", "targetChanOffset", "targetConnectionSize", "targetSectionSize", "sourceChannelOffset", "sourceConnectionSize", "targetChanSize", "sourceChannelPosition", "targetChanPosition", "targetSectionPos", "targetChannelOffset", "targetSectionPosition", "targetConnectionPos", "targetConnectionOffset", "targetChanPos", "sourceConnectionOffset", "targetConnectionPosition", "targetSectionOffset", "sourceConnectionPosition", "targetChannelSize"], "transferAmount": [" transferSize", " transferFactor", "transferOffset", "readLength", "importCount", "transferLength", "transferRate", "downloadSize", "loadAmount", "referenceAmount", "readOffset", "transferSize", "downloadAmount", "loadNumber", "readAmount", "importAmount", "transferAddress", "referenceOffset", "loadLength", "transferCount", "loadOffset", "readRate", " transferNumber", " transferCount", "downloadFactor", "importOffset", "importNumber", "referenceAddress", "transferFactor", "importFactor", "importSize", "transferNumber", " transferLength", "downloadNumber", " transferAddress", "downloadRate", "downloadAddress", "downloadCount", " transferRate", "downloadOffset", " transferOffset", "downloadLength"]}}
{"id1": "3109016", "id2": "19703581", "code1": "    private void copySon(File parent) {\n        System.out.println(\"parent---\" + parent.getAbsolutePath());\n        if (parent.isDirectory() && !\".svn\".equals(parent.getName())) {\n            File cases = new File(parent, \"cases\");\n            if (cases.exists()) {\n                File answers = new File(parent, \"answers\");\n                if (!answers.exists()) {\n                    answers.mkdir();\n                    File answers_linux = new File(parent, \"answers_linux\");\n                    for (File file : answers_linux.listFiles()) {\n                        if (file.isDirectory()) {\n                            continue;\n                        }\n                        File target = new File(answers, file.getName());\n                        try {\n                            IOUtils.copy(new FileInputStream(file), new FileOutputStream(target));\n                        } catch (Throwable t) {\n                            t.printStackTrace();\n                        }\n                    }\n                }\n            } else {\n                for (File son : parent.listFiles()) {\n                    System.out.println(\"parent---\" + son.getAbsolutePath());\n                    copySon(son);\n                }\n            }\n        }\n    }\n", "code2": "    private String hashPassword(String password) {\n        if (password != null && password.trim().length() > 0) {\n            try {\n                MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n                md5.update(password.trim().getBytes());\n                BigInteger hash = new BigInteger(1, md5.digest());\n                return hash.toString(16);\n            } catch (NoSuchAlgorithmException nsae) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"parent": ["contract", "parents", "python", "home", "father", "model", "directory", "mac", "name", "temp", "central", "plant", "create", "mount", "project", "location", "Parent", "folder", "closure", "one", "object", "app", "part", "to", "remote", "child", "shape", "script", "tax", "instance", "point", "c", "self", "ca", "ps", "copy", "port", "source", "draw", "mother", "complete", "function", "example", "this", "client", "request", "fat", "testing", "filename", "path", "context", "valid", "null", "fork", "p", "host", "anc", "connection", "out", "root", "config", "children", "ppa", "pa", "large", "container", "content", "document", "current", "form", "test", "unit"], "cases": ["options", "tests", "comments", "cells", "test", "closure", "reports", "events", "acts", "pes", "sections", "settings", "lines", "packs", "parents", "cas", "books", "app", "types", "ca", "ups", "ctx", "forms", "rooms", "cus", "devices", " tests", "ports", "ches", "phones", "plugins", "cs", "clips", "ls", "rules", "fits", "roots", "scripts", "les", "ops", "features", "thumbnails", "apps", "projects", "files", "aps", "times", "details", "videos", "modules", "project", "ps", "assets", "except"], "answers": ["annwerers", "answwers", "ansswerers", "ansiwERS", "anwered", "ansswars", "anewer", "answiner", "ansewERS", "anewars", "annwers", "annswerers", "ansswters", "ansiwers", "ansewered", "answars", "anwers", "answerers", "answered", "ansewering", "ansewerers", "anshwer", "annwered", "ansowered", "anwars", "ansowerers", "answwering", "ansactering", "annswer", "anewers", "answiners", "answERS", "answering", "ansewer", "anwters", "ansacter", "ansowers", "anwerers", "ansswERS", "ansactered", "ansewars", "anshwering", "answinters", "answinering", "ansiwerers", "answwer", "ansswered", "anshwers", "anwERS", "ansiwer", "anshwars", "ansswering", "anewering", "answer", "anwer", "annwer", "ansswer", "anwering", "annswers", "annswered", "ansewers", "answters", "ansacters", "answwters", "ansswers", "ansower"], "answers_linux": ["answERS_linux", "answer_ux", "answers_ux", "answer_Linux", "answers_cross", "answer_linux", "answERS_lite", "answers_lite", "answer_lite", "answers_Linux", "answers_windows", "answer_windows", "answERS_windows", "answERS_cross"], "file": ["source", "get", "folder", "id", "ile", "url", "queue", "pe", "place", "connection", "build", "function", "File", "l", "lib", "http", "object", "b", "part", "f", "base", "profile", "layer", "fe", "future", "class", "single", "handler", "child", "el", "module", "er", "force", "name", "filename", "it", "full", "dir", "php", "unit", "per", "log", "cl", "comment", "le", "il", "path", "rule", "entity", "socket", " File", "files", "local", "FILE", "et", "test", "line", "use", "type"], "target": ["source", "next", "site", "test", "tor", "connection", "settings", "result", "top", "output", "conn", "object", "client", "driver", "root", "model", "base", "remote", "resource", "master", "match", "child", "external", "shadow", "dest", "bean", "Target", "event", "project", "session", "path", "point", "socket", "support", "goal", "local", "tail", "manager", "proxy", "platform", "value", "location", "unit"], "son": ["source", "select", "sel", "su", "pe", "token", "tor", "phone", "xml", "ton", "conn", "one", "fruit", "sw", "object", "client", "age", "model", "loc", "jack", "directory", "osa", "single", "zip", "Son", "os", "ass", "child", "oss", "pa", "json", "ion", "mos", "se", "kin", "port", "document", "node", "don", "db", "person", "service", "local", "create", "SON", "sn", "project", "test", "two", "collection", "null", "unit"]}}
{"id1": "2654261", "id2": "339340", "code1": "    public char check(String password) {\n        if (captchaRandom.equals(\"null\")) {\n            return 's';\n        }\n        if (captchaRandom.equals(\"used\")) {\n            return 'm';\n        }\n        String encryptionBase = secret + captchaRandom;\n        if (!alphabet.equals(ALPHABET_DEFAULT) || letters != LETTERS_DEFAULT) {\n            encryptionBase += \":\" + alphabet + \":\" + letters;\n        }\n        MessageDigest md5;\n        byte[] digest = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(encryptionBase.getBytes());\n            digest = md5.digest();\n        } catch (NoSuchAlgorithmException e) {\n        }\n        String correctPassword = \"\";\n        int index;\n        for (int i = 0; i < letters; i++) {\n            index = (digest[i] + 256) % 256 % alphabet.length();\n            correctPassword += alphabet.substring(index, index + 1);\n        }\n        if (!password.equals(correctPassword)) {\n            return 'w';\n        } else {\n            captchaRandom = \"used\";\n            return 't';\n        }\n    }\n", "code2": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"password": [" Password", "parent", "input", "user", "token", "auth", "fax", "sword", "username", "wd", "description", "root", "channel", "number", "data", "phrase", "enc", "email", "config", "random", "word", "name", " passwords", "pattern", "ion", "text", "words", "key", "string", "path", "seed", "encrypted", "code", "command", "attribute", "secret", "Password", "value", "padding", "pass"], "encryptionBase": ["encryptBase", "enotiationbase", "EncryptedSecret", "encorshipBase", "enryptionArea", "encgorithmBase", "encryptBuffer", "encryptionBuffer", "enryptionbase", "enoverybase", "encgorithmReal", "enotiationArea", "enoveryUnit", "EncryptionSecret", "encgorithmbase", "encoveryBuffer", "encoveryBase", "encryptionUnit", "encotationBase", "EncryptionBase", "encryptbase", "encryptKit", "encgorithmArea", "EncryptedBase", "encryptionKey", "encryptKey", "EncryptedKey", "encryptedSecret", "encryptedBase", "encotationbase", "enoveryBuffer", "EncryptionKit", "encorshipbase", "EncryptedKit", "encipherSecret", "encryptionbase", "enoveryBase", "encotationUnit", "enotiationReal", "encipherBase", "encipherKey", "encryptionSecret", "encotiationArea", "enryptionBase", "encotiationBase", "encotiationbase", "enryptionUnit", "EncryptionKey", "encryptedKit", "encotiationReal", "encryptionKit", "encorshipReal", "encotationBuffer", "encryptSecret", "encryptedKey", "encoverybase", "encoveryUnit", "enotiationBase", "encipherKit", "encryptUnit", "enryptionBuffer", "encorshipArea", "encryptionArea", "enryptionReal", "encryptionReal"], "md5": ["MDpe", "sha5", "dig2", "MD6", " MDpe", " md1", " MD512", " mdpe", "shadown", "mdpe", " MD2", "MD1", "MD5", "MDdown", " MD5", "MD512", "dig512", "digdown", "md1", "sha1", "mddown", "md512", "sha512", "md6", "MD2", "dig6", "dig1", "md2", "sha2", " md2", " md6", " md512", "dig5"], "digest": ["Diger", "mdester", "dedEST", "digester", "digests", "expests", "DigEST", "modest", " digests", "mdest", "modested", "digense", "diger", "dedest", " digace", "moder", "digEST", " digense", "Digester", "Digested", " digEST", "mdense", "dedense", "expest", "digace", "expester", "dedester", " digester", "mdace", "modEST", "digested", " diger", " digested", "Digests", "Digace", "Digest", "expEST", "mdEST"], "index": ["page", "div", "left", "size", "id", "active", "none", "num", "inc", "default", "si", "connection", "ind", "iter", "output", "weight", "digit", "alpha", "object", "end", "val", "diff", "f", "number", "loc", "data", "find", "address", "info", "condition", "second", "element", "x", "update", "ix", "exp", "length", "ini", "key", "offset", "path", "change", "point", "pointer", "j", "slice", "col", "expression", "width", "oct", "Index", "pos", "zero", "tail", "start", "position", "value", "exit"], "i": ["id", "num", "si", "qi", "multi", "iu", "phi", "io", "hi", "l", "f", "di", "n", "bi", "mu", "I", "ti", "ni", "ji", "info", "ai", "gi", "oi", "x", "ix", "ui", "ci", "u", "o", "e", "ini", "li", "v", "key", "xi", "wei", "j", "c", "uri", "ii", "pi", "chi", "z", "uni", "ip", "p", "ie"], "correctPassword": ["completeSecret", "validPass", "wrongPassword", "wrongpassword", "orrectPass", " correctPass", "completeString", "validpassword", "CorrectString", "orrectpassword", "wrongText", "completepassword", " correctPage", "orrectPage", "orrectSecret", "CorrectSecret", "CorrectText", "correctpassword", "Correctpassword", "validPassword", "correctText", "correctPass", "correctSecret", " correctpassword", "wrongString", "completePassword", "CorrectPass", "validPage", "correctPage", "completeText", "CorrectPassword", "completePass", "orrectPassword", "correctString"], "captchaRandom": ["CaptchaToken", "captureToken", "capturerandom", "captchatrandom", "captachaRoot", "captacharandom", "captondaRand", "captureSecret", "captchRand", "Capturerandom", "captchrandom", "CaptureToken", "captachaRandom", "captcharandom", "captachaToken", "CaptchaRandom", "CaptchaRand", "Captcharandom", "captchaRand", "captcherRoot", "captachaRand", "captcaRandom", "captcarandom", "captcherrandom", "CaptachaRandom", "Captacharandom", "CaptachaSecret", "CaptachaRand", "CaptachaRoot", "captcaRand", "captchRoot", "CaptureRandom", "captchaRoot", "captureRand", "captchatRand", "captachaSecret", "captcherRandom", "CaptchaRoot", "captchatRandom", "captchaToken", "CaptchaSecret", "captchRandom", "CaptureRand", "captureRandom", "captchToken", "captondaRandom", "captcherRand", "captchaSecret", "captondaSecret", "captondarandom"]}}
{"id1": "20725036", "id2": "2687277", "code1": "    private static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void copy(Reader reader, OutputStream outputs) throws IOException {\n        if (outputs == null) {\n            throw new NullPointerException();\n        }\n        if (reader == null) {\n            throw new NullPointerException();\n        }\n        ZipOutputStream zipoutputs = null;\n        try {\n            zipoutputs = new ZipOutputStream(outputs);\n            zipoutputs.putNextEntry(new ZipEntry(\"default\"));\n            IOUtils.copy(reader, zipoutputs);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw e;\n        } finally {\n            if (zipoutputs != null) {\n                zipoutputs.close();\n            }\n            if (reader != null) {\n                reader.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"sourceFile": ["sourceDir", "srcFiles", "sourceFolder", "srcfile", "srcFolder", "SourceFile", " sourceFiles", "SourceFolder", "sourcefile", "targetFiles", "targetfile", "sourceFiles", " sourceFolder", "targetFile", "Sourcefile", "srcFile", " sourcefile", "targetDir", " sourceDir", "srcDir", "SourceDir"], "destFile": ["sourceDir", "foreignPage", "srcFiles", "DestFiles", "DestPoint", "srcfile", "sourcePoint", "resultLine", "destFiles", " destFiles", "DestPage", "srcLine", "destDirectory", "destfile", "foreignFile", " destfile", "resultfile", "Destfile", " destPoint", "resultFile", "srcDirectory", "foreignDir", "DestDirectory", " destPage", "targetfile", "sourceFiles", "destDir", "destPoint", "srcDir", " destDirectory", "targetFile", "srcFile", "destLine", "foreignfile", "targetDir", " destDir", "destPage", "DestDir", "targetLine", "resultDir", "DestFile"], "source": ["get", "parent", "size", "id", "reader", "url", "input", "site", "route", "si", "connection", "reference", "core", "result", "iter", "output", "src", "from", "view", "this", "client", "Source", "object", "root", "channel", "table", "stream", "storage", "remote", "resource", "slave", "server", "ie", "config", "inner", "dest", "component", "scope", "target", "api", "ource", "session", "status", "SOURCE", "slice", "index", "sin", "image", "seed", "cache", "secure", "uri", "context", "file", "service", "current", "scene", "manager", "ce", "start", "proxy", "null", "use", "unit"], "destination": [" destinated", " destinator", "destinate", "domation", "Destinated", "distinated", "distruction", "distination", "identinating", "destinated", "dominator", "generinator", "generination", "Destinate", "partinated", " destion", "generruction", " destinate", "Destion", "Destinator", "identination", "Destruction", "destruction", "domination", "generinated", "identinator", " destruction", " destation", "partruction", "Destation", "destion", "destinating", "Destinating", "partination", "identinate", "destinator", " destinating", "distinator", "distion", "destation", "partinator", "dominated", "Destination"]}}
{"id1": "8043909", "id2": "390730", "code1": "    public static void main(String[] args) {\n        try {\n            String data = URLEncoder.encode(\"page\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"admin\", \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"nick\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"k\", \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"asdf\", \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"login\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"1\", \"UTF-8\");\n            URL url = new URL(\"http://localhost:80/test/index.php\");\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = rd.readLine()) != null) {\n                System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void test(String args[]) {\n        int trace;\n        int bytes_read = 0;\n        int last_contentLenght = 0;\n        try {\n            BufferedReader reader;\n            URL url;\n            url = new URL(args[0]);\n            URLConnection istream = url.openConnection();\n            last_contentLenght = istream.getContentLength();\n            reader = new BufferedReader(new InputStreamReader(istream.getInputStream()));\n            System.out.println(url.toString());\n            String line;\n            trace = t2pNewTrace();\n            while ((line = reader.readLine()) != null) {\n                bytes_read = bytes_read + line.length() + 1;\n                t2pProcessLine(trace, line);\n            }\n            t2pHandleEventPairs(trace);\n            t2pSort(trace, 0);\n            t2pExportTrace(trace, new String(\"pngtest2.png\"), 1000, 700, (float) 0, (float) 33);\n            t2pExportTrace(trace, new String(\"pngtest3.png\"), 1000, 700, (float) 2.3, (float) 2.44);\n            System.out.println(\"Press any key to contiune read from stream !!!\");\n            System.out.println(t2pGetProcessName(trace, 0));\n            System.in.read();\n            istream = url.openConnection();\n            if (last_contentLenght != istream.getContentLength()) {\n                istream = url.openConnection();\n                istream.setRequestProperty(\"Range\", \"bytes=\" + Integer.toString(bytes_read) + \"-\");\n                System.out.println(Integer.toString(istream.getContentLength()));\n                reader = new BufferedReader(new InputStreamReader(istream.getInputStream()));\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                    t2pProcessLine(trace, line);\n                }\n            } else System.out.println(\"File not changed !\");\n            t2pDeleteTrace(trace);\n        } catch (MalformedURLException e) {\n            System.out.println(\"MalformedURLException !!!\");\n        } catch (IOException e) {\n            System.out.println(\"File not found \" + args[0]);\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"data": ["next", "page", "div", "reader", "plain", "input", "write", "la", "layout", "feed", "buffer", "dd", "with", "result", "function", "message", "output", "format", "one", "alpha", "stuff", "wa", "part", "base", "ata", "no", "style", "response", "zip", "raw", "config", "info", "update", "script", "action", "name", "body", "it", "ui", "DATA", "da", "json", "api", "text", "partial", "content", "li", "done", "key", "string", "media", "html", "uri", "i", "code", "map", "block", "empty", "add", "str", "dat", "ad", "p", "type"], "url": ["host", "link", "connection", "open", "ll", "l", "http", "client", "fr", "loc", "ctrl", "r", "org", "server", "address", "cur", "ur", "ob", "fl", "string", "path", "image", "rl", "impl", "socket", "uri", "file", "ssl", "db", "URL", "Url", "www", "blog", "web", "jar", "coll", "sl"], "conn": ["dc", "cb", "nn", "connection", "net", "open", "nw", "co", "ws", "ct", "http", "con", "w", "out", "client", "fr", "loc", "cp", "n", "r", "enc", "ctx", "org", "server", "serv", "comm", "mc", "cn", "exec", "sync", "cur", "oss", "ci", "rc", "nt", "act", "coll", "ch", "ann", "col", "cr", "connect", "c", "socket", "db", "rt", "ssl", "conv", "Connection", "Conn", "nc", "cmp", "p"], "wr": ["WR", "rx", "wal", "arr", "nw", "wx", "w", "wd", "sw", "wa", "fd", "fr", "fw", "r", "Wr", "wm", "riter", "writer", "wer", "wp", "sr", "pr", "rh", "dr", "Writer", "hr", "vr", "cr", "rw", "rt", "mr", "wb", "ww", "war", "wy", "rr", "raft", "RW", "usr", "wt"], "rd": ["reader", "dc", "rf", "ru", "cd", "ra", "rx", "d", "bh", "dig", "ld", "rera", "xd", "ws", "rss", "pd", "src", "wd", "fd", "lr", "fr", "rn", "bd", "r", "rob", "rg", "writer", "rc", "rm", "dh", "rs", "rod", "sr", "rh", "dr", "hr", "adr", "RD", "vr", "cr", "rl", "rw", "rt", "rid", "mr", "db", "rr", "ds", "dra", "rb"], "line": ["source", "page", "sel", "reader", "value", "link", "user", "pe", "lf", "lines", "message", "l", "letter", "one", "out", "object", "b", "char", "LINE", "cell", "end", "Line", "row", "column", "number", "model", "no", "part", "inline", "n", "r", "response", "el", "sync", "name", "ge", "e", "unit", "log", "cl", "non", "text", "comment", "lc", "job", "key", "le", "string", "rule", "pass", "code", "i", "character", "block", "lin", "str", "sl", "entry"]}}
{"id1": "238176", "id2": "10697587", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFileNIO(File in, File out) throws IOException {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(in);\n            fos = new FileOutputStream(out);\n            FileChannel sourceChannel = fis.getChannel();\n            FileChannel targetChannel = fos.getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace(System.out);\n            }\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace(System.out);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "RC", "reader", "sb", "tmp", "url", "input", "proc", "cb", "req", "upload", "SourceFile", "dep", "download", "sth", "sit", "username", "fp", "Source", "supp", "st", "loc", "cpp", "href", "ref", "stream", "storage", "resource", "sc", "ctx", "config", "filename", "name", "component", "rc", "inst", "prot", "feat", "gn", "spec", "fn", "ource", "Dest", "buf", "back", "sin", "gb", "slice", "sec", "path", "gz", "string", "rl", "obj", "load", "uri", "ssl", "file", "secure", "code", "impl", "vr", "dist", "img", "sn", "s", "rb", "cmp", "sl"], "dest": ["source", "tmp", "dc", "txt", "disk", "lib", "home", " destination", "std", "di", "class", "dir", "target", "cont", "fn", "Dest", "temp", "orig", "path", "obj", "wb", "dist", " dst", "img", "bin", "dat", "null"], "in": ["source", "reader", "input", "inc", "din", "d", "win", "io", "doc", "inf", "val", "login", "f", "as", "data", "In", "pin", "stream", "n", "r", "inas", "isin", "ins", "t", "ini", "a", "ex", "up", "file", "i", "IN", "err", "inn", "is", "bin", "ps", "pass"], "p": ["lp", "cop", "bp", "py", "h", "P", "d", "pe", "jp", "pb", "pd", "l", "pre", "fp", "pg", "b", "part", "f", "po", "cp", "wp", "pc", "tp", "pa", "o", "s", "e", "per", "t", "parser", "pr", "m", "v", "pm", "sp", "c", "j", "i", "np", "pp", "g", "pi", "ps", "op"], "ds": ["hs", "d", "dd", "ils", "ld", "lines", "tools", "ns", "bs", "DS", "dp", "sys", "vs", "eps", "sync", "dt", "da", "cs", "ls", "ays", "dist", "ts", "ys", " DS", "pd", " ps", "os", "posts", "models", "cons", "ins", "dm", "els", "scripts", "sts", "dates", "nas", "ps", "dl", "dc", "Ds", "points", "ss", "gs", "styles", "ups", "dos", "qs", "js", " props", "rs", "df", "words", "docs", "utils", "vals", "ans", " sd", "s", "lp", "tests", "ks", " db", "des", "ded", "ws", "gd", "cdn", "ads", "data", "di", "xs", "plugins", "dds", "icks", " dd", "amps", "ants", "db", "parts", "obs", "dat", "uds"], "format": ["source", "language", "host", "url", "ant", "Format", "layout", "xml", "plugin", "function", "scale", "letter", "fp", "object", "fd", "model", "part", "f", "magic", "data", "table", "version", "class", "style", "match", "handler", "prefix", "config", "template", "tag", "filename", "name", "pattern", "feat", "unit", "spec", "fn", "parser", "t", "atter", "api", "act", "frame", "string", "path", "file", "record", "struct", "nat", "sche", "at", "form", "filter", "type"], "hasPixelData": ["haspixelStyle", "hasPicturedata", "hasByteSize", "hasPicOps", " hasPixelStyle", "hasPixelStyle", "hasBytedata", "hasPictureDATA", "hasPicStyle", "hasPicData", "haspixelOps", "hasByteData", " hasPixelSize", "hasPictureData", " hasPixeldata", " hasPixelDATA", "haspixeldata", "haspixelDATA", "haspixelData", " hasPixelOps", "hasPixelSize", "hasPixelOps", "hasPixeldata", "hasPixelDATA", "haspixelSize"], "inflate": ["inflocate", " informate", " inflase", "infolate", "uninfloute", "inFlate", "infloase", "incollute", "incollocate", "infloation", "infloame", "incollame", "inFlation", "uninflate", " informase", "inFlATE", "inflATE", " inflation", "uninfloame", " informATE", "informase", "inflase", "infolocate", "incollate", "inflame", "uninfloocate", "information", "infolute", " inflATE", "inflation", " information", "infloATE", "uninflocate", "informate", "infloate", "infolame", "uninflute", "infloute", "uninfloate", "uninflame", "influte", "informATE", "infloocate", "inFlase"], "pxlen": ["pxlength", "xpval", "pxval", "cpl", "pnglen", "fxlength", "pyln", "xylen", "xplen", "cplen", "pglen", "ppln", "pglength", "pylen", "npfin", "pxden", "pgval", "nplin", "rxlen", "cpden", "pxlin", "pglf", "xplf", "pxfin", "cpln", "rxfin", "npden", "rxden", "pxln", "xplength", "pxl", "xyden", "pyden", "pngLen", "fxval", "ppLen", "ppden", "pplen", "pxlf", "xylin", "pyl", "nplen", "pngln", "rxlin", "fxl", "pngden", "fxlf", "fxden", "pxLen", "xyfin", "fxlen", "xyln", "fxln", "xyLen"], "out": ["page", "parent", "user", "io", "output", "conn", "lib", "dump", "gen", "base", "again", "OUT", "Out", "outs", "work", "server", "print", "re", "prefix", "sys", "inter", "step", "log", "cli", "post", "v", "up", "session", "point", "list", "obj", "lock", "cache", "error", "code", "err", "group", "store", "copy", "line"]}}
{"id1": "20725036", "id2": "2391245", "code1": "    private static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public ObjectInputStream sendObject(String sMethod, Serializable obj) {\n        String sServlet = System.getProperty(\"servlet.jstat\");\n        if (sServlet != null) {\n            try {\n                URL url = new URL(sServlet);\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                conn.setUseCaches(false);\n                conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                ObjectOutputStream out = new ObjectOutputStream(conn.getOutputStream());\n                out.writeObject(sMethod);\n                out.writeObject(obj);\n                out.flush();\n                out.close();\n                return new ObjectInputStream(conn.getInputStream());\n            } catch (Exception exc) {\n                System.out.println(\"Error on SpaceJobRunner::sendObjectPOST() --> \" + exc);\n            }\n        } else {\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"sourceFile": ["sourceDir", "srcFiles", "sourceFolder", "srcfile", "srcFolder", "SourceFile", " sourceFiles", "SourceFolder", "sourcefile", "targetFiles", "targetfile", "sourceFiles", " sourceFolder", "targetFile", "Sourcefile", "srcFile", " sourcefile", "targetDir", " sourceDir", "srcDir", "SourceDir"], "destFile": ["sourceDir", "foreignPage", "srcFiles", "DestFiles", "DestPoint", "srcfile", "sourcePoint", "resultLine", "destFiles", " destFiles", "DestPage", "srcLine", "destDirectory", "destfile", "foreignFile", " destfile", "resultfile", "Destfile", " destPoint", "resultFile", "srcDirectory", "foreignDir", "DestDirectory", " destPage", "targetfile", "sourceFiles", "destDir", "destPoint", "srcDir", " destDirectory", "targetFile", "srcFile", "destLine", "foreignfile", "targetDir", " destDir", "destPage", "DestDir", "targetLine", "resultDir", "DestFile"], "source": ["get", "parent", "size", "id", "reader", "url", "input", "site", "route", "si", "connection", "reference", "core", "result", "iter", "output", "src", "from", "view", "this", "client", "Source", "object", "root", "channel", "table", "stream", "storage", "remote", "resource", "slave", "server", "ie", "config", "inner", "dest", "component", "scope", "target", "api", "ource", "session", "status", "SOURCE", "slice", "index", "sin", "image", "seed", "cache", "secure", "uri", "context", "file", "service", "current", "scene", "manager", "ce", "start", "proxy", "null", "use", "unit"], "destination": [" destinated", " destinator", "destinate", "domation", "Destinated", "distinated", "distruction", "distination", "identinating", "destinated", "dominator", "generinator", "generination", "Destinate", "partinated", " destion", "generruction", " destinate", "Destion", "Destinator", "identination", "Destruction", "destruction", "domination", "generinated", "identinator", " destruction", " destation", "partruction", "Destation", "destion", "destinating", "Destinating", "partination", "identinate", "destinator", " destinating", "distinator", "distion", "destation", "partinator", "dominated", "Destination"]}}
{"id1": "7464995", "id2": "19246986", "code1": "    @Override\n    public void excluir(QuestaoDiscursiva q) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"DELETE FROM questao WHERE id_questao=?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setInt(1, q.getIdQuestao());\n            stmt.executeUpdate();\n            conexao.commit();\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    private List<String> readDescriptor(URL url) {\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            List<String> lines = new ArrayList<String>();\n            String line = reader.readLine();\n            while (line != null) {\n                line = line.trim();\n                if (line.length() > 0 && !line.startsWith(\"#\")) lines.add(line);\n                line = reader.readLine();\n            }\n            return lines;\n        } catch (IOException e) {\n            throw new ExtensionException(\"Failed to read extension descriptor '%s'\", e).withArgs(url);\n        } finally {\n            IoUtil.closeQuietly(reader);\n        }\n    }\n", "label": 0, "substitutes": {"q": ["dq", "plus", "h", "queue", " Q", "qi", "req", "k", "Q", "que", "client", "ue", "f", "r", "qq", "ql", "qs", "query", "u", "e", "qu", "quant", "t", "a", "m", "iq", "v", "quest", "c", "g", "sq", "question", "qt", "z", "qa", "aq", "p", "quer", "type"], "stmt": ["slmd", "fql", " stql", "fbl", "Stsql", "Stmp", "Stcl", "slmt", " stsql", "stct", "strbl", "STsql", "Stmb", " stmd", "slbl", "STct", "fmt", " stct", " stbl", "stmp", "stmd", "rbl", " stcl", "stmb", "Stct", "rmb", "stbl", "strmt", "rmt", " stmp", "stcl", "Stbl", "fct", "STmp", "strql", "strct", "rmd", " stmb", "stql", "slcl", "Stmt", "Stmd", "STmt", "stsql"], "sql": ["select", "dl", "url", "nl", "msg", "function", "statement", "l", "params", "fp", "cmd", "zip", "ql", "where", "shell", "query", "s", "printf", "json", "QL", "log", "fn", "comment", "pr", "mt", "SQL", "ls", "seq", "string", "spr", "install", "db", "sol", "expression", "search", "sq", "database", " SQL", "expr", "str", "filter", "sl"]}}
{"id1": "20073617", "id2": "16324555", "code1": "    public static String digest(String pBase, String pCharSet) {\n        String wdgs = null;\n        try {\n            MessageDigest wmd = MessageDigest.getInstance(\"MD5\");\n            wmd.reset();\n            wmd.update(pBase.getBytes(pCharSet));\n            byte[] wdg = wmd.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < wdg.length; i++) {\n                String w_dup = Integer.toHexString(0xFF & wdg[i]);\n                if (w_dup.length() < 2) {\n                    w_dup = \"0\" + w_dup;\n                }\n                hexString.append(w_dup);\n            }\n            wdgs = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } finally {\n            return wdgs;\n        }\n    }\n", "code2": "    public static String gerarDigest(String mensagem) {\n        String mensagemCriptografada = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            System.out.println(\"Mensagem original: \" + mensagem);\n            md.update(mensagem.getBytes());\n            byte[] digest = md.digest();\n            mensagemCriptografada = converterBytesEmHexa(digest);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return mensagemCriptografada;\n    }\n", "label": 1, "substitutes": {"pBase": ["PBased", "Pbase", "dpBase", "pData", "PRest", "dpStart", "pRest", " pBased", "pBased", "pbase", "PStart", " pData", " pbase", "PBase", "prebase", "PData", "dpbase", "preBase", " pStart", "pStart", "dpData", " pRest", "preBased", "preRest"], "pCharSet": [" pCharacterset", "pBlockSet", "PCharacterList", " pCharList", "pCharList", "PCharacterSet", "pcharGen", "pCharacterset", "pBlockGen", "PCharGen", "pCharGen", "PCharList", "PCharset", " pCharset", "pCharacterSet", "pCharset", "pcharSet", " pCharacterSet", "pBlockset", "pcharset", "pCharacterGen", "PCharacterGen", "pCharacterList", " pCharacterList", "PCharSet", "pBlockList", "PCharacterset", "pcharList"], "wdgs": ["wrgs", "wgars", "wdges", "wGS", "wtgs", "widGS", "widgs", "wsgs", "wwgb", "wrls", "wsgars", "wngs", "wnls", "wwls", "wdps", "wnps", "wgs", "wdgars", "wwges", "wrgp", "wtls", "wges", "wrps", "wdgb", "wdls", "wgb", "wwgp", "widg", "wsGS", "wsg", "wtgb", "wtges", "wdgp", "wg", "wls", "wwps", "widgars", "wdGS", "wwgs", "wngp"], "wmd": ["kwmd", "Wmad", " wdd", "wmand", "wdmad", "awmand", "wddd", "Wmand", "wMD", "ewMD", "awmd", "wdmd", " wmad", "Wcmd", "Wpm", "kwdd", "kwMD", "wpm", "ewmd", "wcmd", "awMD", " wpm", "wdMD", "wmad", " wMD", "Wdd", "Wmd", "awcmd", "WMD", "wdd", " wmand", "ewpm", " wcmd", "kwcmd", "ewcmd"], "wdg": ["ddg", "wwga", "wsge", "wdga", "ddgs", "wsgs", "wnge", "wwgen", "wngs", "wsgp", "wardga", "wardgs", "wardgen", "WDgen", "wardi", "wardp", "wwp", "WDg", "wng", "wardg", "ddgp", "wdp", "wwg", "wdgen", "wdi", "dri", "wsg", "WDgs", "wdgp", "wdge", "WDp", "drga", "ddge", "drg", "drp", "wwi", "wwgs", "wngp"], "hexString": ["hexArray", "rawArray", "octInteger", "shortInteger", "wstring", "shortArray", "xfArray", "xfString", "wLine", "rawstring", "tempStr", "hexstring", "checkString", "rawLine", "shortBuffer", "hexBuffer", "octBuffer", " hexstring", " hexStr", "xfBuffer", "wArray", "hexInteger", "tempBuffer", "tempArray", "hexStr", "octString", "tempString", "checkInteger", "rawString", "xfStr", " hexBuffer", "checkBuffer", "checkArray", "octArray", "wString", "hexLine", " hexLine", " hexArray", "shortString"], "i": ["h", "id", "d", "si", "multi", "qi", "k", "io", "l", "w", "in", "b", "end", "f", "di", "n", "bi", "zi", "I", "ti", "oi", "ai", "gi", "x", "ix", "it", "ui", "u", "o", "e", "ci", "length", "t", "ini", "m", "li", "v", "xi", "ri", "index", "j", "c", "uri", "ii", "pi", "fi", "z", "s", "ip", "p"], "w_dup": ["w_def", "w_udp", "w_defp", "w_dupe", "w_sexf", "w_Ducp", "w_derpe", "w_purb", "w_udP", "w_dg", "w_dupa", "w_dug", "w__dispe", "w_dupi", "w_purpa", "w_dep", "w_trip", "w_depi", "w_derp", "w_Dub", "w_triper", "w_trilp", "w_delpa", "w_purp", "w_delb", "w_sexps", "w_trif", "w_disg", "w_udf", "w_discp", "w_duP", "w_deg", "w_sexp", "w_Dups", "w_dub", "w_Dupe", "w_df", "w_dellp", "w_udps", "w_deflp", "w_ducp", "w_purf", "w_dispi", "w__dup", "w_dp", "w_sexP", "w_delf", "w_delper", "w_duper", "w__discp", "w_dercp", "w_dpi", "w__ducp", "w_Duf", "w_dulp", "w_defper", "w_disp", "w_duf", "w_Dupa", "w_disf", "w_dispe", "w__disp", "w_delp", "w_deff", "w_dups", "w_derP", "w__dupe", "w_DuP", "w_Dup", "w__duP", "w__disP", "w_disP"]}}
{"id1": "3126811", "id2": "6150059", "code1": "    public static void saveProperties(Properties props, String comment, URL url) throws IOException {\n        if (props == null) throw new IllegalArgumentException();\n        if (url == null) throw new IllegalArgumentException();\n        OutputStream out = url.openConnection().getOutputStream();\n        props.store(out, comment);\n        out.close();\n    }\n", "code2": "    private void nioBuild() {\n        try {\n            final ByteBuffer buffer = ByteBuffer.allocateDirect(1024 * 4);\n            final FileChannel out = new FileOutputStream(dest).getChannel();\n            for (File part : parts) {\n                setState(part.getName(), BUILDING);\n                FileChannel in = new FileInputStream(part).getChannel();\n                while (in.read(buffer) > 0) {\n                    buffer.flip();\n                    written += out.write(buffer);\n                    buffer.clear();\n                }\n                in.close();\n            }\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"props": ["Properties", "proops", "proPS", "procs", "crocs", "prob", "comps", "peperties", "crops", "Proops", "Procs", "properties", "pebs", "propperties", "combs", "crobs", "propertiesperties", "comms", "ProPS", "Props", "propops", "propertiesPS", "peps", "propps", "propertiesb", "croops", "comperties", " properties", "propertiesps", "proms", "Prob", "pems", " proPS", "croms", "probs", "croperties", "propcs", " prob"], "comment": ["comments", "source", "not", "buffer", "message", "object", "end", "diff", "description", "bug", "model", "custom", "summary", "ref", "style", "comp", "child", "config", "info", "depth", "desc", "query", "project", "report", "param", "password", "text", "post", "pretty", "cache", "note", "error", "attribute", "block", "commit", "option", "reason", "Comment", "entry"], "url": ["source", "page", "id", "user", "browser", "feed", "rel", "buffer", "connection", "github", "io", "l", "ul", "http", "lib", "object", "client", "bug", "base", "ref", "resource", "server", "address", "config", "ur", "o", "ob", "log", "bel", "location", "job", "ls", "string", "path", "image", "rl", "impl", "uri", "file", "ssl", "URL", "service", "Url", "blog", "proxy", "gl", "null", "sl"], "out": ["source", "page", "parent", "plain", "user", "connection", "buffer", "png", "io", "output", "outer", "conn", "doc", "in", "client", "loader", "data", "OUT", "Out", "again", "outs", "resource", "server", "raw", "serv", "writer", "sync", "init", "o", "dot", "log", "flush", "password", "temp", "obj", "cache", "file", "socket", "err", "array", "bin", "copy", "null", "ext"]}}
{"id1": "13842042", "id2": "18519247", "code1": "    @Override\n    protected Properties loadFile(String fileName) {\n        Properties prop = new Properties();\n        try {\n            URL url = new File(fileName).toURI().toURL();\n            final InputStream input = url.openStream();\n            prop.load(input);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return prop;\n    }\n", "code2": "    public List<PathObject> fetchPath(PathObject parent) throws NetworkException {\n        if (parent.isFetched()) {\n            return parent.getChildren();\n        } else if (!\"d\".equals(parent.getType())) {\n            return null;\n        }\n        HttpClient client = HttpConfig.newInstance();\n        HttpGet get = new HttpGet(HttpConfig.bbsURL() + HttpConfig.BBS_0AN + parent.getPath());\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            Document doc = XmlOperator.readDocument(entity.getContent());\n            BBSBodyParseHelper.parsePathList(doc, parent);\n            return parent.getChildren();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"fileName": [" fileNames", " fileUrl", "fileFile", "FilePath", "fileUrl", "resourceFile", "urlPath", "urlParam", "FileParam", "FileNames", " fileFile", " filePath", "urlNames", "resourceUrl", " fileParam", "resourceName", "FileFile", "filePath", "FileName", "resourcePath", "fileParam", "FileUrl", "urlName", "fileNames"], "prop": ["cop", "parent", "tmp", "proc", "pot", "pkg", "jp", "pb", "properties", "params", "Prop", "owner", "bug", "part", "root", "data", "cp", "style", "comp", "config", "conf", "pa", "mp", " props", "prot", "report", "api", "buf", "temp", "pro", "obj", "parse", "property", "fb", "pos", "pp", "opt", "pi", "project", "ps", "op", "rb", "p"], "url": ["source", "host", "ball", "browser", "feed", "connection", "buffer", "plug", "io", "l", "http", "client", "b", "object", "f", "base", "data", "r", "resource", "server", "address", "config", "name", "e", "api", "ls", "string", "path", "image", "rl", "impl", "file", "uri", "ssl", "i", "URL", "Url", "blog", "jar", "sl"], "input": ["source", "reader", "str", "inc", "feed", "xml", "pull", "io", "output", "audio", "http", "out", "in", "inf", "this", "request", "client", "object", "f", "data", "stream", "resource", "raw", "config", "info", "exec", "Input", "flow", "act", "api", "text", "path", "obj", "impl", "ssl", "context", "i", "file", "service", "is", "form", "s", "ip"]}}
{"id1": "9046204", "id2": "119263", "code1": "    public static void makeLPKFile(String[] srcFilePath, String makeFilePath, LPKHeader header) {\n        FileOutputStream os = null;\n        DataOutputStream dos = null;\n        try {\n            LPKTable[] fileTable = new LPKTable[srcFilePath.length];\n            long fileOffset = outputOffset(header);\n            for (int i = 0; i < srcFilePath.length; i++) {\n                String sourceFileName = FileUtils.getFileName(srcFilePath[i]);\n                long sourceFileSize = FileUtils.getFileSize(srcFilePath[i]);\n                LPKTable ft = makeLPKTable(sourceFileName, sourceFileSize, fileOffset);\n                fileOffset = outputNextOffset(sourceFileSize, fileOffset);\n                fileTable[i] = ft;\n            }\n            File file = new File(makeFilePath);\n            if (!file.exists()) {\n                FileUtils.makedirs(file);\n            }\n            os = new FileOutputStream(file);\n            dos = new DataOutputStream(os);\n            dos.writeInt(header.getPAKIdentity());\n            writeByteArray(header.getPassword(), dos);\n            dos.writeFloat(header.getVersion());\n            dos.writeLong(header.getTables());\n            for (int i = 0; i < fileTable.length; i++) {\n                writeByteArray(fileTable[i].getFileName(), dos);\n                dos.writeLong(fileTable[i].getFileSize());\n                dos.writeLong(fileTable[i].getOffSet());\n            }\n            for (int i = 0; i < fileTable.length; i++) {\n                File ftFile = new File(srcFilePath[i]);\n                FileInputStream ftFis = new FileInputStream(ftFile);\n                DataInputStream ftDis = new DataInputStream(ftFis);\n                byte[] buff = new byte[256];\n                int readLength = 0;\n                while ((readLength = ftDis.read(buff)) != -1) {\n                    makeBuffer(buff, readLength);\n                    dos.write(buff, 0, readLength);\n                }\n                ftDis.close();\n                ftFis.close();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (dos != null) {\n                try {\n                    dos.close();\n                    dos = null;\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"srcFilePath": ["rcFilePath", "srcTaskName", "srcSourceFilePath", "srcFileLocation", "srcfilePath", "srcClassName", "rcfilePath", "sourceFilesName", "srcFileName", "srcKeyName", "srcCodeName", "srcFileList", "srcfileName", "sourceFileList", "srcMessageList", "sourceFilesLocation", "secureKeyInfo", "rcfileName", "srcSourceFileLocation", "srcSourceFileRoot", "srcCodeList", "srcFilesCase", "srcFunctionPoint", "rcFileName", "srcFileStream", "sourceFileStream", "srcFilepath", "srcfileLocation", "srcFilePoint", "srcPageName", "srcFileRoot", "srcfileCase", "secureFileName", "sourceFileLocation", "sourceFilesPath", "srcFilesPoint", "sourceFileRoot", "sourceFilespath", "srcKeyLocation", "srcSourceFilepath", "srcMessagePath", "secureFilePath", "rcFileCase", "srcFilesList", "srcFileCase", "srcfilePoint", "srcCodepath", "srcFunctionPath", "srcFilespath", "sourceFilesRoot", "rcfilePoint", "srcClassInfo", "srcPagePath", "srcFunctionCase", "sourceFilepath", "srcTaskPath", "sourceFilesStream", "srcMessagepath", "secureKeyPath", "srcKeypath", "secureKeyName", "rcFilePoint", "srcFilesRoot", "srcTaskRoot", "srcTaskStream", "sourceFilesList", "srcMessageName", "srcFilesPath", "rcfileCase", "srcPageStream", "sourceFilePath", "srcPageLocation", "srcClasspath", "srcFilesStream", "srcFilesName", "srcFileInfo", "secureFileInfo", "secureFilepath", "srcSourceFileStream", "srcCodePath", "srcKeyPath", "srcSourceFileName", "secureKeypath", "srcFunctionName", "srcClassPath", "srcFilesInfo", "srcfileStream", "srcFilesLocation", "srcKeyInfo"], "makeFilePath": ["parseLinePath", "makeFilespath", "makeFilenamePath", "makefilePath", "parseLinepath", "parseFilePoint", "makeFilepath", "targetFilenameCase", "makeFileName", "makefilepath", "makeLinepath", "makeFilenameCase", "makeClassText", "parseLinePoint", "targetFilenameText", "makeClassPath", "makeClassCase", "targetFileCase", "makeLinePath", "targetFilepath", "makefileCase", "targetFilenamePath", "makeDirPoint", "makeFilenamepath", "makeDirPath", "makefileText", "makeFileCase", "targetFileText", "makeClasspath", "makeFilesName", "parseFilepath", "makeFilesPoint", "parseFileName", "makeDirpath", "targetFilenamepath", "makeLinePoint", "makeFilesPath", "makeFileText", "makeLineName", "makeDirName", "makeFilenameText", "parseFilePath", "makeFilePoint", "targetFilePath", "parseLineName"], "header": ["source", "host", "head", "reader", "h", "later", "input", "queue", "line", "token", "connection", "buffer", "xml", "director", "cf", "result", "player", "output", "message", "http", "definition", "in", "client", "request", "layer", "data", "version", "table", "cover", "hard", "worker", "master", "handler", "server", "config", "writer", "info", "her", "feature", "author", "filename", "name", "body", "liner", "event", "component", "Header", "protection", "report", "per", "cookie", "kernel", "parser", "comment", "dr", "offset", "string", "rule", "document", "headers", "socket", "ssl", "character", "block", "manager", "metadata", "pillar", "project", "null", "type"], "os": ["los", "om", "so", "oses", "io", "fs", "out", "object", "ns", "OS", "bos", "oes", "oa", "zip", "bs", "es", "oi", "ens", "sys", "vs", "oss", "oos", "o", "aos", "mos", "Os", "nos", "ose", "ios", "ops", "ori", "flo", "ol", "pos", "us", "is", "ds", "cos", "boot", "obs", "et", "osi", "s", "ot", "does"], "dos": ["dl", "los", "dose", "die", "did", "des", "Ds", "ils", "dll", "settings", "lines", "oses", "ws", "io", "fo", "cas", "foo", "css", "ros", "bos", "oes", "drops", "lins", "di", "bi", "bs", "zip", "es", "dis", "dp", "DS", "DOS", "lo", "vs", "oss", "oos", "zo", "dds", "da", "aos", "tis", "mos", "ls", "fits", "nos", "done", "rows", "docs", "lis", "ios", "ops", "DoS", "vals", "limits", "flo", "pos", "ses", "ds", "cos", "dal", "bis", "odo", "dat", "does", "uds"], "fileTable": ["liveSection", "FileInfo", "wordChain", "controlTable", "FileChart", "FileBuffer", " fileChain", "fileFile", "liveTable", "FilePath", "fileArray", "resourceChain", "controlFamily", "FileChain", "fileFamily", "ileFile", "fInfo", " fileType", "fileChain", "wordTable", "fileType", "controlSection", "fileRow", " fileChart", "FileArray", "FileType", " fileHeader", "wordType", "fileHeader", "fTable", "fileSection", "placeChain", "controlType", " fileRow", " fileFile", "ileChain", "resourceArray", " filePath", "fChart", "liveType", "FileHeader", "FileTable", "fileInfo", "placeType", "placePath", " fileFamily", "fRow", "resourceTable", " fileInfo", "resourceBuffer", "FileFile", "filePath", "placeTable", "placeRow", " fileSection", " fileBuffer", "fileBuffer", " fileArray", "ileTable", "fileChart", "liveFamily", "ileHeader", "placeFile", "FileRow"], "fileOffset": ["pageShift", "FileOffset", "lineLength", " fileoffset", "logSize", "fileoffset", "FileEntry", " fileShift", "logoffset", " fileLength", "pageoffset", "FileSize", "FileLength", "fileSize", "fileShift", " fileEntry", "logOffset", "lineSize", "pageOffset", "fileLength", "lineOffset", "lineoffset", "fileEntry", "Fileoffset", "logEntry", " fileSize", "FileShift", "pageLength"], "i": ["abi", "l", "bi", "gi", "info", "name", "u", "cli", "xi", "ri", "slice", "ori", "line", "ip", "id", "phi", "io", "yi", "one", "b", "part", "I", "ni", "ti", "ai", "oi", "iv", "it", "ui", "ini", "key", "index", "c", "ii", "pi", "is", "fi", "my", "si", "multi", "hi", "in", "f", "base", "n", "ji", "module", "x", "o", "e", "eni", "v", "j", "q", "uni", "p", "ie", "h", "qi", "iu", "y", "data", "di", "mu", "esi", "inner", "ix", "init", "ci", "m", "li", "uri", "z", "mi", "type"], "sourceFileName": ["sourceDirName", "srcTableFamily", "sourceFolderInfo", "sourceClassName", "sourceFilePath", "sourceTableFamily", "sourceFullAddress", "srcFileSize", "sourceDirPath", "sourceTableSize", "sourceFolderName", "sourceTableName", "srcTableName", "sourceDirAddress", "sourceFileAddress", "sourceDirSize", "srcFileInfo", "sourceTableInfo", "srcClassName", "sourceClassPath", "sourceFullSize", "srcFileFamily", "srcFileAddress", "sourceFolderSize", "srcFileName", "srcClassSize", "sourceFolderFamily", "sourceClassAddress", "srcTableInfo", "sourceFullFamily", "sourceFileInfo", "sourceFullInfo", "srcClassAddress", "srcClassPath", "srcTableSize", "sourceClassSize", "sourceFullPath", "sourceFileFamily", "sourceFullName"], "sourceFileSize": ["sourceDataSIZE", "sourceSectionsize", "srcFileOffset", "srcFileLength", "srcFileSIZE", "srcFileSize", "srcLineSize", "sourceByteSize", "srcPageOffset", "srcSourceFileLength", "srcFilesize", "sourceByteLength", "sourceLineName", "sourceDatasize", "sourceByteName", "sourceFilesInfo", "srcLinesize", "sourceSectionSIZE", "sourceSourceFileName", "srcFileInfo", "srcSourceFileSize", "sourcePageSize", "srcLineSIZE", "sourceDataSize", "sourceFilesize", "srcLineName", "sourceFilesName", "sourceLineOffset", "sourcePageInfo", "sourceSourceFileSize", "srcFileName", "sourceLinesize", "sourcePageName", "srcPageSize", "sourcePageOffset", "srcPageName", "sourceFilesLength", "sourceFileSIZE", "sourceFilesSize", "sourceLineSize", "srcPageLength", "srcSourceFileName", "sourceFileInfo", "sourceLineSIZE", "sourceSectionName", "sourceFileOffset", "srcSourceFileInfo", "sourceFileLength", "sourceLineLength", "sourceSourceFileLength", "sourcePageLength", "sourceByteOffset", "sourceSectionSize", "sourceDataName", "sourceSourceFileInfo"], "ft": ["af", "fts", "bf", "util", "lf", " fl", "flat", "fs", "fp", "sf", "fd", "fr", "f", "fast", " ff", "elt", "det", "fat", "feat", "gt", "t", "tt", "former", "fl", "FH", "tta", " MFT", "aft", "pt", "ut", " FT", "rt", "bt", "let", "att", "fact", "struct", "vt", "at", "FT", "ff", "et", "ct", " ret", "fab", "kt", "wt"], "file": ["source", "play", "folder", "plain", "h", "die", "ile", "binary", "pe", "function", "File", "l", "letter", "http", "out", "fp", "b", "home", "model", "f", "base", "loc", "data", "fe", "to", "directory", "remote", "zip", "single", "work", "resource", "class", "info", "el", "module", "it", "full", "dir", "e", "fly", "php", "o", "log", "le", "book", "il", "path", "image", "document", "rule", "lock", "live", "db", "uri", "ol", "or", "files", "local", "FILE", "line", "use", "unit"], "ftFile": ["ktFiles", "FTRel", "ktRel", "ftTable", "ktDir", "ftF", "ctRel", "ctF", "aftTable", "aftFiles", "FTF", "ctTable", " ftFiles", "ftFiles", "ktFile", "ftRel", "ftDir", "FTFile", "ktTable", " ftTable", "aftDir", "FTTable", "ctFile", " ftDir", "aftFile", "ktF"], "ftFis": ["ftfis", "ftBiss", "ftFus", "fortFis", "ftBis", "ftFIS", "ftLIs", "fortFides", "ftDides", "ftLiss", "fortGFis", "aftFris", "ftDus", "ftFsIs", "ftGFiss", " ftFIs", " ftCiss", "ftFsis", "ftLisc", " ftCis", "ftDiss", " ftFisc", "ftFides", "ftCisc", " ftCIs", "aftLis", "ftfris", "ftLis", "fortGFides", "aftLiss", "aftFIS", "ftGFus", " ftCisc", "ftFisc", "ftLris", "aftLris", "fortGFiss", "ftFris", "aftFiss", "ftFiss", "ftBris", "ftBIS", "ftFIs", "ftfIS", " ftFiss", "ftLIS", "ftCis", "ftCiss", "ftGFides", "ftGFis", "ftCIs", "fortGFus", "aftFis", "fortFus", "fortFiss", "ftfiss", "ftFsisc", "aftLIS", "ftFsiss"], "ftDis": [" ftIs", "wdDes", " FTDis", "aftLo", "wtDis", "wdDis", "aftDe", "faDet", "faDis", " FTDIS", "wtDe", "aftDIS", " ftDIS", " ftDet", "faDIS", "ftDes", "wtIs", " ftDe", "aftIs", "aftDis", " ftLo", "ftDe", "wdDet", "ftIs", "aftDet", " FTDet", "rtDes", "rtDet", "ftLo", "wdDIS", "ftDIS", "faDes", " FTDe", "ftDet", "rtDis", "rtDIS", "wtLo"], "buff": ["read", "cb", "bf", "txt", "append", "feed", "buffer", "tab", "now", "flat", "FF", "app", "b", "char", "cmd", "bug", "fe", "butt", "hack", "qq", "raw", "info", "pad", "Buff", "batch", "grab", "bb", "ob", "ph", "length", "flush", "text", "uf", "bound", "buf", "bag", "gb", "count", "eb", "load", "font", "gg", "fb", "oct", "cast", "front", "uff", "boot", "ff", "nd", "cod", "fab"], "readLength": [" readLibrary", "loadlength", "loadWidth", "readLen", "Readlength", "ReadWidth", "readWidth", "ReadLength", "writeLength", " readWidth", "writeLibrary", "readLibrary", "loadLength", "loadLen", "loadLibrary", "writeWidth", "readlength", " readLen", "writelength", " readlength", "writeLen"]}}
{"id1": "18490448", "id2": "15171197", "code1": "    @Deprecated\n    public void encodeBegin(FacesContext context, UIComponent component) throws IOException {\n        XUIResponseWriter w = getResponseWriter();\n        XUIViewRoot viewRoot = (XUIViewRoot) component;\n        XUIResponseWriter headerW = getResponseWriter().getHeaderWriter();\n        headerW.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<!DOCTYPE foo [\\n\");\n        InputStream is1 = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"xhtml-lat1.ent\");\n        headerW.write(new String(IOUtils.copyByte(is1)));\n        headerW.write(\"\\n\");\n        is1.close();\n        InputStream is2 = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"xhtml-special.ent\");\n        headerW.write(new String(IOUtils.copyByte(is2)));\n        headerW.write(\"\\n\");\n        is2.close();\n        InputStream is3 = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"xhtml-symbol.ent\");\n        headerW.write(new String(IOUtils.copyByte(is3)));\n        headerW.write(\"\\n]>\\n\");\n        is3.close();\n        headerW.startElement(\"html\", component);\n        XUITheme t = getTheme();\n        if (t != null) {\n            headerW.writeAttribute(\"style\", getTheme().getHtmlStyle(), \"style\");\n        }\n        headerW.startElement(\"head\", component);\n        headerW.startElement(\"base\", component);\n        HttpServletRequest req = (HttpServletRequest) getRequestContext().getRequest();\n        String link = (req.isSecure() ? \"https\" : \"http\") + \"://\" + req.getServerName() + (req.getServerPort() == 80 ? \"\" : \":\" + req.getServerPort()) + getRequestContext().getResourceUrl(\"\");\n        headerW.writeAttribute(\"href\", link, \"href\");\n        headerW.endElement(\"base\");\n        w.startElement(\"body\", component);\n        if (t != null && t.getBodyStyle() != null) {\n            w.writeAttribute(\"style\", getTheme().getBodyStyle() + \";height:100%;width:100%\", \"style\");\n        }\n        headerW.writeText('\\n');\n        w.startElement(\"div\", component);\n        w.writeAttribute(\"id\", ((XUIViewRoot) component).getClientId(), \"id\");\n        if (viewRoot.findComponent(Window.class) != null) {\n            w.writeAttribute(HTMLAttr.CLASS, \"x-panel\", \"\");\n        }\n        w.writeAttribute(\"style\", \"width:100%;height:100%\", null);\n        if (t != null) {\n            t.addScripts(w.getScriptContext());\n            t.addStyle(w.getStyleContext());\n        }\n    }\n", "code2": "    private static Pattern getBotPattern() {\n        StringBuilder sb = new StringBuilder();\n        try {\n            Enumeration<URL> urls = AbstractPustefixRequestHandler.class.getClassLoader().getResources(CONFIG);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                InputStream in = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in, \"utf8\"));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    line = line.trim();\n                    if (!line.startsWith(\"#\") && !line.equals(\"\")) {\n                        if (sb.length() > 0) sb.append(\"|\");\n                        sb.append(\"(\").append(line).append(\")\");\n                    }\n                }\n                in.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error reading bot user-agent configuration\", e);\n        }\n        return Pattern.compile(sb.toString());\n    }\n", "label": 0, "substitutes": {"context": ["xml", "view", "cas", "app", "request", "object", "application", "loader", "kit", "face", "ctx", "comp", "tx", "config", " Context", "instance", "text", "com", "frame", "path", "document", "c", "font", "Context", "ce", "cms", "ca"], "component": ["host", "parent", "input", "connection", "cm", "result", "function", "output", "view", "thread", "controller", "request", "app", "object", "cell", "root", "part", "application", "system", "ctx", "comp", "resource", "compatible", "config", "template", "Component", "server", "element", "section", "module", "e", "target", "report", "container", " components", "instance", "chart", "ch", "content", "document", "entity", "html", "c", "callback", "or", "current", "header", "ce", "cms", "omp", "project", "web", "port"], "w": ["h", "d", "xml", "ws", "ew", "wx", "http", "sw", "f", "fw", "response", "r", "writer", " W", "wp", "W", "x", "u", "e", "we", "v", "rw", "c", "wb", "web", "iw", "wt"], "viewRoot": [" imageRO", " navHome", " imageRoot", " viewRO", " imageProxy", "iewHome", " viewProxy", "iewProxy", " navRO", "iewRoot", " navProxy", " viewHome", "iewRO", " navRoot", " imageHome"], "headerW": ["HeaderCW", "pagew", "headerw", " headerGW", "headNW", "layoutW", "jsonw", "detailw", "writerWeb", "HeaderNW", "responseW", " headerWB", "headerWeb", "authorW", "responseWriter", "responseL", "chartW", "reportWB", "authorGW", "jsonCW", "headerWB", "chartWe", " headerQ", "detailA", "triggerGW", "reportSW", "layoutWriter", "layoutWC", "summaryGW", " headerWeb", " headerNW", "summaryP", "HeaderM", "summaryTW", "jsonW", "headerCW", "jsonWS", "chartWC", "headWC", " headerCW", "detailWe", "headW", "HeaderWS", "triggerWB", "summaryWe", "writerM", "summarySW", "writerWB", "centerWeb", "headWP", "chartWriter", "HeaderQ", "HeaderL", " headerA", "summaryW", "headerWC", "HeaderWriter", "headerA", "pageWe", " headerWS", " headerWriter", "layoutw", "headerSW", "metadataGW", "headerGW", "reportTW", "Headerw", "centerWriter", " headerL", "HeaderW", "headerL", "headerQ", "headerM", " headerw", " headerWC", "writerW", "headerWP", "writerWriter", "metadataTW", "triggerTW", "metadataW", "reportW", " headerWP", "writerNW", " headerWe", "reportGW", "authorTW", " headerSW", "detailW", "headerWe", "metadataWB", "reportWe", " headerM", "headerWriter", "headWS", " headerRW", "HeaderWP", "pageA", "headerP", "headWe", "pageW", " headerP", "headerNW", "triggerW", "authorP", " headerTW", "headWriter", "headQ", "HeaderRW", "headw", "responseRW", "centerWB", "headerRW", "headerTW", "headerWS", "centerW"], "is1": ["ISone", "islone", "isOne", "issone", "bis2", "is0", "isone", "lis1", "IsOne", "issN", "isl0", "ione", " is0", "iOne", " isN", "issOne", "Is1", " isone", "lis2", "is01", "isN", " is01", "ISOne", "bis01", "bis0", "IS1", "Is0", " isOne", "Isone", "lis0", "ISN", "iss1", "bis1", "lis01", "isl1", "islOne", "i1", "i0"], "is2": ["has2", "has1", "IS2", "isiSecond", " is4", " isSecond", "isiTwo", "is4", " isTwo", "isTwo", "IsTwo", "IsSecond", "Is4", "isa1", "iss7", "ISTwo", "hasSecond", "issSecond", " is7", "isSecond", "Is2", "isi1", "isaTwo", "isaSecond", "isa2", "ISSecond", "isi2", "IS4", "hasTwo", "is7", "IS7", "IS1", "iss1", "iss2"], "is3": ["inthree", "isa03", "iss3", "asThree", "is23", " isThree", "isiThree", "isa15", "is43", "iss43", "IS23", " is23", " is15", "inThree", "is03", "IS03", "isThree", "in3", "as43", "issThree", "iss15", "asthree", "isi1", " is03", "issthree", "isthree", "IS3", "isi15", "IS15", "is15", "iss1", "isa3", "isa23", "in43", "isi3", "as3"], "t": ["parent", "h", "ant", "d", "tor", "theme", "l", "ct", "y", "b", "f", "n", "r", "ot", "ti", "tp", "u", "e", "o", "T", "tt", "z", "m", " T", "tr", "v", "ut", "j", "c", "i", "att", "g", "at", "Theme", "qt", "ts", "s", "te", "p", "tg"], "req": ["dq", "cb", "gr", "proc", "sem", "rx", "pkg", "require", "wx", " requ", "http", "request", "b", "cmd", "fr", "f", "base", "https", "def", "progress", "worker", "ver", "remote", "r", "ctx", "qq", "org", "config", "Request", "comm", "exec", "conf", "cur", "tar", "desc", "crit", "query", "requ", "exp", "Requ", "pr", "hr", "rec", "sec", "quest", "rw", "c", "reg", "cache", "mr", "err", "resp", "g", "required", "sq", "q", "rr", "grad", "qt", "res", "p", "ext"], "link": ["next", " links", "url", " anchor", " site", " fragment", "loc", "href", "style", "r", "address", "info", "template", "external", " redirect", " Link", "name", "e", "path", "html", "uri", "replace", "i", "Link", "header", "www", "s", "location"]}}
{"id1": "7170603", "id2": "14555518", "code1": "    private static void generateSQLUpgradeFile(String milestoneDefFileName, String sqlDirectoryName, String fromMilestone, String destMilestone, String destFileName) throws Exception {\n        File milestoneDefFile = new File(milestoneDefFileName);\n        if (!milestoneDefFile.exists()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : does not exists\");\n        }\n        if (!milestoneDefFile.isFile()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : not a file\");\n        }\n        if (!milestoneDefFile.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : not readable\");\n        }\n        File sqlDirectory = new File(sqlDirectoryName);\n        if (!sqlDirectory.exists()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : does not exists\");\n        }\n        if (!sqlDirectory.isDirectory()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : not a directory\");\n        }\n        if (!sqlDirectory.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : not readable\");\n        }\n        File destFile = new File(destFileName);\n        if (destFile.exists()) {\n            throw new IllegalArgumentException(\"Cannot write to [\" + destFileName + \"] : already exists\");\n        }\n        destFile.createNewFile();\n        SqlUpgradeXmlParser parser = SqlUpgradeXmlParser.newParser();\n        FileInputStream milestoneDefFIS = null;\n        try {\n            milestoneDefFIS = new FileInputStream(milestoneDefFile);\n            parser.parse(milestoneDefFIS);\n        } catch (XMLParseException e) {\n            printXmlError(e, milestoneDefFileName);\n        } finally {\n            try {\n                if (milestoneDefFIS != null) milestoneDefFIS.close();\n            } catch (Exception e) {\n                _logger.warn(\"Exception caught when closing inputstream \", e);\n            }\n        }\n        int fromMilestoneIdx = parser.getMilestoneIndex(fromMilestone);\n        int toMilestoneIdx = parser.getMilestoneIndex(destMilestone);\n        if (fromMilestoneIdx < 0) {\n            throw new IllegalArgumentException(\"Cannot upgrade from milestone [\" + fromMilestone + \"] : does not exist . (Exisiting milestones \" + parser.listMilestones() + \")\");\n        }\n        if (toMilestoneIdx < 0) {\n            throw new IllegalArgumentException(\"Cannot upgrade to milestone [\" + destMilestone + \"] : does not exist . (Exisiting milestones \" + parser.listMilestones() + \")\");\n        }\n        if (fromMilestoneIdx == toMilestoneIdx) {\n            throw new IllegalArgumentException(\"Cannot upgrade to the same milestone\");\n        }\n        List<String> files = parser.getFilesForMilestones(fromMilestoneIdx, toMilestoneIdx);\n        List<String> views = parser.getViewsForMilestones(fromMilestoneIdx, toMilestoneIdx);\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(destFile);\n            for (Iterator<String> it = files.iterator(); it.hasNext(); ) {\n                appendFileToOutputStream(fos, sqlDirectory, it.next());\n            }\n            for (Iterator<String> it = views.iterator(); it.hasNext(); ) {\n                appendFileToOutputStream(fos, sqlDirectory, it.next());\n            }\n        } catch (Exception e) {\n            fos.close();\n            destFile.delete();\n            throw e;\n        } finally {\n            try {\n                if (fos != null) fos.close();\n            } catch (Exception e) {\n                _logger.warn(\"Exception caught when closing outputstream \", e);\n            }\n        }\n        System.out.println(\"An SQL update file has been generated to \" + destFileName + \".\");\n    }\n", "code2": "    @Override\n    @RemoteMethod\n    public boolean decrypt(int idAnexo) {\n        try {\n            Anexo anexo = anexoService.selectById(idAnexo);\n            aes.init(Cipher.DECRYPT_MODE, aeskeySpec);\n            CipherInputStream cis = new CipherInputStream(new FileInputStream(config.baseDir + \"/arquivos_upload_direto/encrypt/\" + anexo.getAnexoCaminho()), aes);\n            FileOutputStream fos = new FileOutputStream(config.baseDir + \"/arquivos_upload_direto/decrypt/\" + anexo.getAnexoCaminho());\n            IOUtils.copy(cis, fos);\n            cis.close();\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"milestoneDefFileName": ["milestoneDefFILESource", "milestoneDefSourceFilePart", "milestoneInfFILEPart", "milestoneDeffileName", "milestoneDefFILEUrl", "milestoneDeclFileFile", "milestonedefSourceFileName", "milestonedeffileSource", "milestoneDefinitionFilePath", "milestonedefFileDesc", "milestoneDefLineUrl", "milestoneDefFileFile", "milestoneDefPlaceUrl", "milestoneDefPlacePath", "milestoneDefDirectoryPart", "milestoneDefFilePath", "milestoneDeffileUrl", "milestoneDeclfilePart", "milestoneDefFilename", "milestoneDeffileShare", "milestoneDefDirectoryIn", "milestoneDeclfileName", "milestonedefSourceFileDir", "milestoneDefinitionLineName", "milestoneDefinitionLinePath", "milestonedeffileUrl", "milestoneDefFilePart", "milestoneDeffileSource", "milestonedeffileDesc", "milestoneDefFileShare", "milestoneDefinitionFileSize", "milestoneDefClassFile", "milestoneInfFileString", "milestoneDefSourceFileLine", "milestonedefFilePart", "milestoneDefStreamname", "milestoneDefStreamString", "milestoneDefinitionLineSize", "milestonedefSourceFileUrl", "milestoneDefFILEIn", "milestoneDefSourceFileInfo", "milestoneInfFILEString", "milestoneDefDirectoryLine", "milestoneDefFILEString", "milestoneDefSourceFileIn", "milestoneDefinitionFileUrl", "milestoneDefFILEDesc", "milestoneDefClassname", "milestoneDefLineName", "milestoneDefFileDir", "milestoneDefDirectoryName", "milestoneInfFILEName", "milestoneDefClassName", "milestoneDefFileSource", "milestoneInfFileShare", "milestoneDeffileDir", "milestoneInfFileName", "milestoneDefSourceFileUrl", "milestoneDefSourceFileDir", "milestoneInfFilePart", "milestoneDefSourceFileName", "milestoneDefClassUrl", "milestonedefFileDir", "milestonedefSourceFilePart", "milestoneDefFileInfo", "milestoneDeffileFile", "milestoneDefFileString", "milestoneDefFILEPart", "milestoneDefStreamPart", "milestoneDefStreamName", "milestoneDefFileLine", "milestoneDeclfilename", "milestonedefFileUrl", "milestoneDefDirectoryDir", "milestoneDeclFilename", "milestoneDefinitionLineUrl", "milestoneDefFileUrl", "milestoneDeffileDesc", "milestonedefFileName", "milestoneDefFILELine", "milestonedefFileSource", "milestoneDeclFileName", "milestoneDefFileDesc", "milestoneDefClassPart", "milestoneDeffileString", "milestoneDefFileSize", "milestoneDefClassSize", "milestoneDefPlaceName", "milestoneDefPlaceSize", "milestoneDefDirectoryInfo", "milestoneDefStreamShare", "milestoneDefDirectoryUrl", "milestonedeffileName", "milestoneDeffilePart", "milestoneDefFILEShare", "milestoneDeclFilePart", "milestoneDefDirectorySource", "milestoneDefFILEInfo", "milestoneDeffilename", "milestoneDefFileIn", "milestoneDeclfileFile", "milestoneDefLineSize", "milestoneDefinitionFileName", "milestoneDefLinePath", "milestoneDefStreamFile", "milestoneDefFILEName", "milestoneDefClassPath", "milestoneInfFILEShare", "milestoneDefDirectoryDesc"], "sqlDirectoryName": ["solDirectoryKey", "sqlModuleKey", "sqlDirName", "SQLDirAddress", "databaseDirectoryFile", "sqldirectoryPath", "sqlModulename", "sqlDirectoryKey", "SQLDirPath", "sqlFilePath", "sqlFolderName", "solDirectoryPart", "sqlFileFile", "solDirName", "sqlFolderPath", "SQLDirName", "sqlDirAddress", "sqlLocationName", "sqlDirPart", "sqldirectorySize", "sqlDirectoryAddress", "sqlFileAddress", "sqlDocumentPath", "sqlDirKey", "sqlDocumentName", "sqlFolderUrl", "sqlLocationUrl", "sqlDirectorySize", "SQLFolderKey", "databaseDirectoryPath", "sqldirectoryAddress", "SQLDirectoryKey", "sqlFilePart", "sqlDirectoryPart", "SQLFolderName", "SQLDirectorySize", "solDirectoryPath", "sqlFileKey", "sqlDirPath", "sqlFolderPart", "sqlDirectoryPath", "SQLDirectoryPath", "SQLFolderUrl", "sqlFileSize", "solDirKey", "sqlFileName", "sqlFileUrl", "sqlLocationPath", "solDirectoryName", "sqlLocationKey", "sqlDirectoryname", "sqlDocumentFile", "sqlDirSize", "SQLDirectoryName", "SQLFoldername", "SQLFolderPath", "sqlDirectoryUrl", "SQLDirectoryAddress", "sqlModuleName", "SQLDirSize", "databaseDirectoryName", "SQLDirectoryname", "sqlFoldername", "sqlDirectoryFile", "sqlFolderKey", "solDirPart", "SQLDirectoryUrl", "solDirPath", "sqldirectoryName"], "fromMilestone": ["withMilathon", "withLegaxy", "fromGalathon", "fromMilathon", "fromGalaxy", "withLegestone", "withMilaxy", "fromLegaxy", "fromSilaxy", "withMilework", "withLegathon", "fromSilathon", "fromLegathon", "fromGalestone", "fromLegestone", "withLegework", "fromGalework", "fromLegework", "fromSilework", "withMilestone", "fromSilestone", "fromMilaxy", "fromMilework"], "destMilestone": ["DestMilename", "DestMilestones", "destDigenge", "destDigename", "destMilename", "destMilenge", "destMillenge", "DestMilestone", "destMillestone", "destDigestone", "destDigestones", "destMillestones", "destMilestones", "destMillename", "DestMilenge"], "destFileName": ["destPageLine", "sourceFileLine", "DestDirectoryPath", "deleteFileAlias", "destFileLine", "destSourceFilePath", "destFileOption", "destfilePart", "sourceDirectoryname", "sourceFileName", "DestDirectoryPart", "destStreamName", "DestDirectoryName", "sourceDirectoryLocation", "destPagename", "destFilePath", "DestFilePath", "DestFilePart", "destDirectoryPath", "destDirectoryname", "destFilePart", "deleteFilenameOption", "destFilenameLine", "DestFileName", "destSourceFileSize", "deleteFileOption", "destStreamOption", "destFILEAlias", "destPageName", "destFileSize", "destDirectoryLine", "destStreamAlias", "destFILEName", "destDirectoryPart", "destFilenameAlias", "destFilenamename", "destFilenameOption", "sourceDirectoryName", "DestFileSize", "sourceFilename", "destFilenameLocation", "sourceDirectoryLine", "destFileLocation", "destSourceFilePart", "destFILEOption", "destFileAlias", "sourceFileLocation", "destDirectoryLocation", "destPageLocation", "destDirectoryName", "destDirectorySize", "destSourceFileName", "deleteFileName", "deleteFilenameName", "destFilenameName", "destfilePath", "DestDirectorySize", "destFilename", "destfileSize", "destfileName", "deleteFilenameAlias"], "milestoneDefFile": ["milestoneDefFolder", "milelineDEFfile", "milestoneDefPlace", "milestoneDefinitionFile", "milestoneDefinitionfile", "milestonedeffile", "milestonesDefinitionfile", "milestoneDefinitionFolder", "milestonesDefFile", "milestoneConfLine", "milestoneDiffDirectory", "milestoneDiffStream", "milelineDEFFile", "milestonDefDirectory", "milestoneConfFiles", "milestoneConfSourceFile", "milestoneDEFFiles", "milelineDefSourceFile", "milestonDefFolder", "milestoneConfPlace", "milestonDefFile", "milestoneDefDirectory", "milestonDefinitionfile", "milelineDefFile", "milestoneRefDirectory", "milestonesDefStream", "milwallDefFiles", "milestonedefSourceFile", "milwallDefLine", "milestoneDEFStream", "milestonDefinitionFolder", "milestoneConfigFile", "milestoneDEFSourceFile", "milestoneDefSourceFile", "milestoneDEFfile", "milestonDefinitionFile", "milestoneDiffFolder", "milestoneConfigFiles", "milwallDefinitionFile", "milestoneRefPlace", "milestoneDefStream", "milelineDEFFiles", "milestonesDefinitionFile", "milestonesDeffile", "milestoneConffile", "milestonesConfFile", "milestoneDiffFiles", "milestoneDefFiles", "milestoneConfigDirectory", "milestonedefFiles", "milestoneConfFile", "milestoneDiffFile", "milwallDefinitionfile", "milestoneDefinitionDirectory", "milelineDefFiles", "milestonesDefinitionFiles", "milwallDefinitionLine", "milestoneDEFFile", "milestoneDefLine", "milestoneConfDirectory", "milestoneRefFiles", "milestonesDefinitionStream", "milelineDEFSourceFile", "milestoneDefinitionLine", "milestonedefLine", "milestonesDefFiles", "milestoneRefFile", "milestonesDefDirectory", "milestoneDefinitionStream", "milestonDeffile", "milestonesConfPlace", "milwallDeffile", "milestonesConfDirectory", "milwallDefinitionFiles", "milestonDefinitionDirectory", "milestoneDifffile", "milestonesDefPlace", "milestoneConfigPlace", "milelineDeffile", "milestonedefFile", "milwallDefFile", "milestoneDefinitionFiles", "milestoneDeffile", "milestonesConfFiles"], "sqlDirectory": ["SQLDirector", "dsFolder", "qlDirector", "sqlCollection", "SQLDir", "sqCollection", "sqDirectory", "dbDir", "sqDirector", "dsLibrary", "dbFolder", "dsDirectory", "SQLDirectory", "sslDirectory", "sqlFile", "socialDir", "sqlFolder", "SQLFolder", " sqlFolder", "qlFolder", "sqFolder", " sqlCollection", "SQLLibrary", "qlDir", "sslFolder", "qlDirectory", "dbDirectory", "qlCollection", "qlLibrary", "socialFile", "sqlDirector", "sslLibrary", "socialFolder", "dsCollection", "dbFile", "SQLCollection", "sqlLibrary", "socialDirectory", " sqlLibrary", "sqlDir", "qlFile", "sslDir"], "destFile": ["DestFiles", "DestFile", "srcFolder", "destFiles", "targetPage", " destFilename", " destFiles", "DestPage", "destDirectory", "destfile", "DestFilename", " destfile", "Destfile", "srcDirectory", " destFolder", "transFilename", "targetFiles", "DestDirectory", " destPage", "DestFolder", "destDir", "srcDir", " destDirectory", "targetFile", "transFile", "srcFile", "targetDir", "transDirectory", " destDir", "destPage", "DestDir", "destFilename", "destFolder", "transfile"], "parser": ["lp", "parent", "aws", "reader", "general", "processor", "pe", "xml", "plugin", "pd", "l", "arser", "in", "b", "layer", "loader", "jack", "data", "worker", "auto", "system", "handler", "server", "writer", "er", "php", "per", "json", "instance", "se", "up", "document", "node", "sp", "parse", "builder", "manager", "s", "Parser", "fork", "p"], "milestoneDefFIS": ["milestoneDefBISS", "milestoneDefinitionVIs", "milestonedefLIs", "milestoneDEFLIR", "milestoneDefDISS", "milestoneDefDIS", "milestonedefFIS", "milestoneDEFFIs", "milestoneDefEFIS", "milestoneDefFISS", "milestoneDefHIT", "milestoneDEFLINS", "milestonedefLAS", "milestoneDefVIs", "milestoneDefinitionVIT", "milestoneDefFIT", "milestoneDefEISS", "milestoneDefFis", "milestoneDefLAS", "milestoneDefVIT", "milestoneDefLis", "milestoneDivFIs", "milestoneDefVISS", "milestoneDefPFIS", "milestoneDefBIs", "milestoneDefDAS", "milestoneDefLIR", "milestoneDefLISS", "milestoneDefEFINS", "milestoneDefEFIR", "milestoneDefFIR", "milestoneDefHISS", "milestonedefLISS", "milestoneDefBIR", "milestoneDefPFIs", "milestoneDefEIS", "milestoneDefFAS", "milestoneDeffIS", "milestonedefLIS", "milestoneDeffIs", "milestoneDefEIs", "milestoneDEFLIs", "milestoneDEFFIR", "milestoneDefinitionFIS", "milestoneDefinitionFISS", "milestoneDefinitionFIs", "milestoneDEFFINS", "milestoneDefHIs", "milestoneDefEFIs", "milestonedefFAS", "milestoneDefBINS", "milestoneDefLIS", "milestoneDefBIS", "milestonedefFISS", "milestoneDivfIs", "milestoneDivFIS", "milestoneDefinitionFIT", "milestoneDefPFISS", "milestoneDefHIS", "milestoneDefLIT", "milestoneDefinitionVis", "milestoneDivFis", "milestoneDefEAS", "milestoneDefDIT", "milestoneDefinitionVIS", "milestonedefFIs", "milestoneDivfis", "milestoneDEFFIS", "milestoneDefinitionFis", "milestoneDeffIT", "milestoneDefinitionVISS", "milestoneDeffis", "milestoneDefVIS", "milestoneDefBis", "milestoneDEFLIS", "milestoneDefDIs", "milestoneDivFIT", "milestoneDivfIS", "milestoneDivfIT", "milestoneDefLIs", "milestoneDefVis", "milestoneDefFINS", "milestoneDefLINS", "milestoneDefPFis", "milestoneDefFIs"]}}
{"id1": "2897046", "id2": "20109501", "code1": "    public boolean execute_check() {\n        FTPClient ftp = new FTPClient();\n        File filename = null;\n        FileChannel channel;\n        InputStream is;\n        OutputStream os;\n        int reply;\n        if (super.verbose > 0) verbose = true;\n        ftp.setDefaultPort(port);\n        ftp.setDefaultTimeout(timeout);\n        if (verbose) {\n            System.out.println(\"Using FTP Server: \" + hostname);\n            System.out.println(\"Using FTP Port: \" + port);\n            System.out.println(\"Using Timeout of: \" + timeout);\n        }\n        if (passive) {\n            ftp.enterLocalPassiveMode();\n            if (verbose) System.out.println(\"Using Passive Mode\");\n        }\n        try {\n            filename = new File(file);\n            channel = new RandomAccessFile(filename, \"rw\").getChannel();\n            if (verbose) System.out.println(\"Attempting FTP Connection to \" + hostname);\n            ftp.connect(hostname);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                if (verbose) System.out.println(\"FTP Connection to \" + hostname + \" failed\");\n                check_state = common_h.STATE_CRITICAL;\n                check_message = ftp.getReplyString();\n                filename.delete();\n                ftp.disconnect();\n                return true;\n            }\n            if (username != null && password != null) {\n                if (verbose) System.out.println(\"Attempting to log in into FTP Server \" + hostname);\n                if (!ftp.login(username, password)) {\n                    if (verbose) System.out.println(\"Unable to log in to FTP Server \" + hostname);\n                    check_state = common_h.STATE_CRITICAL;\n                    check_message = ftp.getReplyString();\n                    ftp.disconnect();\n                    filename.delete();\n                    return true;\n                }\n            }\n            if (verbose) System.out.println(\"Attempting to change to required directory\");\n            if (!ftp.changeWorkingDirectory(directory)) {\n                if (verbose) System.out.println(\"Required directory cannot be found!\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            if (verbose) System.out.println(\"Attempting to retrieve specified file!\");\n            is = ftp.retrieveFileStream(file);\n            if (is == null) {\n                if (verbose) System.out.println(\"Unable to locate required file.\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            os = Channels.newOutputStream(channel);\n            byte[] buf = new byte[4096];\n            if (verbose) System.out.println(\"Beginning File transfer...\");\n            for (int len = -1; (len = is.read(buf)) != -1; ) os.write(buf, 0, len);\n            if (verbose) {\n                System.out.println(\"...transfer complete.\");\n                System.out.println(\"Attempting to finalise Command\");\n            }\n            if (!ftp.completePendingCommand()) {\n                if (verbose) System.out.println(\"Unable to finalise command\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            if (verbose) System.out.println(\"Check Completed.\");\n            check_state = common_h.STATE_OK;\n            check_message = ftp.getReplyString();\n            is.close();\n            os.close();\n            channel.close();\n            filename.delete();\n        } catch (IOException e) {\n            check_state = common_h.STATE_CRITICAL;\n            check_message = e.getMessage();\n            if (filename != null) filename.delete();\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (Exception e) {\n                }\n            }\n        }\n        return true;\n    }\n", "code2": "    private void native2ascii(LanguageInfo info) {\n        if (!info.isUTF8()) throw new IllegalArgumentException(\"requires utf8 language.\");\n        InputStream in = null;\n        OutputStream out = null;\n        print(\"\\tConverting to ASCII... \");\n        try {\n            in = new BufferedInputStream(new FileInputStream(info.getFileName()));\n            in.mark(3);\n            if (in.read() != 0xEF || in.read() != 0xBB || in.read() != 0xBF) in.reset();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in, \"UTF8\"));\n            out = new BufferedOutputStream(new FileOutputStream(info.getAlternateFileName()));\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, \"ISO-8859-1\"));\n            String read;\n            while ((read = reader.readLine()) != null) {\n                writer.write(ascii(read));\n                writer.newLine();\n            }\n            writer.flush();\n            out.flush();\n            println(\"... done!\");\n        } catch (IOException ignored) {\n            println(\"... error! (\" + ignored.getMessage() + \")\");\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (IOException ignored) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"ftp": ["ufuser", " ftplug", "aftpc", "cfw", "xfb", "rtsp", "webtp", "rtpc", " fttp", "fc", " ftw", "xfp", " ftpc", " ftcp", "afi", "ctw", "ctpc", "ctcp", "uftp", " ftsp", "lfp", "FTplug", "aftm", "afc", "fb", "ctp", " ftc", "lfpi", "cfcp", "fdc", "aftcp", " ftP", "fspc", "xfc", " fti", "cftp", "ctpb", "ftm", "ctP", "fsm", "ftpre", "rtm", "ufpre", "ftjp", "webpart", "lfc", "aftpb", " ftpart", "fttp", "ftl", "webp", "fdp", "ftplug", "webjp", "ufp", "cfuser", "ctb", "fP", "ufpc", "fdcp", "fi", "ctpre", "aftp", "ctport", "xfplug", "ftuser", "aftjp", "rtp", "cttp", "aftsp", "FTc", "fp", "ufport", "ftw", "FTb", "afp", "ftpart", "ufcp", "afl", "fti", "ftc", "ftpb", "ftP", "lftp", "fdl", "fsp", " ftuser", "ftport", "cfp", "ftpc", "aftpart", "ftsp", " ftpi", " ftb", "cfpc", "fpi", "ftcp", "fcp", "fstp", "ftb", "fdpc", " ftm", "ftpi", "ufpb", "afcp", "fl", "aftpre", "FTp", " ftjp", "fdport", "afttp"], "filename": ["source", "via", "folder", "journal", "url", "processor", "queue", "binary", "txt", "memory", "SourceFile", "connection", "download", "jet", "fax", "dll", "username", "message", "output", "audio", "l", "fp", "sf", "fd", "f", "loader", "application", "directory", "phrase", "profile", "resource", "Filename", "prefix", "archive", "config", "ppa", "name", "tp", "password", "fn", "json", "picture", "session", "slice", "string", "il", "document", "socket", "ssl", "file", "uri", "lua", "files", "manager", "database", "sudo", "FILE", "metadata", "nil", "location", "fil"], "channel": ["source", "page", "url", "queue", "connection", "buffer", "username", "chan", "io", "message", "conn", "Channel", "client", "out", "directory", "stream", "resource", "handler", "server", "slave", "config", "writer", "can", "name", "transfer", "target", "password", "log", "ch", "session", "path", "pool", "socket", "file", "command", "self", "entry"], "is": ["id", "rx", "abi", "ais", "fs", "was", "isu", "irc", "ai", "ir", "iv", "isi", "it", "ins", "ci", "tis", "IS", "ri", "il", "image", "ios", "uri", "iii", "ii", "bis", "Is", "ip", "ib"], "os": ["options", "oper", " o", "ws", "io", "ou", "root", "OS", "outs", "oss", "res", "o", "aos", "ok", "log", "flush", "Os", "O", "ios", "ops", "obj", "or", "pos", "opt", "et", " bos", "op"], "reply": ["next", "respond", "continue", "notice", "queue", "link", "write", "msg", " replies", "connection", "buffer", "result", "message", "request", "mode", "ply", "ise", "enable", "response", "repl", "ret", "address", "info", "send", "Reply", "sync", "transfer", "force", "query", "ix", "rc", "report", "flush", "length", "comment", "status", "back", "ping", "dy", "install", "lock", "answer", "delay", "replace", "code", "callback", "resp", "error", "err", "attribute", "wait", "service", "i", "rr", "reason"], "verbose": ["verbore", "mutosed", "combosity", "quosed", "prettyose", "fosity", "combose", "buffosity", "logisy", " verbressed", "logosed", "verbressed", "verbsade", "logoise", "comblier", "logore", "labote", " verbote", "verbitive", "mutosity", "logout", "buffout", "silose", "verbosity", "silative", "fOSE", "verbade", "verbsosed", "prettyressive", "logosity", " verbisy", "vvote", "verbressive", "logose", "labOSE", "verbOSE", "mutout", "verbative", "labosity", "labose", " verbosed", "fose", "quose", "buffoise", "vvose", "vvisy", "logressive", "buffressive", "laboise", "prettyosity", "labressed", "verblier", "logade", "verbout", "buffosed", "querosity", "buffote", "verbisy", "logressed", " verbative", "loglier", "verbsose", "logOSE", "verbote", "silitive", "verbosed", "querose", "quore", "verboise", "quade", " verbitive", "silosity", "buffOSE", "verbsore", "prettyote", "logitive", "logative", "mutose", " verbOSE", " verbout", "buffose", "querlier", "fote", " verbosity", "logote", "vvosity"], "check_state": ["info64state", "check_source", "check64manager", "checkvalmedia", "check_cause", "block_media", "info64source", "check_manager", "info_source", "checkpremanager", "info64manager", "checkvalState", "blockxstate", "checkprestate", "check64source", "info64output", "check64output", "blockxcause", "checkpresource", "checkxstate", "checkxcause", "checkpreoutput", "block_cause", "check_output", "check64state", "block_state", "checkxState", "info_output", "check_media", "check_State", "checkxmedia", "checkvalcause", "info_state", "info_manager", "blockxState", "blockxmedia", "checkvalstate", "block_State"], "check_message": ["comment_message", "comment64member", "block_code", "block___code", "comment_mail", "block___output", "comment_address", "comment64mail", "block_language", "check_address", "check___output", "block_message", "check64language", "check___language", "block___language", "check_member", "checkJoutput", "check64output", "check64mail", "block___message", "block_output", "checkJmessage", "comment_member", "check64member", "check_output", "check___code", "checkJlanguage", "check_code", "checkJcode", "check___message", "check_mail", "check64code", "check64address", "check64message", "comment64address", "comment64message", "check_language"]}}
{"id1": "10940445", "id2": "5795551", "code1": "    protected HttpResponse doGet(String action, String[][] args) throws IOException {\n        long startTime = System.currentTimeMillis();\n        String getString = host + \"?\" + ACTION_PARAMETER + \"=\" + action;\n        if (args != null && args.length != 0) {\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].length != 0) {\n                    getString = getString + \"&\" + args[i][0] + \"=\" + encode(args[i][1]);\n                }\n            }\n        }\n        HttpGet httpGet = new HttpGet(getString);\n        HttpResponse response = getHttpClient().execute(httpGet);\n        if (timingsOn) {\n            totalCalls++;\n            long elapsedTime = (System.currentTimeMillis() - startTime);\n            if (totalCalls != 1) {\n                totalTime = totalTime + elapsedTime;\n                minTime = Math.min(minTime, elapsedTime);\n                maxTime = Math.max(maxTime, elapsedTime);\n            } else {\n                minTime = elapsedTime;\n                maxTime = 0L;\n            }\n            System.out.println(\"http get took \" + elapsedTime + \" ms., (calls, min, max, av) = (\" + totalCalls + \", \" + minTime + \", \" + maxTime + \", \" + (totalTime / totalCalls) + \")\");\n        }\n        return response;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        System.setProperty(\"debug\", \"debug\");\n        OAuthConsumer consumer = new DefaultOAuthConsumer(\"YmRF4HDvikvwDxYafsaK\", \"r)q7L!4X$j$nTS0lXAjC=al9Xf*cLOdyFJsy%2OE\");\n        consumer.setTokenWithSecret(\"5722da60fee79ef9efc2d383f871d550\", \"39142f31ad8a7e6ff7b87f36cc9e8f10\");\n        URL url = new URL(\"http://api.t.sohu.com/statuses/update.json\");\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        HttpParameters para = new HttpParameters();\n        para.put(\"status\", URLEncoder.encode(\"\u4e2d \u6587\", \"utf-8\").replaceAll(\"\\\\+\", \"%20\"));\n        consumer.setAdditionalParameters(para);\n        consumer.sign(request);\n        OutputStream ot = request.getOutputStream();\n        ot.write((\"status=\" + URLEncoder.encode(\"1\u4e2d \u6587\", \"utf-8\")).replaceAll(\"\\\\+\", \"%20\").getBytes());\n        ot.flush();\n        ot.close();\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 0, "substitutes": {"action": ["host", "attr", "route", "value", "operation", "active", "actions", "url", "result", "argument", "function", "format", "request", "part", "data", "version", "resource", "call", "address", "method", "name", "query", "event", "patch", "act", "step", "api", "key", "string", "path", "uri", "command", "ACTION", "service", "option", "str", "Action", "arg", "type"], "startTime": ["startTim", "StartLine", "mintime", "Starttime", "starttime", "StartStart", "minStart", "minLine", " startLine", "minTim", " startStart", "startStart", "StartTime", "startLine", "StartTim", " starttime", " startTim"], "getString": ["GETSite", " getSite", "doFunction", "serviceStr", "serviceStruct", "GETRest", "GETArray", " getStruct", "GetString", " getStream", "getArray", "setArray", "getFunction", "checkstring", "getstring", "dostring", "setRest", "checkString", "setFunction", " getArray", "setstring", " getFunction", "GETString", "setInt", " getRest", "doArray", "getSite", "setStream", "GETStream", "getInt", "getStr", "doString", "GetSite", "getStruct", "checkStruct", "getRest", "GetStream", "serviceString", "GetArray", " getInt", "GETInt", " getStr", " getstring", "checkStr", "setString", "getStream", "servicestring"], "i": ["page", "h", "id", "si", "d", "multi", "qi", "iu", "phi", "k", "hi", "io", "l", "yi", "y", "in", "b", "val", "part", "f", "di", "n", "r", "bi", "I", "oi", "ti", "ai", "info", "gi", "ie", "x", "iv", "isi", "ix", "it", "ui", "u", "o", "e", "ci", "length", "ini", "a", "m", "lc", "li", "v", "key", "xi", "index", "ri", "j", "c", "uri", "ori", "ii", "pi", "s", "ip", "p", "type"], "httpGet": [" httpPut", "HttpGet", "HttpPut", "ttpPut", "HTTPGet", "HTTPPull", "httpPull", "httpsGet", "httpThis", "httpget", " httpPull", "httpsPut", "httpPut", "httpsget", " httpget", " httpThis", "httpSend", "httpsSend", "ttpGet", "HTTPPut", "HttpSend", "HTTPThis", "ttpPull", "Httpget", "ttpThis", " httpSend"], "response": ["next", "respond", "value", "connection", "dict", "reply", "result", "function", "message", "output", "view", "out", "request", "object", "application", "onse", "data", "re", "resource", "server", "method", "body", " Response", "json", "api", "v", "status", "Response", "all", "respons", "answer", "resp", "Resp", "array", "service", "res", "entry"], "totalCalls": ["totalCalled", "totalCales", "totalChalls", "totalRecats", " totalScall", " totalCalled", "totalSall", " totalRecats", " totalRecalled", "totalRall", "totalWall", "totalWats", "totalWalls", " totalFalls", " totalSalled", "totalcalled", "totalFall", " totalFatches", "totalScALL", " totalSall", "totalScalls", "totalCals", "totalChalled", "totalRecatches", "totalRecals", "totalcats", "totalRals", "totalCALL", "totalSalls", "totalScales", " totalScALL", "totalcales", "totalCatches", " totalScalls", " totalSales", "totalScall", " totalRecall", "totalChALL", " totalCats", " totalCALL", "totalRatches", "totalcALL", " totalFall", "totalCats", "totalWalled", "totalcalls", "totalCall", " totalScalled", "totalRecalls", " totalCales", "totalcall", " totalCall", "totalRecall", "totalFalls", "totalFals", "totalFatches", "totalScalled", " totalSalls", "totalSales", " totalCals", "totalRecalled", "totalSalled", "totalRalls", " totalCatches", " totalFals", " totalRecalls", "totalChall"], "elapsedTime": ["elandedTIME", "elapsedtime", "ElapsedTimes", "elapsedTIME", "elodedtime", "elapseStream", "elimatedtime", "elocationTimes", "elasedTimes", "ElapseCount", "ElapsePath", "elocatedValue", "elapsetime", "ElapseDuration", "elapseTimes", "elashedtime", "ElapseValue", "elapsedDuration", "elashedCount", "elandedTime", "elapseValue", "elapsedStream", "ElapsedTime", "elocatedTime", "elashedTime", "elocationTime", "ElapsedValue", "elapsedValue", "ElapseTime", "elashedPath", "elapseTIME", "elapsePath", "ElapsedCount", "elodedCount", "ElapseTIME", "elapseDuration", "elivedPath", "elasedtime", "elapseTime", "elapseCount", "elimatedStream", "ElapsedPath", "ElapsedTIME", "elivedDuration", "elocatedtime", "elapsedPath", "ElapseTimes", "elocationDuration", "elashedDuration", "ElapsedDuration", "elocationStream", "elimatedTime", "elasedTime", "elapsedTimes", "elasedValue", "elapsedCount", "elimatedTimes", "ElapsedStream", "Elapsedtime", "Elapsetime", "elimatedDuration", "ElapseStream", "elandedTimes", "elivedTime", "elodedTime", "elocatedTimes"], "totalTime": ["totalTimeout", "maxtime", "maxTimes", "nextTime", " totaltime", "partialTimes", " totalLength", "totalSpeed", "nextTimeout", "maxTimeout", "TotalTime", "partialSpeed", "totalTimes", "nextTimes", "maxLength", "totaltime", "totalLength", "TotalTimes", "partialTime", "TotalLength", " totalTimeout", "maxSpeed", " totalSpeed", "nextLength", "partialtime", " totalTimes"], "minTime": ["startTim", "useSize", "maxTimes", " minSize", "realTim", "maxDuration", "startTimes", "MinTime", "mintime", "useTime", " mintime", "minTimes", "minDuration", "starttime", " minTimes", "MinSize", "maxTim", "minLength", " minLength", "Mintime", " minDuration", "realTime", "maxLength", "realDuration", "MinLength", "minTim", "realTimes", "startLength", "useTim", "startSize", "minSize", "useLength", "maxSize", " minTim"], "maxTime": ["startTim", "MaxTime", "maxtime", "maxTimes", "startTimes", "cleanLength", "totalSpeed", "cleanSpeed", " maxTimes", " maxSize", " maxtime", "maxCount", "expTim", "maxTim", "expLength", "startCount", "totalTimes", " maxLength", "cleanTim", "totalTim", "maxLength", "totaltime", "totalLength", " maxCount", "expTime", "totalSize", "expSize", " maxTim", "maxSpeed", "Maxtime", " maxSpeed", "MaxLength", "totalCount", "cleanTime", "maxSize", "MaxTimes"]}}
{"id1": "22261730", "id2": "2009328", "code1": "    public static boolean fileCopy(String sFileSrc, String sFileDst) {\n        boolean ok = true;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            File fSrc = new File(sFileSrc);\n            int len = 32768;\n            byte[] buff = new byte[(int) Math.min(len, fSrc.length())];\n            fis = new FileInputStream(fSrc);\n            boolean append = false;\n            fos = new FileOutputStream(sFileDst, append);\n            while (0 < (len = fis.read(buff))) fos.write(buff, 0, len);\n            fos.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n            ok = false;\n        } finally {\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException ex) {\n                    ex.printStackTrace();\n                    JdxLog.logError(ex);\n                }\n            }\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException ex) {\n                    ex.printStackTrace();\n                    JdxLog.logError(ex);\n                }\n            }\n        }\n        return ok;\n    }\n", "code2": "    private String storeProxy(String proxyPath, String userName) throws IOException {\n        File inputFile = new File(proxyPath);\n        String outfile = slcsFactory.getStoreDirectory() + File.separator + userName + File.separator + PROXYFILENAME;\n        File outputFile = new File(outfile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n        Process p = Runtime.getRuntime().exec(\"/bin/chmod 600 \" + outfile);\n        try {\n            p.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return outfile;\n    }\n", "label": 1, "substitutes": {"sFileSrc": ["sPlaceSource", "sFileStrc", "sFilesSrc", "sFilesNource", "sFileStource", "sFileSsrc", "sPlaceSrc", "sPlaceSst", "sFilesNRC", "sFileNRC", "sFilesSdr", "sFileStst", "sFileSeRC", "sFileCsrc", "sPlaceSsrc", "sFilesSRC", "sFileDource", "sFileSRC", "sFileSedr", "sFileCrc", "sFileNource", "sFileSeource", "sFileCst", "sFileCource", "sPlaceDource", "sFilesNdr", "sFileSdr", "sFileSerc", "sFileSource", "sFileDdr", "sFileStsrc", "sFileSst", "sPlaceDrc", "sFileDrc", "sPlaceDst", "sFileNdr", "sFileNrc", "sFilesNrc", "sFileDsrc", "sPlaceDsrc", "sFileDRC", "sFilesSource"], "sFileDst": ["sFileAddSt", "sFilesDot", "sFilesSrc", "sFileDoesost", "sFileSot", "sFileBst", "sFileAddrc", "sFilesSub", "sFileAddst", "sFilesSSt", "sFileDSt", "sFilesSst", "sFilesDost", "sFileDoesrc", "sFileDuot", "sFilesDub", "sFileSost", "sFileSub", "sFileDurc", "sFileDuub", "sFilesDSt", "sFilesDrc", "sFileSst", "sFileBub", "sFileDoesSt", "sFileDrc", "sFilesSot", "sFileDost", "sFileDust", "sFileDoesst", "sFileDot", "sFileBot", "sFilesDst", "sFileSSt", "sFileDub", "sFileBrc", "sFilesSost", "sFileAddost"], "fis": ["lfos", "sfos", "lfies", "los", " fs", " fisc", "vios", "fei", " fIs", "fenos", "fenis", "feis", "flos", "ifios", "fs", "Fos", "sfi", "fenIs", "flis", "flisc", "Fori", "lfis", " fi", "fori", "feos", "sfis", "fios", "cfs", " fios", "fIs", "sfori", "vs", "ifbs", "lfIs", "Fis", "cfos", " fies", "fisc", "cfbs", "fbs", "li", "lis", "vis", "fenies", "ifis", "ifos", "cfios", "vos", "lisc", "Fi", "cfis", "fies", "feori", "fi", "fli", " fbs"], "fos": ["Foes", "Foos", "fus", "infoss", " fo", " foes", "doss", "boos", "ffis", "hoc", "infoes", " foos", "foss", "fo", "ffos", "Fos", "Fus", "Foss", "Foc", "bos", " foc", "fors", "infos", "Fo", "fios", "infus", "dos", " fios", "ffaos", " faos", " fus", "infors", "foc", "hus", "infoos", "hos", "Fis", "haos", " fors", "his", "infis", "ifors", "faos", "ffus", "foos", "ifos", "ifoes", "Fios", "ifoos", "bis", "hios", " foss", "foes", "boes", "does"], "fSrc": ["fssrc", "sfAsst", "fDrc", "fDsrc", "fPsbb", "fAssrc", " fSsrc", "fSRC", "fInsrc", "fpDRC", "fPsst", "sfSrc", "fInRC", "fpSRC", "fpDst", "fSsrc", "sfSst", "sfSsrc", "fpSrc", "fpSsrc", " fAsRC", "fpSst", "sfAssrc", "fAsource", "fAsRC", "fAsrc", "fDst", "fAsbb", "sfSbb", "sfAsbb", "fPssrc", "fSource", " fAsource", "fpDrc", "fPsrc", "fInource", "fsst", " fAssrc", "fInrc", "sfAsrc", " fSRC", "fAsst", "fDRC", "fsRC", " fAsrc", "fSst", "fSbb", " fSource", "fpDsrc", "fsrc"], "len": ["dl", "lp", "size", "split", "en", "url", "ln", "lit", "lf", "min", "limit", "lim", "l", "end", "val", "lon", "part", "f", "lan", "Len", "loc", "base", "data", "n", "el", "body", "nt", "length", "fn", "seq", "partial", "fl", "lc", "li", "buf", "offset", "le", "dy", "count", "err", "pos", "un", "start", "lin", "fin", "bin", "line", "ll"], "buff": ["read", "cb", "bf", "txt", "feed", "buffer", "tab", "build", "FF", "stuff", "b", "cmd", "diff", "bug", "f", "fe", "data", "cp", "ref", "info", "pad", "fam", "Buff", "aff", "batch", "bb", "ob", "ph", "length", "text", "uf", "buf", "bag", "back", "gb", "count", "gz", "load", "code", "fb", "uff", "boot", "ff", "bin", "cod", "fab", "bl", "ext"], "append": ["next", "pend", "continue", "write", "open", "buffer", "repeat", " extend", "ended", "app", "end", "pack", "ending", "enc", "save", "push", "atten", "update", "send", "force", "opp", "batch", "printf", "flush", "length", "text", "string", "vert", "replace", "fail", "each", "pp", "start", "ignore", "add", "op", "apply", "cmp"], "ok": ["yes", "OK", "id", "cb", "success", "pull", "result", "Ok", "k", "ak", "app", "val", "bug", "ise", "f", "p", "always", "auto", "clean", "work", "ready", "sync", "ack", "oks", "full", "ob", "log", "bool", "found", "ko", "job", "rec", "lock", "load", "error", "check", "err", "fail", "or", "c", "valid", "boot", "md", "self", "good", "obj", "null", "coll", "pl"]}}
{"id1": "17728719", "id2": "2102737", "code1": "    private void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private String getContents(Server server, String uri) throws TechnicalException {\n        try {\n            URL url = new URL(\"http://localhost:\" + PORT + uri);\n            return StreamUtils.getStreamContent(url.openStream());\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new TechnicalException(e);\n        }\n    }\n", "label": 0, "substitutes": {"src": ["source", "sel", "sb", "url", "input", "txt", "upload", "download", "sit", "inf", "b", "loc", "stab", "stream", "sc", "config", "dest", "sup", "filename", "ins", "rc", "inst", "ls", "sin", "slice", "path", "rl", "obj", "file", "uri", "files", "sq", "dist", "img", "sn", "proxy", "s", "rb"], "dst": ["sdst", " dsts", "dsts", "dST", "dsrc", "nsts", "adct", "rdft", "nst", "Ddest", "adst", "sdsrc", "ndest", "rdsrc", "rdct", "adft", "DST", "rdst", "Dsts", " ddest", " dST", "dft", "dct", "adsrc", "Dst", "nST", "ddest", "sdft", "sdct"], "in": ["source", "reader", "id", "url", "input", "inc", "din", "ln", "trans", "win", "pull", "nin", "conn", "con", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "stream", "inner", "init", "ins", "gin", "ini", "kin", "sin", "up", "cin", "socket", "file", "i", "IN", "inside", "inn", "rin", "is", "lin", "bin"], "out": ["parent", "trans", "inc", "net", "io", "output", "outer", "conn", "lib", "w", "client", "part", "data", "n", "Out", "OUT", "outs", "again", "server", "raw", "call", "writer", "off", "exec", "sync", "o", "other", "exp", "log", "ex", "post", "up", "pool", "obj", "cache", "file", "i", "err", "cos", "at", "img", "self", "bin", "copy", "ext"], "buf": ["cb", "tmp", "queue", "bf", "bh", "uc", "buffer", "buff", "br", "lim", "b", "cmd", "bc", "fd", "loc", "cv", "base", "data", "bd", "ref", "bytes", "ctx", "box", "raw", "pad", "off", "func", "batch", "rc", "bb", "length", "seq", "uf", "cap", "bag", "orig", "c", "vec", "fb", "ff", "bn", "bin", "rb", "bp"], "len": ["size", "split", "en", "id", "num", "ln", "lf", "ind", "iter", "min", "limit", "lim", "l", "end", "val", "fd", "part", "f", "base", "Len", "data", "no", "n", "enc", "off", "el", "body", "nt", "length", "cap", "lc", "li", "fl", "le", "all", "dy", "count", "c", "rev", "err", "pos", "fin", "line"]}}
{"id1": "6102140", "id2": "4623012", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"readExp": ["loadexp", " readComp", " readExpress", "writeExpl", "readComp", "readEx", "READExpress", "ReadExpl", "Readexp", "writeEx", "writeExt", "readExt", "loadEXP", "ReadExp", " readexp", "ReadEXP", "writeComp", "READExp", " readEx", " readEXP", "readexp", " readExpl", "readEXP", "loadExp", "readExpress", "ReadEx", "loadExt", "READEx", "READExt", "writeExpress", "ReadExt", "ReadComp", " readExt", "readExpl"], "writeExp": ["writeExpl", "WriteExp", "outputStr", "readEx", "writexp", "writeExt", "writeEx", "readExt", "updateEx", "writeexp", "outputEx", "updateExpl", "updateexp", "changeEx", " writeExt", "changeexp", "WriteExpl", " writexp", " writeExpl", " writeStr", "readexp", "updateExp", "outputExt", "changexp", "outputExp", "changeExp", "readStr", " writeEx", " writeexp", "writeStr", "Writeexp", "WriteEx", "readxp"], "expFile": ["pressTable", "expFiles", " expStream", "indexFilename", "exFiles", "exPath", "ExpStream", "xpFiles", "EXPFile", "expPath", "expStream", "pressFile", "ExpFilename", "xpDir", "exampleFilename", "expressFolder", "xpFilename", "indexFILE", " expPath", "expressFilename", "examplefile", "scriptFILE", "expFilename", "expFILE", " expFilename", "exampleFile", "xpPlace", "expDir", "expTable", "expPlace", "ExpTable", "indexFile", "scriptFile", "ExpFile", "expfile", "xpFolder", "scriptfile", " expTable", "EXPPlace", "xpPath", " expDir", "exFilename", " expFiles", "expressfile", "expressFile", "pressStream", "expFolder", "expressPlace", "pressDir", "expressDir", "exampleFILE", "scriptFilename", "exFile", "EXPDir", "ExpDir", "xpFile", "EXPFolder", "expressFILE", "indexDir", "ExpFILE"], "exp": ["expl", "div", "nz", "plus", "str", "input", "xml", "rep", "jp", "pl", "doc", "example", " expansion", "app", "inf", "iz", "Exp", "model", "f", "isp", "fe", "data", "EXP", "progress", "prov", "zip", "comp", "sc", "push", " experiment", "module", "x", "script", "asm", "query", " expand", "inst", "scope", "feat", "act", "ef", "dj", "complex", "express", "exper", "temp", "obj", "i", "vec", "expression", "xp", "np", "ip", "expr", "form", " exam", "project", "test", "acc", "dem", "imp", "p", " expanded", "ext"], "fi": ["py", "lli", "si", "qi", "abi", "cf", "fy", "yi", "fc", "fp", "sf", "FI", "ifi", "fe", "afi", "bi", "zi", "ni", "ffe", "ifa", "isi", "ci", "wi", "eni", "ani", "ini", "xi", "li", "i", "ii", "ilia", "flo", "fb", "pi", "Fi", "osi", "fa", "sci"], "oi": ["obi", "oni", "ahi", "ki", "lli", "si", "qi", "abi", "oid", "io", "odi", "avi", "uci", "asi", "di", "bi", "oxy", "obb", "oa", "ti", "ji", "ai", "ni", "omi", "ofi", "isi", "ui", "ci", "eni", "ani", "eye", "shi", "ski", "ini", "li", "ori", "i", "ii", "flo", "ogi", "ois", "ku", "ilo", "eu", "agi", "edi", "osi"], "jf": ["jenfp", "jetF", "vfx", "pf", " jc", "vf", "ujF", " jfs", "jenf", "jenb", " jfx", "jfx", "che", "chF", "jencf", "jp", "pb", "chf", "ujfs", "uje", "Jfx", "Jfp", "chfx", "vb", " jF", "jb", " jtf", "Jf", " jp", "Jb", "jcf", "Jp", "pcf", "jpfx", " jfp", "jfs", "jete", "jenc", "je", "Jv", "jpcf", "Jcf", "Je", " je", "jc", "vtf", "jv", "jetf", " jv", "jF", " jcf", "jfp", "pp", " jb", "jpF", "jpf", "jtf", "ujf", "JF", "jetfs", "Jc", "jpb", "jenv", "jptf"], "sp": ["px", "lp", "page", "source", "py", "sb", "inc", "si", "pe", "space", "cmp", "sg", "jp", "sm", "sw", "fp", "app", "sf", "osp", "st", "op", "isp", "p", "fe", "cp", "style", "ctx", "sc", "sh", "serv", "wp", "js", "Sp", "sup", "tp", "vp", "inst", "mp", "scope", "amp", "gp", "spec", "per", "sl", "pr", "sv", "esp", "se", "frame", "bsp", "SP", "html", "j", "np", "pp", "sq", "spe", "service", "soc", "ps", "pl", "so", "imp", "bp", "sci"], "e": ["ea", "pe", "ception", "ee", "w", "ev", "vent", "in", " Event", "ep", "E", "exc", "fe", "ec", "ctx", " enc", "es", "el", "x", "event", "de", "ae", "t", "v", "se", "ce"], "fo": ["ao", "la", "yo", "go", "tto", "co", "io", "ico", "ro", "olo", "foo", "jo", "FO", "ho", "po", "mo", "osa", "oooo", "bo", "vo", "lo", "zo", "fa", "o", "ooo", "ph", "ko", "obj", "flo", "oso", "obo", "ato", " lo", "so", "wo"], "oo": ["obi", "ao", "la", "oid", "oh", "co", "ro", "ico", "io", "aco", "olo", "foo", "que", "LO", "FO", "ou", "po", "mo", "osa", "oa", "os", "oooo", "loo", "bo", "lo", "va", "argo", "oos", "o", "da", "ooo", "oe", "ko", "oto", "obe", "OO", "oda", "elo", "ox", "flo", "obo", "goo", "cro", "ilo", "ollo", "so", "wo", "qa"], "ex": ["expl", "su", "ru", "nex", "rx", "ic", "ception", "rex", "Ex", "pl", "example", "tex", "out", "in", "Exc", "exc", "pex", "again", "class", "re", "sex", "x", "de", "ax", "cl", "act", " Ex", "cap", "com", "EX", "obj", "error", "fail", "err", "lex", "ignore", "res", "exit", "null", "except", "ext"]}}
{"id1": "7257286", "id2": "16995204", "code1": "    public static void main(String[] args) {\n        if (args.length <= 0) {\n            System.out.println(\" *** DML script generator and executor ***\");\n            System.out.println(\" You must specify name of the file with SQL script data\");\n            System.out.println(\" Fisrt rows of this file must be:\");\n            System.out.println(\" 1) JDBC driver class for your DBMS\");\n            System.out.println(\" 2) URL for your database instance\");\n            System.out.println(\" 3) user in that database (with sufficient priviliges)\");\n            System.out.println(\" 4) password of that user\");\n            System.out.println(\" Next rows can have:\");\n            System.out.println(\"   '&' before table to insert into,\");\n            System.out.println(\"   '^' before table delete from,\");\n            System.out.println(\"   '*' before table update.\");\n            System.out.println(\" Other rows contain parameters of these actions:\");\n            System.out.println(\"   for & action each parameter is a list of values,\");\n            System.out.println(\"   for * action -//- pare of values with 1st PK (will be in where clause),\");\n            System.out.println(\"   for ^ (not obligatory) -//- part of where clause or AND or OR\");\n            System.out.println(\"    (by depault parts are united with OR)\");\n            System.out.println(\" Note: despite SQLScript, 1) list (pare) of values can be separated\");\n            System.out.println(\"   by space or tab, not only comma and 2) string values can be not quoted,\");\n            System.out.println(\"   but in this (2) case only 2 values allowed (even in insert)\");\n            System.out.println(\" '!' before row means that it is a comment.\");\n            System.out.println(\" If some exception is occured, all script is rolled back.\");\n            System.out.println(\" If you specify 2nd command line argument - file name too -\");\n            System.out.println(\"   connection will be established but all statements will\");\n            System.out.println(\"   be saved in that output file and not transmitted to DB\");\n            System.out.println(\" If you specify 3nd command line argument - connect_string -\");\n            System.out.println(\"   connect information will be added to output file\");\n            System.out.println(\"   in the form 'connect user/password@connect_string'\");\n            System.exit(0);\n        }\n        try {\n            String[] info = new String[4];\n            BufferedReader reader = new BufferedReader(new FileReader(new File(args[0])));\n            Writer writer = null;\n            try {\n                for (int i = 0; i < info.length; i++) info[i] = reader.readLine();\n                try {\n                    Class.forName(info[0]);\n                    Connection connection = DriverManager.getConnection(info[1], info[2], info[3]);\n                    SQLScript script = new DMLScript(connection);\n                    if (args.length > 1) {\n                        writer = new BufferedWriter(new FileWriter(args[1]));\n                        if (args.length > 2) writer.write(\"connect \" + info[2] + \"/\" + info[3] + \"@\" + args[2] + script.statementTerminator);\n                    }\n                    try {\n                        System.out.println(script.executeScript(reader, writer) + \" updates has been performed during script execution\");\n                    } catch (SQLException e4) {\n                        reader.close();\n                        if (writer != null) writer.close();\n                        System.out.println(\" Script execution error: \" + e4);\n                    }\n                    connection.close();\n                } catch (Exception e3) {\n                    reader.close();\n                    if (writer != null) writer.close();\n                    System.out.println(\" Connection error: \" + e3);\n                }\n            } catch (IOException e2) {\n                System.out.println(\"Error in file \" + args[0]);\n            }\n        } catch (FileNotFoundException e1) {\n            System.out.println(\"File \" + args[0] + \" not found\");\n        }\n    }\n", "code2": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        fields.put(item.getFieldName(), item.getString());\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                sendInstance.saveDraft(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, preferencesInstance.getPreferences().isHtmlMessage(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "label": 1, "substitutes": {"script": ["select", "tests", "contract", "input", "sql", "cript", "engine", "output", "doc", "ment", "python", "RIPT", "custom", "model", "Script", "javascript", "data", "system", "sc", "call", "config", "template", "condition", "exec", "module", "action", "query", "report", "log", "comment", "express", "escape", "SQL", "session", "index", "insert", "scripts", "document", "file", "command", "struct", " scripts", "block", "database", "process", "test", "shell"]}}
{"id1": "19434892", "id2": "16995204", "code1": "            public void handle() {\n                if (requestCounter == 0) {\n                    requestCounter++;\n                    return;\n                }\n                requestCounter++;\n                Iterator it = loggerTimeouts.keySet().iterator();\n                while (it.hasNext()) {\n                    String host = (String) it.next();\n                    String timeout = (String) loggerTimeouts.get(host);\n                    int timeoutVal = Integer.parseInt(timeout);\n                    if (timeoutVal > 0) {\n                        timeoutVal /= 10;\n                    }\n                    int timeoutMod = (requestCounter % timeoutVal);\n                    if (timeoutMod == 0) {\n                        Object loggerFile = loggerFiles.get(host);\n                        Object loggerFilenameObject = loggerFilenames.get(host);\n                        Object loggerDestObject = loggerDests.get(host);\n                        Object loggerCompressObject = loggerCompresses.get(host);\n                        Object loggerDayObject = loggerDays.get(host);\n                        Object loggerArchiveObject = loggerArchives.get(host);\n                        Object loggerDeleteObject = loggerDeletes.get(host);\n                        boolean rotateCompress = false;\n                        boolean rotateDelete = false;\n                        String rotateDest = null;\n                        String logFile = null;\n                        String rotateArchive = null;\n                        int rotateDays = 0;\n                        if (loggerCompressObject != null && ((String) loggerCompressObject).equalsIgnoreCase(\"true\")) {\n                            rotateCompress = true;\n                        }\n                        if (loggerDeleteObject != null && ((String) loggerDeleteObject).equalsIgnoreCase(\"true\")) {\n                            rotateDelete = true;\n                        }\n                        if (loggerDestObject != null) {\n                            rotateDest = (String) loggerDestObject;\n                        }\n                        if (loggerFilenameObject != null) {\n                            logFile = (String) loggerFilenameObject;\n                        }\n                        if (loggerArchiveObject != null) {\n                            rotateArchive = (String) loggerArchiveObject;\n                        }\n                        if (loggerDayObject != null) {\n                            rotateDays = Integer.parseInt((String) loggerDayObject);\n                        }\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                                buf = null;\n                                out = null;\n                                in = null;\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"' to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                destChannel = null;\n                                srcChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data from file '\" + logFile + \"' to '\" + destOutFile + \"' for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete) {\n                            try {\n                                ((PrintStream) loggerFile).close();\n                            } catch (Exception e) {\n                            }\n                            (new File(logFile)).delete();\n                            loggerFiles.remove(host);\n                            addLogger(host, logFile);\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            fileList = null;\n                            format1 = null;\n                            archive = null;\n                        }\n                    }\n                }\n                it = null;\n            }\n", "code2": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        fields.put(item.getFieldName(), item.getString());\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                sendInstance.saveDraft(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, preferencesInstance.getPreferences().isHtmlMessage(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "label": 1, "substitutes": {"requestCounter": ["responseNum", "RequestNumber", "RequestCounter", "requestcounter", "responseClock", " requestNum", " requestClock", "resourceCount", "reqcounter", "responsecounter", "reqNum", "responseCount", "reqNumber", "requestClock", "reqCounter", "requestNumber", "RequestCount", "RequestClock", "requestNum", " requestcounter", "requestCount", " requestNumber", "reqCount", "resourceCounter", "resourceClock", " requestCount", "resourceNumber", "responseNumber", "responseCounter"], "it": ["split", "id", "si", "ic", "lit", "the", "ind", "itted", "sit", "iter", "ati", "itter", "mit", "end", "iz", "you", "st", "jit", " It", "p", "pit", "set", "I", "master", "ti", "IT", "he", "It", "iv", "ite", "init", "edit", "ci", "iti", "nt", "they", "ort", "t", "ait", "index", "quit", "slice", "ut", "its", "itting", "ble", "or", "start", "which", "et", "ITS", "op", "rit", "entry"], "host": ["source", "head", "hop", "h", "url", "default", "user", "hour", "Host", "connection", "feed", "conn", "format", "http", "request", "cmd", "client", "state", "object", "driver", "owner", "home", "bug", "hello", "loop", "mac", "part", "loc", "remote", "response", "prefix", "handler", "server", "config", "address", "condition", "box", "chrom", "xx", "name", "method", "component", "query", "project", "large", "target", "device", "container", "cont", "pattern", "dr", "content", "localhost", "post", "key", "path", "node", "docker", "connect", "socket", "uri", "service", "header", "database", "hub", "addr", "subject", "domain", "proxy", "ctor", "port", "coll", "location", "type"], "timeout": ["Timeout", "size", "url", "period", "connection", "network", "io", "limit", "conn", "format", "security", "sleep", "response", "resource", "prefix", "ticket", "config", "second", "address", "sync", "until", "name", "slot", "target", "cookie", "length", "capacity", "frequency", "time", "key", "offset", "socket", "delay", "ssl", "service", "wait", "timer", "value", "port", "duration", "unit"], "timeoutVal": ["TimeoutNum", "timeoutEl", "delayVal", " timeoutEl", "delayEl", "timeLen", "TimeoutValue", "delayLen", "timeNum", "delayUnit", "timeoutValue", "timeEl", "timeoutUnit", " timeoutLen", " timeoutUnit", "timeoutNum", " timeoutValue", "delayNum", "TimeoutVal", "TimeoutUnit", "timeoutLen", "TimeoutLen", "delayValue", " timeoutNum", "timeVal"], "timeoutMod": ["TimeoutNum", "delayVal", "timeoutMin", "delayMod", "timeoutModule", " timeoutModule", "timeoutNum", "delayNum", "delayMin", "timeoutMult", "TimeoutVal", "TimeoutMin", " timeoutNum", "delayModule", " timeoutMult", "TimeoutMult", "TimeoutMod", " timeoutMin", "TimeoutModule", "delayMult"], "loggerFile": ["loglerSourceFile", "loglerFILE", "LoggerFILE", "logerSourceFile", "loggerSourceFile", "logerFile", "LoggerSourceFile", "LogerFile", "loggerFiles", "LogerFiles", "loggersSourceFile", "loggerFILE", "loglerFile", "loggersFile", "LoggerFiles", "LogerFILE", "loggersFILE", "loggersFiles", "logerFiles", "LogerSourceFile", "logerFILE", "loglerFiles", "LoggerFile"], "loggerFilenameObject": ["loggerDirectoryobject", "loggerFileObj", "loglerFilenameObj", "loggerDownloadObj", "loggerDownloadString", "loglerFilenameObject", "loggingFilenameObj", "logerFilenameObj", "loggerFilenameobject", "loggingDirectoryObject", "loggerSourceFileString", "loggerDirectoryPart", "loggerDirectoryObject", "loggerSourceFileobject", "loggingDirectoryArray", "logerFilenamePart", "loglerDownloadObj", "loggerSourceFileArray", "loglerDownloadString", "loggerDownloadobject", "loglerFilenameobject", "logerFileObject", "loggerFileobject", "loggingDirectoryobject", "loggerFileString", "loggingFilenameObject", "loggerDirectoryArray", "loggingFilenameArray", "loggerFilenameArray", "loggerFilenamePart", "loggerFileObject", "loglerFilenameString", "loggerFileArray", "loggingDirectoryObj", "logerFileObj", "logerFileArray", "logerFilenameArray", "logerFilePart", "loggerDirectoryObj", "loggerSourceFilePart", "loggerSourceFileObj", "logerFilenameObject", "loggerFilePart", "loglerDownloadobject", "loggerFilenameString", "loggingFilenameobject", "loglerDownloadObject", "loggerSourceFileObject", "loggerDownloadObject", "loggerFilenameObj"], "loggerDestObject": ["loggerDeleteString", "loggerDirectoryPool", "loggerSourceObject", "logerSourceobject", "loggerSyncObj", "loggerDistObject", "loggerDelObject", "loggerDeleteObj", "loggerTargetObj", "loggerSyncObject", "loggerSourceObj", "loggerDirectoryObject", "logerDirectoryObject", "loggerDestPool", "loggerDelObj", "logerDestString", "loggerDestString", "logerDestPool", "loggerDirObj", "loggerDelString", "logerDirectoryString", "loggerSourceString", "loggerTargetPool", "loggerTargetString", "loggerDistObj", "logerDirectoryObj", "logerDeleteObject", "loggerDistobject", "loggerSourceobject", "loggerDestobject", "loggerTargetObject", "loggerDirPool", "logerDestObj", "loggerDelobject", "loggerDirectoryObj", "loggerDirObject", "logerDestobject", "logerSourceString", "loggerDeleteobject", "loggerDirString", "loggerSyncobject", "loggerDirectoryString", "logerDestObject", "logerDirectoryPool", "logerDeleteobject", "logerDeleteObj", "loggerDestObj", "logerSourceObject", "logerSourceObj"], "loggerCompressObject": ["loggercompressObj", "loggercompressorClass", "loggerCompressorObject", "loggerCompressingObject", "loggerCompressingItem", "loggercompressorNumber", "loggercompressNumber", "loggerCompressUnit", "loggerCompressionNumber", "loggercompressorObject", "loggerCompressFile", "loggerCompressionObj", "loggerCompressesFile", "loggerCompressItem", "loggerCompressClass", "loggerPropressionObj", "loggerCompressesObject", "loggerCompressesUnit", "loggerPropressObj", "loggerCompressesNumber", "loggerCompressesObj", "loggerCompressionObject", "loggerPropressNumber", "loggerPropressionItem", "loggerCompressingNumber", "loggerCompressingObj", "loggerPropressionNumber", "loggerCompressorObj", "loggerPropressionObject", "loggerCompressionItem", "loggerCompressorNumber", "loggerPropressObject", "loggerCompressesClass", "loggerCompressionUnit", "loggerCompressorUnit", "loggercompressObject", "loggercompressesUnit", "loggerCompressionClass", "loggerCompressionFile", "loggercompressClass", "loggerCompressesItem", "loggercompressFile", "loggerCompressorFile", "loggerCompressObj", "loggerCompressNumber", "loggercompressesFile", "loggercompressorObj", "loggerCompressorClass", "loggercompressUnit", "loggercompressesObject", "loggercompressesObj", "loggerPropressItem"], "loggerDayObject": ["loggerDeleteInt", "loggerDaysObject", "loggingDateobject", "loggingDayObj", "loggerdayObject", "logerDateObj", "loggerDeleteObj", "loggingDayobject", "loggerDaysNumber", "loggingDateObject", "loggingDayInt", "logerDayFile", "loggerDateObj", "loggerDateObject", "logerDateFile", "loggerdayObj", "logerDayObject", "loggerDayobject", "loggerDailyNumber", "loggerdayNumber", "loggerDaysobject", "loggerDailyFile", "loggingDateObj", "logerDayNumber", "loggerdayobject", "logerDateNumber", "loggerDayInt", "logerDateobject", "loggerDayFile", "loggerDaysInt", "loggingDayObject", "loggerDeleteobject", "loggerDaysObj", "loggerDailyObject", "loggerDateInt", "loggerDateFile", "logerDateObject", "logerDayobject", "loggerDayObj", "logerDayObj", "loggerDaysFile", "loggerDayNumber", "loggerDateobject", "loggingDateInt", "loggerDateNumber", "loggerDailyObj"], "loggerArchiveObject": ["loggerArchueObject", "loggerPhiveFile", "loggerPhivesArray", "loggerPhiveArray", "loggerEngeObject", "loggerEniveObj", "loggerArchIVEOb", "loggerArchueFile", "loggerArchoreLong", "loggerArchIVELong", "loggerEngeNumber", "loggerEngeOb", "loggerPhiveObj", "loggerArchgeObject", "loggerArchoreElement", "loggerArchivesOb", "loggerArchueArray", "loggerEngeObj", "loggerArchivesArray", "loggerDerIVEObject", "loggerDeriveObj", "loggerArchivesObject", "loggerArchIVEObject", "loggerDeriveLong", "loggerArchivesNumber", "loggerPhivesObject", "loggerArchiveObj", "loggerArchIVENumber", "loggerArchivesLong", "loggerArchiveElement", "loggerDerIVELong", "loggerPhiveObject", "loggerArchIVEFile", "loggerPhivesObj", "loggerArchgeObj", "loggerEniveNumber", "loggerArchgeNumber", "loggerDeriveObject", "loggerPhivesFile", "loggerArchiveLong", "loggerDeriveElement", "loggerArchIVEArray", "loggerArchIVEElement", "loggerEniveObject", "loggerArchiveNumber", "loggerDerIVEElement", "loggerArchivesObj", "loggerArchiveFile", "loggerArchueObj", "loggerArchivesElement", "loggerDerIVEObj", "loggerArchgeOb", "loggerEniveOb", "loggerArchiveOb", "loggerArchIVEObj", "loggerArchoreObject", "loggerArchivesFile", "loggerArchiveArray", "loggerArchoreObj"], "loggerDeleteObject": ["logerDelString", "loggerDeleteString", "loggerCopyobject", "loggeeDeleteElement", "loggerDelObject", "loggerDeleteObj", "loggerCopyString", "loggerDelArray", "loggeeDeleteObj", "loggeeDelElement", "loggerDeleteArray", "logerDeleteFunction", "loggerDelObj", "loggerCopyFunction", "loggerCopyArray", "loggerCleanObj", "loggerCleanObject", "loggerDeleteElement", "loggerCleanElement", "loggerDelString", "logerDelObject", "logerDelobject", "loggerDropObject", "logerDeleteObject", "loggerDeleteFunction", "logerDelFunction", "loggerCopyObj", "loggeeDelArray", "loggerDelElement", "loggeeDeleteObject", "loggerDelobject", "loggerCopyElement", "loggeeDelObj", "loggeeDeleteArray", "loggerUpdateObject", "loggerDelFunction", "loggerDropFunction", "loggerDeleteobject", "loggerDropString", "loggerUpdateobject", "logerDeleteString", "loggerCopyObject", "logerDeleteobject", "loggerCleanArray", "loggerUpdateString", "loggeeDelObject"], "rotateDest": ["polgateDir", "polgateDest", "rotationDirect", " rotizeDest", "rotinateZip", "rotgateRoute", "rotgateDir", "rotateZip", "rotateRoute", "polateDes", "rotizeDir", "rotinateDirect", "rotizeDest", "polateDest", " rotizeZip", "rotizeZip", " rotateDirect", " rotizeDirect", "rotgateDes", "polateDir", "rotationDes", "rotateDir", "rotationZip", "rotationDir", "rotinateDest", "rotinateDir", " rotizeDir", "rotgateDest", " rotateZip", "polgateDes", "rotateDes", "polateRoute", "rotationRoute", "rotationDest", "rotizeDirect", " rotateDir", "rotateDirect", "polgateRoute"], "logFile": ["bugStream", "Logfile", " logFilename", "logfile", "copyFile", "copyFiles", "logClass", " logfile", "bugSourceFile", "logFiles", "logSource", "tagfile", "bugfile", "logFilename", "LogFile", "copyRoute", "tagStream", " logSourceFile", "LogFiles", "configSourceFile", "LogSource", " logStream", "catStream", "configFile", "configStream", "logRoute", "bugClass", "LogSourceFile", "catFile", "copyFilename", "bugFile", "logSourceFile", "tagSource", "catSource", " logClass", "configClass", "LogFilename", "LogRoute", "catfile", "tagFile", "logStream", "bugSource", " logFiles", " logRoute", " logSource"], "rotateArchive": ["rotateExived", "rotgeARCHives", "rotgeArchIVE", "rotateExIVE", "rotgeArchive", "rotateExore", "rotgeArchived", "rotateArchIVE", "rotuneArchIVE", "rotateSlives", "rotgeARCHived", "rotateArchived", "rotateInterived", "rotateARCHive", "rotuneArchived", "rotateOctIVE", "rotateSlIVE", "rotateCompore", "rotateSlived", "rotateOctore", "rotateSlive", "rotateARCHIVE", "rotuneCompived", "rotateOctive", "rotuneCompore", "rotateExive", "rotateInterive", "rotgeARCHive", "rotuneCompive", "rotuneCompIVE", "rotateARCHives", "rotgeArchives", "rotuneArchive", "rotateCompIVE", "rotateArchives", "rotgeARCHIVE", "rotateArchore", "rotateInterIVE", "rotateCompived", "rotateInterives", "rotateARCHived", "rotateOctived", "rotuneArchore", "rotateCompive"], "rotateDays": ["rotateFiles", "rotuteDay", "rotateDay", " rotationWords", "RotationHours", "rotrateHours", "RotateHours", "RotationDays", " rotationFiles", "rotationDay", "rotatedFiles", "RotateDay", "rotuteFiles", " rotationDays", "rotationHours", "rotrateDays", " rotateFiles", "RotationFiles", " rotateDay", "RotateDays", "rotateHours", "rotrateFiles", "RotateFiles", "rotationDays", "rotatedWords", "rotatedDays", " rotationDay", "rotrateDay", "rotationWords", " rotateWords", "rotuteHours", "RotationDay", "rotateWords", "rotatedDay", "rotationFiles", "rotuteDays"], "srcChannel": ["srcFile", "srcStream", "rcFile", "insFile", "insStream", "rcStream", "rcChannel", " srcFile", "rcWriter", " srcStream", "srcWriter", "insChannel", " srcWriter", "insWriter"], "destChannel": [" destChan", "destSocket", "targetChan", "srcSocket", "srcCh", "targetCh", "targetSocket", " destCh", "srcChan", " destSocket", "destChan", "destCh", "targetChannel"], "destOutFile": ["srcoutFILE", "srcoutPath", "destoutPath", "destDiffDir", "destoutFILE", "destDestPath", "srcOutPath", "destDestFile", "destOutPath", "destOutDir", "destDiffFILE", "srcoutFile", "destDestFILE", "srcOutDir", "destDiffPath", "destOutFILE", "destDestDir", "srcOutFile", "destoutFile", "srcOutFILE", "srcoutDir", "destDiffFile", "destoutDir"], "destOutFileCompressed": ["destOutFileRepression", "destOutTimeComposed", "destOutFileExposed", "destOutFilecompression", "destOutFileCompression", "destOutTimeRepress", "destOutFilecompress", "destOutTimeCompression", "destOutFileReposed", "destOutFileExpress", "destOutTimeReposed", "destOutFileComposed", "destOutTimeCompress", "destOutTimeRepressed", "destOutFilecompressed", "destOutFileExpression", "destOutTimeCompressed", "destOutFileRepressed", "destOutFileExpressed", "destOutFilecomposed", "destOutTimeRepression", "destOutFileRepress", "destOutFileCompress"], "rotateCompress": ["rotizeExpressed", "rotureCombush", "rotateCompressed", "rotizeCompresses", "rotizeExpress", "rotatePropress", "rotureCompress", "rotateCombress", "rotateExpress", "rotizeCompression", "rotateCombressed", "rotizeCompress", "rotureCombress", "rotureCombressed", "rotatePropressed", "rotizeExpression", "rotateCompush", "rotizeCompressed", "rotateMacresses", "rotateExpressed", "rotateCompressor", "rotureCompressed", "rotateMacressed", "rotatePropush", "rotateCombressor", "rotizeExpresses", "rotateExpresses", "rotateCombush", "rotateExpression", "rotureCompressor", "rotureCombressor", "rotureCompush", "rotateMacress", "rotateCompression", "rotatePropressor", "rotateMacression", "rotateCompresses"], "rotateDelete": ["copateDel", "rotureDel", "rotateUpdate", "RotateDel", "coporeDel", "rotoreLog", "rotoreCreate", "RotateCopy", "rotateLog", "RotuteDelete", "RotateCreate", "rotureUpdate", "rotureLog", "copateDelete", "copateLog", "rotateCopy", "RotuteCopy", "rotoreCopy", "rotuteCopy", "rotateDel", "coporeUpdate", "rotureDelete", "rotuteCreate", "rotateCreate", "coporeLog", "RotateDelete", "rotuteDelete", "copateUpdate", "coporeDelete", "rotoreDel", "RotuteDel", "rotoreDelete", "rotuteDel", "rotoreUpdate", "RotuteCreate"]}}
{"id1": "10067028", "id2": "1424647", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            long size = in.size();\n            MappedByteBuffer buffer = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buffer);\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "src", "from", "object", "Source", "client", "base", "table", "stream", "remote", "resource", "server", "inner", "ources", "sync", "filename", "name", "ins", "target", "ource", "sin", "SOURCE", "internal", "slice", "path", "image", "string", "cache", "file", "service", "proxy", "use"], "destination": [" Destination", " Destinations", "destitution", "declinator", "declination", "Destinated", "distinated", "distination", "distitution", "declinations", "destinated", "declinated", "Destinator", "constinator", "constitution", "destinations", "Destinations", " Destinator", "constination", "destinator", "constinated", "distinator", " Destinated", "Destination", "Destitution"], "in": ["get", "reader", "id", "url", "input", "inc", "din", "token", "win", "pull", "min", "nin", "conn", "src", "con", "b", "this", "diff", "login", "base", "as", "data", "In", "pin", "again", "n", "r", "include", "thin", "stream", "server", "work", "isin", "inner", "info", "pc", "name", "init", "ins", "gin", "ini", "m", "issue", "up", "slice", "index", "cin", "image", "socket", "c", "file", "i", "IN", "err", "inside", "inn", "is", "bin", "pass"], "out": ["parent", "id", "plain", "write", "line", "net", "connection", "extra", "io", "output", "outer", "conn", "one", "w", "client", "ou", "part", "channel", "to", "no", "version", "OUT", "Out", "again", "n", "prefix", "outs", "server", "external", "writer", "inner", "off", "exec", "dest", "sync", "init", "o", "other", "target", "flush", "ex", "timeout", "up", "image", "pool", "vert", "cache", "obj", "file", "socket", "err", "at", "outside", "bin", "copy", "null", "ext"], "size": ["page", "export", "en", "write", "si", "len", "range", "scale", "weight", "limit", "sized", "end", "mode", "Size", "number", "loc", "SIZE", "bytes", "n", "sum", "address", "shape", "send", "depth", "name", "transfer", "sync", "e", "ize", "length", "flush", "capacity", "max", "content", "offset", "time", "count", "code", "seek", "width", "speed", "type", "order", "empty", "small", "clear", "unit"], "buffer": ["reader", "value", "url", "input", "queue", "feed", "buff", "iter", "Buffer", "output", "BB", "channel", "base", "layer", "data", "resource", "address", "info", "writer", "uffer", "null", "batch", "bb", "flow", "length", "wave", "FFER", "buf", "offset", "document", "cache", "map", "header", "texture", "bin", "copy"]}}
{"id1": "9857413", "id2": "813913", "code1": "    @Override\n    public byte[] readData(byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        if (!server.contains(PORT_SEPARATOR)) {\n            server += PORT_SEPARATOR + DEFAULT_PORT;\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        ByteArrayOutputStream baos = null;\n        try {\n            InputStream is = urlc.getInputStream();\n            baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int br;\n            while ((br = is.read(buffer)) > 0) {\n                baos.write(buffer, 0, br);\n                if (!transferMetaData) {\n                    transferredBytesNum += br;\n                    elapsedTime = System.currentTimeMillis() - startTime;\n                    fireOnProgressEvent(transferredBytesNum, elapsedTime);\n                }\n            }\n            baos.close();\n            is.close();\n        } catch (FileNotFoundException fnfe) {\n        }\n        return baos != null ? baos.toByteArray() : null;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"options": ["resources", "Options", "points", "settings", "keys", "io", "optional", "properties", "http", "params", "object", "types", "table", "data", "style", "os", "objects", "outs", "config", "info", "meta", "groups", "results", "o", "json", "values", "timeout", "ios", "headers", "ops", "or", "details", "files", "opt", "option", "ts"], "transferMetaData": ["transferMetClose", "writeMetaFlow", " transferMetMemory", " transferMetaText", "transferMetaRead", "writeMetaDATA", "writeMultiData", "transferMetaMemory", "transfermetaData", "transferMetFlow", " transferMetaClose", "transferMetaFlow", "transferMetRead", "transferMetText", "transferMetaText", "transferMultiDATA", "transferMetDATA", "writeMultiDATA", "transfermetaMemory", "transfermetaText", "transferMetData", "writeMetaData", "transfermetaRead", "transfermetaClose", " transferMetText", " transferMetaRead", "transferMultiFlow", "transferMultiData", "writeMultiFlow", "transferMetMemory", " transferMetaMemory", " transferMetRead", "transferMetaDATA", " transferMetClose", " transferMetData", "transferMetaClose"], "startTime": ["startTimes", " startTimes", "startingTIME", "middleTime", "http", "this", "startingFile", "startTIME", " startFile", "startFile", " startTIME", "HTTP", "startingTime", "middleTimes", "_", "middleFile", "startingTimes", "middleTIME", "Url", "s"], "transferredBytesNum": ["transendedBytesnum", "transfixedFramesNum", "transferredFramesSum", "transferredBytesSum", "transferredFramesnum", "transfixedBytesNum", "transendedByteMsg", "transendedBytenum", "transfixedFramesSum", "transferredFilesMu", "transferredFilesNum", "transferredWordsnum", "transferredFramesNum", "transendedBytesMu", "transferredWordsNum", "transferredFilesMsg", "transferredFilesnum", "transendedByteNum", "transendedByteMu", "transfixedBytesSum", "transfixedFramesVal", "transferredWordsMu", "transferredbytesnum", "transfixedBytesVal", "transendedBytesNum", "transferredBytesVal", "transferredFilesVal", "transferredBytesnum", "transendedBytesMsg", "transferredByteMu", "transfixedFramesnum", "transferredBytesMsg", "transferredBytesMu", "transferredBytenum", "transfixedBytesnum", "transferredbytesVal", "transferredByteNum", "transferredFilesSum", "transferredByteMsg", "transferredbytesSum", "transferredFramesVal", "transferredWordsMsg", "transferredbytesNum"], "elapsedTime": ["eladjustedStream", "elapsesTimes", "elapsedTimes", "elagoTim", "elagoTimes", "elapseTime", "ElapsedTimes", "ElapsedStream", "elocationTim", "elagoMode", "eladjustedTimes", "elapseTim", "elapsedStream", "ElapseTim", "ElapseMode", "elapseStream", "ElapsedTime", "elocationTimes", "elapsedTim", "ElapseTimes", "ElapseStream", "ElapsedTim", "elapsedMode", "elagoTime", "elocationTime", "elocationStream", "elapsesTime", "eladjustedTime", "ElapsedMode", "elapsesMode", "elapseMode", "ElapseTime", "elapsesTim", "elapseTimes", "eladjustedTim"], "opts": ["obrs", "optments", "OPments", " optts", " optt", "OPms", " opters", " opqs", " optTS", "opters", "optps", "obTS", " opns", "oprs", "OPts", "opTs", "OPqs", "opns", "OPns", " opms", "opments", "OPtt", "OPTS", "optt", "opps", "optTS", "obTs", "OPTs", "OPrs", "obts", "optns", "OPters", "opms", "opTS", "opqs", "optms", " opps", " optters", " oprs", "optts", "optqs", " opTS", " opTs", "OPps", " opttt", " opments"], "server": ["source", "host", "site", "user", "si", "Server", "connection", "ser", "peer", "http", "client", "home", "description", "root", "hello", "version", "directory", "remote", "system", "resource", "prefix", "serv", "address", "email", "slave", "master", "inner", "name", "method", "device", "api", "enter", "erver", "localhost", "string", "path", "seed", "socket", "uri", "ssl", "error", "service", "database", "domain", "project", "port", "location", "type"], "username": ["host", "user", "token", "auth", "sword", "nick", "client", "driver", "login", "profile", "prefix", "email", "config", "dn", "address", "alias", "filename", "name", "users", "usr", "USER", "names", "key", "ername", "string", "uri", "attribute", "property", "character", "header", "manager", "database", "service", "subject", "account", "mobile", "port", "author", "uid"], "password": ["host", "user", "token", "auth", "sword", "fax", "wd", "security", "client", "PASS", "column", "login", "profile", "phrase", "resource", "address", "pad", "word", "name", "api", "money", "picture", "timeout", "session", "key", "path", "pass", "uri", "attribute", "mask", "service", "secret", "database", "Password", "account", "wallet", "port", "padding", "device"], "filePath": ["logPath", " fileLog", " fileUrl", "FileSystem", "fName", "fileFile", "FilePath", "sourceInfo", "ileName", "fileUrl", "sourceName", "resourceFile", "fileLog", "filePoint", "imageName", "fPath", "filepath", "fInfo", "resourceLength", " fileLength", " filepath", "resourceInfo", "FILELength", "logpath", " fileFile", "logName", "ilePath", "resourceUrl", "FILESystem", "pageUrl", "FileLog", "sourcePath", "fileInfo", "imagePath", " filePoint", "resourceName", "resourcePoint", " fileInfo", "ileUrl", "sourcepath", "pageFile", "FileName", "FILEpath", "FILEPath", "imagepath", "Filepath", "imagePoint", "pagePath", "fileLength", "resourcePath", "pageName", "fpath", "FileUrl", "FILEName", "logUrl", "resourcepath", "ileLog", "fileSystem", " fileSystem"], "idx": [" idxx", " idp", " idb", "inx", "indb", "indx", "inxx", "idxx", "inb", "indxx", " idy", "indX", "Idxc", "indxs", "Idy", "Idw", " idw", "indw", "Idx", "indxc", "idy", "idX", "idp", "idxs", "IdX", "Idp", " idX", "indp", "idb", " idxc", "inxc", "indy", " idxs", "inX", "idxc", "idw", "inxs"], "fileName": ["FileInfo", "filePart", " fileAddress", "FilePath", "classPath", "FilePart", "fileAddress", "FILEPart", "fileInfo", " fileInfo", "className", "FileName", "FILEPath", " filePart", "classPart", "classInfo", "FILEAddress", "FILEName", "FileAddress"], "url": ["host", "page", "user", "browser", "connection", "open", "build", "io", "l", "http", "client", "b", "object", "base", "f", "p", "channel", "resource", "org", "config", "ur", "gl", "event", "t", "fl", "li", "v", "path", "image", "uri", "ssl", "i", "g", "URL", "service", "Url", "www", "proxy", "web", "sl"], "urlc": ["Urlconn", "jsonC", "jsonc", "urlpc", "urlt", "urlcon", "URLr", "urlC", "webl", "URLconn", " urlC", "updateconn", "URLp", "jsoncon", "urlcs", "Urlpc", "updatec", "URLc", " urll", "urll", "urlr", "webcs", "updatecon", "urlp", " urlr", " urlconn", " urlt", "Urlc", " urlp", "urlconn", "urlm", "URLt", "URLcs", " urlcs", " urlm", "URLm", "URLl", "webc", "jsonconn", "updateC", "Urlr", "URLpc", " urlpc", " urlcon", "Urlt", "Urlp", "webm"], "baos": ["baor", "boos", "vaus", "BAis", "haus", "baot", "Baot", "hao", "hais", " baor", "bao", "BAus", "Baos", "boo", "vaos", "bools", "BAos", "BAols", "haos", "baus", "BAo", "Baols", "vao", "vais", "Bao", "Baor", "Bais", "bais", "baols", " bais", "BAor", "boot", " bao", "BAot"], "is": ["id", "nis", "browser", "isa", "ais", "http", "isl", "in", "app", "as", "was", "iss", "are", "os", "bs", "ris", "irc", "ai", "ir", "has", "isi", "it", "ci", "iris", "IS", "api", "ri", "lis", "ios", "ori", "i", "im", "ish", "isol", "bis", "Is", "iso", "ip", "ic", "does"], "buffer": ["page", "reader", "button", "memory", "queue", "binary", "input", "feed", "reference", "buff", "iter", "result", "Buffer", "message", "b", "layer", "channel", "data", "table", "resource", "address", "writer", "uffer", "shape", "padding", "batch", "bb", "bridge", "length", "flush", "wave", "uf", "bar", "buf", "FFER", "document", "border", "cache", "fb", "array", "header", "block", "texture", "position", "balance", "stack"], "br": ["next", "ber", "div", "bp", "wr", "gr", "ru", "bf", "arr", "min", "nr", "bg", "pre", "Br", "b", "bc", "lr", "fr", "base", "ver", "BR", "bd", "ref", "bi", "r", "n", "bal", "el", "shr", "body", "batch", "bridge", "hr", "dr", "buf", " dr", "tr", " str", "span", "bar", "ch", "cr", "j", "err", "width", "or", "bro", "img", "ctr", "str", "line", "p", "bl"]}}
{"id1": "11840745", "id2": "762814", "code1": "    public final void close() throws IOException {\n        if (dataStream == null) throw new NullPointerException(\"Write stream is null.\");\n        dataStream.flush();\n        dataStream.close();\n        dataStream = null;\n        File tmpFile = new File(packPath + \".tmp\");\n        FileOutputStream packStream = new FileOutputStream(packPath);\n        try {\n            String nbFiles = Long.toString(currentNbFiles) + \"\\0\";\n            packStream.write(FLAT_PACK_HEADER.getBytes(Charsets.ISO_8859_1));\n            structBufferWriter.flush();\n            structBufferWriter.close();\n            int headerSize = structBuffer.size() + nbFiles.length();\n            packStream.write(Integer.toString(headerSize).getBytes(Charsets.ISO_8859_1));\n            packStream.write('\\0');\n            packStream.write(nbFiles.getBytes(Charsets.ISO_8859_1));\n            structBuffer.writeTo(packStream);\n            structBufferWriter = null;\n            structBuffer = null;\n            FileInputStream in = new FileInputStream(tmpFile);\n            try {\n                byte[] buffer = new byte[FILE_COPY_BUFFER_LEN];\n                int read;\n                while ((read = in.read(buffer)) > 0) packStream.write(buffer, 0, read);\n                packStream.flush();\n                packStream.close();\n            } finally {\n                Utilities.closeStream(in);\n            }\n        } finally {\n            Utilities.closeStream(packStream);\n        }\n        if (tmpFile.isFile()) Utilities.deleteFile(tmpFile);\n        packPath = null;\n        structBuffer = null;\n    }\n", "code2": "    public static void zipFile(String file, String entry) throws IOException {\n        FileInputStream in = new FileInputStream(file);\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(file + \".zip\"));\n        out.putNextEntry(new ZipEntry(entry));\n        byte[] buffer = new byte[4096];\n        int bytes_read;\n        while ((bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n        in.close();\n        out.closeEntry();\n        out.close();\n        File fin = new File(file);\n        fin.delete();\n    }\n", "label": 1, "substitutes": {"dataStream": ["outputSteam", "outputStream", "dataSystem", "inputSteam", "dataSource", "DataReader", " datastream", "DataSteam", "writeStream", " dataSteam", "dataWriter", "inputstream", "dataSem", " dataStreamer", "downloadstream", "downloadStream", "writeWriter", "downloadSteam", "writeSource", " dataWriter", "inputStreamer", "inputReader", "outputstream", " dataSystem", "DataStreamer", " dataSem", "inputSource", "dataSteam", "inputSem", "inputWriter", "datastream", "inputSystem", " dataSource", "writeSteam", "downloadSem", "dataReader", "outputSystem", "inputStream", " dataReader", "dataStreamer", "DataStream"], "tmpFile": ["tempLine", "zipFile", "mpClass", "srcFiles", "tempFiles", "tempPath", "tempFile", " temporaryFile", "srcfile", "zipLine", "tmpPage", "tmpFolder", "pkgLine", "srcPlace", "mpPath", " tmpPath", " temporaryfile", " tmpClass", " tmpPage", "zipFiles", "tempPage", "mpFolder", " tmpfile", "tempfile", " temporaryPage", "tmpfile", "tmpPlace", "pkgFile", "zipfile", "zipPlace", " tmpFiles", "tmpLine", "tempClass", " tmpFolder", "mpFile", "srcFile", "tmpFiles", " temporaryFiles", "pkgfile", "tmpClass", "tempPlace", "tmpPath", "tempFolder", "pkgFiles"], "packStream": ["linkStream", "taskStream", "inputPath", "packContext", "packstream", "caseSteam", "pushStream", "packFile", "taskStreamer", "parseFile", "PackChannel", "loadStreamer", "ackFile", "packSteam", "sendStreamer", "parseStreamer", "PackSteam", "shapeStream", "ackstream", "ackContext", " packContext", "packChannel", "PackPath", "pushChannel", "parseStream", " packSteam", "linkFile", "linkSteam", " packstream", "linkStreamer", "taskSteam", "caseStream", "inputStreamer", "packStreamer", "sendStream", "shapeFile", "buildContext", "buildStreamer", "pushSteam", "PackFile", "ackSteam", "PackStreamer", " packFile", "ackStreamer", "ackStream", "parsestream", "caseStreamer", "caseThread", "taskstream", "loadStream", " packStreamer", "buildStream", "sendSteam", "loadstream", "pushStreamer", "packThread", "parseSteam", "buildSteam", " packThread", "PackStream", "Packstream", "shapeSteam", "parseThread", "shapeStreamer", "inputFile", "loadSteam", "inputStream", "sendChannel"], "nbFiles": ["nbBlocks", "nbFile", "NBPages", "npFrames", "NumBytes", "NBBytes", "nbPages", "NBFiles", "NBFrames", "nbCharacters", "numfiles", "NumFiles", "kbFrames", "nbfiles", "nrPoints", "kbBlocks", "npBlocks", "NBFile", "npPages", "NBPoints", "nrFile", "nbPoints", "nbBytes", "NBCharacters", "NBBlocks", "numFile", "numBytes", "Numfiles", "nbFrames", "kbPages", "nrFiles", "NumCharacters", "numPoints", "numCharacters", "kbFiles", "numFiles", "npFiles", "NBfiles"], "headerSize": ["Headersize", "bufferInfo", " headerLength", "numberLength", "HeaderSize", "headerLen", " headerCode", " headerInfo", " headersize", "headersize", "headerLength", "HeaderLength", "headerCode", "bufferLen", "numbersize", "numberCode", "bufferSize", " headerLen", "HeaderCode", "headerInfo", "numberSize", "HeaderInfo", "HeaderLen", "bufferLength"], "structBufferWriter": ["StructBufferReader", " structBufferWrite", " structBufferReader", "structContainerWrite", "structHeaderRW", "structBlockWrite", " structQueueReader", "structHeaderWritten", "structHeaderFile", "StructBufferWrite", " structQueueWrite", " structQueueRW", " structQueueWriter", "structFileWritten", " structBufferRW", "structBlockWriter", "structQueueWrite", "StructFileWritten", "StructBufferWritten", "structFileWriter", "StructFileWrite", "structQueueRW", "StructBufferFile", "structBufferRW", "structQueueWriter", "structFileFile", "structBlockFile", "structHeaderWriter", "structContainerReader", "structBufferFile", "structContainerWriter", "StructFileFile", "structContainerWritten", "structBufferWritten", "structFileReader", "structHeaderWrite", "StructFileReader", "StructBufferWriter", "structBlockReader", "structFileWrite", "structFileRW", "structHeaderReader", "structBufferWrite", "structBufferReader", "structQueueReader", "StructFileWriter"], "structBuffer": ["StructWriter", " structHeader", "structReader", "structCounter", "STRUCTHeader", " structWriter", "configBuff", "intHeader", "StructBuffer", "STRUCTWriter", "configQueue", "StructCounter", "intWriter", " structContainer", "packReader", "structQueue", "STRUCTReader", "intBuffer", "configReader", "structContainer", "intCounter", "packBuffer", "configBuffer", " structQueue", "configWriter", "STRUCTQueue", "packBuff", " structCounter", "structHeader", " structBuff", " structReader", "structWriter", "STRUCTBuffer", "StructHeader", "configContainer", "structBuff", "STRUCTContainer", "configHeader", "packWriter", "STRUCTBuff"], "in": ["reader", "h", "id", "url", "input", "inc", "din", "win", "connection", "min", "nin", "conn", "l", "con", "out", "b", "login", "f", "data", "In", "stream", "again", "r", "re", "thin", "serv", "isin", "inner", "exec", "it", "ins", "gin", "ini", "a", "ex", "rec", "image", "c", "file", "socket", "i", "IN", "err", "or", "ssl", "inn", "rin", "is", "bin", "on", "ac"], "buffer": ["source", "size", "reader", "queue", "write", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "message", "limit", "row", "layer", "channel", "number", "data", "table", "base", "resource", "server", "address", "writer", "pad", "uffer", "transfer", "null", "batch", "flush", "length", "wave", "capacity", "FFER", "buf", "offset", "variable", "slice", "border", "cache", "record", "character", "header", "block", "texture", "position", "bin", "value"], "read": ["select", "get", "next", " write", "reader", "size", "play", "input", "id", "write", "feed", "Read", "ind", "build", "fill", "READ", "k", "ride", "w", "end", "loop", "skip", "find", "n", "work", "raw", "child", "exec", "x", "send", "sync", "old", "reading", "_", "length", "allow", "text", "max", "run", "key", "index", "count", "pass", "load", "c", "readable", "parse", "i", "check", "seek", "each", "wait", "type", "lex", "create", "start", "add", "copy", " Read", "use", "reads"], "packPath": ["packFile", "parseFile", "packFolder", " packFolder", "packagePath", "zippath", "PackPath", " packDir", "parseLocation", "zipDir", "parseStream", "zipLocation", " packLocation", "packDirectory", "packpath", "PackFile", "packDir", "parseDirectory", "packageDir", " packFile", "zipPath", "packageFolder", "zipFolder", " packpath", "zipDirectory", "PackDir", "zipStream", "parsepath", "parseDir", "packagepath", " packDirectory", "Packpath", "packLocation", "parsePath"]}}
{"id1": "11752189", "id2": "8481623", "code1": "    public static void main(String[] args) {\n        FileDialog fd = new FileDialog(new Frame(), \"Find a .def file\", FileDialog.LOAD);\n        boolean proceed = true;\n        String input = \"\";\n        DataInputStream dis;\n        OutputStream out;\n        InputStream in;\n        File out_file, in_file;\n        byte[] buffer = new byte[2048];\n        int bytes_read;\n        while (proceed) {\n            fd.show();\n            if (fd.getFile() != null) {\n                try {\n                    in_file = new File(fd.getDirectory(), fd.getFile());\n                    out_file = new File(fd.getDirectory(), fd.getFile() + \".out\");\n                    out = new FileOutputStream(out_file);\n                    in = new MSZipInputStream(new FileInputStream(in_file));\n                    while ((bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n                    in.close();\n                    out.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"Do another (y/n)?\");\n            dis = new DataInputStream(System.in);\n            try {\n                input = dis.readLine();\n            } catch (Exception blah) {\n            }\n            if (input.toLowerCase().startsWith(\"n\")) proceed = false;\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        from_file = checkFile(from_file);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fd": ["dl", "draw", "folder", "dc", "draft", "cd", "d", "feed", "lf", "dd", "fax", "ld", "director", "xd", "hd", "vd", "pd", "fc", "fs", "wd", "td", "ird", "f", "fe", "bd", "fw", "FD", "handler", "Dialog", "fun", "dir", "pid", "dm", "fn", "fl", "df", "file", "db", "rd", "flo", "fb", "raf", "ds", "fm", "md", "grad", "ff", "form", "nd", "sd", "fed", "bot", "fa", "fx"], "dis": ["dl", "DIS", "die", "py", "mor", "des", "rx", "rel", "dd", "disc", "mid", "Dis", "ee", " Dis", "io", "co", "conn", "lib", "con", "b", "pre", "part", "over", "data", "no", "di", "re", "det", "server", "serv", "bad", "inner", "el", "sys", "du", "inter", "ui", "de", "non", "mis", "li", "se", "rec", "up", "cache", "sp", "pro", "err", "pos", "dist", "is", "ds", "fin", "bin", "sn", "mi", "on", "unit"], "out": ["source", "page", "parent", "plain", "inc", "write", "msg", "user", "net", "extra", "co", "io", "output", "outer", "conn", "one", "w", "this", "client", "diff", "ou", "state", "part", "data", "no", "to", "OUT", "Out", "again", "outs", "writer", "inner", "exec", "sys", "sync", "name", "null", "o", "exp", "log", "comment", "ex", "cli", "screen", "up", "all", "key", "image", "list", "cache", "socket", "file", "error", "lock", "err", "obj", "debug", "group", "bin", "line", "ext"], "in": ["source", "read", "reader", "url", "inc", "din", "inet", "user", "win", "with", "min", "io", "nin", "conn", "l", "con", "diff", "login", "f", "data", "In", "pin", "again", "n", "r", "resource", "serv", "ac", "isin", "inner", "el", "exec", "x", "name", "init", "ins", "e", "o", "gin", "ini", "a", "ex", "cli", "kin", "cin", "socket", "i", "IN", "err", "inside", "inn", "is", "lin", "bin", "s", "fa", "line", "ic", "pass"], "out_file": ["out_url", "nin_live", "nin_dir", "outoutname", "in_files", "outername", "in_url", "in_name", "out_cache", "out_files", "nin_cache", "out_dir", "out__dir", "outoutfiles", "out_name", "out__files", "outerfile", "outerstream", "nin_file", "out_stream", "outerfiles", "outoutstream", "in_stream", "out_live", "out__file", "out__url", "in_dir", "outoutfile"], "in_file": ["in_File", "in_files", "out_files", "out_File", "out_dir", "out_directory", "out_zip", "in_f", "out_f", "injfile", "out_lock", "in_zip", "in_directory", "injdirectory", "in___file", "in_lock", "in___f", "injzip", "injFile", "in___files", "in_dir"], "buffer": ["source", "page", "read", "reader", "url", "queue", "memory", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "message", "limit", "row", "base", "channel", "layer", "data", "bytes", "server", "raw", "address", "uffer", "sequence", "shape", "padding", "null", "transfer", "batch", "length", "flush", "wave", "buf", "offset", "slice", "count", "cache", "header", "block", "position", "value"], "bytes_read": ["rows___get", "bytes___play", "bytes_get", "rows_ride", "bytesJread", "piecesJwritten", "bytes_load", "bytes_out", "piecesJout", "bytes___read", "rows___ride", "bytesESSwrite", "pieces_out", "bytesESSread", "bytes_wait", "rows_wait", " bytes_write", "bytes_need", "bytes_ride", "bytes___wait", "bytesESSget", "bytesESSride", "rows_get", " bytes_need", "bytes___out", "rows_read", "bytesJout", "bytesJwritten", "bytes___ride", "piecesJplay", "rows___wait", "piecesJread", "bytes___written", "rows___read", " bytes_load", "bytes_written", "bytes_write", "pieces_written", "bytesJplay", "bytes___get", "pieces_read", "bytesESSload", "bytes_play", "pieces_play", "bytesESSwait", "bytesESSneed"], "proceed": ["produceed", "propass", "percess", "receed", "perccess", "perpass", "perply", "reply", "preceed", "proply", " proply", "preply", "precess", "produply", " proccess", "perprocess", " proprocess", "preccess", "repass", "producess", "proccess", "proprocess", " process", "perceed", "preprocess", "process", "produpass", "recess"], "input": ["source", "parent", "value", "url", "inc", "submit", "xml", "pull", "argument", "output", "format", "request", "inf", "data", "progress", "include", "response", "sum", "work", "raw", "inner", "exec", "word", "Input", "method", "event", "pattern", "json", "password", "text", "comment", "enter", "issue", "phy", "session", "key", "temp", "string", "quit", "image", "document", "help", "expression", "command", "inside", "form", "empty", "str", "qa", "type"]}}
{"id1": "11719103", "id2": "492619", "code1": "    public static String hash(final String text) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] sha1hash = new byte[40];\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n            return Sha1.convertToHex(sha1hash);\n        } catch (final Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"text": ["source", "translation", "contract", "url", "input", "TEXT", "txt", "binary", "token", "buffer", " TEXT", "output", "message", "letter", "format", "out", "object", "this", "in", "Text", "data", "hex", "editor", "config", "template", "word", "transfer", "pattern", "password", "content", "string", "path", "image", "obj", "font", "code", "context", "struct", "texture", "test", "str", "ext"], "md": ["hash", "bf", "d", "mb", "dd", "ind", "ld", "hd", "message", " MD", "mm", "ma", "pd", "vd", "wd", "gd", "am", "cmd", "ms", "mode", "data", "mac", "mo", "bd", "ud", "hm", "mand", "editor", "mag", "meta", "mc", "sha", "mp", "rpm", "me", "dm", "mod", "rm", "dh", "MD", "mt", "m", "df", "nm", "od", "pm", "mg", "mad", "metadata", "amd", "sd", "mi", "dig"], "sha1hash": ["SHA2hash", " SHA1hash", "sha91hash", "sha91hex", "sha2Hash", "maonematch", " SHAoneblock", "sha1match", "sha5value", "sha5hash", "sha5Hash", " SHA1Hash", "shaoneHash", "sha9cache", "sha2hash", "SHA2Hash", " SHAonecache", "sha9Hash", "sha2hex", "sha1value", "SHA1hash", " SHAonehash", "ma1hash", " SHA1block", "ma1hex", "shaonematch", "sha1Hash", "sha1cache", "maonehash", "shaonehex", "shaonecache", "sha9hash", "SHA2value", "shaoneblock", " SHA1cache", " SHAoneHash", "sha2value", "sha2block", "maonehex", "sha9block", "sha2cache", "sha2match", "sha1hex", "SHA1Hash", "shaonehash", "sha91match", "SHA1value", "ma1match", "sha1block"]}}
{"id1": "12289756", "id2": "17526811", "code1": "    public String loadURL(URL url) {\n        String retVal = \"\";\n        try {\n            InputStream inputStream = url.openStream();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            String line = bufferedReader.readLine();\n            retVal += line + \"\\n\";\n            while (line != null) {\n                System.out.println(line);\n                line = bufferedReader.readLine();\n                if (line != null) retVal += line + \"\\n\";\n            }\n            bufferedReader.close();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        } catch (IOException e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        } catch (Exception e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        }\n        return retVal;\n    }\n", "code2": "    private String getDocumentAsString(URL url) throws IOException {\n        StringBuffer result = new StringBuffer();\n        InputStream in = url.openStream();\n        int c;\n        while ((c = in.read()) != -1) result.append((char) c);\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "user", "connection", "buffer", "xml", "l", "http", "object", "request", "b", "lr", "base", "loader", "f", "r", "resource", "server", "address", "el", "ur", "e", "sl", "job", "string", "path", "image", "rule", "file", "uri", "ssl", "err", "URL", "service", "Url", "www", "proxy", "str", "location"], "inputStream": ["outputStream", "inBuffer", " inputstream", "InputBuffer", "inputstream", "InputStream", "accessStream", "accessStreamer", "inWriter", "inputStreamer", "inputReader", " inputWriter", "outputstream", "outputReader", "Inputstream", "inStream", "InputStreamer", " inputBuffer", "instream", "inputWriter", "InputWriter", "accessstream", "inputBuffer", "InputReader", "accessReader", "outputStreamer"], "bufferedReader": ["bufflatedLine", "buffinedLine", "bufferredWriter", "buffaredStream", "BufferedRunner", "bufferingRunner", "bufferedRunner", "buffaredreader", "BuffedWriter", "muteredWriter", "mutmentedreader", "buffiedWriter", "buffiedreader", "bufferedWriter", "buffedWriter", "muteredReader", "buffmentedreader", "buffedLine", "buffiedReader", "BufferedReader", "BuffledWriter", "buffaredWriter", "buffiedLine", "bufferedStream", "buffinedWriter", "bufferedLine", "mutmentedReader", "muteredStream", "BuffedRunner", "mutmentedStream", "bufferedreader", "mutmentedWriter", "bufferingReader", "BufferedWriter", "BufferedLine", "bufflatedReader", "bufferingWriter", "bufflatedWriter", "buffledStream", " bufferingStream", " bufferingWriter", " bufferedLine", "buffmentedStream", "buffaredReader", "buffedReader", "buffedStream", " bufferedStream", "BuffedReader", "buffmentedReader", "bufflatedreader", "BuffedStream", "bufferredReader", "muteredreader", "buffledreader", "bufferingStream", "buffledWriter", "BuffledReader", " bufferingReader", "Bufferedreader", "buffmentedWriter", "buffedRunner", "BuffledLine", "buffinedStream", "Buffledreader", "bufferredRunner", "bufferingLine", "bufferredStream", "buffledReader", "buffledLine", "buffinedReader", "BufferedStream", " bufferingLine", " bufferedWriter"], "line": ["lines", "l", "definition", "val", "Line", "model", "number", "style", "zip", "email", "strip", "sync", "cl", "log", "sl", "le", "file", "err", "ip", "pass", "continue", "lf", "one", "object", "cell", "row", "inline", "liner", "job", "lin", "str", "page", "none", "link", "write", "pe", "user", "LINE", "column", "base", "no", "raw", "el", "section", "element", "word", "e", "text", "comment", "string", "error", "i", " Line", "entry", "next", "message", "letter", "out", "char", "layer", "data", "response", "non", "content", "lc", "frame", "code", "character", "block", "item", "shell", "unit"], "retVal": ["ftEl", "rtValue", "RetVAL", "replyValue", "altval", "returnValue", "retValid", "replyBu", "returnval", "RETBu", "RETArg", "replyval", "retVAL", "ftVal", "rtBu", "rtValid", "refBu", "refVAL", "replyVal", "RetValue", "altValue", "refVal", "rtVal", "altVal", "retEl", " retval", "RetValid", "retval", "returnVal", " retValue", "retBu", "RetBu", "rtArg", "altBu", "RETVal", " retBu", "retValue", "rtval", "rtEl", "ftValid", "Retval", "replyValid", "rtVAL", "RetVal", "refValue", "retArg", "returnBu", " retArg", " retEl", " retValid", "ftval"]}}
{"id1": "11902597", "id2": "12838273", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Start filtering zgps...\");\n        final Config config = Gbl.createConfig(args);\n        final String CONFIG_MODULE = \"GPSFilterZGPS\";\n        File sourceFileSelectedStages = new File(config.findParam(CONFIG_MODULE, \"sourceFileSelectedStages\"));\n        File sourceFileZGPS = new File(config.findParam(CONFIG_MODULE, \"sourceFileZGPS\"));\n        File targetFile = new File(config.findParam(CONFIG_MODULE, \"targetFile\"));\n        System.out.println(\"Start reading selected stages...\");\n        FilterZGPSSelectedStages selectedStages = new FilterZGPSSelectedStages();\n        selectedStages.createSelectedStages(sourceFileSelectedStages);\n        System.out.println(\"Done. \" + selectedStages.getSelectedStages().size() + \" stages were stored\");\n        System.out.println(\"Start reading and writing zgps...\");\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFileZGPS)));\n            BufferedWriter out = new BufferedWriter(new FileWriter(targetFile));\n            out.write(in.readLine());\n            out.newLine();\n            String lineFromInputFile;\n            while ((lineFromInputFile = in.readLine()) != null) {\n                String[] entries = lineFromInputFile.split(\"\\t\");\n                if (selectedStages.containsStage(Integer.parseInt(entries[0]), Integer.parseInt(entries[1]), Integer.parseInt(entries[2]))) {\n                    out.write(lineFromInputFile);\n                    out.newLine();\n                    out.flush();\n                }\n            }\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find source file for selected stages.\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.out.println(\"IO Exception while reading or writing zgps.\");\n            e.printStackTrace();\n        }\n        System.out.println(\"Done.\");\n    }\n", "code2": "    public BufferedImage extractUsingCompositor() throws IOException, DjatokaException {\n        boolean useRegion = false;\n        int left = 0;\n        int top = 0;\n        int width = 50;\n        int height = 50;\n        boolean useleftDouble = false;\n        Double leftDouble = 0.0;\n        boolean usetopDouble = false;\n        Double topDouble = 0.0;\n        boolean usewidthDouble = false;\n        Double widthDouble = 0.0;\n        boolean useheightDouble = false;\n        Double heightDouble = 0.0;\n        if (params.getRegion() != null) {\n            StringTokenizer st = new StringTokenizer(params.getRegion(), \"{},\");\n            String token;\n            if ((token = st.nextToken()).contains(\".\")) {\n                topDouble = Double.parseDouble(token);\n                usetopDouble = true;\n            } else top = Integer.parseInt(token);\n            if ((token = st.nextToken()).contains(\".\")) {\n                leftDouble = Double.parseDouble(token);\n                useleftDouble = true;\n            } else left = Integer.parseInt(token);\n            if ((token = st.nextToken()).contains(\".\")) {\n                heightDouble = Double.parseDouble(token);\n                useheightDouble = true;\n            } else height = Integer.parseInt(token);\n            if ((token = st.nextToken()).contains(\".\")) {\n                widthDouble = Double.parseDouble(token);\n                usewidthDouble = true;\n            } else width = Integer.parseInt(token);\n            useRegion = true;\n        }\n        if (is != null) {\n            File f = File.createTempFile(\"tmp\", \".jp2\");\n            f.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(f);\n            sourceFile = f.getAbsolutePath();\n            IOUtils.copyStream(is, fos);\n        }\n        Kdu_simple_file_source raw_src = null;\n        Jp2_family_src family_src = new Jp2_family_src();\n        Jpx_source wrapped_src = new Jpx_source();\n        Kdu_region_compositor compositor = null;\n        BufferedImage image = null;\n        try {\n            family_src.Open(sourceFile);\n            int success = wrapped_src.Open(family_src, true);\n            if (success < 0) {\n                family_src.Close();\n                wrapped_src.Close();\n                raw_src = new Kdu_simple_file_source(sourceFile);\n            }\n            compositor = new Kdu_region_compositor();\n            if (raw_src != null) compositor.Create(raw_src); else compositor.Create(wrapped_src);\n            Kdu_dims imageDimensions = new Kdu_dims();\n            compositor.Get_total_composition_dims(imageDimensions);\n            Kdu_coords imageSize = imageDimensions.Access_size();\n            Kdu_coords imagePosition = imageDimensions.Access_pos();\n            if (useleftDouble) left = imagePosition.Get_x() + (int) Math.round(leftDouble * imageSize.Get_x());\n            if (usetopDouble) top = imagePosition.Get_y() + (int) Math.round(topDouble * imageSize.Get_y());\n            if (useheightDouble) height = (int) Math.round(heightDouble * imageSize.Get_y());\n            if (usewidthDouble) width = (int) Math.round(widthDouble * imageSize.Get_x());\n            if (useRegion) {\n                imageSize.Set_x(width);\n                imageSize.Set_y(height);\n                imagePosition.Set_x(left);\n                imagePosition.Set_y(top);\n            }\n            int reduce = 1 << params.getLevelReductionFactor();\n            imageSize.Set_x(imageSize.Get_x());\n            imageSize.Set_y(imageSize.Get_y());\n            imagePosition.Set_x(imagePosition.Get_x() / reduce - (1 / reduce - 1) / 2);\n            imagePosition.Set_y(imagePosition.Get_y() / reduce - (1 / reduce - 1) / 2);\n            Kdu_dims viewDims = new Kdu_dims();\n            viewDims.Assign(imageDimensions);\n            viewDims.Access_size().Set_x(imageSize.Get_x());\n            viewDims.Access_size().Set_y(imageSize.Get_y());\n            compositor.Add_compositing_layer(0, viewDims, viewDims);\n            if (params.getRotationDegree() == 90) compositor.Set_scale(true, false, true, 1.0F); else if (params.getRotationDegree() == 180) compositor.Set_scale(false, true, true, 1.0F); else if (params.getRotationDegree() == 270) compositor.Set_scale(true, true, false, 1.0F); else compositor.Set_scale(false, false, false, 1.0F);\n            compositor.Get_total_composition_dims(viewDims);\n            Kdu_coords viewSize = viewDims.Access_size();\n            compositor.Set_buffer_surface(viewDims);\n            int[] imgBuffer = new int[viewSize.Get_x() * viewSize.Get_y()];\n            Kdu_compositor_buf compositorBuffer = compositor.Get_composition_buffer(viewDims);\n            int regionBufferSize = 0;\n            int[] kduBuffer = null;\n            Kdu_dims newRegion = new Kdu_dims();\n            while (compositor.Process(100000, newRegion)) {\n                Kdu_coords newOffset = newRegion.Access_pos();\n                Kdu_coords newSize = newRegion.Access_size();\n                newOffset.Subtract(viewDims.Access_pos());\n                int newPixels = newSize.Get_x() * newSize.Get_y();\n                if (newPixels == 0) continue;\n                if (newPixels > regionBufferSize) {\n                    regionBufferSize = newPixels;\n                    kduBuffer = new int[regionBufferSize];\n                }\n                compositorBuffer.Get_region(newRegion, kduBuffer);\n                int imgBuffereIdx = newOffset.Get_x() + newOffset.Get_y() * viewSize.Get_x();\n                int kduBufferIdx = 0;\n                int xDiff = viewSize.Get_x() - newSize.Get_x();\n                for (int j = 0; j < newSize.Get_y(); j++, imgBuffereIdx += xDiff) {\n                    for (int i = 0; i < newSize.Get_x(); i++) {\n                        imgBuffer[imgBuffereIdx++] = kduBuffer[kduBufferIdx++];\n                    }\n                }\n            }\n            if (params.getRotationDegree() == 90 || params.getRotationDegree() == 270) image = new BufferedImage(imageSize.Get_y(), imageSize.Get_x(), BufferedImage.TYPE_INT_RGB); else image = new BufferedImage(imageSize.Get_x(), imageSize.Get_y(), BufferedImage.TYPE_INT_RGB);\n            image.setRGB(0, 0, viewSize.Get_x(), viewSize.Get_y(), imgBuffer, 0, viewSize.Get_x());\n            if (compositor != null) compositor.Native_destroy();\n            wrapped_src.Native_destroy();\n            family_src.Native_destroy();\n            if (raw_src != null) raw_src.Native_destroy();\n            return image;\n        } catch (KduException e) {\n            e.printStackTrace();\n            throw new DjatokaException(e);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new DjatokaException(e);\n        }\n    }\n", "label": 1, "substitutes": {"config": ["host", "Config", "url", "queue", "default", "connection", "cf", "settings", "output", "conn", "view", "Configuration", "con", "license", "app", "b", "driver", "bc", "client", "bug", "console", "f", "loader", "data", "system", "sc", "ctx", "info", "exec", "conf", "module", "gui", "init", "rc", "project", " Config", "log", "spec", "text", "ini", "ch", "lc", "cfg", "utils", "cache", "c", "file", "context", "load", "g", "support", "fig", "service", "manager", "front", "ca", "ext"], "CONFIG_MODULE": ["CONFIG_FORMUL", "CONFIG_Modules", "CONFIG_MOules", "CONFIG_MSUL", "CONFIG_MODAGE", "CONFIG_ModUME", "CONFIG_MODRIPT", "CONFIG_ModRIPT", "CONFIG_ModLE", "CONFIG_REGule", "CONFIG_ModUL", "CONFIG_MOUME", "CONFIG_FORMLE", "CONFIG_ModULE", "CONFIG_MRAGE", "CONFIG_MODLE", "CONFIG_MSule", "CONFIG_FORMULE", "CONFIG_MODules", "CONFIG_MOule", "CONFIG_MRRIPT", "CONFIG_METHODRIPT", "CONFIG_MRule", "CONFIG_MSULE", "CONFIG_REGLE", "CONFIG_METHODAGE", "CONFIG_MOULE", "CONFIG_Module", "CONFIG_FORMule", "CONFIG_REGUL", "CONFIG_MODule", "CONFIG_MSUME", "CONFIG_REGULE", "CONFIG_MRULE", "CONFIG_MODUL", "CONFIG_METHODule", "CONFIG_ModAGE", "CONFIG_METHODULE", "CONFIG_MODUME"], "sourceFileSelectedStages": ["sourceFileSelectedStrays", "sourceFileSelectedEstores", "sourceFileSelectedSTages", "sourceFileSearedStacks", "sourceFileSelectedSTaging", "sourceFileSelectedSTores", "sourceFileSelectedstases", "sourceFileSelectedSTays", "sourceFileSelectedStaging", "sourceFileSelectedRaging", "sourceFileSelectedRarts", "sourceFileSelectedTaging", "sourceFileSelectedRacks", "sourceFileSelectionstays", "sourceFileSearedSTarts", "sourceFileSelectedStays", "sourceFileSelectedTages", "sourceFileSelectionstages", "sourceFileSelectedSTacks", "sourceFileSelectedTacks", "sourceFileSelectedStacks", "sourceFileSearedStages", "sourceFileSelectionStases", "sourceFileSelectedstays", "sourceFileSearedSTages", "sourceFileSelectionStages", "sourceFileSelectionstaging", "sourceFileSelectedEstages", "sourceFileSelectedStrores", "sourceFileSelectedStarts", "sourceFileSelectionStaging", "sourceFileSelectedRages", "sourceFileSelectionStores", "sourceFileSelectedTarts", "sourceFileSelectedStrages", "sourceFileSelectionstores", "sourceFileSelectedstages", "sourceFileSearedStaging", "sourceFileSelectedStraging", "sourceFileSearedStarts", "sourceFileSelectedStases", "sourceFileSelectedEstases", "sourceFileSelectedStores", "sourceFileSelectedstaging", "sourceFileSearedSTacks", "sourceFileSelectedEstays", "sourceFileSelectionstases", "sourceFileSearedSTaging", "sourceFileSelectionStays", "sourceFileSelectedSTarts", "sourceFileSelectedstores"], "sourceFileZGPS": ["sourceFileYGeAPS", "sourceFileZGPPs", "sourceFileZGPps", "sourceFileZGUPC", "sourceFileZXGPFS", "sourceFileYGPC", "sourceFileYGPS", "sourceFileYGps", "sourceFileYGeps", "sourceFileZGPC", "sourceFileZXGFS", "sourceFileZXGPRS", "sourceFileZGFS", "sourceFileZXGPS", "sourceFileZDPS", "sourceFileXGPC", "sourceFileZGPRS", "sourceFileZGPAPS", "sourceFileZGeps", "sourceFileYGePC", "sourceFileZGps", "sourceFileXGUps", "sourceFileZXGRS", "sourceFileZDRS", "sourceFileZGPPC", "sourceFileXGUPC", "sourceFileZDFS", "sourceFileZGePs", "sourceFileZXGPPC", "sourceFileYGePS", "sourceFileZGUPS", "sourceFileXGps", "sourceFileZGPs", "sourceFileZGURS", "sourceFileZDPC", "sourceFileZGePS", "sourceFileXGUPS", "sourceFileZGRS", "sourceFileZGUFS", "sourceFileZGUps", "sourceFileZGUPs", "sourceFileXGPS", "sourceFileXGUPs", "sourceFileZGPFS", "sourceFileZGUAPS", "sourceFileXGPs", "sourceFileZGAPS", "sourceFileZGPPS", "sourceFileZGePC", "sourceFileZXGPC", "sourceFileZXGPPS", "sourceFileZGeAPS", "sourceFileYGAPS"], "targetFile": ["sourceDir", "effectWriter", " targetFILE", "targetFILE", "TargetFile", "defaultPath", "effectPath", "outputFile", "Targetfile", "outputFiles", "defaultFile", "sourcefile", " targetWriter", "targetPath", "sourceFile", "effectfile", "targetFiles", "defaultFILE", "targetfile", "targetWriter", "sourceFiles", " targetDir", "TargetPath", "sourcePath", " targetfile", " targetFiles", " targetPath", "outputDir", "effectFile", "targetDir", "defaultfile", "outputPath", "TargetFILE", "sourceWriter"], "selectedStages": ["selectedStrays", " selectedstarts", "selectedStides", "selectedSlags", "selectedMessarts", " selectedStags", " selectedStasks", "selectedstags", " selectedstages", "selectedStases", " selectedStacks", "selectedStrags", "selectedstides", "namedstages", "selectedSlases", " selectedStases", "selectedSTacks", " selectedStides", " selectedstasks", "namedstays", " selectedstags", "selectedSTarts", " selectedstides", "selectedStacks", "selectedStreamages", "namedStags", "selectedStreamides", "selectedstacks", "selectedStasks", "selectedstages", "selectedStags", "namedstags", "namedStores", "selectedStrases", " selectedstacks", "selectedSTags", "namedStages", "selectedStores", " selectedstases", "selectedSTases", "selectedstarts", "selectedstasks", "selectedMessags", "namedStays", "selectedSTasks", "selectedMessages", "selectedSTages", "selectedstores", "selectedStrores", "selectedStarts", "selectedStrages", " selectedStarts", "namedstores", "selectedstays", "selectedStays", "selectedStrides", "selectedStreamases", "selectedstases", "selectedSlages", "selectedMessacks", "selectedSlasks"], "in": ["get", "reader", "h", "id", "url", "input", "inc", "din", "token", "win", "min", "nin", "conn", "l", "con", "b", "diff", "part", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "re", "thin", "into", "serv", "isin", "inner", "er", "init", "it", "ins", "e", "t", "gin", "ini", "a", "ex", "image", "cin", "lock", "socket", "i", "IN", "inside", "err", "g", "inn", "or", "lin", "bin", "line"], "out": ["default", "wrapper", "net", "down", "extra", "doc", "over", "Out", "r", "call", "writer", "sys", "sync", "name", "log", "flush", "post", "cli", "temp", "image", "list", "obj", "file", "err", "group", "store", "line", "msg", "co", "io", "outer", "conn", "lib", "pre", "b", "part", "gen", "to", "table", "OUT", "exp", "bar", "ex", "key", "all", "point", "pool", "cache", "at", "copy", "ext", "page", "parent", "plain", "size", "inc", "write", "user", "client", "cmd", "f", "n", "work", "server", "raw", "sum", "exec", "o", "comment", "v", "error", "builder", "output", "view", "w", "dump", "state", "data", "again", "outs", "prefix", "serv", "inner", "query", "password", "gin", "session", "up", "window", "lock", "socket", "code", "bin"], "lineFromInputFile": ["lineFromOutputStream", "lineFromOutputFile", "lineFromSourceFile", "lineFrominputFiles", "lineToOutputFile", "lineFromOriginalLine", "linefromInputMessage", "lineFromRawDirectory", "linefromSourceLine", "linefrominputStream", "lineFromOriginalMessage", "linefromInputFile", "lineFromInputStream", "lineFromSourceDirectory", "lineFromInputFiles", "lineFrominputPlace", "lineFrominputFile", "lineFromInputPlace", "lineFrominputDirectory", "lineFromSourceLine", "lineToInputPlace", "lineFromOriginalFile", "lineFromOriginalStream", "lineFrominputStream", "lineToInputLine", "lineToOutputPlace", "lineToInputStream", "lineFromOutputMessage", "linefromInputFiles", "lineFromOutputPlace", "linefromSourceStream", "lineFromSourceFiles", "lineFromOutputLine", "linefromSourceFile", "lineFrominputMessage", "lineToOutputLine", "lineToInputFile", "linefromInputLine", "linefromInputStream", "lineFrominputLine", "linefrominputFiles", "linefrominputMessage", "lineFromOutputDirectory", "lineFromRawPlace", "lineFromRawFile", "lineToInputDirectory", "linefrominputFile", "lineToOutputDirectory", "lineFromSourceMessage", "lineFromRawLine", "lineToOutputStream", "linefromSourceMessage", "lineFromOriginalDirectory", "lineFromInputDirectory", "lineFromInputMessage", "lineFromOriginalFiles", "lineFromInputLine", "lineFromSourceStream"], "entries": ["endrants", "entsry", "entsrys", "endrings", "estents", "enles", "entrings", "entles", "entskeys", "entories", "contorts", "centles", "contry", "entrants", "equriers", "equents", "enries", "Entkeys", "pentrys", "centrants", "estriers", "pentkeys", "entrows", "anchrows", "endry", "entsries", "Entrys", "endorts", "entorts", "anchries", "centries", "pentries", "anchents", "pentrants", "entsrings", "entkeys", "anchriers", "Entrants", "centories", "Entries", "entrys", "enrants", "entents", "estrows", "entsorts", "entriers", "endories", "contrings", "endles", "endries", "contries", "estries", "equries", "entsrants", "equrows", "enories", "entry"]}}
{"id1": "5125847", "id2": "3109015", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineCss(URL base, List<Node> linkCss, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"css\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"style.css\");\n                Writer writer = new FileWriter(combineFile);\n                boolean first = true;\n                for (Node link : linkCss) {\n                    String path = ((Element) link).getAttribute(\"href\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File cssFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(cssFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        writer.write('\\n');\n                    } else {\n                        first = false;\n                    }\n                    Reader reader = new FileReader(cssFile);\n                    if (Configuration.cssMinification()) {\n                        CssCompressor cssCompressor = new CssCompressor(reader);\n                        cssCompressor.compress(writer, 0);\n                    } else {\n                        IOUtils.copy(reader, writer);\n                    }\n                    reader.close();\n                    String fileName = cssFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                writer.close();\n                FileReader reader = new FileReader(combineFile);\n                name.append(hashCode(IOUtils.toString(reader))).append(\".css\");\n                reader.close();\n                File targetFile = new File(Configuration.getCssLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    FileUtils.copyFile(combineFile, targetFile);\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several css files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkCss.get(0);\n            element.setAttribute(\"href\", Configuration.getCssUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private void copy(File parent) {\n        System.out.println(\"parent---\" + parent.getAbsolutePath());\n        if (parent.isDirectory() && !\".svn\".equals(parent.getName())) {\n            File cases = new File(parent, \"cases\");\n            if (cases.exists()) {\n                File answers = new File(parent, \"answers\");\n                if (!answers.exists()) {\n                    answers.mkdir();\n                    File answers_linux = new File(parent, \"answers_linux\");\n                    for (File file : answers_linux.listFiles()) {\n                        if (file.isDirectory()) {\n                            continue;\n                        }\n                        File target = new File(answers, file.getName());\n                        try {\n                            IOUtils.copy(new FileInputStream(file), new FileOutputStream(target));\n                        } catch (Throwable t) {\n                            t.printStackTrace();\n                        }\n                    }\n                }\n            } else {\n                for (File son : parent.listFiles()) {\n                    System.out.println(\"parent---\" + son.getAbsolutePath());\n                    copySon(son);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"base": ["source", "absolute", "bas", "page", "id", "site", "build", "l", "http", "out", "home", "based", "root", "part", "data", "ref", "style", "resource", "prefix", "server", "config", "relative", "log", "api", "area", "string", "image", "cache", "uri", "file", "db", "builder", "Base", "bot", "proxy", "store"], "linkCss": ["lineCustomcss", "linkcps", "linkStss", "stylePSS", "linkccss", "linkCustomcss", "linkCcss", "linkScss", "linkScSS", "lineCcss", "linkCps", "linkcss", "linkPss", "styleCss", "linkPcss", "styleCcss", "linkCfs", "lineCfs", "linkStls", "styleCls", "linkCustomfs", "linkCls", "linkSccss", "linkStcss", "linkScls", "lineCustomfs", "stylePss", "linkCSS", "stylePcss", "linkPSS", "lineCss", "lineCustomss", "stylePls", "linkCustomps", "linkcfs", "linkSfs", "linkCustomss", "linkStSS", "linkSps", "lineCustomps", "lineCps", "linkPls", "styleCSS", "linkSss"], "newFiles": [" newfiles", " newResources", "newfiles", "newSources", "newResources", "oldFiles", "oldSources", "oldfiles", "oldResources", "existingSources", "existingfiles", "existingResources", " newSources", "existingFiles"], "dir": ["folder", "div", "parent", "id", " db", " directory", "draft", "d", "rel", "plugin", "build", " repo", "DIR", "lib", "wd", "http", "out", "in", "home", "diff", "root", "f", " cur", "loc", "directory", " folder", "zip", "work", "editor", " d", "dest", "ir", "module", "desc", " manager", "direction", "container", "log", " parent", "keep", "area", "session", "done", "cache", "lock", "file", "db", "uri", " director", "manager", "local", "dist", " Dir", "md", "domain", "store", " module", "coll", "Dir"], "name": ["source", "NAME", "attr", "parent", "size", "id", "memory", "Name", "default", "connection", "build", "space", "now", "output", "out", "object", "home", "part", "number", "data", "directory", "named", "style", "n", "resource", "prefix", "address", "template", "info", "word", "alias", "filename", "comment", "names", "temp", "key", "time", "string", "image", "cache", "file", "uri", "search", "builder", "files", "array", "block", "create", "mini", "type"], "minDir": ["miniEntry", "localUrl", "MinFile", "mainDb", "minDb", "miniStore", " minFile", "minEntry", "localFolder", "miniDir", "miniFile", "smallFile", "miniFolder", " minDb", "minFolder", "mainDir", "minStore", "smallFolder", "minUrl", "miniDb", "smallDir", " minEntry", " minUrl", "MinDir", "MinFolder", "MinUrl", "mainFile", "localFile", "smallStore", "localDir", " minStore", " minFolder", "mainEntry", "minFile"], "combineFile": ["comineDir", "combinatePath", "combiseFile", "comineDirectory", "combINEFile", "compiningDirectory", "combINEPath", "combiningDirectory", "compiningFiles", "combiningPath", "combinateDirectory", "cominatefile", "domineDir", "combiningFiles", "domineFile", "combinateFiles", "combinFile", "combineDirectory", "cominateDir", "domineFiles", "cominateFile", "dominationFiles", "combinedPath", "combineDir", "combINEFiles", "combineFiles", "combinationFiles", "compiningFile", "combinfile", "combinefile", "combiningFile", "combinateFile", "cominateDirectory", "comineFile", "combINEDirectory", "combiseDir", "compineFile", "combinationDir", "combisefile", "combinedDir", "combinateDir", "compineFiles", "combinePath", "combinationFile", "combinationPath", "combinDir", "dominationPath", "compinePath", "compineDirectory", "dominePath", "combinedFile", "combinedDirectory", "cominefile", "combinatefile", "combinDirectory", "dominationDir", "combiseDirectory", "compiningPath", "dominationFile", "combinedFiles"], "writer": ["source", "page", "parent", "read", "later", "input", "wrapper", "write", "buffer", "director", "player", "engine", "ws", "output", "outer", "io", "format", "w", "out", "driver", "ler", "this", "root", "layer", "loader", "worker", "data", "writers", "stream", "style", "r", "master", "riter", "handler", "editor", "work", "inner", "server", "resource", "er", "word", "null", "o", "wl", "Writer", "temp", "key", "window", "string", "document", "rw", "file", "builder", "war", "self", "writing", "value", "RW", "wr", "entry"], "link": ["page", " links", " page", " comment", "links", " style", " source", "connection", "feed", "user", " anchor", "l", "bug", " object", "loc", "cp", "style", " linked", "match", "info", " Link", " inline", " match", "ink", "linked", "comment", "li", "node", "image", " type", "load", " entry", "parse", " tag", "Link", " node", "follow", " label", "line", "sl", "type"], "path": ["source", "route", "id", "xml", "PATH", "Path", "part", "href", "data", "ref", "style", "info", "ath", "method", "full", "pattern", "step", "text", "content", "key", "ri", "string", "node", "pointer", "pass", "file", "uri", "code", "attribute", "value", "location", "type"], "url": ["source", "page", "route", "browser", "feed", "rel", "download", "open", "connection", "l", "ul", "http", "b", "f", "loc", "data", "href", "ref", "stream", "style", "r", "channel", "resource", "server", "config", "address", "ur", "gl", "sl", "ri", "string", "image", "html", "file", "uri", "ssl", "URL", "Url", "blog", "web", "str", "location"], "inputStream": [" inputContent", "outputSteam", "inputSteam", "loadStreamer", "inputContent", "imageFile", "imageStream", "InputBuffer", "outputBuffer", "outputFile", "InputStream", "imageSteam", " inputFile", "outputContent", "inputStreamer", " inputWriter", "loadFile", "InputFile", " inputBuffer", "inputWriter", "InputWriter", "loadStream", "inputBuffer", "imageStreamer", "outputWriter", "inputFile", "loadSteam", "InputContent", "outputStreamer"], "cssFile": ["nsfile", "ssName", "nsFile", "styleStream", "styleFile", "styleFiles", "stylefile", "cssUrl", "rssName", "ssfile", "ssUnit", "rssUnit", "cssfile", "ssStream", "cssUnit", "cleanfile", "nsFiles", "ssWriter", "rssUrl", "ssUrl", "lsfile", "cssFILE", "ssFILE", "cleanName", "rssFILE", "styleWriter", "cacheFile", "ssFiles", "cssName", "nsWriter", "ssFile", "cleanFile", "cachefile", "cacheUnit", "cssFiles", "lsFile", "cssWriter", "lsStream", "cacheUrl", "rssFile", "lsWriter", "cleanFILE", "cssStream", "rssfile"], "fileName": ["FileInfo", "filePart", " fileTime", " fileCode", "profileDie", "fName", "FilePath", "FILELocation", "profilePath", " fileValue", "fPath", "pageValue", "FileLocation", "typePath", "singlename", "typeInfo", "FileValue", " fileString", "Filename", "typename", "pagePart", "FILEString", "fileDie", " filePath", "fileLine", "filename", "FileDie", "FilePart", "FileCode", " filename", "fname", "fileString", "FileTime", "fileInfo", "singleName", " fileInfo", " fileLocation", "typeName", "fileCode", "filePath", "profileInfo", "FileName", "FileString", "singleLine", "fTime", "FILEPath", "singleCode", " filePart", "pageName", "fileLocation", "FILEName", "pagename", "profileName", " fileDie", "fileValue", "fileTime", " fileLine", "FileLine"], "outputStream": ["outputSteam", "inputSteam", "OutputSteam", "externalWriter", "responseSteam", "resourceStream", "OutputReader", "resourceSteam", "responseStream", "resourceFile", "inputstream", "outputFile", "OutputStream", "resourcestream", "externalSteam", "OutputWriter", " outputFile", "inputReader", "outputstream", "outputReader", "externalStream", " outputSteam", "responseFile", "externalFile", "inputWriter", "responsestream", "OutputFile", " outputReader", "outputWriter", "inputFile"], "first": ["First", "next", "left", "parent", "split", "default", "user", "last", "success", "share", "result", "right", "now", "must", "top", "one", "seen", "st", "root", "again", "always", "auto", "second", "yet", "full", "third", "other", "then", "once", "initial", "all", "same", "before", "leaf", "replace", "error", "prev", "only", "current", "start", "self", "empty", "alpha", "use"], "reader": ["read", "draft", "input", "rar", "wrapper", "rx", "Reader", "feed", "buffer", "iter", "player", "io", "ry", "l", "http", "out", "driver", "ler", "riter", "client", "lr", "row", "layer", "loader", "data", "worker", "auto", "stream", "serial", "r", "system", "zip", "handler", "her", "editor", "config", "inner", "server", "author", "resource", "info", "er", "rer", "rc", "per", "reading", "report", "parser", "runner", "ri", "image", "seed", "readable", "file", "uri", "i", "or", "builder", "manager", "service", "ner", "entry"], "cssCompressor": ["cssCompress", "cssPrepulator", "stylesCompression", "stylesRepoder", "cssComproller", "ssCompressor", "ssComproller", "cssRepressor", "cssContressor", "stylesCompressor", "cssCombress", "cssCombression", "cssContression", "cssController", "cssComboder", "cssCompression", "stylesCompoder", "stylesRepressor", "ssCompulator", "cssCompulator", "stylesCompress", "cssCombressor", "cssRepression", "cssContulator", "ssCompression", "cssPrepressor", "cssPreproller", "cssRepoder", "stylesRepress", "cssCompoder", "stylesRepression", "cssRepress", "cssPrepression"], "pos": ["POS", "su", "num", "rel", "len", "ind", "min", "pl", "limit", "end", "val", "wa", "part", "loc", "prop", "po", "neg", "no", "ref", "oa", "os", "r", "ni", "x", " position", "seq", "pr", "abs", "post", "nos", "offset", "index", "pt", "sort", "col", "pass", "sp", "pro", "obj", "pointer", "i", "Pos", "start", "position", "ps", "s", "eff", "line", "p", "type"], "targetFile": ["cssDir", " destinationStream", "targetfile", "targetDir", " destinationFile", "targetStream", " targetDir", "cssfile", " targetfile", " targetStream", " destinationDir", " destinationfile", "cssStream"]}}
{"id1": "20654105", "id2": "6503552", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static DataElement createMD5Sum(int type, String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(data.getBytes());\n            byte[] dt = md.digest();\n            return new DataElement(type, hexEncode(dt));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new DataElement(type);\n    }\n", "label": 0, "substitutes": {"in": ["source", "reader", "id", "url", "input", "inc", "buffer", "min", "io", "l", "diff", "login", "base", "as", "data", "In", "again", "work", "config", "inner", "name", "query", "ins", "m", "ex", "index", "image", "lock", "c", "file", "i", "IN", "inn", "lin", "bin", "ic"], "out": ["page", "plain", "default", "user", "write", "connection", "io", "output", "conn", "w", "b", "base", "OUT", "Out", "n", "outs", "again", "server", "call", "external", "writer", "prefix", "resource", "off", "exec", "x", "name", "o", "dot", "ex", "v", "string", "point", "image", "cache", "c", "file", "img", "p", "ext"], "inChannel": ["inConnection", "loginchannel", "loginChan", "outChan", "binStream", " inChan", "binchannel", "insChan", "INChannel", "inChan", "InGate", "INchannel", "inputConnection", "outchannel", "InQueue", "binChan", "InChan", "INChan", "insStream", "inputChannel", "iniGate", "inchannel", "inStream", "loginChannel", "Inchannel", "inputChan", "INConnection", "outQueue", "INStream", "outStream", "insChannel", "insConnection", "InStream", "binChannel", "binGate", "iniChan", " inQueue", "iniStream", "InChannel", "inGate", "iniChannel", "inputStream", " inchannel", "loginStream", "inQueue"], "outChannel": ["inConnection", "outputStream", "outChan", " outChan", "inChar", "netChan", " outchannel", "Outchannel", "inChan", "outputchannel", " outGate", "outchannel", "outChar", " outConnection", "outputChan", "OutChan", " outChar", "outputChannel", "netChannel", "OutChannel", "inchannel", "ouGate", "inStream", "ouChan", "outputChar", "outStream", "netGate", "outGate", "outConnection", "netStream", "outputGate", "inGate", "OutConnection", " outStream", "ouChannel", "ouchannel"]}}
{"id1": "18153746", "id2": "16190704", "code1": "    public static void copy(File src, File dst) throws IOException {\n        FileInputStream fIn = null;\n        FileOutputStream fOut = null;\n        FileChannel sIn = null;\n        FileChannel sOut = null;\n        try {\n            fIn = new FileInputStream(src);\n            try {\n                fOut = new FileOutputStream(dst);\n                try {\n                    sIn = fIn.getChannel();\n                    sOut = fOut.getChannel();\n                    sOut.transferFrom(sIn, 0, sIn.size());\n                } finally {\n                    if (sIn != null) {\n                        sIn.close();\n                    }\n                    if (sOut != null) {\n                        sOut.close();\n                    }\n                }\n            } finally {\n                if (fOut != null) {\n                    fOut.close();\n                }\n            }\n        } finally {\n            if (fIn != null) {\n                fIn.close();\n            }\n        }\n    }\n", "code2": "    public static String exchangeForSessionToken(String protocol, String domain, String onetimeUseToken, PrivateKey key) throws IOException, GeneralSecurityException, AuthenticationException {\n        String sessionUrl = getSessionTokenUrl(protocol, domain);\n        URL url = new URL(sessionUrl);\n        HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();\n        String header = formAuthorizationHeader(onetimeUseToken, key, url, \"GET\");\n        httpConn.setRequestProperty(\"Authorization\", header);\n        if (httpConn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new AuthenticationException(httpConn.getResponseCode() + \": \" + httpConn.getResponseMessage());\n        }\n        String body = CharStreams.toString(new InputStreamReader(httpConn.getInputStream(), Charsets.ISO_8859_1));\n        Map<String, String> parsedTokens = StringUtil.string2Map(body, \"\\n\", \"=\", true);\n        parsedTokens = StringUtil.lowercaseKeys(parsedTokens);\n        return parsedTokens.get(\"token\");\n    }\n", "label": 0, "substitutes": {"src": ["source", "sel", "sb", "url", "input", "upload", "conn", "fp", "inf", "in", "sf", "st", "this", "loc", "stream", "bs", "ctx", "resource", "sc", "config", "dest", "sys", "sup", "filename", "ins", "rc", "inst", "fn", "buf", "ls", "sin", "slice", "path", "uri", "dist", "conv", "img", "proxy", "s", "rb", "sl"], "dst": ["Dwd", "dbSt", "isdST", "dST", " dSt", "dwd", "isdnd", "lnd", "Dnd", "bdft", "dbST", "lwd", "lst", "dSt", "dbst", " dST", "dbnd", "Dft", "dft", "Dst", "isdSt", " dnd", "bdnd", "dnd", "isdst", "bdwd", "bdst", "lft"], "fIn": ["FOut", "sInt", "FIns", "hIn", " fInput", "hIN", "eOut", "eInput", "sfOut", "fsIns", "Fin", "sIN", "fsOut", "eIn", "ofOut", "sfIN", "dOut", "fOver", "sOver", "ofInt", "FIn", " fOver", "fIns", "lOut", "ofOver", " fIN", "sInput", "hin", "lIN", "sIns", "dIns", "fsIn", "fInt", "dInput", "lIn", "ofIn", " fInt", "fsin", "fIN", "sin", "fInput", "hOut", "sfInput", "sfIn", "lin", "fin", "eIns", "dIn"], "fOut": ["lDie", "fOutside", "fOUT", "lOUT", "iout", "formIn", "sfOut", "sfGl", "fsOut", " fOutside", "iFor", "fpOutput", "fpOUT", "dOut", "iOut", " fout", "ifOutside", "fpDie", "lOutput", "sOutside", "sFor", "lOut", "dDie", "fOutput", "ifOut", "sDie", "fsOutside", "formDie", "sCore", " fGl", "fGl", "fCore", "fsIn", "dOUT", " fOUT", "fpOut", "sfOutside", "ifIn", "fDie", "sOUT", "fout", "ifCore", "formOut", "sfIn", "fsCore", " fFor", "formOUT", "sout", "sGl", " fDie", "fFor", " fOutput", "iOUT", "dIn"], "sIn": ["ansInit", "esIN", "esOut", " sIN", "esIns", "sIN", "fsOut", "dOut", "ansIN", "dsIns", "dsin", "fIns", "lOut", "dsIn", "dsIN", "sInput", "fsIN", "dsInit", "esIn", "lIN", "dsOut", "sIns", "dIns", "fsIn", "dIN", "dInput", "lIn", "ansIn", "fsin", "fIN", "fInput", "sin", "lInput", "dsInput", "sInit", " sIns", "fInit", "fin", "dIn", "ansOut"], "sOut": ["fOUT", "fExt", "dsWin", "dOut", " sLoop", "fullOut", "sLoop", "dsIn", "fOutput", "isOut", "sWin", " sExt", "sExt", "isOutput", "dsOut", "fLoop", "isIn", "dOUT", "sOutput", "dIn", " sNum", "fWin", " sout", " sOUT", "dsout", " sOutput", "sOUT", "fullIn", "fout", "isout", "sNum", "fNum", "fullOUT", "sout", "fullNum", "dout", " sWin"]}}
{"id1": "3708296", "id2": "7309170", "code1": "    public byte[] transfer(@Nullable final TransferListener transferListener) {\n        try {\n            InputStream inputStream = url.openStream();\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream(inputStream.available());\n            if (transferListener != null) {\n                inputStream = new ObservableInputStream(inputStream, transferListener);\n            }\n            ByteStreams.copy(InputSuppliers.asInputSupplier(inputStream), outputStream);\n            return outputStream.toByteArray();\n        } catch (IOException e) {\n            throw new UnhandledException(e);\n        }\n    }\n", "code2": "    private void zip(File input, File output) {\n        OutputStream os = null;\n        InputStream is = null;\n        try {\n            os = new GZIPOutputStream(new FileOutputStream(output));\n            is = new FileInputStream(input);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"transferListener": ["sourceLayer", "licenseLoader", "uploadReader", " transferReader", " transferLoader", " transferListen", "transferLayer", " transferLayer", "licenseListener", "moveListener", "sourceCallback", "uploadCallback", "uploadListener", " transferHandler", "TransferHandler", "transferHandler", " transferCallback", "TransferCallback", "TransferListen", "transferListen", "transferCallback", "uploadLayer", "transferLoader", "TransferLoader", "sourceListener", "moveListen", "TransferListener", "licenseCallback", "sourceReader", "moveHandler", "transferReader"], "inputStream": ["outputSteam", "outputThread", "inputSteam", "httpStream", " inputFeed", "inputClient", "outStreamer", "resourceClient", " inputstream", "resourceStream", "InputThread", "httpSteam", "resourceSteam", "inputstream", "inputFeed", "InputStream", " inputClient", " inputSteam", " inputThread", "inputStreamer", "httpClient", "inSteam", "outputstream", "httpStreamer", "outstream", "inStreamer", "outputFeed", " inputStreamer", "Inputstream", "outSteam", "InputStreamer", "inStream", "instream", "outStream", "InputFeed", "InputSteam", "resourceStreamer", "outputStreamer", "inputThread"], "outputStream": ["targetStreamer", "outputSteam", "OutputLength", "inputSteam", "targetStream", "OutputSteam", "outputLength", "responseSteam", " outputStreamer", "responseStream", "inputstream", "outputBuffer", "OutputStream", "responseBuffer", "Outputstream", "outputstream", " outputBuffer", "inputLength", " outputSteam", "responseLength", "OutputStreamer", " outputstream", "inputBuffer", "targetstream", "targetSteam", "outputStreamer", "OutputBuffer"]}}
{"id1": "6158845", "id2": "16474825", "code1": "    private void serveRedir(OutputStream os, IRequest req) throws IOException {\n        String urlString = req.getParameter(\"url\");\n        URL url = new URL(urlString);\n        URLConnection con = url.openConnection();\n        InputStream is = new BufferedInputStream(con.getInputStream());\n        String ct = con.getContentType();\n        int cl = con.getContentLength();\n        String jsLink = \"<script language=\\\"JavaScript1.2\\\" src=\\\"/tddt.js\\\" type='text/javascript'></script>\\n\";\n        int i;\n        String head = getHead(\"HTTP/1.0 200 OK\", \"Content-Type: \" + ct + \"\\nContent-Length: -1\");\n        os.write(head.getBytes());\n        if (ct != null && ct.indexOf(\"html\") != -1) {\n            os.write(jsLink.getBytes());\n            NetUtils.saveChangeLink(url, os);\n        } else {\n            int len;\n            byte[] b = new byte[1024];\n            while ((len = is.read(b)) >= 0) {\n                os.write(b, 0, len);\n            }\n        }\n        os.flush();\n    }\n", "code2": "    public static void copyFile(String file1, String file2) {\n        File filedata1 = new java.io.File(file1);\n        if (filedata1.exists()) {\n            try {\n                BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file2));\n                BufferedInputStream in = new BufferedInputStream(new FileInputStream(file1));\n                try {\n                    int read;\n                    while ((read = in.read()) != -1) {\n                        out.write(read);\n                    }\n                    out.flush();\n                } catch (IOException ex1) {\n                    ex1.printStackTrace();\n                } finally {\n                    out.close();\n                    in.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"os": ["opens", "los", "ks", "om", "des", "oid", "ends", "oses", "ws", "io", "rss", "conn", "fs", "http", "acs", "object", "ns", "ros", "OS", "ou", "bos", "ms", "as", "oes", "oa", "bs", "outs", "dos", "es", "serv", "ens", "org", "ot", "gets", "sys", "vs", "oss", "js", "oos", "res", "o", "s", "aos", "ok", "ob", "log", "cs", "abs", "Os", "nos", "ose", "ios", "ops", "ips", "ol", "ols", "or", "pos", "us", "cos", "boot", "obs", "osi", "iso", "ps", "op", "so"], "req": ["rf", "proc", "sem", "require", "util", "pull", "jp", "src", "conn", "http", "request", "out", "in", "app", "fr", "ref", "re", "r", "ctx", "config", "info", "Request", "ir", "conf", "exec", "desc", "requ", "pr", "rec", "cache", "obj", "rt", "err", "resp", "q", "rr", "ctr", "res", "rb"], "urlString": ["urlstring", "strLine", "Urlstring", "UrlString", " urlText", "resourcestring", "UrlLine", "uriText", " urlLine", "uriString", "uriStr", "urlStr", "uristring", " urlstring", "urlText", "strString", "resourceText", "urlLine", "strstring", "resourceStr", "resourceString", " urlStr"], "url": ["source", "host", "page", "route", "id", "link", "user", "connection", "download", "pull", "ll", "conn", "l", "ul", "http", "base", "channel", "loc", "href", "f", "ref", "resource", "server", "config", "address", "el", "name", "ur", "gl", "rc", "ob", "log", "api", "text", "sl", "bel", "fl", "ls", "path", "image", "obj", "html", "file", "uri", "ssl", "c", "socket", "URL", "service", "Url", "www", "blog", "web", "location", "type"], "con": ["plain", "en", "inc", "ln", "win", "connection", "uc", "open", "cf", "co", "conn", "fc", "client", "const", "login", "f", "common", "cover", "re", "pub", "enc", "serv", "can", "cn", "pc", "cur", "cons", "sync", "exec", "func", "rc", "CON", "log", "non", "ann", "com", "close", "connect", "c", "socket", "ran", "un", "conv", "cos", "cc", "Conn", "coll", "ac", "Con"], "is": ["isa", "io", "conn", "ais", "http", "isl", "in", "css", "as", "loc", "iss", "enc", "bs", "ris", "es", "ai", "info", "ir", "oss", "ins", "ci", "ob", "iris", "IS", "ch", "abs", "ri", "lis", "ib", "ios", "ops", "uri", "im", "us", "ar", "Is", "bis", "iso", "ps", "s", "ip", "ic"], "ct": ["dc", "cd", "ant", "pe", "txt", "cy", "ht", "cf", "ld", "cat", "Ct", "conn", "CT", "st", "const", "loc", "enc", "cn", "crit", "xx", "wt", "acl", "ci", "feat", "nt", "act", "sect", "cs", "tt", "t", "unit", "ch", "cont", "lc", "ect", "pt", "col", "ft", "sec", "cr", "ctor", "c", "rt", "oct", "struct", "att", "ce", "cc", "th", "et", "qt", "gh", "ca", "cod", "nc", "sl", "kt", "type"], "cl": [" sh", "cm", " fl", "CL", "ul", "scl", "Cl", " bl", "sh", "kl", "el", "acl", " il", "ipl", " sl", "ch", "fl", "lc", "col", "ocl", "ml", " pl", " clen", " ll", "pl", "ll", "bl"], "jsLink": ["jslink", "jsLock", "jsLine", "jsonLine", "javascriptlink", "javascriptLink", "cssLock", " jsLock", "cssLink", "scriptlink", "scriptLinks", "scriptLink", "jsonLink", "cssLine", "jsBlock", "jsonLock", " jsUrl", "jsLinks", "jsonBlock", " jsLine", "scriptUrl", " jsBlock", "jsUrl", "javascriptUrl", " jslink", " jsLinks", "javascriptLinks", "cssBlock"], "i": ["id", "d", "si", "io", "l", "in", "f", "n", "I", "ai", "it", "ui", "ci", "e", "li", "index", "j", "c", "uri", "ii", "pi", "z", "ip", "p", "type"], "head": ["host", "h", "id", "link", "auth", "doc", "Head", "http", " header", "cmd", "f", "stream", "heads", "meta", "tag", "name", "body", "Header", "HEAD", "then", "text", "comment", "post", "content", "headers", "html", "c", "code", "title", "header", "tail", "block", "md", "subject", "ck", "commit", "foot", "heading", "type"], "len": ["size", "split", "en", "num", "hl", "ln", "d", "la", "lf", "iter", "limit", "l", "ler", "end", "val", "part", "f", "L", "Len", "data", "no", "ref", "n", " length", "el", "fun", "e", "length", "a", "fl", "lc", "li", "ann", "le", " lang", "count", "lock", "c", "rev", "db", "err", "pos", "bin", "line", "sl", "bl", "type"], "b": ["sb", "cb", "binary", "bf", "bh", "mb", "buff", "br", "pb", "l", "bc", "f", "base", "bd", "bi", "bytes", "bs", "batch", "bb", "ob", "bar", "buf", "job", "v", "gb", "ba", "xb", "eb", "B", "emb", "ab", "c", "db", "wb", "fb", "nb", "lb", "bin", "rb", "ib", "bl"]}}
{"id1": "6677391", "id2": "322658", "code1": "    @Override\n    protected void doRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String reqPath = req.getPathInfo();\n        if (reqPath.startsWith(\"/\")) reqPath = reqPath.substring(1);\n        ZipEntry entry = zipInfo.get(reqPath);\n        if (entry == null) {\n            logger.debug(Utils.join(\"Requested path not found: [\", reqPath, \"]\"));\n            resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        logger.debug(Utils.join(\"Requested path: [\", reqPath, \"]\"));\n        ServletUtils.establishContentType(reqPath, resp);\n        InputStream in = null;\n        try {\n            in = new BufferedInputStream(zipFile.getInputStream(entry));\n            IOUtils.copy(in, resp.getOutputStream());\n            logger.debug(\"Rendered: \" + reqPath);\n        } catch (FileNotFoundException e) {\n            logger.error(\"zipped resource not found: \" + reqPath);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"req": ["reader", "proc", "rx", "rel", "rep", "conn", "http", "request", "fr", "data", "ref", "re", "r", "response", "resource", "ctx", "zip", "serv", "info", "Request", "exec", "crit", "desc", "query", "e", "requ", "report", "job", "rec", "rw", "obj", "rt", "err", "Resp", "rr", "res", "rb", "jar", "pkg"], "resp": ["respond", "proc", "rel", "rep", "reply", "result", "jp", "conn", "http", "ev", "out", "request", "app", "wa", "client", "fr", "f", "exc", "red", "ref", "re", "response", "r", "ctx", "zip", "server", "serv", "ret", "conf", " response", "bb", "report", "exp", "rh", "job", "temp", "esp", "rec", "Response", "respons", "sp", "html", "rev", "obj", "prev", "err", "wb", "Resp", "rr", "res", "p", "Rec"], "reqPath": ["questpath", "requestName", "reqHandler", "questPart", "reqPart", " reqPart", "requName", "requestUrl", "requestCase", "reqpath", "reqUrl", " reqCase", "apppath", " reqName", "taskPart", "requestHome", "taskCase", " reqHandler", "requpath", "releaseName", "releasePart", "appName", "questPath", "requHandler", "requestpath", "requestPath", "requPart", "reqCase", "reqHome", "reqName", "requestPart", "appPath", "questUrl", " reqpath", "requPath", "releasePath", "taskPath", "questHandler", " reqHome", " reqUrl", "questHome", "requUrl", "taskpath"], "entry": ["source", "reader", " entries", "id", "inc", "si", "ent", "feed", "connection", "result", "ry", "jo", "object", "cell", "part", "ries", "row", "fr", "data", "auto", "zip", "response", "resource", "r", "ie", "archive", "address", "info", "serv", "element", "conf", "ge", "e", "nt", "report", "log", "found", "je", "se", "session", "index", "ri", "path", "image", "entity", "file", "record", "parse", "or", "uri", "Entry", "manager", "rr", "type", "service", " Entry", "jar"], "in": ["source", "reader", "tin", "id", "input", "inc", "din", "win", "min", "cgi", "nin", "con", "out", "b", "login", "f", "data", "In", "pin", "inas", "re", "r", "n", "resource", "again", "thin", "serv", "stream", "isin", "ac", "ins", "s", "ax", "vin", "zin", "gin", "ini", "ex", "m", "fe", "kin", "index", "cin", "c", "socket", "i", "IN", "err", "or", "inn", "rin", "is", "bin", "copy", "p"]}}
{"id1": "22366636", "id2": "3108499", "code1": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Project project = (Project) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_PROJECT\"));\n            pst.setString(1, project.getName());\n            pst.setString(2, project.getDescription());\n            pst.setInt(3, project.getIdAccount());\n            pst.setInt(4, project.getIdContact());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_project) from project\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"o": ["ado", "none", "ao", "d", "oid", "office", "connection", "object", " object", "op", "po", "mo", "oa", "os", "ono", "oo", "bo", "oi", "online", "e", "ob", "ion", "t", "oe", "OO", "od", "O", "Obj", " O", "obj", "or", "obo", " os", "PO", " obj", "bot", "s", "p", "type"], "insert": ["select", "plus", "read", "inc", "write", "append", "feed", "pull", "exist", "repeat", "result", "ride", "join", "Insert", "row", "delete", "sleep", "put", "save", "push", "update", "sync", "ert", "edit", "step", "length", "enter", "post", "index", "seed", "load", "connect", "replace", "error", "check", "search", "zero", "create", "start", "position", "throw", "add", "copy", "apply", "ip", "use", "entry"], "id": ["parent", "read", "url", "test", "oid", "result", "val", "root", "aid", "delete", "Id", "number", "no", "ret", "info", "update", "x", "action", "name", "event", "it", "edit", "pid", "length", "show", "time", "index", "count", "load", "error", "code", "i", "search", "and", "vid", "ids", "create", "ip", "start", "order", "kid", "add", "ID", "uid", "type"], "project": ["language", "source", "select", "parent", "contract", "operation", "Project", "user", "phase", "pe", "period", "office", "connection", "product", "plugin", "build", "division", "result", "jp", "object", "app", "request", "client", "home", "model", "environment", "base", "application", "po", "data", "to", "future", "version", "zip", "resource", "contact", "config", "primary", "push", "component", "name", "purpose", "target", "patch", "device", "password", "text", "post", "job", "index", "document", "company", "context", "db", "projects", "priority", "service", "database", "subject", "development", "bot", "port", "p", "type"], "pst": ["pretd", "Pft", "dST", "lpse", "lpst", "lpth", "pth", " pste", " psp", "pcr", " ptd", "precr", "Pss", "prst", "Pst", " pcr", "pnd", "epst", " psth", "psp", "opnd", "pct", "Pct", " pse", "Pth", " pss", " pft", "opst", "ptd", "pft", "prft", "opct", "pste", "psth", "epse", "prest", "prese", "pse", " pct", "lpct", "Psth", "dct", "epcr", "prct", "Pnd", "Pse", "pss", "PST", "dst", "dsp", "eptd", " pth", "pST", "Pste", "Psp", " pST", "prste", "opsth", " pnd", "prss"], "st": ["sa", "sb", "ST", "ost", "ld", "ss", " St", "statement", "src", "sw", "ist", "est", "ess", "r", "sc", "sh", "tx", "sta", "inst", " est", "s", "cl", "t", "mt", "pr", "St", "se", "pt", "cr", "sts", "SS", "sp", "rd", "struct", "ust", "ts", "ct", "ps", "str", "rest", "sl", "bl"], "rs": ["ums", "Rs", "ys", "RC", "hs", "ks", "rys", "ows", "ra", "runs", "lines", "ss", "ws", "RS", "rss", "ns", "ros", "ars", "ries", "r", "ris", "rg", "eers", "vs", " rows", " res", "ins", "results", "icks", "rc", "cs", "sr", "hr", "dr", "ls", "pr", "rows", "cr", "rl", " sr", "rd", "mr", "vers", "rr", "ras", "ds", " RS", "ps", "res"]}}
{"id1": "7564559", "id2": "1048705", "code1": "    public static String SHAEncrypt(String originalString) {\n        String encryptedString = new String(\"\");\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(originalString.getBytes());\n            byte b[] = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                char[] digit = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n                char[] ob = new char[2];\n                ob[0] = digit[(b[i] >>> 4) & 0X0F];\n                ob[1] = digit[b[i] & 0X0F];\n                encryptedString += new String(ob);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n            System.out.println(\"the algorithm doesn't exist\");\n        }\n        return encryptedString;\n    }\n", "code2": "    public static String encriptarPassword(String aPassword) throws BusinessException {\n        ILogger logger = LogFactory.getLogger(User.class);\n        String methodId = \"encriptarPassword\";\n        try {\n            MessageDigest currentAlgorithm = MessageDigest.getInstance(\"MD5\");\n            currentAlgorithm.reset();\n            currentAlgorithm.update(aPassword.getBytes());\n            byte[] hash = currentAlgorithm.digest();\n            String d = \"\";\n            for (int i = 0; i < hash.length; i++) {\n                int v = hash[i] & 0xFF;\n                if (v < 16) d += \"0\";\n                d += Integer.toString(v, 16).toUpperCase();\n            }\n            return d.toLowerCase();\n        } catch (NoSuchAlgorithmException nsae) {\n            logger.logError(methodId + \"error al encriptar password:\" + nsae, nsae);\n            throw new BusinessException(\"Error al encriptar password\");\n        }\n    }\n", "label": 1, "substitutes": {"originalString": ["originalPassword", "encryptedText", "modifiedText", "updatedPassword", "OriginalText", "encryptedstring", "modifiedString", " originalstring", "updatedLetter", " originalText", "originalText", " originalStr", "modifiedPassword", "OriginalLetter", "originalstring", "encryptedStr", "updatedString", "originalStr", "originalLetter", "OriginalPassword", "updatedText", "modifiedLetter", "OriginalString", "OriginalStr", "Originalstring"], "encryptedString": ["encryptedText", "protectedText", " encryptedstring", "protectedStr", "protectedstring", "trainedText", "ryptedString", "ryptedStr", " encryptedSection", "encryptedstring", " encryptedService", "ryptedText", "originalText", "encryptedService", "lockedString", "lockedSite", " encryptedText", "trainedStream", "ryptedstring", "encryptedSection", " encryptedSite", "originalSite", "lockedService", "protectedString", "encryptedStr", "ryptedStream", "encryptedSite", "lockedText", "encryptedStream", " encryptedStr", "trainedString", "originalService", "trainedSection", "ryptedSection", " encryptedStream"], "md": ["um", "hash", "cd", "d", "mb", " Md", "alg", "dig", "dd", "ld", "hd", " MD", "mm", "vd", "pd", "gd", "am", "cmd", "ms", "f", "mac", "bd", "clean", "mand", "mag", "mc", "der", "sha", "mp", "dm", "de", "rm", "mod", "dh", "MD", "mt", "m", "df", "od", "pm", "mad", "Cmd", "amd", "sd", "me", "ad"], "b": ["h", "cb", "sb", "binary", "d", "mb", "buffer", "be", "br", "k", "pb", "l", "y", "w", "reb", "f", "base", "bi", "r", "bs", "x", "machine", "body", "u", "e", "bb", "a", "bar", "m", "bit", "v", "gb", "B", "orb", "ib", "emb", "obj", "c", "ab", "db", "wb", "g", "bis", "bin", "s", "rb", "p"], "i": ["h", "id", "d", "si", "multi", "qi", "iu", "phi", "k", "io", "l", "y", "in", "f", "di", "bi", "n", "zi", "I", "mu", "ti", "r", "ai", "gi", "info", "x", "ix", "it", "ui", "u", "e", "o", "ci", "eni", "t", "a", "li", "v", "key", "xi", "index", "j", "c", "uri", "ii", "vi", "pi", "start", "fi", "z", "s", "ip", "p", "ie"], "digit": ["shift", "dec", "id", "factor", "upper", "num", "inc", "operator", "d", "token", "product", "prime", "ord", "extra", "significant", "iter", "argument", "letter", "format", "char", "fix", "bug", "part", "f", "number", "data", "hex", "integer", "capital", "strip", "tag", "u", "dot", "text", "bit", "v", "index", "string", "quad", "pointer", "central", "oct", "character", "unsigned", "figure", "ig", "position", "alpha", "standard", "ext"], "ob": ["nob", "id", "sb", "url", "cb", "bf", "mb", "oid", "buff", "ord", "co", "lib", "object", "app", "bc", "bug", "loc", "bd", "ref", "abb", "obb", "rib", "org", "info", "ub", "Ob", "o", "bb", "atom", "text", "abs", "adr", "OB", "job", "offset", "od", "gb", "string", "eb", "orb", "emb", "obj", "ab", "db", "fb", "obo", "boot", "obs", "position", "lb", "op", "rb", "ib", "ie"]}}
{"id1": "2766456", "id2": "3327745", "code1": "    private void renderScript(PhaseEvent event) {\n        URL url = AjaxPhaseListener.class.getResource(SCRIPT_RESOURCE_NAME);\n        URLConnection conn = null;\n        InputStream stream = null;\n        BufferedReader bufReader = null;\n        HttpServletResponse response = (HttpServletResponse) event.getFacesContext().getExternalContext().getResponse();\n        OutputStreamWriter outWriter = null;\n        String curLine = null;\n        try {\n            outWriter = new OutputStreamWriter(response.getOutputStream(), response.getCharacterEncoding());\n            conn = url.openConnection();\n            conn.setUseCaches(false);\n            stream = conn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(stream));\n            response.setContentType(\"text/javascript\");\n            response.setStatus(200);\n            while (null != (curLine = bufReader.readLine())) {\n                outWriter.write(curLine + \"\\n\");\n            }\n            outWriter.flush();\n            outWriter.close();\n            event.getFacesContext().responseComplete();\n        } catch (Exception e) {\n            String message = null;\n            message = \"Can't load script file:\" + url.toExternalForm();\n        }\n    }\n", "code2": "    public static void copy(String source, String dest) throws java.io.IOException {\n        java.io.BufferedInputStream in = null;\n        java.io.BufferedOutputStream out = null;\n        try {\n            in = new java.io.BufferedInputStream(new java.io.FileInputStream(source), 1000);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(dest), 1000);\n            while (in.available() != 0) {\n                out.write(in.read());\n            }\n        } catch (java.io.IOException e) {\n            throw e;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (java.io.IOException E) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"event": ["source", "parent", "input", "user", "events", "pe", "layout", "complete", "ception", "result", "ee", "function", "game", "view", "actual", "vent", "out", "request", "object", "app", " Event", "ev", "environment", "layer", "data", "style", "resource", "handler", "feature", "config", "info", "address", "element", "name", "e", "other", "flow", "de", "json", "t", "instance", "v", "Event", "change", "image", "file", "context", "command", "press", "ce", "type"], "url": ["source", "host", "page", "route", "link", "user", "feed", "connection", "buffer", "download", "l", "view", "http", "client", "object", "lr", "base", "loader", "f", "channel", "layer", "ctrl", "ref", "re", "resource", "org", "server", "config", "address", "name", "log", "api", "text", "sl", "string", "path", "image", "socket", "file", "uri", "ssl", "context", "URL", "service", "Url", "www", "blog", "location"], "conn": ["Config", "dc", "cb", "connection", "open", "uc", "auth", "cf", "core", "co", "Pool", "ct", "http", "con", "client", "cmd", "connected", "channel", "loader", "loc", "po", "ec", "cp", "ca", "n", "pub", "enc", "ctx", "server", "serv", "config", "pc", "cn", "exec", "ci", "rc", "nt", "log", "api", "ch", "col", "pool", "connect", "cache", "c", "ssl", "socket", "rt", "URL", "conv", "Url", "Connection", "Conn", "nc", "coll", "ac"], "stream": ["source", "host", "reader", "input", "user", "trans", "connection", "Stream", "feed", "buffer", "result", "output", "src", "http", "thread", "out", "client", "sw", "driver", "row", "channel", "loader", "resource", "handler", "server", "raw", "writer", "inner", "cur", "iv", "log", "wave", "content", "col", "string", "path", "pool", "socket", "ssl", "context", "ream", "form", "port", "filter", "coll", "sl"], "bufReader": ["bufferWriter", " bufWriter", "bufLoader", "bufFile", " bufreader", "ufLine", "ufDriver", "buffDriver", "bufLine", "poolWriter", "bufferRead", " bufFile", "buffWriter", " bufDriver", "poolReader", "poolreader", "bufWriter", "bufRead", "buffReader", "buffLoader", " bufLoader", " bufLine", "bufferReader", "ufWriter", " bufRead", "ufFile", "bufDriver", "bufferreader", "ufReader", "bufferFile", "bufferLine", "bufreader", "poolRead", "ufLoader"], "response": ["next", "page", "respond", "site", "default", "connection", "feed", "success", "complete", "reply", "result", "function", "output", "view", "http", "out", "request", "this", "client", "object", "environment", "model", "f", "application", "onse", "data", "version", "re", "resource", "server", "serv", "body", "e", "de", "report", "json", "api", "content", "status", "v", "Response", "session", "index", "document", "image", "file", "error", "resp", "generation", "position", "received", "res"], "outWriter": [" outWire", "outputStream", "outWire", "outReader", " outReader", " outWalker", "ioReader", "outWriting", "outputWrite", "inReader", "ioWalker", "inWriter", "OutWrite", "OutWalker", "inWrite", "outputReader", "ioWire", "outWalker", "outputWire", "OutWriting", " outWriting", "outputWriting", "outWidth", "outputWalker", "ioWriter", "inWidth", " outWidth", "outStream", "OutReader", "OutWidth", " outWrite", "OutStream", "OutWriter", "outWrite", "outputWriter", " outStream"], "curLine": ["celEmail", " curFile", " curline", "celLine", "urLine", "curLength", "ferEmail", "constline", "urLetter", "ferLength", " curLetter", "celL", "crFile", "urBlock", "constBlock", "constLine", " curL", "curLetter", "ferL", "CurBlock", "celLength", "crLine", "curFile", "curline", "CurLine", "urline", "Curline", "constLetter", "curL", "crBlock", " curEmail", " curLength", "CurFile", "curBlock", "ferLine", " curBlock", "crline", "curEmail"], "message": ["source", "language", "page", " messenger", "translation", "mor", "msg", " exception", "result", "core", "Message", "flash", "object", "request", "description", "age", "application", "phrase", "address", "body", "information", "member", "management", "e", "log", "text", "content", "mail", "status", "essage", "string", "document", "error", "expression", "err", "manager", "mess", "level", "reason", "value", " messages", "type"]}}
{"id1": "7495800", "id2": "12728035", "code1": "    public static void copyFile(File fromFile, File toFile) throws IOException {\n        FileReader from = new FileReader(fromFile);\n        FileWriter to = new FileWriter(toFile);\n        char[] buffer = new char[4096];\n        int bytes_read;\n        while ((bytes_read = from.read(buffer)) != -1) {\n            to.write(buffer, 0, bytes_read);\n        }\n        to.flush();\n        to.close();\n        from.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"fromFile": ["orfile", "toDirectory", "fromSourceFile", " fromDirectory", "FromFile", "FromSourceFile", "fromfile", "orSourceFile", " fromFiles", "FromFiles", " fromSourceFile", " fromfile", "FromDirectory", "Fromfile", "fromDirectory", "fromFiles", "tofile", "orFile", "orDirectory", "toFiles"], "toFile": ["ToFile", "Tofile", "toDirectory", "toFolder", " toFolder", " toFilename", " tofile", " toPath", " toDir", "etoFilename", "ToFolder", "toFilename", "etofile", "ToFilename", "ToDirectory", "etoPath", "ToPath", "toDir", "targetFolder", "targetFile", "ToDir", "targetDirectory", "targetDir", "toPath", "etoFile", "tofile", " toDirectory"], "from": ["source", "get", "left", "read", "parent", "url", "link", "with", "range", "after", "io", "one", "original", "out", "this", "client", "end", "of", "in", "part", "normal", "f", "base", "From", "fe", "by", "data", "r", "u", "o", "old", "per", "a", "se", "up", "c", "parse", "file", "or", "ce", "start", "self", "form", "who", "so"], "to": ["via", "size", "write", "token", "with", "after", "co", "io", "TO", "one", "http", "thro", "out", "client", "b", "To", "f", "as", "po", "by", "into", "no", "auto", "data", "storage", "writer", "sync", "o", "target", "per", "api", "copy", "temp", "too", "socket", "file", "flo", "or", "who", "two", "so"], "buffer": ["source", "read", "reader", "url", "queue", "memory", "input", "binary", "feed", "reference", "buff", "repeat", "iter", "result", "Buffer", "limit", "layer", "number", "channel", "data", "base", "bytes", "available", "resource", "server", "raw", "address", "pad", "uffer", "transfer", "null", "batch", "flush", "length", "buf", "timeout", "slice", "count", "document", "border", "seed", "cache", "character", "position", "ip", "duration"], "bytes_read": [" bytes_valid", "bytes_load", " bytes_pass", "bytesIDvalid", "bytesIDload", "bytes_valid", " bytes_write", "bytes_pass", "bytes_length", " bytes_set", " bytes_length", "bytes_set", "bytes_in", " bytes_in", " bytes_load", "bytes_write", "bytesIDpass", "bytesIDread"]}}
{"id1": "1789990", "id2": "9793984", "code1": "    public String getHash(final String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash;\n        digest.update(password.getBytes(\"utf-8\"), 0, password.length());\n        md5hash = digest.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void setChecksum() {\n        try {\n            java.security.MessageDigest md5 = java.security.MessageDigest.getInstance(\"MD5\");\n            String fqn = this.path + this.name;\n            md5.update(fqn.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & BYTE_CLEANER_FF;\n                if (b < BYTE_CLEANER_10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            this.checksum = sb.toString();\n        } catch (java.security.NoSuchAlgorithmException nsae) {\n            this.checksum = this.path + this.name;\n        }\n    }\n", "label": 1, "substitutes": {"password": [" Password", "hash", "input", "token", "auth", "buffer", "sword", "username", "message", "python", "wd", "PASS", "description", "number", "data", "phrase", "hex", "resource", "prefix", "address", "word", "null", " passwords", "pattern", "paste", "text", "words", "key", "path", "seed", "encrypted", "secret", "database", "Password", "crypt", "wallet", "value", "padding", "p", "pass"], "digest": ["Diger", "mdester", "signests", "digester", "mdusher", "digests", "signester", "DigEST", "mdest", "Digher", "diger", "signEST", " digusher", "mdher", "generest", "digusher", "digEST", "Digester", " digEST", "generests", "mder", " digher", "generester", "digher", " digester", "signest", "generEST", "Digusher", " diger", "Digests", "Digest", "mdEST"], "md5hash": ["MD6address", "mdokHash", "MD5sum", "md4sum", "MD5hash", " md4sum", "md4url", "mdoksum", "md5sum", "md8hash", "md4hash", "md6hash", "md6array", "md6address", "md6sum", "mdokurl", "md2sum", "md2hash", "md8Hash", " md5url", "md5url", " md5sum", "md8array", "MD5Hash", "md4array", "md2Hash", " md4url", "md4address", "md8address", " md4hash", "md6url", "MD6sum", "md6Hash", "MD5array", "MD6array", " md5Hash", "md5address", "md5array", "MD6hash", "MD5address", " md4Hash", "MD6Hash", "md5Hash", "mdokhash", "md4Hash"]}}
{"id1": "15861394", "id2": "6176440", "code1": "    public static String md5(String string) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException exception) {\n            LOGGER.warn(exception.getMessage());\n        }\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(string.getBytes(\"iso-8859-1\"), 0, string.length());\n        } catch (UnsupportedEncodingException exception) {\n            LOGGER.warn(exception.getMessage());\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String encrypt(String password, String algorithm, byte[] salt) {\n        StringBuffer buffer = new StringBuffer();\n        MessageDigest digest = null;\n        int size = 0;\n        if (\"CRYPT\".equalsIgnoreCase(algorithm)) {\n            throw new InternalError(\"Not implemented\");\n        } else if (\"SHA\".equalsIgnoreCase(algorithm) || \"SSHA\".equalsIgnoreCase(algorithm)) {\n            size = 20;\n            if (salt != null && salt.length > 0) {\n                buffer.append(\"{SSHA}\");\n            } else {\n                buffer.append(\"{SHA}\");\n            }\n            try {\n                digest = MessageDigest.getInstance(\"SHA-1\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new InternalError(\"Invalid algorithm\");\n            }\n        } else if (\"MD5\".equalsIgnoreCase(algorithm) || \"SMD5\".equalsIgnoreCase(algorithm)) {\n            size = 16;\n            if (salt != null && salt.length > 0) {\n                buffer.append(\"{SMD5}\");\n            } else {\n                buffer.append(\"{MD5}\");\n            }\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new InternalError(\"Invalid algorithm\");\n            }\n        }\n        int outSize = size;\n        digest.reset();\n        digest.update(password.getBytes());\n        if (salt != null && salt.length > 0) {\n            digest.update(salt);\n            outSize += salt.length;\n        }\n        byte[] out = new byte[outSize];\n        System.arraycopy(digest.digest(), 0, out, 0, size);\n        if (salt != null && salt.length > 0) {\n            System.arraycopy(salt, 0, out, size, salt.length);\n        }\n        buffer.append(Base64.encode(out));\n        return buffer.toString();\n    }\n", "label": 1, "substitutes": {"string": ["source", "str", "strings", "input", "binary", "connection", "buffer", "space", "result", "function", "message", "format", "letter", "object", "in", "this", "number", "data", "version", "class", "single", "setting", "ident", "address", "sequence", "section", "word", "name", "filename", "ring", "s", "password", "text", "content", "slice", "document", "file", "uri", "parse", "expression", "array", "service", "database", "value", "null", "duration", "type"], "md": ["cb", "hash", "cd", "bf", "d", "mb", "cm", "dd", "ld", "hd", "sm", "mm", "ma", "mem", "pd", " MD", "wd", "am", "pg", "cmd", "ms", "mode", "po", "mo", "mac", "bd", "hm", "mand", "mag", "meta", "mc", "sha", "mp", "dm", "mod", "MD", "mt", "m", "od", "gb", "pm", "docker", "mg", "mage", "grad", "metadata", "nd", "amd", "nm", "dig", "amp", "ad", "pkg"], "md5hash": ["md512Hash", "md6header", "md5header", "md5sum", " md6sum", "md75copy", "md6hash", "md005hash", "md75hash", "md005sum", "md6sum", "mdhedkey", "md2sum", " md5byte", "md2hash", "mddownHash", " md512hash", "md5key", "md6copy", " md5sum", "mdblocksum", "md2Hash", "mddownhash", "md005header", "mddownsum", "md512sum", "md6byte", "md005byte", " md6byte", "md5copy", " md5key", " md5header", " md6hash", "md512hash", " md512Hash", " md6header", "md6key", " md5Hash", "mdblockbyte", " md6copy", "md75key", " md512sum", "md5byte", "mdhedhash", " md6key", "mdblockhash", "mdblockheader", " md5copy", "md5Hash", "mdhedcopy"]}}
{"id1": "21682040", "id2": "5125847", "code1": "    public void extractFrinika() throws Exception {\n        FileInputStream fis = new FileInputStream(frinikaFile);\n        progressBar.setIndeterminate(true);\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry ze = zis.getNextEntry();\n        while (ze != null) {\n            showMessage(\"Extracting: \" + ze.getName());\n            File file = new File(installDirName + \"/\" + ze.getName());\n            if (ze.isDirectory()) file.mkdir(); else {\n                FileOutputStream fos = new FileOutputStream(file);\n                byte[] b = new byte[BUFSIZE];\n                int c;\n                while ((c = zis.read(b)) != -1) fos.write(b, 0, c);\n                fos.close();\n            }\n            ze = zis.getNextEntry();\n        }\n    }\n", "code2": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineCss(URL base, List<Node> linkCss, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"css\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"style.css\");\n                Writer writer = new FileWriter(combineFile);\n                boolean first = true;\n                for (Node link : linkCss) {\n                    String path = ((Element) link).getAttribute(\"href\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File cssFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(cssFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        writer.write('\\n');\n                    } else {\n                        first = false;\n                    }\n                    Reader reader = new FileReader(cssFile);\n                    if (Configuration.cssMinification()) {\n                        CssCompressor cssCompressor = new CssCompressor(reader);\n                        cssCompressor.compress(writer, 0);\n                    } else {\n                        IOUtils.copy(reader, writer);\n                    }\n                    reader.close();\n                    String fileName = cssFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                writer.close();\n                FileReader reader = new FileReader(combineFile);\n                name.append(hashCode(IOUtils.toString(reader))).append(\".css\");\n                reader.close();\n                File targetFile = new File(Configuration.getCssLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    FileUtils.copyFile(combineFile, targetFile);\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several css files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkCss.get(0);\n            element.setAttribute(\"href\", Configuration.getCssUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"fis": ["lbs", "afiss", "lais", "piss", "Fiss", "Fos", "fiss", "fais", "afos", "afis", "fios", "pbs", " fios", "Fis", "fbs", "pis", "lis", "liss", "afios", "Fios", " fais", " fbs", " fiss", "pais"], "zis": [" zins", " zos", "zais", "zas", " ziss", " zIS", "zipos", " zas", "zeiss", "zips", "zisa", "zenisa", "zipips", "zipis", "zenins", "zipais", "zipisi", "zeIS", " zips", "zenis", "zeniss", "ZIS", "zenisi", "zenos", "ziss", " zisi", "Zas", "zos", "zenips", "zIS", "zeas", "zenIS", "Zins", "zeis", "Ziss", "Zis", "zenais", "zisi", " zisa", "zins", "zipisa", " zais"], "ze": ["forge", "ice", "ette", "ipe", "zes", "za", "isse", "ld", "cf", "ee", "one", "ez", "que", "jo", "zy", "model", "ane", "lde", "ise", "fe", "ine", "zi", "zip", "zen", "ie", "ffe", "he", "el", "element", "zone", "zo", "ge", "ne", "liner", "e", "ace", "de", "ide", "ve", "cel", "oe", "sl", "kel", "je", "zz", "se", "ke", "zer", "ZE", "frame", "sk", "note", "code", "zed", "lex", "zie", "ede", "zee", "ce", "aze", "kee", "sea", "z", "lane", "te", "line", "ele", "entry"], "file": ["get", "folder", "parent", "die", "ile", "pe", "place", "feed", "connection", "cf", "function", "File", "l", "letter", "http", "out", "fp", "object", "f", "base", "fe", "data", "directory", "future", "zip", "single", "resource", "work", "force", "name", "dir", "it", "full", "e", "log", "jar", "le", "book", "up", "path", "cache", "files", "local", "FILE", "line", "unit"], "fos": ["Foos", "infOS", "infoss", "Fio", " foos", "foss", " fOS", "Fos", "Foss", "bos", "afos", "infos", "fios", " fios", "boss", "fio", "infoos", "FOS", "afoss", "fOS", "infio", "infis", "foos", "infios", "afios", "Fios", "bis", " fio", "afOS", " foss", "bOS"], "b": ["sb", "cb", "bf", "d", "mb", "buffer", "be", "buff", "br", "pb", "l", "bc", "f", "base", "bd", "bytes", "r", "bs", "abb", "x", "e", "bb", "ob", "a", "buf", "v", "ba", "gb", "xb", "eb", "ib", "emb", "B", "ab", "db", "i", "wb", "nb", "boot", "lb", "rb", "p", "bl"], "c": ["size", "dc", "id", "d", "uc", "cy", "cm", "cu", "cf", "k", "fc", "l", "w", "con", "bc", "f", "ec", "cp", "n", "r", "enc", "xc", "sc", "ac", "pc", "x", "ci", "e", "o", "esc", "cl", "a", "m", "lc", "col", "count", "cr", "code", "i", "ce", "cc", "nc", "p", "C"]}}
{"id1": "14196271", "id2": "20292404", "code1": "    private synchronized File zipTempFile(File tempFile) throws BlogunityException {\n        try {\n            File zippedFile = new File(BlogunityManager.getSystemConfiguration().getTempDir(), tempFile.getName() + \".zip\");\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zippedFile));\n            byte[] readBuffer = new byte[2156];\n            int bytesIn = 0;\n            FileInputStream fis = new FileInputStream(tempFile);\n            ZipEntry anEntry = new ZipEntry(tempFile.getName());\n            zos.putNextEntry(anEntry);\n            while ((bytesIn = fis.read(readBuffer)) != -1) {\n                zos.write(readBuffer, 0, bytesIn);\n            }\n            fis.close();\n            zos.close();\n            return zippedFile;\n        } catch (Exception e) {\n            throw new BlogunityException(I18NStatusFactory.create(I18N.ERRORS.FEED_ZIP_FAILED, e));\n        }\n    }\n", "code2": "    protected void convertInternal(InputStream inputStream, DocumentFormat inputFormat, OutputStream outputStream, DocumentFormat outputFormat) {\n        File inputFile = null;\n        File outputFile = null;\n        try {\n            inputFile = File.createTempFile(\"document\", \".\" + inputFormat.getFileExtension());\n            OutputStream inputFileStream = null;\n            try {\n                inputFileStream = new FileOutputStream(inputFile);\n                IOUtils.copy(inputStream, inputFileStream);\n            } finally {\n                IOUtils.closeQuietly(inputFileStream);\n            }\n            outputFile = File.createTempFile(\"document\", \".\" + outputFormat.getFileExtension());\n            convert(inputFile, inputFormat, outputFile, outputFormat);\n            InputStream outputFileStream = null;\n            try {\n                outputFileStream = new FileInputStream(outputFile);\n                IOUtils.copy(outputFileStream, outputStream);\n            } finally {\n                IOUtils.closeQuietly(outputFileStream);\n            }\n        } catch (IOException ioException) {\n            throw new OpenOfficeException(\"conversion failed\", ioException);\n        } finally {\n            if (inputFile != null) {\n                inputFile.delete();\n            }\n            if (outputFile != null) {\n                outputFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"tempFile": ["zipFile", "poraryDir", "tempFiles", "tempPath", " temporaryFile", "validPath", "TempFile", "tempSourceFile", " tempPath", "TempFunction", "zipSourceFile", " temporaryFunction", "porarySourceFile", "temFiles", " temporaryfile", "validDir", "zipDir", "TempSourceFile", "temFunction", "tempFunction", " tempDir", "zipFiles", "tempfile", "poraryfile", "TempFiles", "tmpfile", "TempPlace", "tmpFile", "tmpPlace", " tempFILE", "Tempfile", "tempDir", "zipfile", "zipPlace", "zipPath", "temfile", "poraryFile", "tempFILE", "tmpFiles", " temporaryFiles", "validFile", "validFILE", "TempDir", "tempPlace", "temFile", "zipFILE"], "zippedFile": ["zipFile", "ziedFILE", "zippingFolder", " zippedFiles", "zonedFile", "zippingFile", "zipippingFolder", "zyippedFile", "zipippedFile", "zedfile", "zyippedDir", "zipippedfile", "zippingfile", " zippedPlace", "zipippingfile", "zipedFile", "zixedDir", " zippedfile", "zppedFile", "zedFile", "zipippingFile", "zixedFile", "zipedFolder", "zipedSourceFile", "zippingPlace", "zipippingSourceFile", " zippingfile", "zyippedPage", "zipFiles", " zippingFile", "zippedDir", "zipedfile", "zedFiles", "ziedDir", "zippedfile", "zyippedFILE", "ziedPage", "zedPlace", "zppedPage", "zyixedFile", " zippingFiles", "zipfile", "zipPlace", "zippedFiles", "zixedFILE", "zippedFILE", "zipippedFolder", "ziedFile", "zonedfile", "zppedDir", "zyixedDir", "zyixedFILE", "zppedFILE", "zonedSourceFile", "zipippedSourceFile", "zippingFiles", "zonedFolder", "zippedFolder", "zixedPage", "zyixedPage", "zippedSourceFile", " zippingPlace", "zippedPage", "zippingSourceFile", "zippedPlace"], "zos": ["opens", "los", "nz", "bes", "kos", "zes", "ZI", "ZA", "oses", "zon", "packs", "zik", "zl", "zy", "ros", "ozo", "bos", "loop", "drops", "lins", "zip", "zi", "obb", "dos", "os", "zar", "rez", "zo", "webkit", "lol", "enos", "zin", "iframe", "iffs", "obos", "zb", "jas", "inos", "ls", "fits", "hops", "zag", "ios", "hess", "zers", "chini", "ses", "cos", "bis", "obs", "osi", "videos", "z", "zan"], "readBuffer": ["playbuffer", "playBase", "ReadPosition", "ReadBuffer", "loadBuffer", "readLength", " readPosition", "loadBuff", "readInfo", " readBuff", " readBase", "readBase", " readLimit", "writeLength", "writeBuff", "loadBase", "writePosition", "readPosition", "readBuff", "writeInfo", "ReadBuff", "writeBuffer", "playBuffer", "readLimit", "loadbuffer", " readbuffer", "inputLimit", "playBuff", "inputBuff", "writeLimit", "inputBuffer", "readbuffer", " readLength", "ReadLength", "inputInfo", " readInfo"], "bytesIn": ["ipsIN", "daysIns", "readsin", "daysIn", "readsIn", "bytesIns", "ipsIns", "filesIn", " bytesIns", "ipsIn", "bytesIN", "readsIN", "ipsin", "daysIN", "readsIns", "filesIns", " bytesIN", "BytesIn", "BytesIns", "filesin", "Bytesin", "bytesin", "filesIN", " bytesin", "daysin"], "fis": ["ifiss", "Ficks", "fileiss", "ofiss", "fileicks", " fIs", "fileis", "Fiss", "ifais", "fiss", "fais", "ofIs", "fIs", "Fires", "Fis", "ficks", "fileais", "ofis", " ficks", "ifis", "FIs", " fais", "fires", "ifIs", "ofires", " fiss", "ifires", "Fais"], "anEntry": ["anInfo", "ANEntry", "annLine", "anentry", "ANentry", "AnEntry", "annFile", "anLine", "hanEntry", "annEntry", "anFile", "anObj", "ANObj", "AnInfo", "ANFile", "annentry", " anInfo", " anLine", "hanFile", "hanentry", "hanObj", "annInfo", " anentry", "annObj", "Anentry", "AnLine"]}}
{"id1": "12340187", "id2": "1760352", "code1": "    private static boolean downloadFile(URL remote, File local) throws IllegalArgumentException, IOException {\n        if (local == null) throw new IllegalArgumentException(\"Must specify remote file\");\n        if (local.exists() && !local.canWrite()) throw new IOException(\"Cannot write to \" + local);\n        long lengthCurrent = local.exists() ? local.length() : -1l;\n        if (lengthCurrent == 0) throw new IOException(\"Cannot get the length for \" + local);\n        long lastModifiedCurrent = local.exists() ? local.lastModified() : -1l;\n        if (remote == null) throw new IllegalArgumentException(\"Must specify remote url\");\n        URLConnection urlConnection = remote.openConnection();\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(false);\n        long lengthRemote = urlConnection.getContentLength();\n        long lastModifiedRemote = urlConnection.getLastModified();\n        if (lengthRemote == lengthCurrent) {\n            LOGGER.fine(\"Not downloading \" + remote + \" of length \" + lengthRemote + \" and date \" + (lastModifiedRemote > 0 ? new Date(lastModifiedRemote).toString() : \"n/a\") + \" for \" + local + \" of length \" + lengthCurrent + \" and date \" + new Date(lastModifiedCurrent));\n            return false;\n        }\n        BufferedInputStream inputStream = null;\n        BufferedOutputStream bufferedOutputStream = null;\n        try {\n            inputStream = new BufferedInputStream(urlConnection.getInputStream(), BUFFER_SIZE);\n            bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(local));\n            byte[] buffer = new byte[BUFFER_SIZE];\n            do {\n                int count = inputStream.read(buffer);\n                if (count < 0) break;\n                bufferedOutputStream.write(buffer, 0, count);\n            } while (true);\n            return true;\n        } finally {\n            try {\n                if (inputStream != null) inputStream.close();\n            } catch (Throwable throwable) {\n            }\n            try {\n                if (bufferedOutputStream != null) bufferedOutputStream.close();\n            } catch (Throwable throwable) {\n            }\n        }\n    }\n", "code2": "    public static int deleteContract(String likePatten) {\n        Connection conn = null;\n        PreparedStatement psmt = null;\n        StringBuffer SQL = new StringBuffer(200);\n        int deleted = 0;\n        SQL.append(\" DELETE FROM JHF_ALIVE_CONTRACT \").append(\" WHERE   ORDER_ID LIKE  ? \");\n        try {\n            conn = JdbcConnectionPool.mainConnection();\n            conn.setAutoCommit(false);\n            conn.setReadOnly(false);\n            psmt = conn.prepareStatement(SQL.toString());\n            psmt.setString(1, \"%\" + likePatten + \"%\");\n            deleted = psmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            if (null != conn) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    System.out.println(\" error when roll back !\");\n                }\n            }\n        } finally {\n            try {\n                if (null != psmt) {\n                    psmt.close();\n                    psmt = null;\n                }\n                if (null != conn) {\n                    conn.close();\n                    conn = null;\n                }\n            } catch (SQLException e) {\n                System.out.println(\" error  when psmt close or conn close .\");\n            }\n        }\n        return deleted;\n    }\n", "label": 0, "substitutes": {"remote": ["source", "host", "parent", "route", " Remote", "active", "url", "queue", "foreign", "connection", "reference", "download", "office", "plugin", "range", "network", "Local", "wire", "core", "output", "message", "io", "Remote", "one", "http", "client", "union", "custom", "request", "root", "gate", "home", "base", "loc", "directory", "region", "version", "re", "multiple", "resource", " remotely", "server", "prefix", "external", "feature", "update", "managed", "transfer", "large", "other", "target", "instance", "timeout", "localhost", "global", "media", "image", "point", "secure", "live", "file", "uri", "attribute", "current", "proxy", "store", "port", "broad", "location"], "local": ["translation", "foreign", "l", "home", "model", "directory", "storage", "resource", "shared", "relative", "other", "old", "log", "temp", "missing", "back", "secure", "file", "ssl", "location", "lang", "real", "one", "object", "part", "auto", "child", "length", "instance", "same", "cache", "present", "reported", "self", "source", "parent", "url", "queue", "link", "util", "http", "client", "custom", "loc", "base", "stream", "serial", "available", "server", "raw", "external", "el", "managed", "universal", "full", "partial", "localhost", "global", "valid", "null", "journal", "host", "upload", "Local", "Remote", "original", "state", "single", "inner", "json", "session", "internal", "lock", "current", "standard"], "lengthCurrent": ["LengthLocal", "widthcurrent", " lengthLocal", "lenLocal", "lengthCurrently", "lengthClient", "LengthAny", "LengthRemote", "countRecent", "durationCurrent", "lenCurrent", " lengthClient", "LengthURRENT", "lengthURRENT", "widthCurrent", "levelURRENT", " lengthCurrently", " lengthRecent", "levelRemote", "lengthRecent", "levelCurrent", "countCurrently", "lenRemote", "LengthCurrently", " lengthAny", "durationAny", "lengthLocal", "widthCurrently", "LengthCurrent", "countcurrent", "countCurrent", "lenRecent", "durationLocal", "lengthAny", "Lengthcurrent", "LengthRecent", "LengthClient", "widthRecent", "levelClient", " lengthURRENT", "lengthcurrent", "durationCurrently"], "lastModifiedCurrent": ["lastModifyNow", "lastMinificationRemote", "lastModificationRemote", "lastModifiedNow", "lastModificationLatest", "lastMinificationNow", "lastModiedNow", "lastMinifiedLocal", "lastModifyCurrent", "lastModificationCurrent", "lastMinificationCurrently", "lastModifiedLocal", "lastMinIFIEDLatest", "lastModIFIEDCurrent", "lastMinifiedNow", "lastModifiedLatest", "lastModIFIEDLocal", "lastModIFIEDLatest", "lastMinifiedCurrent", "lastMinificationCurrent", "lastMinIFIEDRemote", "lastModifiedCurrently", "lastMinIFIEDCurrent", "lastModifyRemote", "lastMinifiedLatest", "lastModificationCurrently", "lastMinIFIEDLocal", "lastModifyCurrently", "lastMinifiedCurrently", "lastModIFIEDRemote", "lastModificationLocal", "lastModificationNow", "lastModifyLocal", "lastModiedRemote", "lastMinifiedRemote", "lastModiedCurrent", "lastModifyLatest", "lastModiedCurrently"], "urlConnection": ["resourceConnect", "UrlRemote", "fileClient", "urlSession", "UrlClient", "webClient", "urlChannel", "fileConnector", "resourceClient", "URLChannel", "httpConnect", "remoteClient", "httpConnection", "urlConnect", "urlRemote", "fileConnect", "fileConnection", " urlClient", "URLConnection", "glConnect", " urlSession", "URLClient", "glConnection", "httpClient", "httpChannel", "urlconnection", "fileconnection", "remoteConnection", "webConnection", " urlRemote", "glSession", "sslConnection", "urlConnector", "urlClient", "uriConnection", "resourceConnection", "urlConn", "sslConnector", "fileConn", "UrlSession", "URLconnection", "UrlConnect", "remoteChannel", " urlConnect", "resourceconnection", "UrlConnection", " urlconnection", "glRemote", "uriConnect", "webConnect", "sslConnect", "webconnection", "URLSession", "remoteConnect", "uriConnector", "URLConnect", "sslConn", "uriConn"], "lengthRemote": ["lengthGlobal", "LengthLocal", "LengthServer", " lengthLocal", "lenServer", "LengthRemote", "durationActive", "durationCurrent", "LengthExternal", "numberremote", "lenActive", "lengthExternal", "lengthServer", "LengthGlobal", "numberExternal", "durationGlobal", "durationRemote", "lenRemote", "lengthLocal", " lengthActive", "lengthremote", "LengthCurrent", "Lengthremote", "durationLocal", " lengthremote", "lenGlobal", "lengthActive", "numberGlobal", " lengthExternal", " lengthServer", "numberRemote", " lengthGlobal", "durationServer"], "lastModifiedRemote": ["lastModifierServer", "lastModificationRemote", "lastMODificationServer", "lastModificationClient", "lastModifierLocal", "lastMODificationRemote", "lastModedLocal", "lastModIFIEDGlobal", "lastModedCurrent", "lastMODificationCurrent", "lastModifyClient", "lastModifiedServer", "lastModifyCurrent", "lastModificationCurrent", "lastModifiedLocal", "lastMODificationLocal", "lastModifiedGlobal", "lastModizedRemote", "lastModIFIEDCurrent", "lastModIFIEDLocal", "lastModifiedClient", "lastModificationServer", "lastMODificationGlobal", "lastModifyGlobal", "lastModifyRemote", "lastModificationGlobal", "lastMODifiedServer", "lastMODifiedGlobal", "lastMODificationClient", "lastMODifiedClient", "lastModizedClient", "lastMODifiedCurrent", "lastModizedCurrent", "lastModedRemote", "lastModificationLocal", "lastModifyLocal", "lastModifierRemote", "lastMODifiedRemote", "lastModedServer", "lastModIFIEDRemote", "lastMODifiedLocal", "lastModifierCurrent", "lastModizedGlobal"], "inputStream": [" inputReader", "outputSteam", "innerPath", "outputStream", " inputChannel", "inputSteam", "inputPath", "innerStream", "httpStream", "inputCh", "imageStream", "InputCh", "httpSteam", "innerSt", "inputstream", " inputView", "InputStream", "inputSt", " inputSteam", "imageSteam", "InputPath", " inputPath", "inputStreamer", " inputMode", "httpstream", "outputCh", "inputReader", "InputView", "inputView", "outputstream", "httpStreamer", "inputChannel", "InputChannel", "imageChannel", " inputStreamer", "innerSteam", "Inputstream", "InputStreamer", "controlSt", "controlStream", "controlSteam", "outputView", " inputCh", "InputSteam", "innerReader", "InputReader", " inputSt", "imageStreamer", "inputMode", "controlMode", "outputStreamer", "innerMode"], "bufferedOutputStream": ["bufferedInputChannel", "bufferedEdgeStream", "bufferedOutputstream", "bufferedInputPath", "bufferedMemoryChannel", "bufferingOutputstream", "bufferedContentChannel", "bufferedoutputView", "bufferingInputSteam", "bufferedSoftwareStream", "bufferedOutputChannel", "bufferedMemoryStream", "bufferedApplicationSteam", "bufferedSoftwarestream", "bufferingInputstream", "bufferingInputView", "bufferedOutputSteam", "bufferedInputSteam", "bufferingInputStream", "bufferingOutputStream", "bufferingInputWriter", "bufferingInputHalf", "bufferedMemorySteam", "bufferedInputView", "bufferedWritingPath", "bufferingOutputWriter", "bufferedEdgeWriter", "bufferedContentStream", "bufferingOutputChannel", "bufferedContentstream", "bufferingInputFile", "bufferingOutputHalf", "bufferingOutputView", "bufferedoutputstream", "bufferedOutputWriter", "bufferedoutputFile", "bufferingInputChannel", "bufferingOutputFile", "bufferedInputFile", "bufferedWritingStream", "bufferedOutputHalf", "bufferedWritingSteam", "bufferedApplicationHalf", "bufferedoutputPath", "bufferingOutputPath", "bufferedInputWriter", "bufferedoutputHalf", "bufferedSoftwareView", "bufferedInputstream", "bufferingInputPath", "bufferedSoftwareSteam", "bufferedoutputStream", "bufferedWritingstream", "bufferedOutputPath", "bufferedContentSteam", "bufferedInputStream", "bufferedOutputView", "bufferedEdgeSteam", "bufferedoutputWriter", "bufferedMemorystream", "bufferedApplicationFile", "bufferedInputHalf", "bufferedOutputFile", "bufferedoutputSteam", "bufferingOutputSteam", "bufferedApplicationStream"], "buffer": ["read", "default", "queue", "memory", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "message", "output", "layer", "number", "data", "base", "resource", "address", "pad", "uffer", "sequence", "shape", "transfer", "padding", "event", "batch", "null", "bb", "length", "flush", "wave", "FFER", "buf", "offset", "slice", "document", "border", "cache", "character", "header", "block", "texture", "total", "position"], "count": ["parent", "size", "id", "default", "queue", "handle", "len", "ind", "core", "weight", "b", "val", "char", "age", "part", "base", "number", "data", "n", "sum", "child", "Count", "depth", "flow", "allow", "length", "keep", "max", "a", "content", "area", "key", "index", "string", "pool", "list", "load", "c", "file", "cache", "code", "i", "process", "start", "amount", "group", "s", "coll", "type"]}}
{"id1": "22075658", "id2": "19476935", "code1": "    public static InputStream getResponse(String pURL, String pUserName, String pPassword, OutputStream pResponseOutputStream, String pHttpMethodType) throws Exception {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        URL url = new URL(pURL);\n        int port = url.getPort();\n        if (-1 == port) {\n            port = url.getDefaultPort();\n        }\n        if (url.getProtocol().equals(HTTPS_PROTOCOL)) {\n            Protocol httpsProtocol = new Protocol(HTTPS_PROTOCOL, new EasySSLProtocolSocketFactory(), port);\n            Protocol.registerProtocol(HTTPS_PROTOCOL, httpsProtocol);\n        }\n        HttpClient httpClient = new HttpClient();\n        httpClient.getParams().setParameter(\"http.socket.timeout\", HTTP_SOCKET_TIMEOUT);\n        HttpMethod httpMethod = getHttpMethod(pHttpMethodType, pURL);\n        if (null != pUserName && null != pPassword) {\n            httpClient.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(pUserName, pPassword));\n        }\n        try {\n            httpClient.executeMethod(httpMethod);\n            if (null != pResponseOutputStream) {\n                IOUtils.copy(httpMethod.getResponseBodyAsStream(), pResponseOutputStream);\n            }\n            return httpMethod.getResponseBodyAsStream();\n        } catch (Exception e) {\n            throw (e);\n        } finally {\n            httpMethod.releaseConnection();\n        }\n    }\n", "code2": "    public static void copyResource(String src, File dest) throws IOException {\n        InputStream fin = ResourceLoader.openResource(src);\n        if (fin == null) {\n            LogFactory.getLog(ResourceLoader.class).error(\"Failed to load resource '\" + src + \"'\");\n            LogFactory.getLog(ResourceLoader.class).info(\"Attempting to open file from from file system\");\n            fin = new FileInputStream(src);\n        }\n        if (fin == null) {\n            LogFactory.getLog(ResourceLoader.class).warn(\"Giving up on copy operation, can't find source '\" + src + \"'\");\n            return;\n        }\n        BufferedOutputStream fout = new BufferedOutputStream(new FileOutputStream(dest));\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n        int readBytes = fin.read(buffer);\n        while (readBytes > -1) {\n            fout.write(buffer, 0, readBytes);\n            readBytes = fin.read(buffer);\n        }\n        fout.close();\n        fin.close();\n    }\n", "label": 1, "substitutes": {"pURL": [" pUrl", "pcURL", "paUrl", " pIP", "pIP", "nURL", "pStream", "paURI", "nUrl", "nURI", " pLocation", "pcURI", "PIP", "pcUrl", "PURL", "pLocation", "PURI", "nLocation", "paURL", "pcStream", "PUrl", "PStream", "paIP", "PLocation", "pUrl", " pURI", " pStream", "pURI"], "pUserName": ["pDeviceInfo", " pUserInfo", "pLoginName", " pFullInfo", "pUserInfo", "pTeamAddress", "pDeviceAddress", "pFullAddress", "pLoginKey", "pLongHalf", "eUSERNumber", "primaryUserCry", "pTeamNAME", "pUsername", "eUSERName", "primaryUserName", "primaryUSERCry", "pUSERKey", "pUSERCry", "eUserNumber", "pUserKey", "eUSERname", "pTeamName", "primaryUSERKey", "pFullName", "pFullInfo", " pUserAddress", "primaryUserKey", "pUserCry", "pApplicationname", "pUserNumber", "pUserAddress", "pStringName", "pFullNAME", "pLoginHalf", " pUserNAME", "pUserNAME", "pTeamInfo", "pUSERName", "eUsername", "pLongName", "pUSERNumber", "pDeviceName", "pUSERname", "primaryUSERHalf", "pDeviceNAME", "pStringNumber", "primaryUSERName", " pFullAddress", "pApplicationName", "pApplicationNumber", "pUSERHalf", "primaryUserHalf", " pFullName", " pFullNAME", "pLongKey", "pUserHalf", "eUserName", "pLoginCry", "pStringname", "pLongCry"], "pPassword": ["PLogin", "Ppassword", "pEmail", "paPass", "sLogin", "ppassword", "pPass", "PPass", "PEmail", "sPassword", "paSecret", "PPassword", "paPASS", "pPASS", " pPass", "PSecret", "spassword", " pLogin", "sPass", "pLogin", " pSecret", "tpEmail", " ppassword", "paPassword", "pSecret", "tpPass", " pPASS", "PPASS", "tpSecret", " pEmail", "tpPassword"], "pResponseOutputStream": ["pResponseInputView", "pResponseWriteForm", "pResponseInputstream", "pResponseApplicationstream", "pResponseBodystream", "pResponseBodyStream", "pResponseWriteView", "pResponseInputForm", "pRequestInputSteam", "pResponseOutputForm", "pResponseApplicationStream", "pResponseInputSteam", "pRequestInputView", "pResponseOutputSteam", "pRequestOutputSteam", "pRequestInputstream", "pRequestOutputstream", "pRequestOutputView", "pRequestInputStream", "pResponseWriteStream", "pResponseInputStream", "pRequestBodySteam", "pResponseApplicationView", "pRequestInputForm", "pResponseOutputstream", "pResponseOutputView", "pRequestOutputForm", "pRequestOutputStream", "pResponseApplicationSteam", "pRequestBodyStream", "pResponseApplicationForm", "pRequestBodystream", "pResponseBodySteam", "pResponseWriteSteam"], "pHttpMethodType": ["pHttpMType", "pHttpOperationClass", "pHttpMethodID", "pHTTPMethodType", "pHttpOperationId", "pHTTPMID", "pHttpContextClass", "phttpMethodName", "pHttpMClass", "pHttpOperationType", "pHTTPMName", "phttpOperationId", "pHttpMETHODId", "pHttpMethodName", "pHttpOperationID", "phttpOperationName", "pHttpContextName", "phttpMethodId", "pHTTPMethodID", "pHttpContextType", "pHttpMETHODtype", "pHTTPMethodClass", "pHttpMETHODType", "pHttpMID", "phttpOperationtype", "phttpMethodType", "pHttpMethodtype", "phttpMethodtype", "pHTTPMType", "pHTTPMClass", "phttpOperationType", "pHttpMName", "pHttpMtype", "pHttpMETHODName", "pHttpMId", "pHttpOperationName", "pHTTPMethodName", "pHttpContextID", "pHttpMethodClass", "pHttpOperationtype", "pHttpMethodId"], "bis": ["sb", "abi", " inf", "ais", "Im", " ins", "b", " io", "os", "bs", "oss", "ins", "bb", "IS", "abs", " ris", "ri", "ios", " In", "IN", " os", "us", "ses", "is", " cis", " bi", " inter"], "bos": ["binary", " oy", " bo", "oth", "OS", "bi", "os", "bs", "outs", "ocr", "zo", "oS", "bye", "ob", "aos", "ooo", "oe", "obe", "xb", "eb", " bio", " bom", "flo", "wb", "ses", " Bos", "soc", " bi"], "url": ["source", "host", "page", "SSL", "browser", "connection", "feed", "l", "http", "client", "base", "loc", "https", "resource", "org", "server", "address", "config", "el", " URL", "name", "method", "ur", "event", "gl", "ob", "log", "api", "bel", "fl", "location", "string", "path", "image", "rl", "socket", "file", "ssl", "uri", "fail", "URL", "Url", "www", "web", "line", "coll", "sl"], "port": ["host", "parent", "num", "PORT", "connection", "phone", "limit", "format", "client", "state", "part", "channel", "number", "version", "stream", "resource", "server", "address", "Port", "ports", "name", "method", "project", "target", "patch", "allow", "ort", "length", "api", "password", "timeout", "key", "sort", "index", "string", "count", "point", "pool", "slice", "path", "file", "uri", "width", "service", "pi", "position", "proxy", "test", "ip", "p", "type"], "httpsProtocol": ["sslProocol", "httpsprotport", "sslProtport", "httpProocol", "httpsProotype", "httpsPoport", "httpsProport", "httpProection", "httpsPrototype", "httpsProocol", "httpsprototype", "sslProistry", "httpsPoo", "httpProo", "httpsprotistry", "httpsProtport", "httpsProtistry", "httpProtocol", "httpsProistry", "sslProtocol", "httpsPoistry", "httpsprotection", "httpsProection", "httpProtection", "httpsPoection", "httpsproto", "sslProport", "httpProto", "httpsProo", "httpsProtection", "httpPrototype", "httpsPootype", "httpsProto", "httpsprotocol", "sslProtistry", "httpsPoocol", "httpProotype"], "httpClient": ["HTTPClient", "phpMethod", "phpClient", "httpConnection", " httpConnection", "httpsConnection", "httpsServer", "HTTPAPI", " httpCase", " httpCode", " httpAPI", "httpsContext", "httpsContainer", " httpContext", "httpServer", "HttpConnection", "httpCase", "httpContainer", "httpCode", "httpContext", " httpContainer", "phpServer", "HTTPServer", "httpsAPI", "httpsClient", "phpCase", "HttpClient", "httpsMethod", "httpsCode", " httpServer", "HttpCode", "HTTPContext", "phpContainer", "HttpServer", "httpAPI", "httpsCase"], "httpMethod": ["infoMethod", "infomethod", "webClient", "HttpOperation", "webBlock", " httpOperation", " httpUnit", "httpsBlock", "httpsmethod", "phpMethod", "phpClient", "phpClass", "HttpFunction", "HttpClass", "httpOperation", " httpBlock", " httpmethod", " httpFunction", "httpsOperation", "httpUnit", "httpServer", "httpmethod", "httpsUnit", "Httpmethod", "phpServer", "webMethod", "httpsClient", "HttpClient", "httpsMethod", "httpFunction", "httpClass", " httpServer", "HttpMethod", "phpOperation", "infoClient", "infoFunction", "webUnit", " httpClass", "httpBlock", "HttpServer", "phpBlock"]}}
{"id1": "14113380", "id2": "1274215", "code1": "    @SuppressWarnings(\"unchecked\")\n    public void execute() throws MojoExecutionException {\n        List<Dependency> dependencies = project.getDependencies();\n        File file = new File(this.localRepository.getBasedir());\n        File dojoArtifact = null;\n        for (Dependency dependency : dependencies) {\n            if (!dependency.getGroupId().equals(\"org.dojotoolkit\") && !dependency.getArtifactId().equals(\"dojo\")) continue;\n            File file2 = new File(file, dependency.getGroupId().replace('.', File.separatorChar));\n            file2 = new File(file2, dependency.getArtifactId());\n            file2 = new File(file2, dependency.getVersion());\n            file2 = new File(file2, dependency.getArtifactId() + '-' + dependency.getVersion() + '.' + dependency.getType());\n            if (!file2.exists()) throw new MojoExecutionException(\"No artifact found in base repository \" + file2);\n            dojoArtifact = file2;\n        }\n        if (dojoArtifact == null) throw new MojoExecutionException(\"No dojo dependencies found\");\n        Plugin plugin = (Plugin) project.getBuild().getPluginsAsMap().get(\"org.apache.maven.plugins:maven-war-plugin\");\n        if (plugin == null) return;\n        String webappDirectory = null;\n        Xpp3Dom dom = (Xpp3Dom) plugin.getConfiguration();\n        if (dom != null) webappDirectory = dom.getChild(\"webappDirectory\").getValue();\n        if (webappDirectory == null) webappDirectory = project.getBuild().getDirectory() + File.separatorChar + project.getArtifactId() + '-' + project.getVersion();\n        try {\n            File webAppDojoDir = new File(webappDirectory, this.dojoDir);\n            if (!webAppDojoDir.exists()) webAppDojoDir.mkdirs();\n            ZipInputStream inputStream = new ZipInputStream(new FileInputStream(dojoArtifact));\n            ZipEntry zipentry = inputStream.getNextEntry();\n            byte[] buf = new byte[1024];\n            while (zipentry != null) {\n                File entry = new File(webAppDojoDir, zipentry.getName());\n                if (zipentry.isDirectory()) {\n                    entry.mkdirs();\n                } else {\n                    int n;\n                    FileOutputStream fileoutputstream;\n                    if (entry.getParent() != null) {\n                        entry.getParentFile().mkdirs();\n                    }\n                    fileoutputstream = new FileOutputStream(entry);\n                    while ((n = inputStream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                    fileoutputstream.close();\n                    inputStream.closeEntry();\n                }\n                zipentry = inputStream.getNextEntry();\n            }\n            inputStream.close();\n        } catch (Exception e) {\n            throw new MojoExecutionException(\"Error to extract the dojo artifact \", e);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            if (args.length < 2) {\n                System.err.println(\"usage: test [src] [dest]\");\n                return;\n            }\n            FileInputStream in = new FileInputStream(args[0]);\n            FileOutputStream out = new FileOutputStream(args[1]);\n            FileChannel src = in.getChannel();\n            FileChannel channel = out.getChannel();\n            long pos = 0, len = src.size(), ret;\n            while (len > 0) {\n                if ((ret = channel.transferFrom(src, pos, len)) < 0) break;\n                len -= ret;\n                pos += ret;\n            }\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"dependencies": ["dependancies", "instences", "depency", "activirements", "ependency", "requancies", "activences", "depancies", "ependants", "depencies", "ependirements", "instancies", "dependirements", "depirements", "instencies", "instency", "ependancies", "activencies", "depants", "requants", "dependences", "dependants", "requencies", "ependencies", "requences", "depences", "activency", "ependences"], "file": ["source", "get", "parent", "ile", "url", "pe", "feed", "xml", "function", "File", "output", "l", "http", "out", "fp", "object", "this", "model", "f", "base", "data", "directory", "future", "include", "zip", "resource", "work", "call", "module", "filename", "name", "dir", "full", "log", "il", "path", "load", "parse", "files", "local", "FILE", "use"], "dojoArtifact": ["dojaArribution", "dojoArticleifact", "dojoartifact", "dojoArtifest", "dojaArtjo", "dojoGraifacts", "dojoArifacts", "dojaArolution", "dojoArticleribution", "dojoArgifacts", "dojoAristance", "dojaAristance", "dojaArifacts", "dojaArifact", "dojoGrajo", "dojoArtistance", "dojaArifest", "dojoArtository", "dojaArtolution", "dojoartifacts", "dojoAttifact", "dojoArticleifacts", "dojoArticleistance", "dojaArtistance", "dojoExifacts", "dojoArtolution", "dojoArjo", "dojaArtifest", "dojoArgifact", "dojoArifest", "dojoExjo", "dojaArtribution", "dojaArtifact", "dojoArtjo", "dojaArtository", "dojoArolution", "dojoArifact", "dojaArjo", "dojoArtifacts", "dojoAttifacts", "dojoAttository", "dojoartistance", "dojoGraolution", "dojoExifact", "dojoartribution", "dojoGraifact", "dojoArgifest", "dojaArository", "dojoArgository", "dojoArribution", "dojoArository", "dojoExolution", "dojoArtribution", "dojoAttifest", "dojaArtifacts"], "dependency": ["ependetry", "ependivity", "ependension", "uploadencies", "depence", "variension", "depependence", "depolution", "ependance", "pendivity", "dependension", "dependant", " recipency", "dependentency", "participiation", "ependence", "pendension", "dependance", "dependity", "dependependence", "codency", "ependency", "codetry", "variency", "participension", " recipension", "depiation", "requant", "ependant", "ependolution", "ependity", "dependiation", "uploadency", "depency", "participency", "pendency", "requension", "depivity", "pendant", "depencies", "variment", "dependence", "dependivity", "dependentity", "depity", "uploadetry", "equension", " recipant", "dependetry", "variencies", "requity", "equicer", "participant", "codence", "dependolution", "ependment", "ependependence", "equency", "dependentension", "ependiation", "dependment", "equment", " recipance", "codencies", "variicer", "dependentolution", "dependicer", "requance", "depant", "depension", "uploadependence", "ependencies", "ependicer", "depetry", "varietry", "requency"], "file2": ["filesTwo", "file0", "f0", " file1", "function1", "feed1", "ftwo", "File3", "Filesecond", "f5", "files4", "ile1", "function4", " fileCopy", "ile5", " file5", "feedsecond", "filetwo", "files1", "feed2", "file20", "feed5", "file200", "ileCopy", "files2", "File2", "fileTwo", "file62", "f3", " file20", " file3", "File20", "fileL", "ile62", "letterL", "image62", "f1", "f2", "letter2", "File4", "filesecond", " file200", "fileCopy", "file4", "place2", "ile2", "ileL", "file3", " fileTwo", "ile4", "FileTwo", " file0", "place4", "ileTwo", "iletwo", "File0", "letter200", "imagetwo", "file1", "ile20", "ile3", " filesecond", " file4", "f62", "functionsecond", " fileL", "image2", "image5", "file5", "letter1", "File5", "placeTwo", "place1", "ile200", "File1", "FileCopy", "function2"], "plugin": ["py", "binary", "plug", "product", "build", "band", "panel", "audio", "lib", "license", "jo", "this", "b", "in", "app", "bug", "model", "gen", "pack", "f", "pin", "zip", "org", "feature", "config", "module", "plugins", "Plugin", "bridge", "api", "parser", "job", "client", "pm", "agent", "install", "manager", "service", "type", "group", "bot", "android", "project", "filter", "p", "pod"], "webappDirectory": ["webappFolder", "WebAppDirectory", "webpageDirector", "WebAppRoot", "webappPath", "webAppDir", "webappsDir", "webAppLocation", "WebAppUrl", "webappsDirectory", "webAppPath", "webbaseDirectory", "webflowLocation", "WebAppFolder", "webappRoot", "webpageFolder", "WebAppPath", "WebAppLocation", "webappDirector", "webflowRoot", "WebappDirector", "WebappLocation", "webAppDirector", "webbaseUrl", "webappsLocation", "WebAppDirector", "webAppFolder", "webAppRoot", "WebappDir", "WebAppDir", "webAppUrl", "WebappFolder", "webpageDirectory", "webappsUrl", "webappDir", "WebappUrl", "webrootDirectory", "WebappRoot", "webrootLocation", "webbaseLocation", "webpageLocation", "webrootRoot", "webbaseFolder", "webflowDirectory", "webrootFolder", "WebappDirectory", "webflowFolder", "webappUrl", "webappsFolder", "webappLocation", "WebappPath", "webappsPath", "webflowPath", "webAppDirectory"], "dom": ["host", "Dom", "div", "om", "DOM", "compl", "cd", "d", "browser", "cm", "xml", "dict", "doc", "rss", "lib", "http", "bug", "ver", "data", "di", "nav", "config", "serv", "module", "conf", "facebook", "dm", "complex", "parser", "api", "ch", "dr", "rh", "dim", "com", "session", "node", "html", "cloud", "or", "valid", "hub", "img", "form", "bot", "domain", "project", "dem"], "webAppDojoDir": ["webAppLojDirectory", "webAppDojoDirectory", "webAppDojiDir", "webAppDojDir", "webAppDoelDir", "webAppDochoJar", "webAppDochoDir", "webAppDoelFile", "webAppDojStore", "webAppLojoDirectory", "webAppDojiDirectory", "webAppDojaDir", "webAppDoelUrl", "webAppDochoFile", "webAppDojiStore", "webAppDochoDirectory", "webAppDojaFile", "webAppLojJar", "webAppDojFile", "webAppLojDir", "webAppDojaUrl", "webAppDojiFile", "webAppDojoStore", "webAppLojFile", "webAppDojoFile", "webAppDojJar", "webAppLojoFile", "webAppLojoJar", "webAppDojoUrl", "webAppDojoJar", "webAppDoelDirectory", "webAppLojoDir", "webAppDojUrl", "webAppDojaStore", "webAppDojDirectory", "webAppDojaDirectory", "webAppDojaJar"]}}
{"id1": "20086435", "id2": "3023702", "code1": "    private InputStream createInputStream(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"classpath://\")) {\n            InputStream is = XMLResource.class.getResourceAsStream(url.substring(12));\n            if (is == null) throw new IOException(\"Couldn't open stream to [\" + url + \"]\");\n            return is;\n        } else {\n            return new URL(url).openStream();\n        }\n    }\n", "code2": "    static HashSet<ScriptEngineFactory> lookup(ClassLoader loader, String name) {\n        HashSet<ScriptEngineFactory> factories = new HashSet<ScriptEngineFactory>();\n        try {\n            Enumeration<URL> urls = loader.getResources(name);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if ((line = trim(line)) != null) {\n                        try {\n                            Class<ScriptEngineFactory> clazz = (Class<ScriptEngineFactory>) Class.forName(line, true, loader);\n                            ScriptEngineFactory factory = clazz.newInstance();\n                            factories.add(factory);\n                        } catch (java.lang.UnsupportedClassVersionError error) {\n                            if (DEBUG) {\n                                System.err.println(line + \": version mismatch - ignore\");\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (IOException ex) {\n            throw new ScriptException(ex);\n        } finally {\n            return factories;\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "route", "id", "input", "link", "user", "feed", "xml", "pull", "ll", "src", "l", "http", "in", "fr", "f", "base", "loc", "href", "data", "ref", "class", "zip", "resource", "server", "address", "el", "element", "name", "text", "location", "string", "path", "image", "rule", "rl", "secure", "html", "uri", "file", "i", "ssl", "URL", "service", "date", "Url", "www", "gl", "str", "coll", "sl", "type"], "is": ["get", "ils", "isa", "ws", "fs", "http", "ps", "out", "in", "app", "css", "ms", "as", "was", "iss", "os", "bs", "ens", "ris", "serv", "info", "x", "has", "js", "iv", "isi", "vs", "it", "ui", "ins", "iris", "IS", "api", "cs", "abs", "ls", "index", "il", "lis", "ios", "ori", "uri", "i", "or", "us", "bis", "Is", "ar", "iso", "web", "s", "ip", "does"]}}
{"id1": "15385608", "id2": "9356670", "code1": "    public boolean setFavBoard(List<BoardObject> list) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        HttpPost post = new HttpPost(HttpConfig.bbsURL() + HttpConfig.BBS_FAV_SETTING);\n        List<NameValuePair> nvps = new ArrayList<NameValuePair>();\n        for (BoardObject board : list) nvps.add(new BasicNameValuePair(board.getId(), \"on\"));\n        try {\n            post.setEntity(new UrlEncodedFormEntity(nvps, BBSBodyParseHelper.BBS_CHARSET));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isHttp200(response) && HTTPUtil.isXmlContentType(response)) {\n                HTTPUtil.consume(response.getEntity());\n                return true;\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    private FTPClient loginToSharedWorkspace() throws SocketException, IOException {\n        FTPClient ftp = new FTPClient();\n        ftp.connect(mSwarm.getHost(), mSharedWorkspacePort);\n        if (!ftp.login(SHARED_WORKSPACE_LOGIN_NAME, mWorkspacePassword)) {\n            throw new IOException(\"Unable to login to shared workspace.\");\n        }\n        ftp.setFileType(FTPClient.BINARY_FILE_TYPE);\n        return ftp;\n    }\n", "label": 0, "substitutes": {"list": ["dl", "lp", "parent", "land", "queue", "LIST", "range", "chain", "result", "view", "l", "pre", "que", "object", "part", "base", "table", "set", "config", "can", "sequence", "stack", "name", "batch", "cl", "lists", "listed", "all", "pool", "load", "live", "array", "gallery", "many", "test", "collection", "entry", "coll"], "client": ["host", "head", "url", "pe", "connection", "io", "pb", "conn", "http", "request", "app", "object", "end", "to", "resource", "handler", "server", "config", "force", "method", "per", "patch", "bird", "api", "Client", "cli", "session", "media", "pool", "connect", "cache", "c", "ssl", "i", "cloud", "service", "ip", "self", "et", "project", "copy", "p"], "post": ["next", "get", "head", "POST", "proc", "upload", "feed", "pod", "submit", "the", "open", "ost", "build", "one", "http", "pre", "request", "object", "f", "to", "put", "set", "zip", "server", "push", "posts", "wp", "send", "body", "project", "patch", "od", "Post", "pass", "load", "install", "posted", "valid", "create", "form", "add", "copy", "rest", "p"], "nvps": ["NVp", "nvPS", "vPS", "nvips", "nvp", "NVPS", "nvpps", "vps", "NVips", "nvsp", "nwps", "nncs", "NVps", "svp", "svpps", "NVpps", "svps", "nlPS", "nlps", "vp", "nwpps", "nlcs", "nwPS", "nnsp", "nnps", "svips", "svsp", "nvcs", "nlsp", "nnPS", "svcs", "vips", "svPS", "nwp"], "board": [" row", "land", " lobby", " corporation", "upload", "feed", "division", " dashboard", "game", " builder", " video", " obstacle", "card", "deck", "view", "object", "model", "row", " chunk", " poll", " card", "server", " image", "boards", " bar", "Board", "flow", " deck", " block", " box", " game", " opponent", "hole", " logo", " clip", "pool", "node", " cross", " controller", " player", " billboard", "boarding", "database", "builder", "video", "bot", "league", " tile"], "response": ["page", "successful", "respond", "site", "connection", "success", "feed", "reply", "ception", "result", "message", "output", "view", "http", "request", "object", "model", "channel", "application", "onse", "data", "f", "stream", "resource", "handler", "server", "body", "full", "o", "report", "json", "api", "former", "wave", "session", "status", "Response", "index", "document", "image", "error", "resp", "code", "received", "res", "collection"], "entity": ["page", "translation", "pe", "ent", "connection", "xml", "feed", "ception", "result", "ee", "output", "message", "article", "ity", "object", "model", "environment", "onse", "data", "tree", "resource", "server", "el", "activity", "component", "body", "e", "Entity", "content", "node", "image", "document", "uri", "error", "resp", "person", "service", "ce", "collection", "entry"], "msg": ["str", "id", "mid", "sg", "message", "doc", "ma", "gs", "cmd", "ms", "op", "gen", "loc", "exc", "agg", "data", "comm", "desc", "body", "ge", "e", "gm", "log", "text", "comment", "ko", "m", "content", "dr", "status", "string", "Msg", "html", "reg", "error", "err", "map", "g", "mess", "md", "reason", "s", "ug", "pkg", "type"]}}
{"id1": "6217412", "id2": "13351146", "code1": "    protected void EncodeRoute() throws EncodeFailedException, IOException {\n        File storefile = getNode().getCodec().PackStore(null, ReturnStore);\n        DownRoute.EncodeData(storefile);\n        File data = getNode().getCodec().PackRemoteDownload(this);\n        data = PigData.EncodeData(data);\n        FileOutputStream fos = new FileOutputStream(PiggybackRouteFile, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(data);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        UpRoute.EncodeData(PiggybackRouteFile);\n    }\n", "code2": "    public static void copy(final File src, File dst, final boolean overwrite) throws IOException, IllegalArgumentException {\n        if (!src.isFile() || !src.exists()) {\n            throw new IllegalArgumentException(\"Source file '\" + src.getAbsolutePath() + \"' not found!\");\n        }\n        if (dst.exists()) {\n            if (dst.isDirectory()) {\n                dst = new File(dst, src.getName());\n            } else if (dst.isFile()) {\n                if (!overwrite) {\n                    throw new IllegalArgumentException(\"Destination file '\" + dst.getAbsolutePath() + \"' already exists!\");\n                }\n            } else {\n                throw new IllegalArgumentException(\"Invalid destination object '\" + dst.getAbsolutePath() + \"'!\");\n            }\n        }\n        final File dstParent = dst.getParentFile();\n        if (!dstParent.exists()) {\n            if (!dstParent.mkdirs()) {\n                throw new IOException(\"Failed to create directory \" + dstParent.getAbsolutePath());\n            }\n        }\n        long fileSize = src.length();\n        if (fileSize > 20971520l) {\n            final FileInputStream in = new FileInputStream(src);\n            final FileOutputStream out = new FileOutputStream(dst);\n            try {\n                int doneCnt = -1;\n                final int bufSize = 32768;\n                final byte buf[] = new byte[bufSize];\n                while ((doneCnt = in.read(buf, 0, bufSize)) >= 0) {\n                    if (doneCnt == 0) {\n                        Thread.yield();\n                    } else {\n                        out.write(buf, 0, doneCnt);\n                    }\n                }\n                out.flush();\n            } finally {\n                try {\n                    in.close();\n                } catch (final IOException e) {\n                }\n                try {\n                    out.close();\n                } catch (final IOException e) {\n                }\n            }\n        } else {\n            final FileInputStream fis = new FileInputStream(src);\n            final FileOutputStream fos = new FileOutputStream(dst);\n            final FileChannel in = fis.getChannel(), out = fos.getChannel();\n            try {\n                long offs = 0, doneCnt = 0;\n                final long copyCnt = Math.min(65536, fileSize);\n                do {\n                    doneCnt = in.transferTo(offs, copyCnt, out);\n                    offs += doneCnt;\n                    fileSize -= doneCnt;\n                } while (fileSize > 0);\n            } finally {\n                try {\n                    in.close();\n                } catch (final IOException e) {\n                }\n                try {\n                    out.close();\n                } catch (final IOException e) {\n                }\n                try {\n                    fis.close();\n                } catch (final IOException e) {\n                }\n                try {\n                    fos.close();\n                } catch (final IOException e) {\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"storefile": ["Storepart", "StoreFile", "transferFile", "fileFile", "transferhttp", "storeaction", "fileaction", "transferaction", "storehttp", "storepart", "Storepage", " storehttp", "gatepart", "transferfile", "storepage", "gatefile", "Storefile", "gateFile", " storeaction", "filehttp", " storepart", " storepage", "filefile", "storeFile", " storeFile", "gatepage"], "data": ["next", "parent", "reader", "default", "input", "memory", "queue", "d", "feed", "download", "buffer", "result", "message", "output", "dump", "object", "part", "base", "loader", "ata", "bytes", "response", "zip", "resource", "raw", "address", "config", "body", "DATA", "results", "json", "content", "missing", "session", "done", "buf", "media", "image", "change", "cache", "load", "file", "error", "record", "map", "array", "current", "database", "block", "video", "empty", "store", "value", "dat", "p"], "fos": ["infOS", "eos", " fo", "dOS", " foes", "infoes", " fOS", "fo", "Fos", "Foc", "infos", "Fo", "dos", "info", "eoc", "FOS", "fOS", "eo", "eOS", "foes", "does"], "foc": [" foca", "eos", "Fic", " fisc", "tos", "foca", "Focl", "Fos", "Foc", "Focol", "toc", "infos", "focol", "eoc", "fisc", "infoc", " focol", "focl", "tocol", "tocl", "Foca", "eoca", "eocl", " focl", "Fisc", "infisc", "infic"], "fis": ["Fics", "bisc", "Fic", " fisc", "ofos", "Fos", "bos", "ofics", "fics", "Fis", "ofis", "fisc", "ofic", " fics", "bics", "bis", "Fisc"], "fic": ["cfci", "Fics", "Fic", "fci", "dfic", "cfoc", " fci", "Foc", "fico", "infics", "fice", "Fci", "fics", "Fice", "poc", "dfics", "Fico", "Fis", " fico", "infoc", "pic", "pics", "infis", "dfice", " fics", "dfoc", "cfic", "pico", " fice", "cfis", "infic"]}}
{"id1": "9221947", "id2": "1395368", "code1": "    private static boolean copyFile(String src, String dest) {\n        try {\n            File inputFile = new File(src);\n            File outputFile = new File(dest);\n            FileInputStream in = new FileInputStream(inputFile);\n            FileOutputStream out = new FileOutputStream(outputFile);\n            FileChannel inc = in.getChannel();\n            FileChannel outc = out.getChannel();\n            inc.transferTo(0, inc.size(), outc);\n            inc.close();\n            outc.close();\n            in.close();\n            out.close();\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    private File copyFile(File currFile) throws IOException {\n        String relativePath = currFile.getPath().substring(_distDir.length() + 1);\n        File targetFile = new File(_installDir, relativePath);\n        if (targetFile.exists()) {\n            log(targetFile.getPath() + \" already exists, skipping libcopy\", Project.MSG_INFO);\n            return targetFile;\n        } else {\n            if (!targetFile.getParentFile().exists()) {\n                if (!targetFile.getParentFile().mkdirs()) {\n                    log(\"Unable to create target dir tree for \" + targetFile.getPath(), Project.MSG_ERR);\n                    throw new IOException();\n                }\n            }\n        }\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(currFile);\n        } catch (FileNotFoundException e) {\n            log(\"Library from plugin manifest appears to have been deleted: \" + currFile.getPath(), Project.MSG_ERR);\n            throw new IOException();\n        }\n        try {\n            fos = new FileOutputStream(targetFile);\n        } catch (FileNotFoundException e) {\n            log(\"Unable to create target file to write to: \" + targetFile.getPath(), Project.MSG_ERR);\n            throw new IOException();\n        }\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        int read = 0;\n        byte[] buff = new byte[65536];\n        boolean success = true;\n        while (read != -1 && success) {\n            try {\n                read = bis.read(buff, 0, 65536);\n            } catch (IOException e) {\n                log(\"Read error whilst reading from: \" + currFile.getPath(), Project.MSG_ERR);\n                success = false;\n            }\n            if (read != -1 && success) {\n                try {\n                    bos.write(buff, 0, read);\n                } catch (IOException e) {\n                    log(\"Write error whilst writing to: \" + targetFile.getPath(), Project.MSG_ERR);\n                    success = false;\n                }\n            }\n        }\n        try {\n            bis.close();\n        } catch (IOException e) {\n        }\n        try {\n            bos.close();\n        } catch (IOException e) {\n        }\n        try {\n            fis.close();\n        } catch (IOException e) {\n        }\n        try {\n            fos.close();\n        } catch (IOException e) {\n        }\n        if (!success) {\n            throw new IOException();\n        }\n        return targetFile;\n    }\n", "label": 1, "substitutes": {"src": ["source", "head", "sel", "sb", "split", "url", "input", "txt", "upload", "download", "sit", "inf", "loc", "href", "stream", "remote", "resource", "sc", "archive", "config", "sub", "filename", "name", "rc", "inst", "ource", "sin", "string", "path", "image", "load", "uri", "file", "code", "dist", "img", "rb", "sl"], "dest": ["source", "folder", "route", "tmp", "later", "suff", "append", "result", "output", "flat", "join", "home", "end", " destination", "delete", "loc", "data", "thin", " Dest", "du", "sup", "filename", "desc", "dir", "target", "Dest", "temp", "done", "orig", "file", "replace", "comb", "wb", "opt", "dist", "destroy", "project", "test", "usr"], "inputFile": ["outputStream", "inputFolder", "inputfile", "outFile", "sourceFolder", " inputfile", " inputFolder", "outPage", "outputFolder", "sourcefile", "sourceFile", "outfile", "outputPage", "outFolder", " inputStream", "outStream", "inputPage", "sourcePage", "inputStream", "sourceStream"], "outputFile": ["outputStream", " outputfile", "inputfile", "outFile", "writeStream", "writefile", "outDir", "outDirectory", "externalDirectory", "configfile", " outputDir", "outputDirectory", "outfile", "externalfile", "inputPlace", "configFile", "configStream", "writeFile", "externalFile", "outputDir", " outputDirectory", "configPlace", "externalDir", "writePlace", "inputStream", "outputPlace", "outputfile"], "in": ["source", "plus", "reader", "id", "url", "input", "ince", "win", "pull", "min", "nin", "conn", "con", "inf", "this", "login", "include", "In", "pin", "again", "n", "enc", "config", "inner", "exec", "ir", "update", "init", "ins", "ini", "issue", "kin", "up", "index", "image", "cin", "lock", "socket", "i", "IN", "inside", "inn", "lin", "bin", "ic"], "out": ["parent", "default", "user", "net", "extra", "co", "io", "outer", "output", "conn", "lib", "app", "client", "ou", "n", "Out", "OUT", "outs", "again", "server", "call", "external", "writer", "inner", "off", "exec", "update", "init", "ins", "o", "other", "exp", "up", "point", "cache", "c", "file", "err", "at", "img", "self", "outside", "working", "bin", "inv", "option", "line", "p"], "inc": ["reader", "dc", "anc", "input", "ic", "ince", "iter", "inf", "include", "pin", "ec", "circ", "enc", "org", "irc", "config", "inner", "ir", "INC", "init", "ins", "rc", "inst", "ci", "keep", "ini", "lc", "issue", "rec", "up", "abc", "index", "Inc", "impl", "c", "inn", "asc", "nc", "cc", "inv", "acc", "imp", "ac"], "outc": ["outcon", "inp", "indc", " outci", " outC", "oudc", "ine", "incon", "oucon", "outci", " oute", "Outc", "outp", "oup", "Outci", "ouc", " outdc", "outC", "outdc", "oute", "ouC", " outp", "inC", " outcon", "OutC", "inci", "Oute"]}}
{"id1": "21704918", "id2": "1551466", "code1": "    public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {\n        File archive = new File(EncoderPlugin.getDefault().getStateLocation().toFile(), \"ffmpeg-0.5.zip\");\n        String message = \"Downloading FFMpeg, contacting downloads.sourceforge.net\";\n        LOGGER.info(message);\n        monitor.beginTask(message, 1);\n        HttpClient client = new HttpClient();\n        HttpMethod method = new GetMethod(DOWNLOAD_URI);\n        int statusCode = HttpStatus.SC_SERVICE_UNAVAILABLE;\n        try {\n            statusCode = client.executeMethod(method);\n        } catch (HttpException exception) {\n            monitor.setCanceled(true);\n            throw new InvocationTargetException(exception);\n        } catch (IOException exception) {\n            monitor.setCanceled(true);\n            throw new InvocationTargetException(exception);\n        }\n        if (statusCode != HttpStatus.SC_OK) {\n            LOGGER.error(MessageFormat.format(\"Can't download ffmpeg.zip from zourceforge, \" + \"status = [{0}]\", statusCode));\n            monitor.setCanceled(true);\n            return;\n        }\n        monitor.worked(1);\n        Header header = method.getResponseHeader(\"Content-Length\");\n        long contentLength = 3173544;\n        if (header != null) {\n            try {\n                contentLength = Long.parseLong(header.getValue());\n            } catch (NumberFormatException nfe) {\n            }\n        }\n        monitor.beginTask(\"Downloading FFMpeg, \" + DOWNLOAD_URI, (int) contentLength);\n        OutputStream archiveOutput = null;\n        try {\n            archiveOutput = new FileOutputStream(archive);\n        } catch (FileNotFoundException exception) {\n            monitor.setCanceled(true);\n            throw new InvocationTargetException(exception, \"Can't write temporary download file\");\n        }\n        InputStream responseInput = null;\n        try {\n            responseInput = method.getResponseBodyAsStream();\n        } catch (IOException exception) {\n            monitor.setCanceled(true);\n            throw new InvocationTargetException(exception);\n        }\n        byte[] buffer = new byte[1024 * 4];\n        int count = -1;\n        try {\n            while ((count = responseInput.read(buffer)) != -1) {\n                if (monitor.isCanceled()) {\n                    return;\n                }\n                archiveOutput.write(buffer, 0, count);\n                monitor.worked(count);\n            }\n            archiveOutput.close();\n            responseInput.close();\n        } catch (IOException exception) {\n            monitor.setCanceled(true);\n            throw new InvocationTargetException(exception);\n        }\n        monitor.beginTask(\"Downloading FFMpeg, extracting executable\", 1);\n        try {\n            ZipFile zipFile = new ZipFile(archive);\n            ZipEntry entry = zipFile.getEntry(\"ffmpeg-0.5/ffmpeg.exe\");\n            InputStream input = zipFile.getInputStream(entry);\n            OutputStream output = new FileOutputStream(target);\n            IOUtils.copy(input, output);\n            input.close();\n            output.close();\n        } catch (IOException exception) {\n            monitor.setCanceled(true);\n            throw new InvocationTargetException(exception, \"Can't unzip ffmpeg.exe\");\n        }\n        monitor.worked(1);\n        monitor.done();\n    }\n", "code2": "    public static void test2() throws Exception {\n        int keySize = 1024;\n        int dBlockSize = keySize / 8;\n        int eBlockSize = dBlockSize - 8 - 3;\n        CertAndKeyGen certAndKeyGen = new CertAndKeyGen(\"RSA\", \"MD5WithRSA\");\n        certAndKeyGen.generate(keySize);\n        PublicKey publicKey = certAndKeyGen.getPublicKey();\n        PrivateKey privateKey = certAndKeyGen.getPrivateKey();\n        Cipher cipher1 = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher1.init(Cipher.ENCRYPT_MODE, publicKey);\n        String fileA = \"C:/temp/a.txt\";\n        String fileB = \"C:/temp/b.txt\";\n        String fileC = \"C:/temp/c.txt\";\n        FileInputStream fis = new FileInputStream(fileA);\n        FileOutputStream fos = new FileOutputStream(fileB, false);\n        CipherOutputStream eos = new CipherOutputStream(fos, cipher1, eBlockSize);\n        byte[] b = new byte[128];\n        int i = fis.read(b);\n        while (i != -1) {\n            eos.write(b, 0, i);\n            i = fis.read(b);\n        }\n        eos.flush();\n        eos.close();\n        fos.close();\n        Cipher cipher2 = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher2.init(Cipher.DECRYPT_MODE, privateKey);\n        fis = new FileInputStream(fileB);\n        CipherInputStream cis = new CipherInputStream(fis, cipher2, dBlockSize);\n        FileOutputStream decodedFile = new FileOutputStream(fileC, false);\n        int read = -1;\n        while ((read = cis.read()) > -1) {\n            decodedFile.write(read);\n        }\n        decodedFile.close();\n        fis.close();\n    }\n", "label": 1, "substitutes": {"monitor": ["program", " webcam", " reporter", "mon", "period", " monitors", "counter", " pm", "thread", "control", "console", "number", "directory", "report", "log", "runner", "timeout", "pm", "timer", "Monitor", "reason", "platform", "ban", " monitored", "object", "master", "handler", "update", " manager", "management", "collect", "key", "pool", "port", "parent", "processor", "watch", "core", "controller", "mx", "loader", "n", " meter", "server", "module", " watchdog", "meter", "don", "builder", "manager", "ignore", "p", "journal", "remove", " collector", "num", "cm", "min", "view", "driver", "state", "summary", "match", "condition", "config", "inner", "monkey", "member", "param", "m", "lock", "check", "test", " mon", "unit"], "archive": ["source", "ive", "folder", "url", " directory", "upload", "open", "download", "io", "audio", "out", "object", "directory", "stream", "zip", "system", "resource", "handler", "server", "archives", "tar", "name", "volume", "report", "api", " zip", "escape", "temp", "slice", "media", "path", "image", "install", "file", "array", "database", " archives", "ignore", "metadata", "store", "copy", "jar", "ip"], "message": ["language", "msg", "warning", "result", "username", "Message", "definition", "request", "description", "application", "data", "summary", "phrase", "response", "email", "template", "info", "update", "filename", "body", "information", "event", "management", "report", "log", "text", "content", "mail", "status", "essage", "string", "image", "document", "file", "error", "title", "code", "mess", "subject", "metadata", "reason", "value"], "client": ["source", "host", "url", "connection", "cm", "plugin", "io", "conn", "man", "http", "con", "app", "request", "cell", "console", "channel", "https", "stream", "response", "resource", "handler", "server", "config", "per", "api", "Client", "cli", "m", "temp", "session", "window", "media", "image", "secure", "cache", "ssl", "socket", "service", "manager", "project"], "method": ["source", "Method", "operation", "url", "user", "term", "wrapper", "director", "plugin", "function", "sign", "man", "view", "one", "http", "request", "end", "METHOD", "data", "version", "stream", "response", "resource", "master", "server", "call", "module", "send", "event", "full", "direction", "report", "api", "transform", "text", "trip", "post", "session", "status", "sort", "path", "document", "record", "each", "service", "manager", "process", "subject", "form", "received", "project", "ip", "type"], "statusCode": ["StatusState", " statuscode", "speedType", "speedState", "responseCode", "StatusCode", " statusPoint", "statusCount", "statCode", "statusPoint", "responsecode", " statusType", "responseType", "StatusStatus", "exCode", "statusState", "statCount", "excode", "StatusType", "exNo", "statcode", "StatusCount", "Statuscode", "exStatus", "statusNo", "statuscode", "speedPoint", "statType", " statusStatus", " statusState", "StatusNo", "statusStatus", "statusType", " statusNo", "speedCode", "StatusPoint", " statusCount"], "header": ["head", "reader", "h", " headers", "first", "token", "director", "result", "player", "definition", "description", "column", "layer", "data", "cover", "response", "handler", "her", "second", "info", "writer", "meta", "section", " response", "body", "event", "Header", "report", "json", "filter", "hr", "dr", "content", "leader", "status", "key", "offset", "index", "string", "document", "headers", "record", "prev", "code", "title", "type", "tail", "metadata", "line"], "contentLength": ["ContentType", "ContentLen", "contentLen", " contentType", "resourceLength", "ContentSize", "Contentlength", "loadLength", "loadLen", " contentlength", "resourcelength", "loadType", "ContentLength", " contentLen", "contentSize", "loadSize", "contentlength", "resourceType", "contentType", " contentSize", "resourceSize"], "archiveOutput": [" archiveInput", "audioOutput", "audiooutput", "archiveUnit", "archiveResult", " archiveoutput", " archiveResult", "audioUnit", "responseOutput", "responseResult", "audioInput", "audioResult", " archiveUnit", "archiveoutput", "responseoutput", "archiveInput", "responseUnit"], "responseInput": ["responseFeed", "outputOutput", "resourceFile", " responseOutput", " responseContent", "resourceOutput", "responseSource", " responseFile", "ResponseFeed", "responseFile", "ResponseSource", "ResponseFile", "outputFeed", "responseOutput", "ResponseInput", "ResponseContent", "ResponseOutput", "resourceInput", "resourceContent", "outputInput", " responseFeed", "outputSource", " responseSource", "responseContent"], "buffer": ["source", "memory", "queue", "binary", "buff", "iter", "Buffer", "channel", "data", "address", "pad", "uffer", "shape", "batch", "flush", "length", "buf", "offset", "window", "image", "pool", "file", "map", "array", "block", "bin"], "count": ["id", "len", "counter", "weight", "limit", "part", "base", "data", "class", "sum", "match", "Count", "depth", "batch", "length", "found", "max", "offset", "index", "list", "cache", "c", "file", "error", "code", "start", "filter"]}}
{"id1": "5252227", "id2": "17180286", "code1": "    protected String doIt() throws java.lang.Exception {\n        StringBuffer sql = null;\n        int no = 0;\n        String clientCheck = getWhereClause();\n        if (m_deleteOldImported) {\n            sql = new StringBuffer(\"DELETE I_BPartner \" + \"WHERE I_IsImported='Y'\").append(clientCheck);\n            no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n            log.fine(\"Delete Old Impored =\" + no);\n        }\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET AD_Client_ID = COALESCE (AD_Client_ID, \").append(m_AD_Client_ID).append(\"),\" + \" AD_Org_ID = COALESCE (AD_Org_ID, 0),\" + \" IsActive = COALESCE (IsActive, 'Y'),\" + \" Created = COALESCE (Created, SysDate),\" + \" CreatedBy = COALESCE (CreatedBy, 0),\" + \" Updated = COALESCE (Updated, SysDate),\" + \" UpdatedBy = COALESCE (UpdatedBy, 0),\" + \" I_ErrorMsg = ' ',\" + \" I_IsImported = 'N' \" + \"WHERE I_IsImported<>'Y' OR I_IsImported IS NULL\");\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Reset=\" + no);\n        ModelValidationEngine.get().fireImportValidate(this, null, null, ImportValidator.TIMING_BEFORE_VALIDATE);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET GroupValue=(SELECT MAX(Value) FROM C_BP_Group g WHERE g.IsDefault='Y'\" + \" AND g.AD_Client_ID=i.AD_Client_ID) \");\n        sql.append(\"WHERE GroupValue IS NULL AND C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Set Group Default=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BP_Group_ID=(SELECT C_BP_Group_ID FROM C_BP_Group g\" + \" WHERE i.GroupValue=g.Value AND g.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Set Group=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'ERR=Invalid Group, ' \" + \"WHERE C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.config(\"Invalid Group=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Country_ID=(SELECT C_Country_ID FROM C_Country c\" + \" WHERE i.CountryCode=c.CountryCode AND c.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Country_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Set Country=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'ERR=Invalid Country, ' \" + \"WHERE C_Country_ID IS NULL AND (City IS NOT NULL OR Address1 IS NOT NULL)\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.config(\"Invalid Country=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"Set RegionName=(SELECT MAX(Name) FROM C_Region r\" + \" WHERE r.IsDefault='Y' AND r.C_Country_ID=i.C_Country_ID\" + \" AND r.AD_Client_ID IN (0, i.AD_Client_ID)) \");\n        sql.append(\"WHERE RegionName IS NULL AND C_Region_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Set Region Default=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"Set C_Region_ID=(SELECT C_Region_ID FROM C_Region r\" + \" WHERE r.Name=i.RegionName AND r.C_Country_ID=i.C_Country_ID\" + \" AND r.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Region_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Set Region=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'ERR=Invalid Region, ' \" + \"WHERE C_Region_ID IS NULL \" + \" AND EXISTS (SELECT * FROM C_Country c\" + \" WHERE c.C_Country_ID=i.C_Country_ID AND c.HasRegion='Y')\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.config(\"Invalid Region=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Greeting_ID=(SELECT C_Greeting_ID FROM C_Greeting g\" + \" WHERE i.BPContactGreeting=g.Name AND g.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Greeting_ID IS NULL AND BPContactGreeting IS NOT NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Set Greeting=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'ERR=Invalid Greeting, ' \" + \"WHERE C_Greeting_ID IS NULL AND BPContactGreeting IS NOT NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.config(\"Invalid Greeting=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET (C_BPartner_ID,AD_User_ID)=\" + \"(SELECT C_BPartner_ID,AD_User_ID FROM AD_User u \" + \"WHERE i.EMail=u.EMail AND u.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE i.EMail IS NOT NULL AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Found EMail User=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BPartner_ID=(SELECT C_BPartner_ID FROM C_BPartner p\" + \" WHERE i.Value=p.Value AND p.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE C_BPartner_ID IS NULL AND Value IS NOT NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Found BPartner=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET AD_User_ID=(SELECT AD_User_ID FROM AD_User c\" + \" WHERE i.ContactName=c.Name AND i.C_BPartner_ID=c.C_BPartner_ID AND c.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE C_BPartner_ID IS NOT NULL AND AD_User_ID IS NULL AND ContactName IS NOT NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Found Contact=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BPartner_Location_ID=(SELECT C_BPartner_Location_ID\" + \" FROM C_BPartner_Location bpl INNER JOIN C_Location l ON (bpl.C_Location_ID=l.C_Location_ID)\" + \" WHERE i.C_BPartner_ID=bpl.C_BPartner_ID AND bpl.AD_Client_ID=i.AD_Client_ID\" + \" AND (i.Address1=l.Address1 OR (i.Address1 IS NULL AND l.Address1 IS NULL))\" + \" AND (i.Address2=l.Address2 OR (i.Address2 IS NULL AND l.Address2 IS NULL))\" + \" AND (i.City=l.City OR (i.City IS NULL AND l.City IS NULL))\" + \" AND (i.Postal=l.Postal OR (i.Postal IS NULL AND l.Postal IS NULL))\" + \" AND (i.Postal_Add=l.Postal_Add OR (l.Postal_Add IS NULL AND l.Postal_Add IS NULL))\" + \" AND i.C_Region_ID=l.C_Region_ID AND i.C_Country_ID=l.C_Country_ID) \" + \"WHERE C_BPartner_ID IS NOT NULL AND C_BPartner_Location_ID IS NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Found Location=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET R_InterestArea_ID=(SELECT R_InterestArea_ID FROM R_InterestArea ia \" + \"WHERE i.InterestAreaName=ia.Name AND ia.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE R_InterestArea_ID IS NULL AND InterestAreaName IS NOT NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.fine(\"Set Interest Area=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'ERR=Value is mandatory, ' \" + \"WHERE Value IS NULL \" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n        log.config(\"Value is mandatory=\" + no);\n        ModelValidationEngine.get().fireImportValidate(this, null, null, ImportValidator.TIMING_AFTER_VALIDATE);\n        commitEx();\n        if (p_IsValidateOnly) {\n            return \"Validated\";\n        }\n        int noInsert = 0;\n        int noUpdate = 0;\n        sql = new StringBuffer(\"SELECT * FROM I_BPartner \" + \"WHERE I_IsImported='N'\").append(clientCheck);\n        sql.append(\" ORDER BY Value, I_BPartner_ID\");\n        PreparedStatement pstmt = null;\n        ResultSet rs = null;\n        try {\n            pstmt = DB.prepareStatement(sql.toString(), get_TrxName());\n            rs = pstmt.executeQuery();\n            String Old_BPValue = \"\";\n            MBPartner bp = null;\n            MBPartnerLocation bpl = null;\n            while (rs.next()) {\n                String New_BPValue = rs.getString(\"Value\");\n                X_I_BPartner impBP = new X_I_BPartner(getCtx(), rs, get_TrxName());\n                log.fine(\"I_BPartner_ID=\" + impBP.getI_BPartner_ID() + \", C_BPartner_ID=\" + impBP.getC_BPartner_ID() + \", C_BPartner_Location_ID=\" + impBP.getC_BPartner_Location_ID() + \", AD_User_ID=\" + impBP.getAD_User_ID());\n                if (!New_BPValue.equals(Old_BPValue)) {\n                    bp = null;\n                    if (impBP.getC_BPartner_ID() == 0) {\n                        if (impBP.getName() == null || impBP.getName().length() == 0) {\n                            sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Invalid Name, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                            DB.executeUpdate(sql.toString(), get_TrxName());\n                            continue;\n                        }\n                        bp = new MBPartner(impBP);\n                        if (!impBP.get_ValueAsString(\"AD_Language\").equals(\"\")) bp.set_ValueOfColumn(\"AD_Language\", impBP.get_ValueAsString(\"AD_Language\"));\n                        if (!impBP.get_ValueAsString(\"lbr_BPTypeBR\").equals(\"\")) bp.set_ValueOfColumn(\"lbr_BPTypeBR\", impBP.get_ValueAsString(\"lbr_BPTypeBR\"));\n                        if (!impBP.get_ValueAsString(\"lbr_CNPJ\").equals(\"\")) {\n                            Boolean ok = org.adempierelbr.validator.ValidatorBPartner.validaCNPJ(impBP.get_ValueAsString(\"lbr_CNPJ\"));\n                            if (ok) bp.set_ValueOfColumn(\"lbr_CNPJ\", impBP.get_ValueAsString(\"lbr_CNPJ\")); else {\n                                sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Invalid CNPJ, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                                DB.executeUpdate(sql.toString(), get_TrxName());\n                                continue;\n                            }\n                        }\n                        if (!impBP.get_ValueAsString(\"lbr_CPF\").equals(\"\")) {\n                            Boolean ok = org.adempierelbr.validator.ValidatorBPartner.validaCPF(impBP.get_ValueAsString(\"lbr_CPF\"));\n                            if (ok) bp.set_ValueOfColumn(\"lbr_CPF\", impBP.get_ValueAsString(\"lbr_CPF\")); else {\n                                sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Invalid CPF, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                                DB.executeUpdate(sql.toString(), get_TrxName());\n                                continue;\n                            }\n                        }\n                        if (!impBP.get_ValueAsString(\"lbr_IE\").equals(\"\")) {\n                            bp.set_ValueOfColumn(\"lbr_IE\", impBP.get_ValueAsString(\"lbr_IE\"));\n                            bp.set_ValueOfColumn(\"lbr_IsIEExempt\", false);\n                        }\n                        if (!impBP.get_ValueAsString(\"lbr_CCM\").equals(\"\")) bp.set_ValueOfColumn(\"lbr_CCM\", impBP.get_ValueAsString(\"lbr_CCM\"));\n                        if (!impBP.get_ValueAsString(\"lbr_RG\").equals(\"\")) bp.set_ValueOfColumn(\"lbr_RG\", impBP.get_ValueAsString(\"lbr_RG\"));\n                        if (!impBP.get_ValueAsString(\"isVendor\").equals(\"\")) bp.set_ValueOfColumn(\"isVendor\", impBP.get_ValueAsString(\"isVendor\"));\n                        if (!impBP.get_ValueAsString(\"isCustomer\").equals(\"\")) bp.set_ValueOfColumn(\"isCustomer\", impBP.get_ValueAsString(\"isCustomer\"));\n                        if (!impBP.get_ValueAsString(\"isSalesRep\").equals(\"\")) bp.set_ValueOfColumn(\"isSalesRep\", impBP.get_ValueAsString(\"isSalesRep\"));\n                        ModelValidationEngine.get().fireImportValidate(this, impBP, bp, ImportValidator.TIMING_AFTER_IMPORT);\n                        setTypeOfBPartner(impBP, bp);\n                        if (bp.save()) {\n                            impBP.setC_BPartner_ID(bp.getC_BPartner_ID());\n                            log.finest(\"Insert BPartner - \" + bp.getC_BPartner_ID());\n                            noInsert++;\n                        } else {\n                            sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"(CASE WHEN (SELECT COUNT(*) FROM C_BPartner WHERE lbr_CNPJ IS NOT NULL AND lbr_CNPJ='\").append(impBP.get_ValueAsString(\"lbr_CNPJ\")).append(\"') > 0 THEN 'CNPJ Duplicado, ' WHEN (SELECT COUNT(*) FROM C_BPartner WHERE lbr_CPF IS NOT NULL AND lbr_CPF='\").append(impBP.get_ValueAsString(\"lbr_CPF\")).append(\"') > 0 THEN 'CPF Duplicado, ' END) ||\").append(\"'Cannot Insert BPartner, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                            DB.executeUpdateEx(sql.toString(), get_TrxName());\n                            continue;\n                        }\n                    } else {\n                        bp = new MBPartner(getCtx(), impBP.getC_BPartner_ID(), get_TrxName());\n                        if (impBP.getName() != null) {\n                            bp.setName(impBP.getName());\n                            bp.setName2(impBP.getName2());\n                        }\n                        if (impBP.getDUNS() != null) bp.setDUNS(impBP.getDUNS());\n                        if (impBP.getTaxID() != null) bp.setTaxID(impBP.getTaxID());\n                        if (impBP.getNAICS() != null) bp.setNAICS(impBP.getNAICS());\n                        if (impBP.getDescription() != null) bp.setDescription(impBP.getDescription());\n                        if (impBP.getC_BP_Group_ID() != 0) bp.setC_BP_Group_ID(impBP.getC_BP_Group_ID());\n                        ModelValidationEngine.get().fireImportValidate(this, impBP, bp, ImportValidator.TIMING_AFTER_IMPORT);\n                        if (!impBP.get_ValueAsString(\"AD_Language\").equals(\"\")) bp.set_ValueOfColumn(\"AD_Language\", impBP.get_ValueAsString(\"AD_Language\"));\n                        if (!impBP.get_ValueAsString(\"lbr_BPTypeBR\").equals(\"\")) bp.set_ValueOfColumn(\"lbr_BPTypeBR\", impBP.get_ValueAsString(\"lbr_BPTypeBR\"));\n                        if (!impBP.get_ValueAsString(\"lbr_CNPJ\").equals(\"\")) {\n                            Boolean ok = org.adempierelbr.validator.ValidatorBPartner.validaCNPJ(impBP.get_ValueAsString(\"lbr_CNPJ\"));\n                            if (ok) bp.set_ValueOfColumn(\"lbr_CNPJ\", impBP.get_ValueAsString(\"lbr_CNPJ\")); else {\n                                sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Invalid CNPJ, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                                DB.executeUpdate(sql.toString(), get_TrxName());\n                                continue;\n                            }\n                        }\n                        if (!impBP.get_ValueAsString(\"lbr_CPF\").equals(\"\")) {\n                            Boolean ok = org.adempierelbr.validator.ValidatorBPartner.validaCPF(impBP.get_ValueAsString(\"lbr_CPF\"));\n                            if (ok) bp.set_ValueOfColumn(\"lbr_CPF\", impBP.get_ValueAsString(\"lbr_CPF\")); else {\n                                sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Invalid CPF, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                                DB.executeUpdate(sql.toString(), get_TrxName());\n                                continue;\n                            }\n                        }\n                        if (!impBP.get_ValueAsString(\"lbr_IE\").equals(\"\")) bp.set_ValueOfColumn(\"lbr_IE\", impBP.get_ValueAsString(\"lbr_IE\"));\n                        if (!impBP.get_ValueAsString(\"lbr_CCM\").equals(\"\")) bp.set_ValueOfColumn(\"lbr_CCM\", impBP.get_ValueAsString(\"lbr_CCM\"));\n                        if (!impBP.get_ValueAsString(\"lbr_RG\").equals(\"\")) bp.set_ValueOfColumn(\"lbr_RG\", impBP.get_ValueAsString(\"lbr_RG\"));\n                        if (!impBP.get_ValueAsString(\"isVendor\").equals(\"\")) bp.set_ValueOfColumn(\"isVendor\", impBP.get_ValueAsString(\"isVendor\"));\n                        if (!impBP.get_ValueAsString(\"isCustomer\").equals(\"\")) bp.set_ValueOfColumn(\"isCustomer\", impBP.get_ValueAsString(\"isCustomer\"));\n                        if (!impBP.get_ValueAsString(\"isSalesRep\").equals(\"\")) bp.set_ValueOfColumn(\"isSalesRep\", impBP.get_ValueAsString(\"isSalesRep\"));\n                        setTypeOfBPartner(impBP, bp);\n                        if (bp.save()) {\n                            log.finest(\"Update BPartner - \" + bp.getC_BPartner_ID());\n                            noUpdate++;\n                        } else {\n                            sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Cannot Update BPartner, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                            DB.executeUpdateEx(sql.toString(), get_TrxName());\n                            continue;\n                        }\n                    }\n                    bpl = null;\n                    if (impBP.getC_BPartner_Location_ID() != 0) {\n                        bpl = new MBPartnerLocation(getCtx(), impBP.getC_BPartner_Location_ID(), get_TrxName());\n                        MLocation location = new MLocation(getCtx(), bpl.getC_Location_ID(), get_TrxName());\n                        location.setC_Country_ID(impBP.getC_Country_ID());\n                        location.setC_Region_ID(impBP.getC_Region_ID());\n                        location.setCity(impBP.getCity());\n                        location.setAddress1(impBP.getAddress1());\n                        location.setAddress2(impBP.getAddress2());\n                        location.setAddress3(impBP.get_ValueAsString(\"Address3\"));\n                        location.setAddress4(impBP.get_ValueAsString(\"Address4\"));\n                        location.setPostal(impBP.getPostal());\n                        location.setPostal_Add(impBP.getPostal_Add());\n                        if (!location.save()) log.warning(\"Location not updated\"); else bpl.setC_Location_ID(location.getC_Location_ID());\n                        if (impBP.getPhone() != null) bpl.setPhone(impBP.getPhone());\n                        if (impBP.getPhone2() != null) bpl.setPhone2(impBP.getPhone2());\n                        if (impBP.getFax() != null) bpl.setFax(impBP.getFax());\n                        ModelValidationEngine.get().fireImportValidate(this, impBP, bpl, ImportValidator.TIMING_AFTER_IMPORT);\n                        bpl.save();\n                    } else if (impBP.getC_Country_ID() != 0 && impBP.getAddress1() != null && impBP.getCity() != null) {\n                        MLocation location = new MLocation(getCtx(), impBP.getC_Country_ID(), impBP.getC_Region_ID(), impBP.getCity(), get_TrxName());\n                        location.setAddress1(impBP.getAddress1());\n                        location.setAddress2(impBP.getAddress2());\n                        location.setAddress3(impBP.get_ValueAsString(\"Address3\"));\n                        location.setAddress4(impBP.get_ValueAsString(\"Address4\"));\n                        location.setPostal(impBP.getPostal());\n                        location.setPostal_Add(impBP.getPostal_Add());\n                        if (location.save()) log.finest(\"Insert Location - \" + location.getC_Location_ID()); else {\n                            rollback();\n                            noInsert--;\n                            sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Cannot Insert Location, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                            DB.executeUpdateEx(sql.toString(), get_TrxName());\n                            continue;\n                        }\n                        bpl = new MBPartnerLocation(bp);\n                        bpl.setC_Location_ID(location.getC_Location_ID());\n                        bpl.setPhone(impBP.getPhone());\n                        bpl.setPhone2(impBP.getPhone2());\n                        bpl.setFax(impBP.getFax());\n                        ModelValidationEngine.get().fireImportValidate(this, impBP, bpl, ImportValidator.TIMING_AFTER_IMPORT);\n                        if (bpl.save()) {\n                            log.finest(\"Insert BP Location - \" + bpl.getC_BPartner_Location_ID());\n                            impBP.setC_BPartner_Location_ID(bpl.getC_BPartner_Location_ID());\n                        } else {\n                            rollback();\n                            noInsert--;\n                            sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Cannot Insert BPLocation, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                            DB.executeUpdateEx(sql.toString(), get_TrxName());\n                            continue;\n                        }\n                    }\n                }\n                Old_BPValue = New_BPValue;\n                MUser user = null;\n                if (impBP.getAD_User_ID() != 0) {\n                    user = new MUser(getCtx(), impBP.getAD_User_ID(), get_TrxName());\n                    if (user.getC_BPartner_ID() == 0) user.setC_BPartner_ID(bp.getC_BPartner_ID()); else if (user.getC_BPartner_ID() != bp.getC_BPartner_ID()) {\n                        rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'BP of User <> BP, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                        DB.executeUpdateEx(sql.toString(), get_TrxName());\n                        continue;\n                    }\n                    if (impBP.getC_Greeting_ID() != 0) user.setC_Greeting_ID(impBP.getC_Greeting_ID());\n                    String name = impBP.getContactName();\n                    if (name == null || name.length() == 0) name = impBP.getEMail();\n                    user.setName(name);\n                    if (impBP.getTitle() != null) user.setTitle(impBP.getTitle());\n                    if (impBP.getContactDescription() != null) user.setDescription(impBP.getContactDescription());\n                    if (impBP.getComments() != null) user.setComments(impBP.getComments());\n                    if (impBP.getPhone() != null) user.setPhone(impBP.getPhone());\n                    if (impBP.getPhone2() != null) user.setPhone2(impBP.getPhone2());\n                    if (impBP.getFax() != null) user.setFax(impBP.getFax());\n                    if (impBP.getEMail() != null) user.setEMail(impBP.getEMail());\n                    if (impBP.getBirthday() != null) user.setBirthday(impBP.getBirthday());\n                    if (bpl != null) user.setC_BPartner_Location_ID(bpl.getC_BPartner_Location_ID());\n                    ModelValidationEngine.get().fireImportValidate(this, impBP, user, ImportValidator.TIMING_AFTER_IMPORT);\n                    if (user.save()) {\n                        log.finest(\"Update BP Contact - \" + user.getAD_User_ID());\n                    } else {\n                        rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Cannot Update BP Contact, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                        DB.executeUpdateEx(sql.toString(), get_TrxName());\n                        continue;\n                    }\n                } else if (impBP.getContactName() != null || impBP.getEMail() != null) {\n                    user = new MUser(bp);\n                    if (impBP.getC_Greeting_ID() != 0) user.setC_Greeting_ID(impBP.getC_Greeting_ID());\n                    String name = impBP.getContactName();\n                    if (name == null || name.length() == 0) name = impBP.getEMail();\n                    user.setName(name);\n                    user.setTitle(impBP.getTitle());\n                    user.setDescription(impBP.getContactDescription());\n                    user.setComments(impBP.getComments());\n                    user.setPhone(impBP.getPhone());\n                    user.setPhone2(impBP.getPhone2());\n                    user.setFax(impBP.getFax());\n                    user.setEMail(impBP.getEMail());\n                    user.setBirthday(impBP.getBirthday());\n                    if (bpl != null) user.setC_BPartner_Location_ID(bpl.getC_BPartner_Location_ID());\n                    ModelValidationEngine.get().fireImportValidate(this, impBP, user, ImportValidator.TIMING_AFTER_IMPORT);\n                    if (user.save()) {\n                        log.finest(\"Insert BP Contact - \" + user.getAD_User_ID());\n                        impBP.setAD_User_ID(user.getAD_User_ID());\n                    } else {\n                        rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(\"'Cannot Insert BPContact, ' \").append(\"WHERE I_BPartner_ID=\").append(impBP.getI_BPartner_ID());\n                        DB.executeUpdateEx(sql.toString(), get_TrxName());\n                        continue;\n                    }\n                }\n                if (impBP.getR_InterestArea_ID() != 0 && user != null) {\n                    MContactInterest ci = MContactInterest.get(getCtx(), impBP.getR_InterestArea_ID(), user.getAD_User_ID(), true, get_TrxName());\n                    ci.save();\n                }\n                impBP.setI_IsImported(true);\n                impBP.setProcessed(true);\n                impBP.setProcessing(false);\n                impBP.saveEx();\n                commitEx();\n            }\n            DB.close(rs, pstmt);\n        } catch (SQLException e) {\n            rollback();\n            throw new DBException(e, sql.toString());\n        } finally {\n            DB.close(rs, pstmt);\n            rs = null;\n            pstmt = null;\n            sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='N', Updated=SysDate \" + \"WHERE I_IsImported<>'Y'\").append(clientCheck);\n            no = DB.executeUpdateEx(sql.toString(), get_TrxName());\n            addLog(0, null, new BigDecimal(no), \"@Errors@\");\n            addLog(0, null, new BigDecimal(noInsert), \"@C_BPartner_ID@: @Inserted@\");\n            addLog(0, null, new BigDecimal(noUpdate), \"@C_BPartner_ID@: @Updated@\");\n        }\n        return \"\";\n    }\n", "code2": "    public static String encodePassword(String plainTextPassword) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n        messageDigest.update(plainTextPassword.getBytes(\"UTF-8\"));\n        byte[] digestBytes = messageDigest.digest();\n        String hex = null;\n        for (int i = 0; i < digestBytes.length; i++) {\n            hex = Integer.toHexString(0xFF & digestBytes[i]);\n            if (hex.length() < 2) sb.append(\"0\");\n            sb.append(hex);\n        }\n        return new String(sb);\n    }\n", "label": 0, "substitutes": {"sql": ["dl", "select", "cop", "sb", "general", "nl", "url", "ln", "actions", "auth", "util", "lines", "sg", "limit", "conn", "l", "http", "params", "pg", "fp", "serial", "zip", "os", "bs", "repl", "serv", "ql", "el", "sys", "qs", "sync", "shell", "eps", "vs", "body", "query", "acl", "s", "log", "fn", "bool", "stat", "QL", "pr", "sv", "SQL", "ls", "spec", "status", "session", "pel", "csv", "string", "il", "sk", "seed", "rl", "socket", "ssl", "db", "sol", "err", "html", "lock", "vals", "pos", "sq", " SQL", "sn", "inv", "str", "null", "sl"], "no": ["yes", "nothing", "size", "none", " NO", "num", "go", "la", "yo", "how", "connection", "not", "dev", "io", "ma", "eno", "cho", "number", "po", "to", "ada", "data", "n", "mo", "auto", "ni", "bo", "off", "lo", "x", "na", "o", "da", "No", "nt", "step", "max", "ko", "ino", "nos", "done", "but", "error", "NO", "only", "pos", "zero", " lo", "which", "who", " mo", "so"], "clientCheck": ["clientBlock", "clientcheck", "serverNum", "serverCheck", "serverBlock", " clientNum", "ClientNum", " ClientLink", " clientcheck", "ClientCheck", "ClientLink", " clientBlock", "servercheck", "ClientBlock", "Clientcheck", " clientLink", " ClientCheck", "clientNum", "clientLink"]}}
{"id1": "672082", "id2": "3108499", "code1": "    public boolean copyOneOfMyFile(File f, String dest) {\n        if (!ownsThisFile(f.getName())) return false;\n        if (!dest.endsWith(File.separator)) dest = dest.concat(File.separator);\n        try {\n            BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(new File(dest + f.getName())));\n            BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n            int len = 1024;\n            byte[] read = new byte[len];\n            while ((len = in.read(read)) > 0) out.write(read, 0, len);\n            out.flush();\n            out.close();\n            in.close();\n            if (!PatchManager.mute) System.out.println(\"file created : \" + dest + f.getName());\n        } catch (IOException e) {\n            System.out.println(\"copy directory : \" + e);\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"f": ["source", "d", "lf", "cf", "k", "flat", "fo", "fc", "l", "fs", "w", "fp", "inf", "sf", "fd", "b", "this", "fr", "of", "tf", "part", "fe", "fw", "n", "x", "name", "u", "e", "o", "fn", "t", "F", "m", "df", "fold", "v", "j", "c", "file", "i", "g", "fen", "fm", "self", "fi", "form", "ff", "fa", "p", "fx"], "dest": ["next", "source", "folder", "route", "die", "tmp", "dc", "url", "txt", "append", "lit", "priv", "result", "output", "flat", "src", "wd", "cdn", "home", "end", " destination", "st", "const", "delete", "loc", "data", "detail", "zip", "resource", "south", " Dest", "shape", "sup", "name", "desc", "dir", "target", "de", "cont", "text", "transform", "Dest", "post", "content", "temp", "done", "sort", "string", "path", "secure", "comb", "wb", "coord", "front", "dist", "ignore", "destroy", "www", "project", "test", "dat", "null", "rest", "except"], "out": ["net", "doc", "style", "Out", "writer", "sync", "log", "flush", "post", "cli", "temp", "list", "obj", "file", "quiet", "err", "line", "co", "io", "outer", "conn", "lib", "one", "pre", "b", "diff", "part", "gen", "OUT", "os", "auto", "print", "ins", "ex", "key", "pool", "point", "cache", "note", "IN", "copy", "ext", "page", "parent", "plain", "inc", "write", "user", "cmd", "base", "In", "raw", "exec", "o", "comment", "error", "i", "reader", "output", "w", "dump", "state", "data", "again", "outs", "prefix", "inner", "query", "wave", "up", "lock", "socket", "bin"], "in": ["source", "reader", "url", "input", "inc", "din", "win", "io", "nin", "con", "b", "login", "In", "pin", "again", "r", "inner", "exec", "init", "ins", "gin", "ini", "a", "m", "ex", "sin", "cin", "c", "socket", "file", "i", "IN", "err", "inn", "is", "lin", "bin", "ac"], "len": ["size", "split", "en", "num", "write", "ln", "lf", "min", "iter", "limit", "lim", "l", "pre", "end", "val", "part", "base", "lan", "Len", "loc", "data", "no", "n", " limit", "el", "nt", "length", "partial", "fl", "lc", "li", "le", "all", "count", "lock", "load", "i", "err", "pos", "block", "start", "lin", "fin", "bin", "line"], "read": ["select", "get", "next", "reader", "size", "en", "input", "write", "feed", "open", "Read", "buffer", "iter", "READ", "ride", "io", "end", "val", "skip", "data", "bytes", "r", "work", "raw", "exec", "x", "send", "sync", "transfer", "rc", "e", "reading", "log", "length", "allow", "text", "se", "run", "count", "pass", "load", "readable", "parse", "connect", "check", "rw", "lex", "block", "wait", "current", "is", "boot", "start", "add", "copy", "ip", "reads"]}}
{"id1": "10899860", "id2": "1424647", "code1": "    public void copy(File in, File out) throws Exception {\n        FileChannel src = new FileInputStream(in).getChannel();\n        FileChannel dest = new FileOutputStream(out).getChannel();\n        src.transferTo(0, src.size(), dest);\n        src.close();\n        dest.close();\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"in": ["source", "reader", "id", "url", "input", "inc", "d", "min", "io", "b", "login", "base", "data", "In", "again", "work", "config", "info", "inner", "name", "ins", "old", "ini", "m", "ex", "index", "image", "c", "file", "i", "IN", "inn", "at", "img", "bin", "ac"], "out": ["source", "parent", "inc", "output", "flat", "io", "conn", "w", "b", "end", "cmd", "part", "gen", "OUT", "Out", "outs", "prefix", "server", "writer", "off", "exec", "name", "target", "exp", "ex", "temp", "v", "up", "string", "vert", "point", "c", "file", "err", "opt", "at", "img", "bin", "ext"], "src": ["source", "sel", "RC", "reader", "sb", "tmp", "url", "cb", "input", "req", "upload", "pull", "gs", "Source", "client", "st", "this", "loc", "stream", "storage", "scenes", "bs", "sc", "sh", "serv", "config", "server", "ources", "sys", "sub", "cur", "sup", "sync", "desc", "rc", "inst", "rs", "ource", "ls", "gb", "rl", "impl", "obj", "ssl", "dist", "conv", "img", "self", "rb", "sl"], "dest": ["source", "die", "dc", "tmp", "later", "proc", "des", "d", "txt", "result", "ord", "dev", "output", "cdn", "home", "ou", " destination", "st", "delete", "const", "std", "di", "config", "writer", " Dest", "du", "sup", "desc", "dir", "ui", "target", "de", "Dest", "temp", "yout", "comb", "wb", "coord", "opt", "dist", "ds", "img", "destroy", "bin", "test", "dat", "rest"]}}
{"id1": "9046354", "id2": "1406925", "code1": "    public static String downloadWebVersionString(String address) {\n        StringBuffer stb = new StringBuffer();\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                for (int i = 0; i < numRead; i++) {\n                    stb.append((char) buffer[i]);\n                }\n                numWritten += numRead;\n            }\n        } catch (Exception exception) {\n            exception.printStackTrace();\n            return stb.toString();\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        return stb.toString();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.out.println(\"Usage: <target URI> <no of requests>\");\n            System.exit(-1);\n        }\n        URI targetURI = new URI(args[0]);\n        int n = Integer.parseInt(args[1]);\n        URL url = targetURI.toURL();\n        byte[] buffer = new byte[4096];\n        long startTime;\n        long finishTime;\n        int successCount = 0;\n        int failureCount = 0;\n        String serverName = \"unknown\";\n        long total = 0;\n        long contentLen = 0;\n        long totalContentLen = 0;\n        startTime = System.currentTimeMillis();\n        for (int i = 0; i < n; i++) {\n            HttpURLConnection c = (HttpURLConnection) url.openConnection();\n            c.connect();\n            InputStream instream = c.getInputStream();\n            try {\n                contentLen = 0;\n                if (instream != null) {\n                    int l = 0;\n                    while ((l = instream.read(buffer)) != -1) {\n                        total += l;\n                        contentLen += l;\n                    }\n                }\n                if (c.getResponseCode() == 200) {\n                    successCount++;\n                } else {\n                    failureCount++;\n                }\n                totalContentLen += contentLen;\n            } catch (IOException ex) {\n                failureCount++;\n            }\n            String s = c.getHeaderField(\"Server\");\n            if (s != null) {\n                serverName = s;\n            }\n        }\n        finishTime = System.currentTimeMillis();\n        float totalTimeSec = (float) (finishTime - startTime) / 1000;\n        float reqsPerSec = (float) successCount / totalTimeSec;\n        float timePerReqMs = (float) (finishTime - startTime) / (float) successCount;\n        System.out.print(\"Server Software:\\t\");\n        System.out.println(serverName);\n        System.out.println();\n        System.out.print(\"Document URI:\\t\\t\");\n        System.out.println(targetURI);\n        System.out.print(\"Document Length:\\t\");\n        System.out.print(contentLen);\n        System.out.println(\" bytes\");\n        System.out.println();\n        System.out.print(\"Time taken for tests:\\t\");\n        System.out.print(totalTimeSec);\n        System.out.println(\" seconds\");\n        System.out.print(\"Complete requests:\\t\");\n        System.out.println(successCount);\n        System.out.print(\"Failed requests:\\t\");\n        System.out.println(failureCount);\n        System.out.print(\"Content transferred:\\t\");\n        System.out.print(total);\n        System.out.println(\" bytes\");\n        System.out.print(\"Requests per second:\\t\");\n        System.out.print(reqsPerSec);\n        System.out.println(\" [#/sec] (mean)\");\n        System.out.print(\"Time per request:\\t\");\n        System.out.print(timePerReqMs);\n        System.out.println(\" [ms] (mean)\");\n    }\n", "label": 0, "substitutes": {"address": ["host", "connection", "reference", "network", "output", "message", "format", "object", "state", "base", "number", "data", "resource", "email", "server", "prefix", "Address", "name", "report", "password", "content", "localhost", "string", "path", "point", "uri", "record", "code", "attribute", "URL", "array", "addr", "position", "add", "port", "ip", "location", "type"], "stb": ["spob", "STbb", "stp", "stfb", "Stob", "Stf", " stfb", " stbody", " stp", "strb", "Stab", " stf", "Stp", "Stb", "stnb", "stbody", "stab", "spb", " stob", " stbs", "strbody", "Stbs", "spnb", "stbb", "stob", "STf", "spab", " stab", "STp", "Stbody", "strab", " stbb", "stf", "Stfb", "Stnb", "STbs", " stnb", "strnb", "Stbb", "STb", "stbs", "STfb"], "conn": ["cb", "en", "inc", "ln", "win", "connection", "open", "net", "not", "l", "http", "con", "out", "client", "cp", "n", "enc", "ai", "config", "pc", "conf", "cn", "exec", "sync", "init", "func", "ci", "nt", "act", "api", "ch", "cli", "ls", "session", "connect", "impl", "c", "ssl", "socket", "lock", "err", "inn", "conv", "Connection", "Conn", "nc", "coll"], "in": ["source", "reader", "id", "input", "inc", "din", "ln", "win", "connection", "min", "nin", "con", "out", "b", "client", "login", "f", "as", "data", "In", "pin", "again", "n", "resource", "isin", "inner", "exec", "init", "ins", "gin", "ini", "m", "rec", "index", "cin", "image", "connect", "cache", "c", "socket", "file", "IN", "err", "ssl", "inside", "inn", "is", "lin", "bin"], "url": ["connection", "open", "download", "rel", "ll", "l", "http", "con", "out", "client", "b", "object", "fr", "channel", "base", "f", "loc", "n", "r", "resource", "server", "cur", "ob", "api", "bel", "fl", "ls", "impl", "c", "uri", "ssl", "obj", "socket", "URL", "Url", "www", "blog", "web", "coll", "sl"], "buffer": ["source", "read", "reader", "cb", "queue", "memory", "binary", "input", "feed", "reference", "buff", "iter", "result", "Buffer", "message", "limit", "b", "layer", "base", "data", "bytes", "pad", "uffer", "shape", "sequence", "padding", "transfer", "batch", "bb", "length", "flush", "buf", "offset", "slice", "border", "seed", "cache", "load", "fb", "header", "position", "bin", "copy"], "numRead": ["nWrite", "nWritten", " numread", "nread", "nRead", "numread", "numberread", "nonWrite", " numWrite", "NumWritten", "Numread", "nonReader", "numReader", "numWrite", "nonWritten", "NumReader", " numReader", "nonRead", "numberWritten", "NumWrite", "NumRead", "nReader", "numberRead", "numberReader"], "numWritten": ["nWrite", "Numwritten", "nWritten", "numwritten", "nwritten", "NumWrite", "numWrite", " numwritten", "NumRead", " numWrite", "nRead", "NumWritten"], "i": ["h", "id", "d", "si", "multi", "qi", "abi", "hi", "k", "phi", "io", "limit", "l", "b", "end", "f", "data", "di", "n", "r", "bi", "I", "oi", "ti", "ai", "gi", "x", "ix", "it", "ui", "u", "e", "o", "ci", "length", "t", "ini", "a", "m", "li", "v", "key", "xi", "ri", "slice", "count", "index", "j", "c", "uri", "ii", "pi", "at", "start", "field", "z", "p", "type"]}}
{"id1": "22622804", "id2": "1457394", "code1": "    protected byte[] generateHashBytes() {\n        String s = createString(false);\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nsa) {\n            System.out.println(\"Can't get MD5 implementation \" + nsa);\n            throw new RuntimeException(\"DynanmicAddress2: Can't get MD5 implementation\");\n        }\n        if (m_key != null) md.update(m_key.getBytes(), 0, m_key.length());\n        md.update(s.getBytes(), 0, s.length());\n        byte[] hash = md.digest();\n        return hash;\n    }\n", "code2": "    private File download(String filename, URL url) {\n        int size = -1;\n        int received = 0;\n        try {\n            fireDownloadStarted(filename);\n            File file = createFile(filename);\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));\n            System.out.println(\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0534\ufffd\ufffd\" + filename + \", url=\" + url);\n            InputStream bis = url.openStream();\n            byte[] buf = new byte[1024];\n            int count = 0;\n            long lastUpdate = 0;\n            size = bis.available();\n            while ((count = bis.read(buf)) != -1) {\n                bos.write(buf, 0, count);\n                received += count;\n                long now = System.currentTimeMillis();\n                if (now - lastUpdate > 500) {\n                    fireDownloadUpdate(filename, size, received);\n                    lastUpdate = now;\n                }\n            }\n            bos.close();\n            System.out.println(\"\ufffd\ufffd\u0534\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u03e3\ufffd\" + filename);\n            fireDownloadCompleted(filename);\n            return file;\n        } catch (IOException e) {\n            System.out.println(\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0534\u02a7\ufffd\u0723\ufffd\" + filename + \", error=\" + e.getMessage());\n            fireDownloadInterrupted(filename);\n            if (!(e instanceof FileNotFoundException)) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"s": ["hs", "ks", "sb", "h", "strings", "msg", "d", "si", "lines", "ss", "ws", "sm", "sg", "fs", "params", "gs", "b", "ns", "ms", "f", "n", "os", "bs", "es", "qs", "js", "xs", "sets", "u", "e", "rs", "cs", "m", "abs", "ls", "string", "c", "ssl", "i", "ans", "g", "ses", "ds", "parts", "services", "ts", "S", "ps", "p"], "md": ["msg", "cd", "d", "mb", "dig", "dd", "ld", "bind", "hd", "sm", "message", "mm", "pd", "ma", "vd", " MD", "doc", "wd", "cmd", "ms", "magic", "data", "mac", "bd", "mo", "style", "hm", "mand", "editor", "mag", "meta", "mc", "sha", "method", "mp", "rpm", "dm", "me", "mod", "dh", "MD", "mt", "a", "m", "dr", "mail", "od", "key", "docker", "sp", "html", "mg", "db", "med", "Cmd", "addr", "metadata", "nd", "ng", "amd", "nm", "str", "pkg"], "hash": ["ash", "size", "h", "id", "url", "abi", "ha", "buffer", "build", "result", "fill", "message", "ho", "data", "mac", "hex", "response", "sum", "sh", "her", "shadow", "address", "sha", "hed", "body", "log", "length", "height", "rh", "key", "image", "pool", "cache", "html", "error", "search", "array", "header", "block", "Hash", "bin", "dig"]}}
{"id1": "19592942", "id2": "12482760", "code1": "    public Fen_Download_FlameRobin() {\n        super();\n        initialize();\n        long HeureDebut = System.currentTimeMillis();\n        long HeureActuelle;\n        String urlsetup = \"http://downloads.sourceforge.net/project/autobackupbysim/tools/flamerobin-0.9.2-1-setup.exe\";\n        int erreurOuverture = 0;\n        InputStream input = null;\n        String cheminFichier = \"\";\n        File fichier;\n        FileOutputStream writeFile = null;\n        try {\n            URL url = new URL(urlsetup);\n            URLConnection connection = url.openConnection();\n            final int fileLength = connection.getContentLength();\n            if ((fileLength == -1) || (fileLength == 0)) {\n                System.out.println(\"Invalide URL or file.\");\n                erreurOuverture++;\n            }\n            input = connection.getInputStream();\n            String fileName = url.getFile().substring(url.getFile().lastIndexOf('/') + 1);\n            if (fileName.contains(\"%20\") == true) {\n                fileName = fileName.replaceAll(\"%20\", \" \");\n            }\n            if (fileName.contains(\"&amp;\") == true) {\n                fileName = fileName.replaceAll(\"&amp;\", \" and \");\n            }\n            cheminFichier = GestionRepertoire.RecupRepTravail() + \"\\\\\" + fileName;\n            jLabel1.setText(\" Fichier en cours : \" + fileName);\n            fichier = new File(cheminFichier);\n            writeFile = new FileOutputStream(cheminFichier);\n            byte[] buffer = new byte[4096 * 1024];\n            int read;\n            while ((read = input.read(buffer)) > 0) {\n                writeFile.write(buffer, 0, read);\n                long TailleEncours = fichier.length();\n                int progressionEnCours = (int) ((100 * (TailleEncours + 1)) / fileLength);\n                HeureActuelle = System.currentTimeMillis();\n                long Vitesse = (long) (TailleEncours / (HeureActuelle - HeureDebut));\n                jLabel1.setText(\"T\ufffdl\ufffdchargement du fichier , Vitesse Actuelle : \" + Vitesse + \" Ko/s\");\n                jProgressBar.setValue(progressionEnCours);\n                jProgressBar.setString(progressionEnCours + \" %\");\n            }\n            writeFile.flush();\n        } catch (IOException e) {\n            System.out.println(\"Error while trying to download the file.\");\n            e.printStackTrace();\n        } finally {\n            try {\n                if (erreurOuverture == 0) {\n                    writeFile.close();\n                    input.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        String cmdExecuteSetup = (\"cmd /c \\\"\" + cheminFichier + \"\\\" /silent\");\n        Runtime r = Runtime.getRuntime();\n        Process p = null;\n        try {\n            p = r.exec(cmdExecuteSetup);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            p.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public synchronized void connect() throws FTPConnectionException {\n        checkLocked();\n        try {\n            int reply;\n            this.disconnect();\n            if (isSecured()) {\n                this.client = new FTPSClient(protocol, protection, impliciteSec, null, null);\n            } else {\n                this.client = new FTPClient();\n            }\n            if (this.controlEncoding != null) {\n                this.client.setControlEncoding(this.controlEncoding);\n                debug(\"control encoding : \", controlEncoding);\n            }\n            Logger.defaultLogger().info(\"Trying to connect to server : \" + this.remoteServer + \" ...\");\n            debug(\"connect : connect\", remoteServer);\n            client.connect(remoteServer, this.remotePort);\n            Logger.defaultLogger().info(\"Received FTP server response : \" + formatFTPReplyString(client.getReplyString()));\n            this.connectionId = Util.getRndLong();\n            reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                String msg = formatFTPReplyString(client.getReplyString());\n                this.disconnect();\n                throw new FTPConnectionException(\"Unable to communicate with remote FTP server. Got message : \" + msg);\n            } else {\n                Logger.defaultLogger().info(\"Trying to log in with user : \" + this.login + \" ...\");\n                debug(\"connect : login\", login + \"/\" + password);\n                if (!client.login(this.login, this.password)) {\n                    String msg = formatFTPReplyString(client.getReplyString());\n                    this.disconnect();\n                    throw new FTPConnectionException(\"Unable to login on FTP server (\" + login + \"/\" + password + \"). Received response : \" + msg);\n                } else {\n                    Logger.defaultLogger().info(\"Logged in with user : \" + this.login + \". Received response : \" + formatFTPReplyString(client.getReplyString()));\n                    if (this.passivMode) {\n                        Logger.defaultLogger().info(\"Switching to passive mode ...\");\n                        debug(\"connect : pasv\");\n                        client.enterLocalPassiveMode();\n                        reply = client.getReplyCode();\n                        if (!FTPReply.isPositiveCompletion(reply)) {\n                            String msg = formatFTPReplyString(client.getReplyString());\n                            this.disconnect();\n                            throw new FTPConnectionException(\"Unable to switch to passiv mode. Received response : \" + msg);\n                        } else {\n                            this.updateOpTime();\n                        }\n                    } else {\n                        this.updateOpTime();\n                    }\n                    debug(\"connect : bin\");\n                    client.setFileType(FTP.BINARY_FILE_TYPE);\n                    Logger.defaultLogger().info(\"Connected to server : \" + this.remoteServer);\n                }\n            }\n        } catch (UnknownHostException e) {\n            resetClient(e);\n            throw new FTPConnectionException(\"Unknown FTP server : \" + this.remoteServer);\n        } catch (SocketException e) {\n            resetClient(e);\n            throw new FTPConnectionException(\"Error during FTP connection : \" + e.getMessage());\n        } catch (IOException e) {\n            resetClient(e);\n            throw new FTPConnectionException(\"Error during FTP connection : \" + e.getMessage());\n        } finally {\n            clearCache();\n        }\n    }\n", "label": 0, "substitutes": {"HeureDebut": ["HeureRebit", "HeureRebut", "HeureDebuti", "HeureBluti", "HeureExecut", "HeurDebut", "HeureDebot", "HeureBlit", "HeureExecuti", "HeureRebot", "HeurBluti", "HeurDebot", "HeureDebit", "HeureRebuti", "HeureBlot", "HeureExecit", "HeureBlut", "HeurBlit", "HeurBlut", "HeurDebit", "HeurBlot", "HeureExecot", "HeurDebuti"], "HeureActuelle": ["HeureActualLE", "HeureActuallet", "HeureManuellet", "HeureACTuelet", "HeureActuellet", "HeureActualLe", "HeureManuelLe", "HeureManuallet", "HeureActimeLE", "HeureActimelet", "HeureActuele", "HeureActualle", "HeureActimele", "HeureACTuelLE", "HeureACTuelLe", "HeureActuelLe", "HeureManualLE", "HeureACTuelle", "HeureManuelLE", "HeureManuelle", "HeureActuelLE", "HeureACTuele", "HeureActuelet", "HeureManualle", "HeureActueLE", "HeureActimeLe", "HeureManualLe", "HeureACTuellet", "HeureACTueLe", "HeureACTueLE", "HeureActueLe"], "urlsetup": ["roundsetup", "urlseed", "filesetup", "filereset", "fileseed", "URLseed", "roundreset", "buildsetup", "urldatabase", "URLSetup", "roundSetup", "roundseed", "urlSetup", "URLsetup", " urldatabase", "URLreset", "URLdatabase", "buildSetup", "urlreset", "builddatabase", " urlSetup", "fileSetup"], "erreurOuverture": ["erreurOupture", "erreurOuvertime", "erreurOruvertsured", "erreurOuvertured", "erreurOtuvertURE", "erreurOruvertur", "erreurOujectured", "erreurOuptured", "erreurOtuverture", "erreurOruverture", "erreurOujecture", "erreurOruvertURE", "erreurOruvertsure", "erreurOuventURE", "erreurOruvertured", "erreurOuventure", "erreurOuventime", "erreurOuptime", "erreurOujectur", "erreurOuvertsime", "erreurOuvertsure", "erreurOuvertURE", "erreurOtuventour", "erreurOuvertsur", "erreurOruvertsURE", "erreurOtuvertour", "erreurOtuventime", "erreurOuvertur", "erreurOuptur", "erreurOuvertsour", "erreurOruvertsur", "erreurOuvertour", "erreurOuptURE", "erreurOuvertsURE", "erreurOtuventure", "erreurOuptour", "erreurOujectURE", "erreurOuvertsured", "erreurOtuventURE", "erreurOuventour", "erreurOtuvertime"], "input": ["source", "reader", "wrapper", "inc", "feed", "xml", "pull", "result", "output", "audio", "conn", "http", "out", "in", "inf", "client", "request", "this", "channel", "loader", "data", "ref", "stream", "resource", "qq", "child", "config", "inner", "exec", "Input", "container", "instance", "temp", "session", "index", "media", "image", "list", "socket", "ssl", "error", "context", "form", "qa", "type"], "fichier": ["fichiers", "ficherer", "factoryier", "Fachie", "faffer", "fither", "factoryerer", "focherer", "Fich\u00e8", "faundie", "Fichier", "fictie", "fithier", "fachie", "fafferer", "fichie", "factoryie", "faffie", "faffier", " factoryiere", " fichie", " fichiere", "fochier", "fichiere", "fithie", "Fach\u00e8", "fictier", "fictiere", "Fachiers", "factoryiere", "ficterer", "fitherer", "ficher", "Fithie", "Fithier", "fith\u00e8", " ficherer", "Ficherer", "Fichie", "ficter", "Fither", "faundier", "fachier", "fochiere", "fochie", "Fichiers", "fachiers", "fich\u00e8", "faundiers", " factoryier", "fithiers", " factoryie", " factoryerer", "fach\u00e8", "Ficher", "Fachier", "Fitherer", "faund\u00e8"], "writeFile": ["writerStream", "outputStream", "writeLine", "writeStream", " writeFiles", " writeBuffer", " writeLine", "outputBuffer", "createFile", "outputFile", "outputLine", "writerFile", " writeStream", "readStream", "outputFiles", "WriteDir", " writeDir", "writerLine", "writerPlace", "createPlace", "WriteBuffer", "writeBuffer", "writeDir", "readFiles", "createLine", "writeFiles", "createStream", "WriteFile", "outputDir", "WriteLine", "readBuffer", "writePlace", " writePlace", "readFile"], "url": ["source", "host", "page", "link", "user", "open", "download", "feed", "conn", "l", "http", "control", "out", "client", "bc", "channel", "loc", "data", "stream", "system", "response", "resource", "server", "contact", "address", "config", "location", "session", "string", "path", "image", "connect", "impl", "socket", "file", "ssl", "uri", "html", "URL", "database", "service", "Url", "position", "www", "proxy", "web", "sl"], "connection": ["reader", "operation", "sql", "open", "io", "conn", "communication", "http", "con", "out", "client", "bc", "connected", "channel", "application", "loc", "directory", "stream", "response", "resource", "handler", "server", "config", "info", "condition", "section", "machine", "body", "relation", "session", "index", "string", "document", "connect", "cache", "c", "socket", "context", "uri", "URL", "character", "database", "Connection"], "fileLength": ["lineLen", "contentNumber", " fileOffset", "lineLength", "resourceLen", "FileNumber", "contentLen", " fileLen", "fileOffset", "fileLeft", "resourceWidth", " fileType", "fileWidth", "resourceLength", "fileType", "FileSize", "FileLength", " fileNumber", "fileSize", "FileType", " fileLeft", "contentLength", "contentOffset", " filelength", "contentLeft", "FileLeft", "contentSize", "lineSize", "contentlength", "fileNumber", " fileWidth", "lineType", "resourceOffset", "FileLen", "filelength", "Filelength", "fileLen", " fileSize", "contentWidth"], "fileName": ["urlname", "FileInfo", "placeInfo", "entityTime", "urlType", "fileType", "FILEType", "FileSize", "fileSize", "banInfo", "fileRoot", "filenamePath", "urlLocation", " filename", "fileInfo", "placeName", "mailTime", "filenameName", "FileName", "letterPath", "lettername", "fileLocation", "modelPath", "banHalf", " fileTime", "mailName", "FilePath", "placeHalf", "FileLocation", "stringname", "letterHalf", "stringName", "Filename", "entityName", "cacheInfo", "forceRoot", " fileRoot", "forcename", "forceName", "FILEName", "fileTime", "fileHalf", "modelHalf", "cacheName", "filename", "banname", "filePath", "FILEPath", "banName", "forcePath", "filenameType", " fileHalf", "filenameSize", "modelName", "modelname", "stringRoot", " fileType", "cachePath", "FileType", " filePath", "placename", "letterInfo", " fileInfo", " fileLocation", "letterName", "stringPath", "urlName", " fileSize"], "cheminFichier": ["cheminFichiere", "cheminFICHer", "cheminFicier", "cheminTantie", "cheminfichrice", "cheminFrenchien", "cheminFoudiere", "cheminFictie", "cheminFither", "cheminFoudier", "cheminFoudiers", "cheminFichie", "cheminFictier", "cheminDrenchien", "cheminFictien", "cheminfichier", "cheminFichrice", "cheminDichien", "cheminFithiere", "cheminFichien", "cheminTichiere", "cheminDichery", "cheminTantier", "cheminDichier", "cheminFICHrice", "cheminFithie", "cheminFictiere", "cheminFictery", "cheminFicher", "cheminTichery", "cheminfithier", "cheminDichiers", "cheminfithiere", "cheminFrenchiers", "cheminFicery", "cheminFithrice", "cheminFicien", "cheminFoudien", "cheminFichery", "cheminDrenchiers", "cheminFICHier", "cheminfithrice", "cheminFachier", "cheminTichie", "cheminFithien", "cheminFICHiere", "cheminFantie", "cheminFoudie", "cheminFantier", "cheminFantiere", "cheminTantery", "cheminFacher", "cheminficher", "cheminfither", "cheminFrenchier", "cheminTantiere", "cheminFachiere", "cheminFachrice", "cheminFichiers", "cheminDrenchier", "cheminFoudery", "cheminFantery", "cheminFiciers", "cheminfichiere", "cheminDrenchery", "cheminFithier", "cheminFrenchery", "cheminTichier"], "buffer": ["source", "page", "reader", "memory", "queue", "binary", "write", "feed", "reference", "buff", "iter", "Buffer", "output", "message", "layer", "channel", "number", "data", "table", "bytes", "resource", "server", "address", "writer", "uffer", "sequence", "transfer", "padding", "batch", "length", "flush", "wave", "initial", "FFER", "buf", "slice", "image", "document", "seed", "cache", "border", "array", "header", "texture", "block", "position"], "read": ["play", "get", "reader", "id", "size", "default", "write", "d", "last", "feed", "open", "Read", "ind", "READ", "ride", "reads", "in", "end", "tell", "skip", "data", "rate", "find", "stream", "work", "raw", "config", "sync", "send", "old", "reading", "length", "text", "max", "se", "run", "close", "index", "count", "pass", "load", "connect", "parse", "readable", "check", "seek", "wait", "valid", "current", "level", "start", "add", "copy", "put", "use", "type"], "TailleEncours": ["TailenDecore", "TailleCore", "TailleMcuries", "TailleEscore", "TailleDecore", "TailleeEncours", "TailleeCours", "TailleDecuries", "TailenEncour", "TailenDecuries", "TailenDecours", "TailenDecour", "TailleCour", "TailleEscour", "Tailleencores", "TailleCores", "TailleEncores", "TailleeCores", "TailleDecour", "TailleOctour", "TailleEscores", "TailleMcour", "TailleEncour", "TailleDecours", "TailleOctours", "TailleMcore", "TailleeCore", "Tailleencore", "TailleOcturies", "TailleMcours", "Tailleencour", "TailleEncore", "TailenEncours", "TailleEscours", "TailleeEncore", "Tailleencours", "TailenEncore", "TailleeEncores", "TailleEncuries", "TailleeEncour", "TailleeCour", "TailleCours", "TailenEncuries", "TailleOctore"], "progressionEnCours": ["ProgressionEnColOUR", "ProgressionConColOUR", "ProgressionEnColours", "ProgressionConCOUR", "ProgressionConCores", "ProgressionConColou", "ProgressionEnColou", "ProgressionConColours", "ProgressionConCou", "ProgressionEnCours", "ProgressionEnVOUR", "ProgressionEnVores", "ProgressionEnVou", "ProgressionEnacou", "ProgressionConColores", "ProgressionEnColores", "ProgressionEnCores", "ProgressionEnVours", "ProgressionEnacOUR", "ProgressionEnacores", "ProgressionEnCou", "ProgressionEnacours", "ProgressionEnCOUR", "ProgressionConCours"], "Vitesse": [" Vdata", "vdata", "v\n", "V\n", "Vdata", " V\n", " vdata", " v\n"]}}
{"id1": "7541432", "id2": "948486", "code1": "    public void run() {\n        String s, s2;\n        s = \"\";\n        s2 = \"\";\n        try {\n            URL url = new URL(\"http://www.m-w.com/dictionary/\" + Word);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while (((str = in.readLine()) != null) && (!stopped)) {\n                s = s + str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        Pattern pattern = Pattern.compile(\"popWin\\\\('/cgi-bin/(.+?)'\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n        Matcher matcher = pattern.matcher(s);\n        if ((!stopped) && (matcher.find())) {\n            String newurl = \"http://m-w.com/cgi-bin/\" + matcher.group(1);\n            try {\n                URL url2 = new URL(newurl);\n                BufferedReader in2 = new BufferedReader(new InputStreamReader(url2.openStream()));\n                String str;\n                while (((str = in2.readLine()) != null) && (!stopped)) {\n                    s2 = s2 + str;\n                }\n                in2.close();\n            } catch (MalformedURLException e) {\n            } catch (IOException e) {\n            }\n            Pattern pattern2 = Pattern.compile(\"<A HREF=\\\"http://(.+?)\\\">Click here to listen with your default audio player\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n            Matcher matcher2 = pattern2.matcher(s2);\n            if ((!stopped) && (matcher2.find())) {\n                if (getWave(\"http://\" + matcher2.group(1))) label.setEnabled(true);\n            }\n        }\n        button.setEnabled(true);\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"s": ["h", "strings", "sb", "su", "site", "si", "d", "lines", "ss", "sg", "ws", "l", "w", "less", "b", "ns", "gs", "f", "https", "p", "n", "r", "es", "sites", "south", "js", "sym", "shell", "name", "x", "sync", "sets", "u", "e", "ins", "t", "cs", "rs", "sv", "m", "ls", "abs", "session", "v", "sing", "a", "string", "c", "ssl", "i", "search", "g", "ses", "is", "ds", "services", "ts", "S", "ps", "sl"], "s2": [" sTwo", "s32", "p1", "m2", "ss2", " stwo", "sg1", "args1", "s5", "args62", " ssecond", "args2", "ws32", "argstwo", "n62", "urltwo", "url1", "ses5", "S2", " s4", "mtwo", "psecond", "sTwo", "wsTwo", "s62", "sg2", "m1", "sstwo", "s1", "ss1", "sgsecond", "ntwo", " s32", "ws5", "s4", "n1", "p12", "ssecond", "ssTwo", " s1", "sesTwo", "S1", "mTwo", "ws2", "ses32", " s12", " s5", "stwo", "s12", "sg12", "url62", "ses2", "p2", "STwo", "S4", "n2", "ss4"], "url": ["source", "page", "ball", "input", "en", "browser", "feed", "connection", "download", "buffer", "pull", "ll", "l", "http", "fr", "f", "base", "server", "address", "gl", "log", "fl", "string", "rule", "image", "socket", "file", "ssl", "uri", "URL", "hub", "Url", "www", "blog", "web", "sl"], "in": ["source", "reader", "h", "id", "input", "inc", "din", "token", "win", "min", "doc", "nin", "l", "con", "out", "login", "f", "data", "In", "pin", "again", "r", "inner", "exec", "init", "ins", "t", "ini", "m", "kin", "all", "image", "c", "ssl", "i", "IN", "inside", "g", "inn", "rin", "is", "lin", "bin", "on", "pass"], "str": ["div", "wr", "STR", "strike", "id", "num", "len", "arr", "ld", "iter", "br", "doc", "l", "ct", "char", "val", "star", "st", "fr", "part", "f", "p", "data", "style", "r", "n", "enc", "elt", "kr", "inner", "er", "name", "e", "exp", "step", "cl", "spec", "Str", "text", "t", "pr", "sr", "dr", "hr", "tr", "key", "bar", "string", "cr", "list", "pass", "sp", "obj", "sol", "err", "code", "g", "pos", "expr", "stri", "ctr", "z", "line", "usr", "sl", "bl", "entry"], "pattern": ["pat", "reader", "counter", "widget", "python", "format", "letter", "regular", "app", "bug", "model", "directory", "style", "print", "system", "match", "handler", "archive", "config", "template", "condition", "Pattern", "script", "shell", "php", "batch", "patch", "log", "atter", "password", "text", "comment", "variable", "string", "path", "image", "expression", "command", "group", "form", "project", "test", "cher", "pl"], "matcher": ["matchter", " matter", "parcher", "atcher", "matche", " mather", " matatcher", "atche", "Mather", "Matatcher", "catcher", "catchers", "parter", "rather", "pitcher", "pitatcher", " matque", "patner", " matched", " mature", "matatcher", "matque", "mather", "patter", "pither", "masque", "catoder", "matner", "Matter", "matched", "Matoder", "matchner", "Matcher", "ratcher", "matchcher", "matoder", "mascher", "pather", "paroder", "rature", "pitter", "matchers", "atque", "ratter", "mature", "parchers", "matchher", "atched", "matter", "masched", "Matchers", "catter", "masche", " matche", "pature", "patcher", " matner"], "newurl": ["anotheruri", "olduri", "uniquelr", "oldUrl", "Newurl", "uniqueurl", "Newlr", "anotherUrl", "uniqueUrl", " newfeed", "NEWstr", " newuri", "anotherfeed", "newstr", "uniquestr", "NEWlr", "oldurl", "newuri", "oldfeed", "newlr", "NewUrl", "newUrl", "NEWUrl", "newfeed", "NEWurl", "Newstr", "anotherurl", " newUrl"], "url2": ["input256", "resource2", "filesecond", "inputtwo", "resourcetwo", "url_", "page256", "page2", "url256", "filetwo", "intwo", "pagesecond", "urltwo", " urltwo", "in1", "resource_", "inputsecond", "in_", " url_", "file256", "input2", "resource1", "pagetwo", "urlsecond", " url1", "url1", "file2"], "in2": ["inTwo", "inn5", "in5", "lin2", " in256", "val256", "in256", " inball", "intwo", "ins5", "in3", " intwo", "valtwo", " in5", "inntwo", "val02", "linball", "insTwo", "ins2", "in02", "inn256", " in3", "linTwo", " inTwo", "insball", "ins3", "inn02", "ins02", "instwo", "inn2", "inball", " in02", "val2", "lin3"], "pattern2": ["Pattern4", "formatcel", "expression1", "pattern1", "url22", "cher2", "stringtwo", "string22", "format2", "Patterncel", "expressiontwo", "pattern22", "urltwo", "string1", "expression22", "pattern4", "chercel", "patterncel", "expression2", "format4", "Pattern2", "patterntwo", "string2", "cher4", "url1"], "matcher2": [" matacher3", "matpatch52", " matcher3", "patcher1", "matcher1", "matter1", "mather4", "matacher3", " matter2", "matter52", " matcher52", "mather5", "matched4", "patcher2", "matter4", " matacher1", "matacher2", "matter5", "mather2", "matcher52", " matcher1", "pather5", "mather3", "matacher1", "matchers2", "matchers52", "matcher3", "matcher4", "pather4", "patcher5", "matter2", "matched1", "matacher4", " matcher4", "matched2", "pather1", "matter3", "pather2", " matacher4", "matcher5", "matpatch2", " matacher2", "mather1", " matter52", "matched5", "patcher4"]}}
{"id1": "6066145", "id2": "12116028", "code1": "    public void copy(String source, String target) throws IOException {\n        @Cleanup FileChannel sourceChannel = new FileInputStream(new File(source)).getChannel();\n        @Cleanup FileChannel targetChannel = new FileOutputStream(new File(target)).getChannel();\n        targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        File inputFile = new File(args[0]);\n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));\n        StringBuffer stringBuffer = new StringBuffer();\n        String readed;\n        while ((readed = reader.readLine()) != null) stringBuffer.append(readed + \"\\r\\n\");\n        readed = stringBuffer.toString();\n        reader.close();\n        File outputFile = new File(args[0] + \".output\");\n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));\n        readed = readed.replaceAll(\"\\\\t+\", \"#\");\n        readed = readed.replaceAll(\"\\\\s*#\\\\s*\", \"#\");\n        readed = readed.replaceAll(\"Latitude,.*\", \"\");\n        readed = readed.replaceAll(\"Flag of\", \"\");\n        readed = readed.replaceAll(\"^\\\\s+$\", \"\");\n        writer.write(readed);\n        writer.close();\n    }\n", "label": 1, "substitutes": {"source": ["parent", "site", "id", "url", "input", "reference", "core", "origin", "src", "from", "view", "Source", "base", "stream", "resource", "slave", "server", "address", "inner", "name", "scope", "ource", "SOURCE", "slice", "string", "path", "image", "index", "seed", "file", "uri", "code", "search", "service", "current", "scene", "start", "proxy", "use", "unit"], "target": ["next", "parent", "write", "rel", "reference", "download", "top", "result", "output", "src", "effect", "join", "out", "object", "end", "base", "to", "remote", "resource", "master", "compatible", "address", "dest", "Target", "force", "filename", "name", "it", "large", "cross", "other", "text", "string", "path", "file", "replace", "goal", "reset", "blank", "proxy", "platform", "arget"], "sourceChannel": ["sourceConnection", "resourcechannel", "inputClient", " sourceChan", " sourceButton", "ourceButton", "ourceQueue", "sourceChan", "resourceChannel", " sourceConnection", " sourceClient", "targetQueue", " sourceQueue", "targetClient", "ourceChan", " sourceScope", "inputChannel", " sourcechannel", "targetChan", "targetConnection", "resourceConnection", "targetchannel", "inputChan", "sourceButton", "ourceChannel", "sourceQueue", "targetScope", "sourceClient", "resourceChan", "inputScope", "targetButton", "sourcechannel", "sourceScope"], "targetChannel": ["sourceConnection", "sourceChan", " targetChan", "TargetClient", "targetClient", "Targetchannel", "TargetConnection", "TargetChan", "targetChan", "targetConnection", "targetchannel", "sourceClient", "sourcechannel", " targetClient", "TargetChannel", " targetConnection", " targetchannel"]}}
{"id1": "11902597", "id2": "3109016", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Start filtering zgps...\");\n        final Config config = Gbl.createConfig(args);\n        final String CONFIG_MODULE = \"GPSFilterZGPS\";\n        File sourceFileSelectedStages = new File(config.findParam(CONFIG_MODULE, \"sourceFileSelectedStages\"));\n        File sourceFileZGPS = new File(config.findParam(CONFIG_MODULE, \"sourceFileZGPS\"));\n        File targetFile = new File(config.findParam(CONFIG_MODULE, \"targetFile\"));\n        System.out.println(\"Start reading selected stages...\");\n        FilterZGPSSelectedStages selectedStages = new FilterZGPSSelectedStages();\n        selectedStages.createSelectedStages(sourceFileSelectedStages);\n        System.out.println(\"Done. \" + selectedStages.getSelectedStages().size() + \" stages were stored\");\n        System.out.println(\"Start reading and writing zgps...\");\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFileZGPS)));\n            BufferedWriter out = new BufferedWriter(new FileWriter(targetFile));\n            out.write(in.readLine());\n            out.newLine();\n            String lineFromInputFile;\n            while ((lineFromInputFile = in.readLine()) != null) {\n                String[] entries = lineFromInputFile.split(\"\\t\");\n                if (selectedStages.containsStage(Integer.parseInt(entries[0]), Integer.parseInt(entries[1]), Integer.parseInt(entries[2]))) {\n                    out.write(lineFromInputFile);\n                    out.newLine();\n                    out.flush();\n                }\n            }\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find source file for selected stages.\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.out.println(\"IO Exception while reading or writing zgps.\");\n            e.printStackTrace();\n        }\n        System.out.println(\"Done.\");\n    }\n", "code2": "    private void copySon(File parent) {\n        System.out.println(\"parent---\" + parent.getAbsolutePath());\n        if (parent.isDirectory() && !\".svn\".equals(parent.getName())) {\n            File cases = new File(parent, \"cases\");\n            if (cases.exists()) {\n                File answers = new File(parent, \"answers\");\n                if (!answers.exists()) {\n                    answers.mkdir();\n                    File answers_linux = new File(parent, \"answers_linux\");\n                    for (File file : answers_linux.listFiles()) {\n                        if (file.isDirectory()) {\n                            continue;\n                        }\n                        File target = new File(answers, file.getName());\n                        try {\n                            IOUtils.copy(new FileInputStream(file), new FileOutputStream(target));\n                        } catch (Throwable t) {\n                            t.printStackTrace();\n                        }\n                    }\n                }\n            } else {\n                for (File son : parent.listFiles()) {\n                    System.out.println(\"parent---\" + son.getAbsolutePath());\n                    copySon(son);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"config": ["host", "Config", "url", "queue", "default", "connection", "cf", "settings", "output", "conn", "view", "Configuration", "con", "license", "app", "b", "driver", "bc", "client", "bug", "console", "f", "loader", "data", "system", "sc", "ctx", "info", "exec", "conf", "module", "gui", "init", "rc", "project", " Config", "log", "spec", "text", "ini", "ch", "lc", "cfg", "utils", "cache", "c", "file", "context", "load", "g", "support", "fig", "service", "manager", "front", "ca", "ext"], "CONFIG_MODULE": ["CONFIG_FORMUL", "CONFIG_Modules", "CONFIG_MOules", "CONFIG_MSUL", "CONFIG_MODAGE", "CONFIG_ModUME", "CONFIG_MODRIPT", "CONFIG_ModRIPT", "CONFIG_ModLE", "CONFIG_REGule", "CONFIG_ModUL", "CONFIG_MOUME", "CONFIG_FORMLE", "CONFIG_ModULE", "CONFIG_MRAGE", "CONFIG_MODLE", "CONFIG_MSule", "CONFIG_FORMULE", "CONFIG_MODules", "CONFIG_MOule", "CONFIG_MRRIPT", "CONFIG_METHODRIPT", "CONFIG_MRule", "CONFIG_MSULE", "CONFIG_REGLE", "CONFIG_METHODAGE", "CONFIG_MOULE", "CONFIG_Module", "CONFIG_FORMule", "CONFIG_REGUL", "CONFIG_MODule", "CONFIG_MSUME", "CONFIG_REGULE", "CONFIG_MRULE", "CONFIG_MODUL", "CONFIG_METHODule", "CONFIG_ModAGE", "CONFIG_METHODULE", "CONFIG_MODUME"], "sourceFileSelectedStages": ["sourceFileSelectedStrays", "sourceFileSelectedEstores", "sourceFileSelectedSTages", "sourceFileSearedStacks", "sourceFileSelectedSTaging", "sourceFileSelectedSTores", "sourceFileSelectedstases", "sourceFileSelectedSTays", "sourceFileSelectedStaging", "sourceFileSelectedRaging", "sourceFileSelectedRarts", "sourceFileSelectedTaging", "sourceFileSelectedRacks", "sourceFileSelectionstays", "sourceFileSearedSTarts", "sourceFileSelectedStays", "sourceFileSelectedTages", "sourceFileSelectionstages", "sourceFileSelectedSTacks", "sourceFileSelectedTacks", "sourceFileSelectedStacks", "sourceFileSearedStages", "sourceFileSelectionStases", "sourceFileSelectedstays", "sourceFileSearedSTages", "sourceFileSelectionStages", "sourceFileSelectionstaging", "sourceFileSelectedEstages", "sourceFileSelectedStrores", "sourceFileSelectedStarts", "sourceFileSelectionStaging", "sourceFileSelectedRages", "sourceFileSelectionStores", "sourceFileSelectedTarts", "sourceFileSelectedStrages", "sourceFileSelectionstores", "sourceFileSelectedstages", "sourceFileSearedStaging", "sourceFileSelectedStraging", "sourceFileSearedStarts", "sourceFileSelectedStases", "sourceFileSelectedEstases", "sourceFileSelectedStores", "sourceFileSelectedstaging", "sourceFileSearedSTacks", "sourceFileSelectedEstays", "sourceFileSelectionstases", "sourceFileSearedSTaging", "sourceFileSelectionStays", "sourceFileSelectedSTarts", "sourceFileSelectedstores"], "sourceFileZGPS": ["sourceFileYGeAPS", "sourceFileZGPPs", "sourceFileZGPps", "sourceFileZGUPC", "sourceFileZXGPFS", "sourceFileYGPC", "sourceFileYGPS", "sourceFileYGps", "sourceFileYGeps", "sourceFileZGPC", "sourceFileZXGFS", "sourceFileZXGPRS", "sourceFileZGFS", "sourceFileZXGPS", "sourceFileZDPS", "sourceFileXGPC", "sourceFileZGPRS", "sourceFileZGPAPS", "sourceFileZGeps", "sourceFileYGePC", "sourceFileZGps", "sourceFileXGUps", "sourceFileZXGRS", "sourceFileZDRS", "sourceFileZGPPC", "sourceFileXGUPC", "sourceFileZDFS", "sourceFileZGePs", "sourceFileZXGPPC", "sourceFileYGePS", "sourceFileZGUPS", "sourceFileXGps", "sourceFileZGPs", "sourceFileZGURS", "sourceFileZDPC", "sourceFileZGePS", "sourceFileXGUPS", "sourceFileZGRS", "sourceFileZGUFS", "sourceFileZGUps", "sourceFileZGUPs", "sourceFileXGPS", "sourceFileXGUPs", "sourceFileZGPFS", "sourceFileZGUAPS", "sourceFileXGPs", "sourceFileZGAPS", "sourceFileZGPPS", "sourceFileZGePC", "sourceFileZXGPC", "sourceFileZXGPPS", "sourceFileZGeAPS", "sourceFileYGAPS"], "targetFile": ["sourceDir", "effectWriter", " targetFILE", "targetFILE", "TargetFile", "defaultPath", "effectPath", "outputFile", "Targetfile", "outputFiles", "defaultFile", "sourcefile", " targetWriter", "targetPath", "sourceFile", "effectfile", "targetFiles", "defaultFILE", "targetfile", "targetWriter", "sourceFiles", " targetDir", "TargetPath", "sourcePath", " targetfile", " targetFiles", " targetPath", "outputDir", "effectFile", "targetDir", "defaultfile", "outputPath", "TargetFILE", "sourceWriter"], "selectedStages": ["selectedStrays", " selectedstarts", "selectedStides", "selectedSlags", "selectedMessarts", " selectedStags", " selectedStasks", "selectedstags", " selectedstages", "selectedStases", " selectedStacks", "selectedStrags", "selectedstides", "namedstages", "selectedSlases", " selectedStases", "selectedSTacks", " selectedStides", " selectedstasks", "namedstays", " selectedstags", "selectedSTarts", " selectedstides", "selectedStacks", "selectedStreamages", "namedStags", "selectedStreamides", "selectedstacks", "selectedStasks", "selectedstages", "selectedStags", "namedstags", "namedStores", "selectedStrases", " selectedstacks", "selectedSTags", "namedStages", "selectedStores", " selectedstases", "selectedSTases", "selectedstarts", "selectedstasks", "selectedMessags", "namedStays", "selectedSTasks", "selectedMessages", "selectedSTages", "selectedstores", "selectedStrores", "selectedStarts", "selectedStrages", " selectedStarts", "namedstores", "selectedstays", "selectedStays", "selectedStrides", "selectedStreamases", "selectedstases", "selectedSlages", "selectedMessacks", "selectedSlasks"], "in": ["get", "reader", "h", "id", "url", "input", "inc", "din", "token", "win", "min", "nin", "conn", "l", "con", "b", "diff", "part", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "re", "thin", "into", "serv", "isin", "inner", "er", "init", "it", "ins", "e", "t", "gin", "ini", "a", "ex", "image", "cin", "lock", "socket", "i", "IN", "inside", "err", "g", "inn", "or", "lin", "bin", "line"], "out": ["default", "wrapper", "net", "down", "extra", "doc", "over", "Out", "r", "call", "writer", "sys", "sync", "name", "log", "flush", "post", "cli", "temp", "image", "list", "obj", "file", "err", "group", "store", "line", "msg", "co", "io", "outer", "conn", "lib", "pre", "b", "part", "gen", "to", "table", "OUT", "exp", "bar", "ex", "key", "all", "point", "pool", "cache", "at", "copy", "ext", "page", "parent", "plain", "size", "inc", "write", "user", "client", "cmd", "f", "n", "work", "server", "raw", "sum", "exec", "o", "comment", "v", "error", "builder", "output", "view", "w", "dump", "state", "data", "again", "outs", "prefix", "serv", "inner", "query", "password", "gin", "session", "up", "window", "lock", "socket", "code", "bin"], "lineFromInputFile": ["lineFromOutputStream", "lineFromOutputFile", "lineFromSourceFile", "lineFrominputFiles", "lineToOutputFile", "lineFromOriginalLine", "linefromInputMessage", "lineFromRawDirectory", "linefromSourceLine", "linefrominputStream", "lineFromOriginalMessage", "linefromInputFile", "lineFromInputStream", "lineFromSourceDirectory", "lineFromInputFiles", "lineFrominputPlace", "lineFrominputFile", "lineFromInputPlace", "lineFrominputDirectory", "lineFromSourceLine", "lineToInputPlace", "lineFromOriginalFile", "lineFromOriginalStream", "lineFrominputStream", "lineToInputLine", "lineToOutputPlace", "lineToInputStream", "lineFromOutputMessage", "linefromInputFiles", "lineFromOutputPlace", "linefromSourceStream", "lineFromSourceFiles", "lineFromOutputLine", "linefromSourceFile", "lineFrominputMessage", "lineToOutputLine", "lineToInputFile", "linefromInputLine", "linefromInputStream", "lineFrominputLine", "linefrominputFiles", "linefrominputMessage", "lineFromOutputDirectory", "lineFromRawPlace", "lineFromRawFile", "lineToInputDirectory", "linefrominputFile", "lineToOutputDirectory", "lineFromSourceMessage", "lineFromRawLine", "lineToOutputStream", "linefromSourceMessage", "lineFromOriginalDirectory", "lineFromInputDirectory", "lineFromInputMessage", "lineFromOriginalFiles", "lineFromInputLine", "lineFromSourceStream"], "entries": ["endrants", "entsry", "entsrys", "endrings", "estents", "enles", "entrings", "entles", "entskeys", "entories", "contorts", "centles", "contry", "entrants", "equriers", "equents", "enries", "Entkeys", "pentrys", "centrants", "estriers", "pentkeys", "entrows", "anchrows", "endry", "entsries", "Entrys", "endorts", "entorts", "anchries", "centries", "pentries", "anchents", "pentrants", "entsrings", "entkeys", "anchriers", "Entrants", "centories", "Entries", "entrys", "enrants", "entents", "estrows", "entsorts", "entriers", "endories", "contrings", "endles", "endries", "contries", "estries", "equries", "entsrants", "equrows", "enories", "entry"]}}
{"id1": "6276684", "id2": "14134127", "code1": "    public static VersionMinorMajor fetchVersion() throws BusinessException {\n        LOG.info(\"Fetching version from url '\" + WEB_URL + \"'.\");\n        URL url = null;\n        try {\n            url = new URL(WEB_URL);\n            assert (url.getProtocol().equalsIgnoreCase(\"HTTP\"));\n        } catch (MalformedURLException e) {\n            LOG.warn(\"Invalid url '\" + WEB_URL + \"' specified!\", e);\n            throw new BusinessException(\"Tried to fetch most current version from invalid url: \" + WEB_URL);\n        }\n        try {\n            LOG.debug(\"Opening connection to webserver.\");\n            final URLConnection connection = url.openConnection();\n            final Scanner scanner = new Scanner(connection.getInputStream());\n            scanner.useDelimiter(END_OF_INPUT);\n            final String versionString = scanner.next();\n            try {\n                VersionMinorMajor version = new VersionMinorMajor(versionString);\n                LOG.debug(\"Successfully fetched version '\" + version + \"' from web.\");\n                return version;\n            } catch (Exception e) {\n                LOG.error(\"Stored version string '\" + versionString + \"' is invalid!\", e);\n                throw new BusinessException(\"Could not construct VersionMinorMajor by string '\" + versionString + \"' (url was: \" + WEB_URL + \")!\");\n            }\n        } catch (IOException e) {\n            LOG.info(\"Fetching application version failed!\", e);\n            throw new BusinessException(\"Could not get contents of url '\" + WEB_URL + \"'!\", e);\n        }\n    }\n", "code2": "    private void addFilesToExistingZip(File zipFile, String[] dirs, File[] files) throws IOException {\n        File tempFile = new File(zipFile.getAbsoluteFile() + \".temp\");\n        if (tempFile.exists()) tempFile.delete();\n        boolean renameOk = zipFile.renameTo(tempFile);\n        if (!renameOk) {\n            throw new RuntimeException(\"Could not rename the file \" + zipFile.getAbsolutePath() + \" to \" + tempFile.getAbsolutePath());\n        }\n        ZipInputStream zin = new ZipInputStream(new FileInputStream(tempFile));\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));\n        ZipEntry entry = zin.getNextEntry();\n        byte[] buf = new byte[1024];\n        while (entry != null) {\n            String entryName = entry.getName();\n            boolean inFiles = false;\n            for (int i = 0; i < files.length; i++) {\n                String fileName = dirs[i] + \"/\" + files[i].getName();\n                if (fileName.equals(entryName)) {\n                    inFiles = true;\n                    break;\n                }\n            }\n            if (!inFiles) {\n                out.putNextEntry(new ZipEntry(entryName));\n                int len;\n                while ((len = zin.read(buf)) > 0) out.write(buf, 0, len);\n            }\n            entry = zin.getNextEntry();\n        }\n        zin.close();\n        for (int i = 0; i < files.length; i++) {\n            InputStream in = new FileInputStream(files[i]);\n            out.putNextEntry(new ZipEntry(dirs[i] + \"/\" + files[i].getName()));\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            out.closeEntry();\n            in.close();\n        }\n        out.close();\n        tempFile.delete();\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "parent", "language", "id", "input", "link", "user", "browser", "feed", "download", "xml", "ll", "conn", "l", "http", "client", "internet", "bug", "layer", "base", "loc", "channel", "resource", "email", "server", "org", "address", "config", " URL", "ur", "ob", "log", "text", "sl", "bel", "course", "rule", "path", "image", "string", "cert", "uri", "file", "ssl", "context", "or", "URL", "service", "hub", "Url", "www", "blog", "proxy", "web", "domain", "coll", "location"], "connection": ["reader", "operation", "link", "open", "result", "function", "io", "conn", "l", "communication", "http", "con", "out", "client", "b", "in", "bc", " conn", "connected", "channel", "application", "number", " Connection", "stream", "response", "resource", "handler", "server", "info", "access", "name", "body", "log", "ion", "instance", "Connect", "relation", "string", "path", "image", "connect", "c", "uri", "socket", "db", "URL", "database", "character", "www", "position", "Connection"], "scanner": [" scaninner", "Scanror", "scner", " scaner", " scanker", "runener", "scanning", " scancer", "Scanener", "Scaner", "scinner", "scning", "Scaninner", "runinner", "scanror", "scer", " scanror", "scanker", "Scancer", "runner", "Scanner", "scaninner", "scanener", "scror", " scanener", " scanning", "sccer", "scancer", "scaner", "runker", "Scanker", "Scanning"], "versionString": ["versionstring", "installstring", "translationStr", "verMessage", "verNumber", "translationBuffer", "installCode", "connectionNumber", "versionMessage", " versionLibrary", "verDouble", "versionDouble", " versionCode", "verstring", "versionStr", "installString", "versionSection", "urlExp", "connectionStr", "urlLibrary", "verCode", "verBuffer", "versionBuffer", " versionStr", "connectionstring", " versionDouble", "translationLibrary", "versionLibrary", "verStr", "versionCode", "versionExp", "translationString", " versionNumber", " versionstring", "connectionString", "installMessage", "urlString", "translationDouble", "urlSection", " versionExp", "translationExp", " versionMessage", " versionBuffer", "verString", " versionSection", "versionNumber", "translationSection"], "version": ["translation", "vision", "ison", "result", "python", "Version", "model", "number", "resource", "name", "information", "beta", "release", "image", "file", "expression", "type", "position", "project", "id", "VERSION", "plugin", "ception", "build", "one", "object", "bug", "ver", "application", "class", "update", "depth", "component", "ion", "instance", "video", "value", "page", "grade", "software", "request", "cover", "serial", "server", "section", "element", "versions", "v", "string", "vert", "install", "vers", "date", "secret", "host", "hash", "download", "wire", "major", "message", "view", "format", "driver", "response", "feature", "latest", "content", "up", "code", "current", "generation", "unit"]}}
{"id1": "4955403", "id2": "13653451", "code1": "    public FetchTextFromWebPage(String path) {\n        HTMLEditorKit.Parser parser;\n        HTMLFile = new File(path);\n        byte[] html = new byte[new Long(HTMLFile.length()).intValue()];\n        try {\n            FileInputStream fis = new FileInputStream(HTMLFile);\n            try {\n                fis.read(html);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            ByteArrayInputStream ba_read = new ByteArrayInputStream(html);\n            r = new InputStreamReader(ba_read);\n        } catch (FileNotFoundException e) {\n            URL url = null;\n            try {\n                url = new URL(path);\n                URLConnection connection = null;\n                try {\n                    connection = url.openConnection();\n                    connection.setDoInput(true);\n                    InputStream inStream = null;\n                    try {\n                        inStream = connection.getInputStream();\n                        BufferedReader input = new BufferedReader(new InputStreamReader(inStream));\n                        StringBuffer sbr = new StringBuffer();\n                        String line = null;\n                        try {\n                            while ((line = input.readLine()) != null) {\n                                System.out.println(line);\n                                sbr.append(line + \"\\n\");\n                            }\n                        } catch (IOException e1) {\n                            e1.printStackTrace();\n                        }\n                        File temp = new File(\"//home//wiki14//temp.txt\");\n                        if (!temp.exists()) {\n                            if (!temp.createNewFile()) System.out.println(\"File caanot be created\");\n                        } else {\n                            temp.delete();\n                            if (!temp.createNewFile()) System.out.println(\"File caanot be created\");\n                        }\n                        java.io.FileWriter fw = new java.io.FileWriter(temp);\n                        fw.write(sbr.toString());\n                        fw.close();\n                        byte[] newbyte = new byte[new Long(sbr.length()).intValue()];\n                        ByteArrayInputStream ba_read = new ByteArrayInputStream(newbyte);\n                        r = new InputStreamReader(ba_read);\n                    } catch (IOException e1) {\n                        e1.printStackTrace();\n                    }\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n            } catch (MalformedURLException e1) {\n                e1.printStackTrace();\n            }\n        }\n        parser = new ParserDelegator();\n        htmltextparser = new HtmlTextParser();\n        htmltextparser.initData();\n        try {\n            parser.parse(r, htmltextparser, true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            r.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public ViewInitListener() throws IOException {\n        URL url = this.getClass().getResource(VIEW_INIT_CONFIG);\n        log.debug(\"Loading configuration from: \" + url);\n        config = new Properties();\n        InputStream in = url.openStream();\n        config.load(in);\n        in.close();\n    }\n", "label": 0, "substitutes": {"path": ["source", "host", "page", "folder", "pdf", "route", "txt", "xml", "download", "src", "format", "PATH", "Path", "base", "p", "href", "data", "directory", "resource", "prefix", "handler", "template", "ath", "filename", "name", "dir", "pattern", "text", "content", "string", "image", "pointer", "file", "uri", "title", "location", "type"], "parser": [" R", " self", " pars", " format", " router", "R", " builder", "arser", " instance", " parsed", " soup", "er", " response", "t", " rs", " config", "se", " re", " Pars", "parse", " rc", " parse", " parsing", "Parser", "p"], "HTMLFile": ["tmlFile", " HTMLSourceFile", "HTMLFolder", "WebFile", "URLFile", "HTTPFILE", " HTMLStyle", "WebFolder", " HTMLfile", "HTMLReader", "htmlSourceFile", "DBFile", "htmlfile", "tmlfile", "tmlSourceFile", "WebFILE", "HTMLfile", "URLPage", " HTMLPage", "HTMLFILE", "DBFILE", " HTMLFILE", "HTTPfile", "DBPage", "tmlReader", "HTTPFolder", "URLFolder", "Webfile", "HTMLPage", "HTTPFile", " HTMLReader", "HTMLSourceFile", "HTMLStyle", "URLfile", "htmlFile", "htmlReader", "URLStyle", "DBStyle", "URLFILE"], "html": ["source", "page", "HTML", "h", "link", "htm", "xml", "message", "output", "doc", "view", "format", "http", "css", "f", "javascript", "tf", "href", "summary", "base", "style", "zip", "template", "body", "php", "json", "ph", "api", "text", "document", "live", "db", "title", "uri", "details", "file", "array", "header", "tml", "img", "www", "web", "sl"], "fis": ["filehas", "frhas", "fris", " fbis", " fhas", " fIs", "fileis", "lais", "fbis", "fiss", "fais", "hais", "frisi", "fhas", "filebis", "fileisi", "hIs", "fIs", " fisi", "his", "hiss", "lis", "liss", " fais", "frbis", " fiss", "fisi", "lIs"], "ba_read": ["ba_add", "BA_count", "ba___view", "BA_add", "ba_feed", "ba_sync", "bal_read", "bal_parse", "na_view", "bal_config", "ba_view", "ba_find", "BA_find", "ba_reader", "ba_run", "ba_count", "ba___feed", "na_read", "ba___read", "ba_write", "ba_parse", "ba_config", "BA_read", "BA_reader", "ba___sync", "BA_write", "na_feed", "na_sync", "BA_run", "bal_find"], "r": ["reader", "h", "d", "result", "R", "br", "ro", "l", "w", "b", "f", "re", "n", "resource", "ir", "er", "it", "u", "e", "o", "s", "res", "t", "rs", "sr", "pr", "m", "v", "c", "i", "g", "ar", "str", "rb", "p"], "url": ["source", "host", "page", "left", "link", "user", "feed", "conn", "l", "http", "control", "client", "b", "base", "f", "stream", "resource", "server", "config", "address", "log", "location", "li", "string", "image", "connect", "cache", "socket", "file", "uri", "ssl", "URL", "manager", "Url", "position", "www", "proxy", "web", "coll", "sl"], "connection": ["reader", "open", "cf", "function", "io", "conn", "l", "communication", "http", "con", "out", "in", "client", "union", "bc", "control", "controller", "connected", "channel", "loc", "application", "to", "stream", "response", "resource", "handler", "server", "config", "condition", "section", "body", "log", "bridge", "password", "ion", "relation", "string", "image", "connect", "cache", "c", "uri", "context", "socket", "URL", "character", "database", "manager", "which", "position", "Connection", "proxy", "coll"], "inStream": ["innerStream", "binStream", "inBuffer", "pinStream", "inCh", "INCh", " inStreamer", "pinBuffer", "innerStreamer", "inReader", "pinSteam", " instream", " inBuffer", "insSteam", "insReader", "binstream", "inSteam", "INSteam", "outSt", "outstream", "inStreamer", "inSt", "insStream", "innerBuffer", "innerSteam", "instream", " inSteam", "INStream", "outStream", " inCh", "outCh", "binSt", "InStream", " inSt", "pinStreamer", "INReader", "InCh", "InSteam", "binCh", "insCh", "InReader"], "input": ["source", "reader", "inc", "operator", "buffer", "xml", "pull", "io", "output", "iterator", "l", "conn", "http", "out", "in", "inf", "client", "this", "request", "f", "data", "ruby", "stream", "storage", "resource", "raw", "config", "Input", "text", "instance", "inch", "image", "connect", "ssl", "context", "i", "inside", "form", "s", "null"], "sbr": ["scr", "fbm", "fbre", "bhr", "bcr", "Sbsp", "sbl", "sbm", "fhr", "setsrb", "Sbr", " sbsp", "ansbsp", "fBR", "ansbr", " shr", "Shr", "sBR", "shr", "setsbr", "bbr", "srb", "fbr", " srb", " sbre", " sbl", "Srb", "bBR", "sbre", "ansbl", "anshr", " sbm", "SBR", "fcr", "Sbl", "setsBR", "bbre", "setsbsp", " scr", "sbsp", " sBR", "bbm"], "line": ["page", "sel", "value", "link", "len", "lf", "space", "lines", "iter", "message", "l", "letter", "stroke", "jo", "object", "char", "end", "LINE", "cell", "lined", "Line", "part", "base", "f", "row", "data", "pin", "model", "inline", "no", "zip", "raw", "word", "sync", "name", "liner", "ge", "log", "non", "cl", "text", "comment", "lc", "li", "key", "col", "le", "string", "frame", "pass", "parse", "code", "character", "header", "block", "lin", "str", "sl", "entry"], "temp": ["folder", "parent", "tmp", "export", "txt", "office", "buffer", "porary", "now", "output", "flat", "io", "format", "original", "w", "out", "fake", "home", "this", "fd", "stable", "part", "base", "f", "loc", "data", "directory", "tem", "table", "storage", "zip", "single", "thin", "clean", "config", "template", "wrap", "store", "Temp", "testing", "tx", "full", "cel", "tc", "api", " temporary", "cache", "file", "c", "font", "emp", "current", "local", "form", "empty", "test", "null", "unit"], "fw": ["hw", "wal", "win", "ht", "cf", "nw", "wire", "wk", "io", "widget", "wx", "fc", "ew", "w", "wd", "out", "fp", "sw", "wa", "fd", "fr", "f", "tf", "work", "ctx", "writer", "wrap", "wp", "W", "fly", "fn", "wl", "rh", "fl", "ow", "rw", "file", "flo", "wb", "fb", "war", "FW", "img", "ff", "iw", "usr", "wt"], "newbyte": ["newsmor", " newletter", "NewByte", " Newword", "newsword", "NEWword", "Newbyte", "NEWbyte", "newletter", " Newbyte", "newmor", " Newpixel", "NEWpixel", "newword", "newpixel", "newByte", "Newpixel", " NewByte", " newmor", "Newword", "NEWletter", "newsletter", "newsbyte", " newword", "NEWmor", "NEWByte"]}}
{"id1": "6413929", "id2": "672082", "code1": "    public HogsCustomizer() {\n        m_filename = PathFinder.getCustsFile();\n        m_currenttaunts = new String[10];\n        m_textfields = new JTextField[10];\n        m_color = new Color(255, 255, 255);\n        boolean exists = (new File(m_filename)).exists();\n        m_inverted = false;\n        m_chooser = new JColorChooser();\n        AbstractColorChooserPanel[] panels = m_chooser.getChooserPanels();\n        m_chooser.removeChooserPanel(panels[0]);\n        m_chooser.removeChooserPanel(panels[2]);\n        m_chooser.setPreviewPanel(new JPanel());\n        Reader reader = null;\n        if (exists) {\n            try {\n                reader = new FileReader(m_filename);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        } else {\n            Object[] options = { \"Yes\", \"No, Thanks\" };\n            int n = JOptionPane.showOptionDialog(this, \"You do not have a customization file in your home directory.\\n                 \" + \"Would you like to create one?\", \"Hogs Customization\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n            if (n == 0) {\n                try {\n                    FileChannel srcChannel = new FileInputStream(HogsConstants.CUSTS_TEMPLATE).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(m_filename).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    System.exit(0);\n                }\n            } else {\n                System.exit(0);\n            }\n            try {\n                reader = new FileReader(m_filename);\n            } catch (FileNotFoundException e1) {\n                e1.printStackTrace();\n                System.exit(0);\n            }\n        }\n        try {\n            readFromFile(reader);\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n        Box mainpanel = Box.createVerticalBox();\n        mainpanel.add(buildTauntsPanel());\n        mainpanel.add(buildMouseStylePanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        mainpanel.add(buildColorPanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        mainpanel.add(buildButtonsPanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setContentPane(mainpanel);\n        this.pack();\n        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n        this.setLocation(dim.width / 2 - (this.getWidth() / 2), dim.height / 2 - (this.getHeight() / 2));\n        this.setTitle(\"Hogs Customizer\");\n        this.setVisible(true);\n    }\n", "code2": "    public boolean copyOneOfMyFile(File f, String dest) {\n        if (!ownsThisFile(f.getName())) return false;\n        if (!dest.endsWith(File.separator)) dest = dest.concat(File.separator);\n        try {\n            BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(new File(dest + f.getName())));\n            BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n            int len = 1024;\n            byte[] read = new byte[len];\n            while ((len = in.read(read)) > 0) out.write(read, 0, len);\n            out.flush();\n            out.close();\n            in.close();\n            if (!PatchManager.mute) System.out.println(\"file created : \" + dest + f.getName());\n        } catch (IOException e) {\n            System.out.println(\"copy directory : \" + e);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"m_filename": ["m_location", "M_selection", "m__source", "mockpath", "m___directory", "rm_username", " m_source", "m_resource", "m__file", " m_file", "m_file", "rmOCKfilename", "mOCKusername", "rmOCKnom", "mocknom", "m_path", "m2directory", "m2filename", "p_filename", "m___file", " m_directory", "M_url", "p_content", "mOCKfilename", "m2content", "m_content", "rm_nom", " m__directory", "m_url", "mockusername", " m__source", "rm_path", " m__filename", " m__file", "mockfilename", "m_nom", "M_directory", "p_directory", "mOCKpath", "m_username", "m__directory", "M_username", "m__filename", "m___filename", "m_directory", "rmOCKpath", "m2location", "m___source", "M_resource", "m_selection", "mOCKnom", "p_location", "rm_filename", "rmOCKusername", "m_source", "M_filename"], "m_currenttaunts": ["m_currentTitle", "m_currentxtidy", "m_contenttpl", "m_currenttitle", "m_currentfontidy", "m_currenttitles", "m_currentxtpl", "m_contentfontpl", "m_currentTitles", "m_currentfontitle", "m_currentxtitle", "m_contenttitles", "m_currenttpl", "m_currenttidy", "m_contenttidy", "m_contentfontitles", "m_contentfontitle", "m_contentfontidy", "m_contenttitle", "m_currentfontitles", "m_currentfontpl", "m_currentxtitles", "m_currentTidy", "m_currentTpl"], "m_textfields": ["m_inputfields", "m_textboxes", "m_fontfields", "m_buttons", "m_buttonfield", "m_fontboxes", "m_inputfield", "m_texts", "m_fonts", "m_fontfield", "m_buttonboxes", "m_inputboxes", "m_textfield", "m_buttonfields", "m_inputs"], "m_color": ["m__color", "M__background", "M__bg", "M_color", "M_theme", "M__theme", "m__theme", "m__background", "m_background", "M_background", "m_bg", "M_bg", "m__bg", "M__color", "m_theme"], "exists": [" existence", "expist", "existitions", "exits", "Exits", "exist", "Exists", "existence", "EXits", "Exceptions", "expails", "EXist", "existizes", "EXists", "fist", "exizes", "Exizes", "fists", "Exist", "exitions", "existists", "existinates", "EXinates", " exits", "Exinates", "EXistence", "Existence", "EXizes", "exceptions", "fails", "expitions", "exails", "exinates", "existist", "existails", "fitions", "expists", "EXceptions", " exceptions"], "m_chooser": ["m_colosing", "m_close", "m_joose", "m_suppinder", "m_compicker", "m_joerer", "m_choose", "m_boosed", "m_noicker", "m_boer", "m_boinder", "m_joosed", "mockchoinder", "mockboinder", "m_composer", "m_colosite", "m_choer", "m_booser", "m_defosite", "mockchooser", "mockchoerer", "m_composed", "m_noose", "m_noosing", "m_comperer", "m_closing", "mockbooser", "m_choinder", "m_cler", "m_boicker", "m_deferer", "m_boose", "m_choosed", "m_compose", "m_composing", "mockboerer", "m_boerer", "m_supposite", "m_choosing", "m_jooser", "m_composite", "mockboosite", "m_boosing", "m_nooser", "m_definder", "m_choosite", "m_defoser", "mockchoosite", "m_closer", "m_boosite", "m_coloser", "m_supposer", "m_colose", "m_supperer", "m_choicker", "m_choerer"], "panels": ["panagers", "Panels", "Panars", "panes", "panars", "panators", "panices", "polels", "Panors", "cholets", "Panes", "parenices", "spanagers", "choators", "Panlets", "parenels", "polars", "choels", "panlets", "spanels", "panors", "choes", "choagers", "colators", "polices", "Panators", "spanices", " panices", "coles", "polors", "parenors", "choices", "spanes", " panagers", " panes", "Panices", "parenars", "colels", "collets"], "reader": ["source", "read", "h", "draft", "input", "wrapper", "rx", "Reader", "feed", "connection", "buffer", "result", "iter", "player", "io", "ry", "driver", "ler", "client", "lr", "part", "row", "f", "loader", "data", "worker", "stream", "r", "resource", "handler", "server", "author", "writer", "inner", "er", "rc", "e", "reading", "per", "parser", "instance", "dr", "key", "book", "ri", "image", "library", "file", "or", "service", "manager", "rr", "value", "null", "entry"], "options": ["opens", "comments", "value", "Options", "none", "open", "settings", "lines", "io", "optional", "example", "items", "params", "object", "types", "data", "no", "choice", "style", "multiple", "objects", "es", "changes", "info", "groups", "results", "e", "other", "o", "values", "text", "names", "content", "ops", "obj", "html", "details", "times", "files", "zero", "empty", "option", "ts", "ps", "s", "p", "type"], "n": ["en", "num", "nl", "ln", "d", "l", "y", "out", "b", "ns", "f", "number", "r", "ni", "dn", "nor", "adj", "ne", "u", "o", "s", "e", "nt", "fn", "t", "m", "nu", "norm", "count", "N", "don", "j", "c", "i", "g", "un", "pn", "nb", "sn", "z", "nc", "p"], "srcChannel": ["instChannel", "destClient", "srcchannel", "instGate", "inputClient", "inputButton", "srcClient", " srcButton", "rcChan", " srcChan", "destChan", "srcServer", "inputConnection", " srcServer", " srcStream", " srcConnection", "destchannel", "rcchannel", "srcChan", "rcChannel", " srcGate", "instStream", "inputChannel", "instChan", "inputchannel", "distChannel", "destServer", "destConnection", "inputChan", "rcConnection", "destChannel", "distChan", "distGate", "srcGate", "srcStream", "inputServer", " srcchannel", " srcClient", "rcButton", "distStream", "srcConnection", "srcButton"], "dstChannel": ["DndMessage", "ddestChan", "dstsChan", "ddestchannel", "DndButton", "Ddestchannel", "dostChannel", "dirstchannel", "DstButton", "ddestChannel", "drcChannel", "dndchannel", "DstChan", "dndContext", "dstFlow", "dostChan", "dndMessage", "drcMessage", "dirstChan", "dstContext", "DstChannel", "dostchannel", "dsrcchannel", "DdestFlow", "DstMessage", "dstButton", "Dstschannel", "Dndchannel", "dstsFlow", "DstFlow", "dstChan", "DndChannel", "dstMessage", "DstsContext", "dstsContext", "dndChan", "dstschannel", "drcchannel", "dsrcChannel", "drcButton", "dirstFlow", "dostContext", "DstsChan", "ddestFlow", "dsrcMessage", "dndChannel", "dirstChannel", "DstContext", "dsrcButton", "Dstchannel", "DdestChan", "DstsChannel", "DdestChannel", "dstchannel", "dndButton", "dstsChannel"]}}
{"id1": "15634393", "id2": "20841292", "code1": "    public boolean copyStoredTileTo(File targetFileName, int x, int y, int zoom, MapSource tileSource) throws IOException {\n        File sourceFile = getTileFile(x, y, zoom, tileSource);\n        if (!sourceFile.exists()) return false;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        long sourceBytes = 0;\n        long writtenBytes = 0;\n        try {\n            fis = new FileInputStream(sourceFile);\n            fos = new FileOutputStream(targetFileName);\n            FileChannel source = fis.getChannel();\n            FileChannel destination = fos.getChannel();\n            sourceBytes = source.size();\n            writtenBytes = destination.transferFrom(source, 0, sourceBytes);\n        } finally {\n            Utilities.closeStream(fis);\n            Utilities.closeStream(fos);\n        }\n        if (writtenBytes != sourceBytes) throw new IOException(\"Target file's size is not equal to the source file's size!\");\n        return true;\n    }\n", "code2": "    public void fileCopy(File src, File dest) throws IOException {\n        if (!dest.exists()) {\n            final File parent = new File(dest.getParent());\n            if (!parent.exists() && !parent.mkdirs()) {\n                throw new IOException();\n            }\n            if (!dest.createNewFile()) {\n            }\n        }\n        FileInputStream is = null;\n        FileOutputStream os = null;\n        try {\n            is = new FileInputStream(src);\n            os = new FileOutputStream(dest);\n            final FileChannel srcChannel = is.getChannel();\n            final FileChannel dstChannel = os.getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } finally {\n            try {\n                if (is != null) {\n                    is.close();\n                }\n            } finally {\n                if (os != null) {\n                    os.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"targetFileName": [" targetfilePath", " targetfileNAME", "TargetfilePath", "targetTablePath", "TargetfileUrl", "TargetFilePath", "targetfilePath", "TargetfileName", "targetfileUrl", "targetfileAddress", "targetFilenameNAME", "targetTableName", "targetFileAddress", "TargetFileName", " targetfileName", "targetFileUrl", "targetRoutePath", " targetfileAddress", "targetRouteName", " targetFilePath", "targetFilenameAddress", "targetLogAddress", "targetFilenamePath", "targetTableUrl", "targetFilenameName", " targetFileNAME", "targetFileNAME", "TargetFileUrl", "targetLogPath", "targetfileNAME", "targetfileName", " targetFileAddress", "targetRouteUrl", "targetLogName", "targetFilePath", "targetLogNAME"], "x": ["px", "host", "en", "d", "rx", "l", "w", "in", "b", "xy", "f", "X", "tx", "name", "xs", "ix", "a", "ex", "xi", "v", "time", "col", "index", "image", "c", "dx", "i", "width", "pos", "z", "on", "p", "lat"], "y": ["Y", "h", "py", "d", "cy", "yt", "ry", "l", "yi", "w", "b", "zy", "xy", "yy", "ny", "f", "o", "yd", "ch", "m", "yl", "ey", "time", "col", "dy", "c", "i", "ye", "type", "vy", "sy", "oy", "z", "ya", "ip", "p", "ie"], "zoom": ["tzom", "zhooming", "gzoom", " zdepth", "tzooming", "gzow", "zow", "zooming", "zhom", " zooming", "tzoom", "gzom", "zom", "gzdepth", "gzooming", "zhoom", "zdepth", "tzow", "tzdepth", "zhow"], "tileSource": ["TileSource", "TileService", "themeSourceFile", "multiSources", "tileSources", "themeSOURCE", "tileFile", "tileSourceFile", "mapFile", "mapSource", "mapService", " tileService", " tileSourceFile", "mapSources", " tileSources", "TileFile", "tileSOURCE", "multiSOURCE", "themeSources", " tileSOURCE", " tileFile", "tileService", "TileSources", "themeSource", "multiSource", "multiSourceFile"], "sourceFile": ["sourceDir", "ourceDirectory", "parentFile", "parentPlace", "srcF", "srcfile", "parentFiles", "ourcefile", " sourceFiles", "ourceFile", " sourcePath", "targetPlace", "sourceF", " sourceDirectory", "sourcefile", "switchF", "sourcePlace", "targetFiles", "parentfile", "targetfile", "switchPath", "sourceFiles", "sourcePath", " sourcePlace", " sourceF", "targetFile", "srcFile", " sourcefile", "targetDirectory", "targetDir", " sourceDir", "switchFile", "sourceDirectory", "switchfile", "ourceDir", "srcPath"], "fis": ["sfos", "Fics", " fs", "tos", "fs", "Fos", "Fiss", "FIS", "fiss", "fIS", "sfs", "infics", "fsos", " fists", "fsisa", "infos", "fios", "fists", "sfis", "fsis", "infisa", " fios", "fics", "infists", "infiss", "Fis", "tis", "infIS", "Fs", " fas", "infis", " fIS", "Fisa", "sfios", "fsics", "Fios", "infas", "fisa", "tists", "tas", " fiss", "fas"], "fos": ["sfos", " fot", "infoss", " fo", " foes", "flaos", "feios", "flos", "foss", "sfot", "fo", " fOS", "sfaos", "Fos", "Foss", "fols", "feOS", "Fot", "infos", "Fo", "fios", "feos", "dosi", "dos", " fios", "info", "dis", "sfols", " fosi", "feot", "fot", "poes", "infols", "FOS", "Fis", "fosi", "pis", "fOS", "infis", "faos", "Fios", "pos", "infaos", "posi", "flols", " foss", "foes", "flot", "infot", "does"], "sourceBytes": ["siteBytes", " sourceSize", "targetPages", " sourcePages", "SourceSize", "SourceByte", "sourceSize", "sourceByte", "ourceByte", "sourceCharacters", "writtenSize", "ourcebytes", " sourcebytes", "targetBytes", "SourceBytes", "ourceSize", "sourcebytes", "ourceBytes", " sourceByte", "targetSize", "Sourcebytes", "ourcePages", " sourceCharacters", "targetCharacters", "sourcePages", "sitebytes", "siteCharacters", "writtenbytes", "targetbytes"], "writtenBytes": ["writeBytes", " writtenByte", " writtenCount", " writtenCode", "writtenByte", "rittenCode", "writerBytes", "rittenCount", " writtenZip", "rittenBytes", "wroteBytes", "writtenBlocks", "writtenPages", "rittenPages", "wroteZip", "writtenCode", "writerPages", "rittenZip", "rittenByte", "rittenBlocks", "writtenbytes", "sourcebytes", " writtenbytes", "writtenZip", "sourceBlocks", "wrotebytes", "rittenbytes", "writerBlocks", "writerbytes", "writeCode", "sourcePages", "writeByte", "writtenCount", "writebytes", "wroteCount"], "source": ["plus", "parent", "route", "size", "reader", "site", "id", "input", "si", "connection", "reference", "core", "result", "origin", "output", "src", "from", "original", "out", "in", "client", "Source", "this", "channel", "base", "data", "stream", "storage", "single", "remote", "resource", "slave", "master", "config", "info", "ources", "dest", "Target", "ui", "scope", "target", "unit", "ource", " sources", "temp", "status", "sin", "SOURCE", "slice", "string", "index", "secure", "file", "uri", "search", "service", "current", "type", "scene", "local", "start", "proxy", "use", "ie"], "destination": ["descinations", " destinator", " destinations", "Destining", "continion", " destining", "contininator", "continining", "describution", " destion", "Destion", "Destinator", "continination", "destinations", " destation", "Destinations", " destribution", "Destation", "destion", "destribution", "destinator", "descation", "descination", "destation", "destining", "Destination", "Destribution"]}}
{"id1": "3897603", "id2": "12822637", "code1": "    public void updateDBModel(Tasks task) throws Exception {\n        task.setOperationName(\"Updating DB Model..\");\n        int localVersion = getLocalModelVersion();\n        int currentVersion = 0;\n        try {\n            currentVersion = getModelVersion();\n        } catch (SQLException e) {\n            if (e.getErrorCode() != 1146) {\n                throw e;\n            }\n        }\n        boolean autoCommit = getConn().getAutoCommit();\n        try {\n            getConn().setAutoCommit(false);\n            for (int version = currentVersion + 1; version <= localVersion; version++) {\n                task.setStatus(\"Updating to version \" + version);\n                InputStream in = EDACCApp.class.getClassLoader().getResourceAsStream(\"edacc/resources/db_version/\" + version + \".sql\");\n                if (in == null) {\n                    throw new SQLQueryFileNotFoundException();\n                }\n                executeSqlScript(task, in);\n                Statement st = getConn().createStatement();\n                st.executeUpdate(\"INSERT INTO `Version` VALUES (\" + version + \", NOW())\");\n                st.close();\n            }\n        } catch (Exception e) {\n            getConn().rollback();\n            throw e;\n        } finally {\n            getConn().setAutoCommit(autoCommit);\n        }\n    }\n", "code2": "    private void doLogin(String password) throws LoginFailedException, IncorrectPasswordException {\n        long mgr = Constants.MANAGER;\n        Data data, response;\n        try {\n            response = sendAndWait(new Request(mgr)).get(0);\n            MessageDigest md;\n            try {\n                md = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"MD5 hash not supported.\");\n            }\n            byte[] challenge = response.getBytes();\n            md.update(challenge);\n            md.update(password.getBytes(Data.STRING_ENCODING));\n            try {\n                data = Data.valueOf(md.digest());\n                response = sendAndWait(new Request(mgr).add(0, data)).get(0);\n            } catch (ExecutionException ex) {\n                throw new IncorrectPasswordException();\n            }\n            loginMessage = response.getString();\n            response = sendAndWait(new Request(mgr).add(0, getLoginData())).get(0);\n            ID = response.getWord();\n        } catch (InterruptedException ex) {\n            throw new LoginFailedException(ex);\n        } catch (ExecutionException ex) {\n            throw new LoginFailedException(ex);\n        } catch (IOException ex) {\n            throw new LoginFailedException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"task": ["Task", "contract", "asks", "link", "txt", "connection", "the", "complete", "result", "message", "conn", "thread", "app", "request", "table", "worker", "n", "ctx", "work", "resource", "server", "tx", "config", "master", "address", "exec", "sync", "action", "event", "ack", "batch", "e", "query", "target", "device", "tc", "password", "t", "tt", "text", "instance", "post", "job", "session", "status", "load", "ask", "db", "command", "process", "create", "commit", "project", "test", "kt", "unit"], "localVersion": ["LocalInstance", " localUser", "finalFeature", " localInstance", "currentUser", "localId", "currentInstance", "LocalUser", "reportedVersion", "localModel", " localFeature", "localInstance", " localversion", "reportedId", "LocalModel", " localId", "localversion", "finalVersion", "finalversion", "LocalVersion", "localFeature", " localModel", "localUser", "currentModel", "reportedversion", "finalId", "reportedFeature"], "currentVersion": ["futureVersion", "reportedVERSION", "localVer", "localDatabase", "localVERSION", "currentDatabase", "futureVer", "currentversion", "parentPosition", "requestversion", "requestPosition", "requestVERSION", "parentVersion", "parentversion", "localIndex", " currentFeature", "parentVERSION", " currentVERSION", " currentIndex", "requestVersion", "reportedVersion", "currentPosition", " currentVer", " currentPosition", "currentIndex", "futureIndex", "currentVERSION", "currentVer", "localFeature", " currentDatabase", "reportedDatabase", "currentFeature", "futureVERSION", " currentversion", "reportedFeature"], "autoCommit": ["autoCompmit", "autoCompit", "autocommmit", "automaticDebIT", "automaticDebite", "autoCommite", "autoDebIT", "automaticDebit", "autoLogit", "autocommlit", "autoLoglit", " autoComitting", "autoCommlit", "autocommit", " autoComit", "autocommitting", "autoModIT", "autoDebit", "autoComlit", "autoDebmit", "autoComit", "autoCommIT", "automaticCommIT", "autoCompite", " autoCommitting", "autoModite", "autoLogmit", " autoCommlit", "automaticCommit", "autoCompIT", "automaticCommite", "automaticCommmit", "autoComitting", "autoCommitting", "autoDebite", "autoModmit", "automaticDebmit", "autoCommmit", "autoModit", " autoComlit", "autoLogitting", " autoCommmit"], "version": ["vision", "parent", "id", "VERSION", "connection", "ison", "ception", "with", "grade", "python", "view", "object", "Version", "driver", "request", "model", "ver", "number", "class", "serial", "resource", "server", "feature", "child", "latest", "condition", "stage", "section", "update", "element", "sequence", "action", "name", "edition", "query", "patch", "json", "step", "instance", "initial", "relation", "versions", "v", "release", "index", "vert", "image", "seed", "install", "expression", "code", "vers", "date", "current", "database", "secret", "block", "create", "type", "level", "position", "option", "project", "platform", "value", "null", "unit"], "in": ["source", "reader", "id", "str", "url", "input", "inc", "din", "min", "doc", "nin", "conn", "src", "con", "out", "b", "part", "login", "f", "as", "data", "In", "fe", "stream", "n", "r", "re", "resource", "again", "serv", "el", "ins", "cl", "gin", "ini", "a", "ex", "m", "kin", "image", "c", "file", "socket", "i", "IN", "inn", "rin", "is", "ilo", "bin", "on", "fa", "null"], "st": ["h", "sa", "ST", "d", "sth", "ost", "ld", "ss", "sm", "statement", "src", "l", "sw", "ist", "fr", "ste", "est", "fe", "std", "stream", "r", "sc", "ast", "sh", "sta", "shell", "inst", "s", "cl", "t", "mt", "hr", "St", "se", "pt", "sts", "sp", "c", "db", "rd", "struct", "ust", "nd", "sn", "ct", "str", "put", "rest", "sl", "bl"]}}
{"id1": "288695", "id2": "917011", "code1": "    public void CopyFile(File source, File destination) throws Exception {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(source);\n            fos = new FileOutputStream(destination);\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                fos.write(buffer, 0, read);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "io", "src", "from", "in", "this", "Source", "base", "table", "directory", "stream", "remote", "resource", "ie", "server", "address", "info", "ources", "filename", "name", "e", "target", "ource", "sin", "SOURCE", "slice", "string", "image", "file", "uri", "i", "service", "scene", "proxy", "use", "unit"], "destination": ["deadinated", "deadination", "Desturation", "destiner", "combinated", "deaduration", "Destinated", "desturation", "Destiner", "destinated", "dinations", "combination", "diination", "diinations", "Destinator", "deadiner", "diinated", "dinated", "destinations", "dinator", "Destinations", "dination", "combiner", "diinator", "comburation", "destinator", "Destination"], "fis": ["los", "fris", "infris", "fois", "Fos", "Fiss", "las", "fiss", "bos", "infos", "lois", "fios", "Fas", " fois", "biss", " fios", "bris", "Fris", "hos", "Fis", "his", "hiss", " fas", "infis", " fris", "hris", "Fois", "lis", "infios", "Fios", "lris", "bis", " fiss", "fas"], "fos": ["Foes", "los", " fros", " foses", "fose", "fus", " foes", " fou", "ufou", "ufos", "baos", "ufros", "pose", "bros", "fros", "Fos", "bos", "infos", "fios", "infus", " fios", " faos", " fus", "Faos", "poes", "lios", "bou", "Fis", "infis", "Fose", "loses", "faos", "lis", "ufis", "infios", "foses", "bus", "Fios", "bios", "pos", "Foses", "poses", "bis", "fou", "foes", " fose"], "buffer": ["reader", "url", "queue", "memory", "binary", "input", "write", "feed", "reference", "buff", "repeat", "iter", "result", "Buffer", "limit", "request", "b", "channel", "number", "layer", "data", "available", "resource", "address", "uffer", "shape", "transfer", "null", "batch", "flush", "length", "wave", "buf", "slice", "count", "document", "border", "seed", "cache", "header", "block", "total", "position", "bin"], "read": ["play", "get", "next", "reader", "en", "size", "id", "write", "d", "input", "feed", "len", "Read", "ind", "open", "iter", "READ", "io", "in", "b", "end", "f", "data", "rate", "find", "n", "work", "raw", "exec", "x", "send", "e", "reading", "_", "length", "allow", "text", "max", "se", "key", "run", "index", "close", "count", "pass", "load", "connect", "parse", "readable", "i", "check", "seek", "current", "type", "wait", "start", " count", "add", "ed", " Read", "use", " ride", "reads"]}}
{"id1": "1562772", "id2": "19182834", "code1": "    private String getCoded(String pass) {\n        String passSecret = \"\";\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(pass.getBytes(\"UTF8\"));\n            byte s[] = m.digest();\n            for (int i = 0; i < s.length; i++) {\n                passSecret += Integer.toHexString((0x000000ff & s[i]) | 0xffffff00).substring(6);\n            }\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return passSecret;\n    }\n", "code2": "    public synchronized String encrypt(String password) {\n        try {\n            MessageDigest md = null;\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            byte[] hash = (new Base64()).encode(raw);\n            return new String(hash);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"Algorithm SHA-1 is not supported\", e.getCause());\n            return null;\n        } catch (UnsupportedEncodingException e) {\n            logger.error(\"UTF-8 encoding is not supported\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"pass": ["source", "Secret", "input", "user", "token", "auth", "result", "sign", "wd", "object", "PASS", "in", "mode", "gen", "skip", "phrase", "re", "enc", "prefix", "ass", "strip", "use", "e", "device", "password", "Pass", "text", "ress", "key", " password", "string", "path", "parse", "file", "fail", "ask", "secret", "Password", "crypt", "str", "port", "p"], "m": ["h", "um", "d", "cm", "mut", "sm", "mm", "l", "am", "ms", "ym", "f", "bm", "mac", "mu", "hm", "mand", "wm", "mc", "module", "machine", "u", "e", "me", "dm", "o", "rm", "gm", "M", "nm", "v", "pm", "tm", "c", "vm", "mr", "im", "g", "fm", "md", "em", "mi", "p"], "s": ["h", "ings", "en", "strings", "d", "ss", "l", "fs", "gs", "b", "ns", "f", "n", "r", "bytes", "os", "es", "qs", "x", "js", "u", "e", "t", "rs", "a", "abs", "ls", "v", "c", "ips", "g", "ses", "is", "parts", "ds", "bis", "services", "S", "ps", "uploads", "p"], "i": ["id", "h", "si", "d", "abi", "multi", "qi", "phi", "io", "l", "in", "b", "f", "di", "n", "bi", "zi", "I", "oi", "ti", "ai", "ji", "info", "ni", "gi", "x", "ix", "init", "ui", "u", "o", "e", "ci", "eni", "t", "ini", "a", "li", "v", "xi", "ri", "index", "j", "c", "uri", "ii", "vi", "pi", "field", "chi", "z", "p"], "passSecret": [" passPass", "PASSRET", "passwordsecret", "passSign", "PASSSec", "passwordPass", "passwordText", "passSalt", "assSalt", "passPass", "crossRET", "assSign", "passwordSalt", "passRET", "passSec", " passRET", "crossSecret", "asssecret", "PASSText", "PASSSecret", "passwordSign", "passwordRET", "assSecret", " passSign", " passSalt", " passsecret", "assPass", "passText", "passwordSecret", "passsecret", "crossText", "assRET", "passwordSec", "crossSec"]}}
{"id1": "18284811", "id2": "16995204", "code1": "    private Map<String, String> readStuff(Iterator<URL> urls) throws IOException {\n        Map<String, String> result = new LinkedHashMap();\n        while (urls.hasNext()) {\n            URL url = urls.next();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String s = reader.readLine();\n            while (s != null) {\n                s = s.trim();\n                if (s.length() > 0) {\n                    String[] ss = s.split(\"\\\\s\");\n                    for (int i = 1; i < ss.length; i++) {\n                        result.put(ss[i], ss[0]);\n                    }\n                }\n                s = reader.readLine();\n            }\n            reader.close();\n        }\n        return result;\n    }\n", "code2": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        fields.put(item.getFieldName(), item.getString());\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                sendInstance.saveDraft(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, preferencesInstance.getPreferences().isHtmlMessage(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "label": 0, "substitutes": {"urls": ["inputs", "inputches", "URLss", "materialls", "ssls", "urlls", "urlss", "httpservices", " urlits", "https", "URLits", "urlits", "URLs", "inputls", "urlservices", "materials", " urlls", "materialservices", "urlches", "httpls", "URLls", "URLches", "sslservices", " urlss", "httpss", "httpits", "httpches", "sslls"], "result": ["source", "resources", "value", "default", "user", "our", "success", "dict", "Result", "range", "complete", "message", "properties", "params", "this", "root", "ver", "data", "response", "match", "master", "resource", "ret", "work", "sum", "changes", "repl", "results", "report", "json", "values", "transform", "comment", "found", "instance", "df", "status", "make", "features", "cache", "record", "error", "search", "map", "manager", "array", "valid", "current", "total", "order", "group", "test", "res", "filter", "use"], "url": ["source", "id", "link", "user", "browser", "connection", "feed", "buffer", "plug", "iter", "conn", "l", "http", "b", "base", "f", "loader", "r", "resource", "server", "name", "ur", "api", "ls", "job", "string", "path", "image", "obj", "socket", "uri", "file", "ssl", "URL", "service", "Url", "str", "sl", "entry"], "reader": ["folder", "read", "h", "upper", "input", "rar", "rx", "Reader", "feed", "buffer", "iter", "ser", "io", "iterator", "l", "http", "in", "ler", "driver", "f", "loader", "worker", "oder", "stream", "r", "handler", "editor", "server", "writer", "inner", "er", "rer", "reading", "per", "bird", "parser", "ri", "uri", "file", "err", "ssl", "builder", "rr", "finder", "ner"], "s": ["su", "d", "sg", "l", "ns", "sf", "r", "es", "sync", "u", "ls", "ssl", "err", "line", "strings", "sb", "site", "settings", "sports", "rss", "b", "os", "results", "t", "sv", "abs", "a", "se", "sp", "c", "ses", "is", "services", "ps", "str", "source", "si", "sm", "fs", "in", "styles", "f", "n", "server", "js", "sym", "e", "o", "rs", "v", "words", "string", "g", "service", "ds", "S", "p", "h", "sa", "ws", "message", "w", "data", "spec", "m", "session", "sq", "sl"], "ss": ["su", "ks", "fts", "test", "si", "ws", "rss", "fs", "sw", "less", "css", "sf", "ns", "ms", "styles", "ros", "iss", "ess", "bs", "os", "uss", "ass", "es", "js", "vs", "eps", "oss", "xs", "xx", "ins", "icks", "pps", "rs", "ress", "cs", "sv", "ls", "se", "string", "SS", "sts", "sp", "hess", "struct", "us", "ses", "ds", "is", "services", "ts", "ps", "sl", "pass"], "i": ["id", "h", "si", "d", "multi", "qi", "hi", "io", "l", "y", "b", "part", "f", "data", "di", "bi", "I", "oi", "ti", "ai", "gi", "info", "x", "ix", "it", "ui", "u", "ci", "e", "o", "length", "a", "m", "li", "v", "key", "xi", "ri", "index", "j", "ori", "uri", "ii", "vi", "pi", "is", "at", "mi", "ip", "p", "ie"]}}
{"id1": "14232817", "id2": "22026286", "code1": "    protected void lookupForParsedElementAnnotations(JClassType t) {\n        List<JMethod> methods = getParsableElementMethods(t);\n        if (methods != null) {\n            for (JMethod method : methods) {\n                ParsedElement elementAnnotation = method.getAnnotation(ParsedElement.class);\n                if (elementAnnotation.type() == ParsedElement.Types.SYNC) {\n                    try {\n                        String contents = \"\";\n                        URL url = getClass().getClassLoader().getResource(elementAnnotation.file());\n                        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                        String line = null;\n                        while ((line = reader.readLine()) != null) {\n                            contents += line;\n                        }\n                        reader.close();\n                        ParsedElementDescriptor elementDescriptor = new ParsedElementDescriptor(method.getName(), contents.replaceAll(\"\\\"\", \"'\"), elementAnnotation.type());\n                        this.parsedElementList.add(elementDescriptor);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                } else {\n                    ParsedElementDescriptor elementDescriptor = new ParsedElementDescriptor(method.getName(), elementAnnotation.file(), elementAnnotation.type());\n                    this.parsedElementList.add(elementDescriptor);\n                }\n            }\n        }\n    }\n", "code2": "    public static void main(String args[]) {\n        int i, j, l;\n        short NUMNUMBERS = 100;\n        short numbers[] = new short[NUMNUMBERS];\n        printIntro();\n        int time = (int) System.currentTimeMillis();\n        for (i = 0; i < NUMNUMBERS; i++) {\n            numbers[i] = (short) (NUMNUMBERS - 1 - i);\n        }\n        for (i = 0; i < NUMNUMBERS; i++) {\n            for (j = 0; j < NUMNUMBERS - i - 1; j++) {\n                if (numbers[j] > numbers[j + 1]) {\n                    short temp = numbers[j];\n                    numbers[j] = numbers[j + 1];\n                    numbers[j + 1] = temp;\n                }\n            }\n            if (WANT_PROGRESS) {\n                printProgress();\n            }\n        }\n        time = (int) System.currentTimeMillis() - time;\n        System.out.print(time);\n        System.out.print(\"End\\n\");\n    }\n", "label": 0, "substitutes": {"t": ["h", "d", "tor", "the", "l", "this", "b", "types", "Type", "st", "typ", "tf", "f", "class", "n", "r", "template", "dt", "tp", "it", "e", "o", "target", "tc", "T", "tt", "a", "m", "tm", "j", "c", "i", "att", "qt", "ts", "test", "s", "te", "p", "type"], "methods": ["pathes", "structb", "METHODes", " methodits", "pathisms", " methodsisms", "METHODions", " methodss", " methodes", "methodions", "Methodb", "hodits", "structs", "methodes", "METHODacks", "pathb", "pathions", "structes", "methodits", " methodacks", "hodacks", "METHODisms", "paths", "methodisms", "METHODits", "Methodes", "hods", "methodacks", "Methods", " methodses", "hodes", "methodb", "METHODs", " methodsions"], "method": ["source", "Method", "attr", "user", "default", "verb", "plugin", "result", "function", "right", "message", "true", "view", "one", "this", "in", "request", "METHOD", "version", "class", "r", "resource", "feature", "call", "address", "module", "element", "name", "null", "event", "member", "func", "cl", "text", "transform", "instance", "trip", "m", "job", "session", "string", "path", "document", "record", "expression", "each", "attribute", "property", "manager", "header", "block", "process", "hod", "field", "form", "subject", "th", "self", "project", "filter", "month", "type"], "elementAnnotation": ["elementAnment", "elementAnyotation", "elementAcction", "elementEntion", "elementEnotation", "elementEnnotations", "elementAnter", "objectANotation", "lementApzer", "objectAnnter", "objectAnnnotations", "objectAnnment", "elementEnment", "objectAnnotation", "objectANnotations", "elementAnynotations", " elementAnnnotations", "objectANnotation", "objectAnter", "lementAnzer", "elementAnnnotation", "elementCanter", "elementSynotation", "elementAntion", "elementANion", "elementAnzer", " elementAnnotations", "elementAnotation", "elementAnnotations", "lementAnnotations", "objectAnion", "elementAnntion", "elementApnotation", "elementAnnette", "lementApnotations", "lementApnette", "elementANnotations", "elementParnette", "elementANoration", " elementAnnnotation", " elementAntion", "elementCannotations", "elementParnotation", "lementApnotation", "elementAnnnette", "elementParzer", "elementSynnotations", "elementSynment", "elementAnyion", "elementAnnzer", "elementAnnoration", "elementEnoration", "elementSynnotation", "elementAnnnotations", "elementAccment", "elementAnnion", "objectAnotation", "objectAnnotations", " elementAnnment", " elementAnment", "elementEnnotation", "elementAnion", "objectAnment", "elementANter", "elementCannotation", " elementAnntion", "lementAnnotation", "objectAnoration", "elementAnynotation", "elementCanotation", "elementParnotations", "elementApnette", "elementAnnment", "objectANion", "elementApnotations", "objectAnnnotation", "objectAnnoration", "elementANotation", "elementApzer", "elementAccnotation", "lementAnnette", "elementAnoration", "elementAnnter", "elementANnotation", "elementAccnotations"], "url": ["source", "ball", "link", "user", "browser", "connection", "feed", "buffer", "director", "l", "http", "client", "b", "channel", "loader", "base", "data", "layer", "stream", "r", "resource", "handler", "server", "editor", "address", "element", "api", "location", "string", "path", "image", "rule", "file", "uri", "ssl", "URL", "service", "Url", "coll", "sl"], "reader": ["read", "rar", "wrapper", "rx", "Reader", "feed", "buffer", "iter", "ser", "keeper", "io", "ry", "iterator", "ler", "driver", "row", "layer", "loader", "worker", "oder", "stream", "re", "r", "resource", "handler", "server", "editor", "writer", "inner", "er", "rer", "e", "per", "reading", "bird", "parser", "ri", "uri", "file", "i", "err", "or", "rr", "ner", "entry"], "line": ["source", "page", "link", "connection", "lines", "iter", "message", "l", "letter", "char", "end", "description", "cell", "LINE", "Line", "row", "column", "number", "data", "inline", "response", "r", "server", "word", "name", "e", "coll", "cl", "text", "comment", "content", "lc", "key", "col", "le", "string", "pass", "file", "record", "code", "character", "header", "block", "lin", "str", "sample", "sl", "entry"], "contents": ["explcontent", "explodes", "extents", "constices", "Contences", "intens", "conturs", "intcontent", "Content", "contacts", "extodes", "contcontent", " conturs", "compacts", "Conturs", "encents", " content", "Contices", " contacts", "contants", "compent", "constants", "encants", "Contacts", "explens", "content", "contodes", "explents", "compents", "encences", "extens", "Contents", "constences", "encices", "constents", "Contants", "contences", "intodes", "extcontent", "compurs", "intents", "contens", "contices"], "elementDescriptor": ["elementDesccriptory", "elementDescruption", "elementDescendion", "elementDescription", "elementDesriptal", "elementDesriptory", "elementScriptor", "elementDesriptor", "elementDesription", "elementDescruptory", "elementDesributory", "elementDescectors", "elementDesribution", "elementDescributour", "elementDescendory", "elementDescributory", "elementDescriptors", "elementDescector", "elementDescritour", "elementDescriptour", "elementDescributal", "elementDescendors", "elementDescectal", "elementDesccriptor", "elementDesributors", "elementScriptory", "elementScription", "elementDescritor", "elementDescribution", "elementDesccription", "elementDescrition", "elementDesributor", "elementDescruptors", "elementScriptors", "elementDescributors", "elementDesriptour", "elementDescritors", "elementScributor", "elementScributors", "elementDescendor", "elementDesccriptal", "elementDescection", "elementDescruptor", "elementDescriptal", "elementDescriptory", "elementDescributor", "elementScributory", "elementScribution", "elementDesccriptour", "elementDesriptors", "elementDesccriptors"]}}
{"id1": "5675397", "id2": "11444436", "code1": "    private void delete(String location) throws Exception {\n        URL url = new URL(location);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"DELETE\");\n        conn.connect();\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK && responseCode != HttpURLConnection.HTTP_NO_CONTENT) {\n            String response = \"location \" + location + \" responded: \" + conn.getResponseMessage() + \" (\" + responseCode + \")\";\n            fail(response);\n        }\n    }\n", "code2": "    public void run() {\n        try {\n            FTPClient c = new FTPClient();\n            c.configure(ftpConfig);\n            logger.debug(\"Trying to connect\");\n            c.connect(\"127.0.0.1\", 21211);\n            logger.debug(\"Connected\");\n            c.setSoTimeout(5000);\n            if (!FTPReply.isPositiveCompletion(c.getReplyCode())) {\n                logger.debug(\"Houston, we have a problem. D/C\");\n                c.disconnect();\n                throw new Exception();\n            }\n            if (c.login(\"drftpd\", \"drftpd\")) {\n                logger.debug(\"Logged-in, now waiting 5 secs and kill the thread.\");\n                _sc.addSuccess();\n                Thread.sleep(5000);\n                c.disconnect();\n            } else {\n                logger.debug(\"Login failed, D/C!\");\n                throw new Exception();\n            }\n        } catch (Exception e) {\n            logger.debug(e, e);\n            _sc.addFailure();\n        }\n        logger.debug(\"exiting\");\n    }\n", "label": 0, "substitutes": {"location": ["language", "page", "folder", "route", "operation", "site", "layout", "connection", "ocation", "message", "from", "LOC", "request", "object", "description", "loc", "base", "layer", "href", "data", "directory", "remote", "resource", "server", "address", "Location", "name", "filename", "method", "station", "direction", "content", "localhost", "area", "string", "path", "point", "node", "pointer", "uri", "file", "error", "command", "property", "database", "position", "collection", "entry", "type"], "url": ["host", "page", "connection", "build", "ll", "l", "http", "client", "b", "loc", "base", "f", "resource", "org", "server", "config", "el", "gl", "bb", "ob", "log", "bel", "ls", "job", "path", "impl", "obj", "uri", "file", "ssl", "URL", "Url", "www", "blog", "web", "sl"], "conn": ["cb", "h", "en", "connection", "open", "cf", "co", "l", "http", "con", "client", "Conn", "loc", "ec", "cp", "n", "oa", "enc", "ctx", "config", "ai", "inner", "cn", "pc", "exec", "sync", "conf", "init", "ci", "rc", "nt", "act", "ok", "ch", "cli", "ann", "close", "col", "connect", "c", "ssl", "rt", "fail", "err", "code", "resp", "g", "socket", "conv", "Connection", "ct", "nc", "coll"], "responseCode": [" responseCod", " responseClass", " responseMessage", "ResponseCount", "requestClass", "ResponseCode", "requestType", "respCount", "ResponseSize", "replyCount", "replyType", "responseCount", "responsecode", " responseType", "responseSize", "responseType", "replycode", "respCode", "replyMessage", "requestCode", "responseClass", "responseMessage", " responseCount", "requestCount", " responsecode", "replyCode", "Responsecode", "ResponseCod", "ResponseClass", "ResponseType", "responseCod", " responseSize", "respType", "ResponseMessage", "respCod", "replySize"], "response": ["translation", "successful", "respond", "route", "warning", "connection", "success", "reply", "result", "female", "output", "message", "request", "object", "description", "model", "application", "onse", "hello", "version", "resource", "server", "address", "body", "offer", "json", "content", "status", "Response", "respons", "document", "answer", "uri", "error", "resp", "reason", "entry"]}}
{"id1": "19999376", "id2": "8481623", "code1": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        from_file = checkFile(from_file);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"zipfile": ["zipFile", "zFile", "Zipdir", "zfile", "clipfile", "zentry", "zipfiles", "clipfiles", "zipdir", "gzdir", "Zipfiles", " zipfiles", "zipentry", "Zipfile", "clipFile", "Zipstream", "clipstream", "gzFile", "Zipentry", "gzentry", " zipstream", " zipFile", "zdir", "ZipFile", "gzfile", "zipstream"], "entry": ["next", "source", "folder", "route", "reader", "draft", "id", "export", "input", "link", "queue", "si", "line", "connection", "feed", "xml", "plugin", "ry", "audio", "lock", "in", "object", "cell", "ries", "base", "data", "directory", "zip", "system", "her", "archive", "server", "address", "info", "inner", "element", "module", "name", "dir", "it", "e", "country", "nt", "container", "log", "cel", "parser", "api", "enter", "comment", "se", "session", "path", "image", "cache", "install", "file", "record", "uri", "error", "or", "parse", "Entry", "service", "sea", "add", "ie"], "outputDir": ["inputFolder", " outputDIR", "outFile", " outputdir", "writeDIR", "inputdir", "inputDIR", "writeFolder", "outDir", "outDirectory", "exitDIR", "outputFolder", "exitDir", "outDIR", "outputDirectory", "outputDIR", "writeDir", "writeDirectory", "outFolder", "targetFolder", "exitdir", " outputDirectory", "targetFile", "inputDirectory", "targetDirectory", "outputdir", "targetDir", "inputDir", "exitDirectory", "inputFile"], "outputFile": [" outputfile", "inputfile", "inputFolder", "outFile", "inputPath", " outputPath", "outLine", "inputLine", "OutputPath", "outDir", "outDirectory", "outputLine", "outputFolder", "inputJar", "outputDirectory", " outputFolder", "responseFile", "OutputDir", "outputJar", " outputLine", " outputDirectory", "OutputFile", "responsefile", "inputDirectory", "outStream", "responseFolder", "responseDir", " outputJar", "inputDir", "outputPath", "OutputJar", "inputFile", "outputfile"], "inputStream": [" inputReader", "outputSteam", " inputChannel", "inputSteam", "InputStream", " inputView", " inputSteam", " inputFile", "inputReader", "InputView", "inputView", "outputReader", "outputChannel", "inputChannel", "InputFile", "InputChannel", "outputView", "InputSteam", "InputReader", "inputFile"], "outputStream": ["outputSteam", "inputSteam", "OutputSteam", "execStream", " outputChannel", "OutputStream", "execFile", "inputStreamer", "outputChannel", "inputChannel", " outputSteam", "OutputFile", "OutputStreamer", "execStreamer", "OutputChannel", "inputFile", "outputStreamer", "execSteam"]}}
{"id1": "13510171", "id2": "14677081", "code1": "        private String readCreditsHtml(IApplication app) {\n            final URL url = app.getResources().getCreditsURL();\n            StringBuffer buf = new StringBuffer(2048);\n            if (url != null) {\n                try {\n                    BufferedReader rdr = new BufferedReader(new InputStreamReader(url.openStream()));\n                    try {\n                        String line = null;\n                        while ((line = rdr.readLine()) != null) {\n                            String internationalizedLine = Utilities.replaceI18NSpanLine(line, s_stringMgr);\n                            buf.append(internationalizedLine);\n                        }\n                    } finally {\n                        rdr.close();\n                    }\n                } catch (IOException ex) {\n                    String errorMsg = s_stringMgr.getString(\"AboutBoxDialog.error.creditsfile\");\n                    s_log.error(errorMsg, ex);\n                    buf.append(errorMsg + \": \" + ex.toString());\n                }\n            } else {\n                String errorMsg = s_stringMgr.getString(\"AboutBoxDialog.error.creditsfileurl\");\n                s_log.error(errorMsg);\n                buf.append(errorMsg);\n            }\n            return buf.toString();\n        }\n", "code2": "    protected void findPackages(Set<String> packages, ClassLoader classLoader) throws IOException {\n        Enumeration<URL> resources = classLoader.getResources(META_INF_SERVICES);\n        while (resources.hasMoreElements()) {\n            URL url = resources.nextElement();\n            String path = url.getPath();\n            if (!visitedURIs.contains(path)) {\n                visitedURIs.add(path);\n                LOG.debug(\"Loading file {} to retrieve list of packages, from url: {}\", META_INF_SERVICES, url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                try {\n                    while (true) {\n                        String line = reader.readLine();\n                        if (line == null) {\n                            break;\n                        }\n                        line = line.trim();\n                        if (line.startsWith(\"#\") || line.length() == 0) {\n                            continue;\n                        }\n                        tokenize(packages, line);\n                    }\n                } finally {\n                    IOHelper.close(reader, null, LOG);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"app": ["page", "user", "plug", "xml", "admin", "plugin", "doc", "APP", "request", "client", "this", "model", "base", "application", "data", "App", "resource", "server", "config", "info", "conf", "e", "report", "api", "session", "install", "html", "sp", "db", "i", "apps", "support", "pp", "manager", "service", "img", "self", "android", "project", "web", "p"], "url": ["source", "host", "page", "user", "feed", "connection", "buffer", "download", "ll", "io", "l", "http", "object", "lr", "f", "base", "loc", "data", "channel", "ref", "resource", "email", "server", "org", "address", "ur", "rc", "log", "fl", "location", "job", "string", "path", "image", "rl", "html", "file", "ssl", "uri", "err", "URL", "service", "hub", "Url", "www", "web", "sl"], "buf": ["cb", "sb", "tmp", "queue", "msg", "bf", "la", "bh", "proc", "uc", "buffer", "buff", "cmp", "result", "br", "Buffer", "bg", "pb", "src", "cas", "fp", "b", "aux", "bc", "fd", "cv", "fw", "ctx", "box", "Buff", "bb", "log", "uf", "bag", "gb", "port", "pool", "ab", "db", "err", "wb", "fb", "raf", "array", "conv", "nb", "img", "ff", "lb", "bu", "str", "rb", "null", "coll"], "rdr": ["fdrs", "rdl", "rf", "vdtr", "rdrs", "rtrs", "rtb", "ldb", "rtw", "ldrs", "rrw", "vdf", "rn", "RDn", "rdn", "rtr", "rrtr", "rdb", "rrr", "rdf", "fdf", "rrf", "RDr", "ldr", "rl", "ldf", "rttr", "rtn", "RDf", "rdw", "rdtr", "rr", "fdr", "RDl", "rtf", "fdb", "rtl", "vdw", "vdr"], "line": ["source", "page", "value", "split", "link", "feed", "lf", "lines", "result", "message", "l", "letter", "object", "char", "end", "LINE", "cell", "Line", "row", "f", "part", "base", "data", "number", "inline", "style", "response", "word", "name", "ge", "unit", "log", "text", "comment", "content", "lc", "key", "le", "string", "rule", "point", "rl", "pass", "file", "error", "code", "err", "parse", "header", "character", "lin", "str", "sl", "entry"], "internationalizedLine": ["internationalizeCode", "internationalizedCode", "internationalizableLine", "internationalizeBlock", " internationalisedline", "internationalizableBlock", "internationalizeLine", "internationalisedCode", " internationalizedline", "internationalisedline", "internationalisedLine", " internationalisedLine", " internationalisedCode", "internationalisedBlock", "internationalizedBlock", "internationalizeline", "internationalizedline", " internationalisedBlock", " internationalizedCode", " internationalizedBlock", "internationalizableCode", "internationalizableline"], "errorMsg": ["infoMsg", "errSm", " errorStr", " errorObj", "rorMessage", "rormsg", "errMessage", "ErrorMessage", " errormsg", "errmsg", "progressMessage", "bugMail", "rorLog", "infoLog", "errorLog", " errorLog", "errorStr", "bugMs", "errLog", "errMs", "rorMail", "bugMessage", "noMsg", "rorStr", "ErrorLog", "errorMail", "errorMs", "infoMessage", "rorObj", "progressSm", "Errormsg", "ErrorMsg", "rorMsg", "errorSm", " errorMessage", "nomsg", " errorSm", "ErrorStr", "infomsg", "errorObj", "errMsg", "ErrorMs", "ErrorObj", " errorMail", "errormsg", "rorMs", "bugMsg", "errorMessage", "progressMs", "noLog", "progressMsg", " errorMs"]}}
{"id1": "3542936", "id2": "339340", "code1": "    public boolean deleteByQuery(String query, int coreId) {\n        try {\n            URL url = new URL(solrUrl + \"/core\" + coreId + \"/update\");\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-type\", \"text/xml\");\n            conn.setRequestProperty(\"charset\", \"utf-8\");\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            System.out.println(\"******************\" + query);\n            wr.write(\"<delete><query>\" + query + \"</query></delete>\");\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = rd.readLine()) != null) {\n                System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-type\", \"text/xml\");\n            conn.setRequestProperty(\"charset\", \"utf-8\");\n            wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(\"<commit/>\");\n            wr.flush();\n            rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "code2": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"query": ["dq", "sql", "term", "year", "xml", "core", "out", "request", "model", "row", "table", "style", "resource", "feature", "qs", "module", "update", "script", "depth", "name", "qu", "scope", "patch", "json", "password", "text", "comment", "iq", "timeout", "index", "string", "quest", "cache", "lock", "uri", "parse", "error", "command", "Query", "search", "expression", "sq", "q", "database", "question", "str", "filter", "quer", "type"], "coreId": ["ceid", "coreid", "serverPath", "ceId", "corePath", " coreType", "customPath", "coreType", "customById", "serverId", " coreid", "customID", "serverID", "coreById", "ceType", "Coreid", "serverById", "CoreId", "CoreType", "ceID", " coreById", "coreID", " coreID", "customId", " corePath", "CoreID"], "url": ["dl", "host", "sel", "left", "nl", "link", "user", "connection", "pull", "build", "ll", "io", "l", "http", "con", "b", "lr", "fr", "f", "base", "loc", "loader", "layer", "r", "resource", "server", "config", "el", "ur", "bb", "cl", "log", "bel", "fl", "ls", "li", "lc", "key", "il", "path", "rl", "impl", "connect", "file", "ssl", "uri", "lock", "ol", "URL", "Url", "www", "blog", "gl", "sl"], "conn": ["attr", "contract", "net", "win", "auth", "not", "cf", "l", "con", "ctrl", "enc", "ctx", "sync", "oss", "rc", "nt", "gn", "log", "cl", "syn", "cli", "rec", "connect", "ssl", "err", "qt", "Conn", "ll", "cb", "nn", "lang", "ht", "co", "part", "po", "ec", "oa", "ai", "mc", "act", "fn", "apt", "col", "c", "rt", "dc", "en", "client", "loc", "rn", "cp", "n", "org", "server", "cn", "exec", "pr", "ch", "ann", "reg", "conv", "ct", "nc", "iw", "host", "connection", "cm", "nw", "cat", "pg", "serv", "config", "dn", "conf", "init", "ci", "api", "lc", "session", "sec", "lock", "on", "coll"], "wr": ["WR", "wu", "ru", "rar", "rx", "wal", "arr", "nw", "nr", "wk", "wx", "ew", "w", "wd", "sw", "wa", "fr", "rn", "fw", "wh", "r", "Wr", "raft", "wm", "writer", "wer", "wp", "shr", "nor", "wo", "rer", "wl", "sr", "pr", "rh", "dr", "Writer", "hr", "vr", "spr", "rw", "rt", "mr", "wb", "raf", "war", "err", "wy", "rr", "wan", "kr", "RW", "usr", "wt"], "rd": ["respond", "dc", "ru", "rf", "reader", "rar", "rowd", "rx", "cd", "ra", "dig", "dd", "director", "ld", "mid", "xd", "arr", "RS", "wx", "pd", "rss", "wd", "td", "fd", "fr", "bd", "rn", "r", "rob", "rg", "writer", "RR", "rus", "nor", "rer", "func", "rm", "rs", "rod", "pr", "rh", "dr", "sr", "hr", "adr", "vr", "cr", "rl", "rw", "rt", "rid", "mr", "rr", "ds", "nd", "dra", "rb", "RL", "RD"], "line": ["sel", "nl", "lines", "l", "definition", "end", "val", "Line", "model", "number", "style", "sync", "name", "ge", "cl", "log", "sl", "le", "day", "cr", "file", "pass", "id", "feed", "plugin", "iter", "one", "cell", "part", "row", "inline", "job", "key", "col", "lin", "str", "source", "page", "none", "link", "write", "pe", "user", "len", "space", "LINE", "column", "no", "el", "e", "text", "comment", "string", "error", "i", "entry", "next", "reader", "connection", "letter", "out", "char", "data", "ne", "spec", "lc", "li", "code", "character", "block", "shell", "unit"]}}
{"id1": "15292308", "id2": "1188160", "code1": "    private static File createFileFromURL(URL url) throws IOException {\n        File tempFile = File.createTempFile(\"oboFile\", \".obo\");\n        PrintStream ps = new PrintStream(tempFile);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            ps.println(line);\n        }\n        ps.close();\n        return tempFile;\n    }\n", "code2": "    public static String urlContentToString(URL url, String encoding) throws IOException {\n        String out = \"\";\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), Constants.ENCODING));\n        String line;\n        while ((line = in.readLine()) != null) {\n            out += line;\n        }\n        in.close();\n        return out;\n    }\n", "label": 0, "substitutes": {"url": ["source", "page", "user", "connection", "buffer", "io", "l", "http", "object", "b", "lr", "loc", "base", "loader", "data", "f", "ref", "resource", "server", "address", "config", "name", "ur", "sl", "job", "string", "path", "rule", "image", "obj", "html", "uri", "file", "ssl", "URL", "service", "Url", "gl", "str", "location"], "tempFile": ["tempFiles", " tempPlace", "tempJar", " tempfile", "tempPath", "empFile", " tempPath", "TempFile", "TempPath", "empJar", "empPath", "empfile", "fakeFile", " tempPage", "tempPage", "tempF", "tempfile", "fakeF", "poraryPage", "poraryfile", "TempFiles", "tmpfile", "TempPlace", "tmpFile", "tmpPlace", "fakefile", "Tempfile", "fakePage", "poraryFile", "TempJar", "poraryF", "tmpFiles", " tempJar", "tempPlace", " tempFiles", " tempF"], "ps": ["py", "ks", "pe", "errors", "events", "ils", "lines", "ss", "ws", "pipe", "fs", "http", "params", "gs", "css", "ep", "as", "po", "ups", "print", "os", "tx", "posts", "eps", "ports", "ppa", "pa", "per", "pps", "cs", "parser", "PS", "pr", "amps", "rs", "ls", "rules", "Ps", "pse", "les", "ips", "file", "pp", "pos", "files", "pi", "ds", "pers", "ras", "p", "reads"], "reader": ["read", "input", "rar", " Reader", "rx", "Reader", "buffer", "iter", "ser", "ro", "l", "ler", "lr", "row", "f", "loader", "worker", "oder", "stream", "r", "her", "handler", "server", "writer", "inner", "er", "rer", "reading", "per", "bird", "parser", "ri", "file", "err", "rr", "cher", "ner", "entry"], "line": ["source", "next", "page", "value", "nl", "link", "user", "pe", "write", "feed", "lf", "lines", "iter", "message", "l", "letter", "object", "char", "end", "LINE", "cell", "Line", "row", "f", "number", "model", "data", "base", "style", "raw", "strip", "word", "name", "cle", "e", "cl", "text", "comment", "content", "lc", "key", "le", "string", "rule", "pass", "file", "code", "i", "character", "block", "lin", "str", "entry"]}}
{"id1": "10361726", "id2": "16589432", "code1": "    void queryFile(String rendezvousProgram, String rendezvousMD5) {\n        try {\n            XMLConfigParser.readUrlHost();\n            String url = XMLConfigParser.urlHost;\n            String query;\n            String param1 = \"op=query\";\n            String param2 = \"program=\" + rendezvousProgram;\n            String param3 = \"md5=\" + rendezvousMD5;\n            query = String.format(\"%s&%s&%s\", param1, param2, param3);\n            openConnection(query, url);\n            String line = br.readLine();\n            NetworkLog.logMsg(NetworkLog.LOG_DEBUG, this, \"(Query) Response of the server: \" + line);\n            br.close();\n        } catch (MalformedURLException e) {\n            NetworkLog.logMsg(NetworkLog.LOG_ERROR, this, \"Error\" + e);\n        } catch (IOException e) {\n            NetworkLog.logMsg(NetworkLog.LOG_ERROR, this, e.getMessage());\n        }\n    }\n", "code2": "    private static String hash(String string) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (Exception e) {\n            return null;\n        }\n        try {\n            md.update(string.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            return null;\n        }\n        byte raw[] = md.digest();\n        return (new BASE64Encoder()).encode(raw);\n    }\n", "label": 0, "substitutes": {"rendezvousProgram": ["endiscoveryProgram", "renditingMAC", "rendiscoveryMAC", "endezvousMAC", "rendichoMAC", " rendiosityProgram", "rendezvousMODE", "rendichoprogram", "rendiosityMaterial", " rendiositySoftware", " rendiosityMODE", "rendrificationProgram", " rendezvousSoftware", "rendiscoveryURL", "rendezvousURL", "rendiscoveryprogram", "rendiscoveryProgram", "rendezvousSoftware", "rendrificationMODE", "rendezvousMAC", "rendezvousMaterial", "endezvousprogram", "renditingprogram", " rendezvousMODE", "rendlinessSoftware", "rendlinessProgram", "endezvousProgram", "rendlinessMaterial", "endiscoveryURL", " rendezvousMaterial", "endiscoveryprogram", "rendichoURL", "rendrificationSoftware", " rendiosityMaterial", "rendiosityProgram", "endiscoveryMAC", "rendezvousprogram", "rendiosityMODE", "renditingURL", "rendichoProgram", "rendrificationMaterial", "rendlinessMODE", "renditingProgram", "endezvousURL", "rendiositySoftware"], "rendezvousMD5": ["rendezvousIPDie", "rendluxMD0", "rendezvousSHAN", "rendezvousmdN", "renditeMDDie", "rendezvousURL0", "rendluxMD5", "rendluxMDLE", "rendezvousMDLE", "rendezvousIP2", "rendezvousIP5", "renditeMDN", "renditeSHADie", "renditeSHA5", "rendluxMAC3", "rendezvousSHALE", "rendezvousmd5", "rendezvousMAC5", "renditeMD5", "renditeSHA2", "rendezvousMDDie", "renditeMD2", "rendezvousSHADie", "rendezvousURL5", "rendluxMACLE", "rendezvousSHA5", "rendezvousSHA2", "rendezvousURL3", "rendezvousSHA3", "rendezvousmd2", "rendezvousMACLE", "rendezvousMAC3", "rendezvousURLLE", "rendezvousMD0", "rendezvousMD2", "rendezvousIPN", "rendezvousMD3", "rendezvousmdDie", "renditeSHAN", "rendezvousSHA0", "rendezvousMDN", "rendezvousMAC0", "rendluxMAC0", "rendluxMAC5", "rendluxMD3"], "url": ["host", "page", "route", "user", "link", "connection", "buffer", "ll", "br", "io", "l", "http", "channel", "base", "f", "loc", "response", "server", "address", "config", "name", "ur", "json", "log", "api", "location", "string", "path", "file", "uri", "error", "URL", "q", "service", "Url", "web", "str", "sl"], "query": ["source", "sql", "user", "xml", "range", "result", "message", "params", "request", "row", "data", "response", "clean", "server", "raw", "config", "ql", "qs", "random", "module", "script", "name", "body", "qu", "report", "filter", "json", "comment", "content", "timeout", "string", "rule", "cache", "answer", "uri", "parse", "error", "command", "Query", "search", "ask", "code", "header", "q", "sq", "block", "database", "question", "form", "str", "qa"], "param1": ["mark1", "par2", "mark0", "param51", " param4", "par5", " param51", " parameter51", "par1", "mark51", "mark4", "param4", "param5", " parameter4", "Param5", " parameter0", "Param2", " param5", " parameter1", "param0", " param0", "par3", "Param1", "Param3"], "param2": [" param4", "resource2", "params4", "par5", "par1", "prom62", "param62", "params1", "param4", "param5", "Param5", "resource5", " param62", "prom5", "params5", "Param62", "resource4", "Param2", "params2", " param5", "resource1", "Param4", "prom2", "prom4", "par4", "par2"], "param3": ["grade5", "gradethree", " param4", "grade3", "params3", "params4", "aramthree", "param15", "grade15", "aram3", "param5", "param4", "Param5", "params5", "aram5", "Param2", "params2", " param5", "paramthree", "Param4", "params15", "aram15", "paramsthree", "Param3"], "line": ["source", "page", "link", "connection", "lf", "xml", "buffer", "reply", "result", "lines", "message", "l", "end", "LINE", "Line", "row", "base", "data", "inline", "response", "server", " response", "name", "body", "e", "de", "log", "status", "string", "error", "code", "db", "header", "lin", "str", "ip", "entry"]}}
{"id1": "832329", "id2": "18623182", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"inFile": ["inputfile", "inPlace", "InFiles", "oldfile", "inputFiles", "incPlace", " inPath", "outFilename", "outfile", "inFilename", "outPlace", "outPath", "oldFiles", "inputFilename", "infile", "InFile", "oldFilename", "incfile", "oldFile", "outFiles", "inPath", "incFile", "inFiles", " inFiles", "incFiles", "InPlace", " infile", "inputFile", "Infile", "InPath"], "outFile": [" outTable", "zipFile", " outPlace", "inputFolder", "outTable", "zipString", "newfile", " outString", "newPlace", "OutFile", " outfile", "outputFILE", "outputFilename", "outDir", "zipFilename", "outputFile", "outputFolder", "outFILE", "outFilename", "outputString", " outFolder", " outDir", "outfile", "newDir", "inputPlace", "outPlace", "OutPlace", "Outfile", " outFilename", "outFolder", "OutDir", "newFile", "inputTable", " outFILE", "outString", "inputFile", "outputPlace", "outputTable", "zipFILE"], "iis": [" iIS", " iiss", "Iisc", " iIs", "iniais", "ciis", "iois", "iiIS", "ioIs", "IIs", "iIS", "iniIS", "iiIs", "iid", "iisc", "ioiss", " iais", "Iiss", "ciid", "iiss", "iniIs", "iils", "ciais", "Iis", " iils", "iiils", " iid", "ioisc", "iniis", "iniisc", "iiis", "iniiss", "iniid", "iIs", "ciiss", "iniils", "iais"], "dcmParser": ["dcpJar", " dpmarser", "dcpReader", "dcmLoader", "pdymJar", "dpmarser", "dpmLoader", "dcyJar", "pdcmparser", "dcyReader", "Dcmarser", " dpmPlugin", "dsemPlugin", "dmcarser", "dcmparser", "dsemStreamer", "dcrarser", "dpmStreamer", "dcrParser", "dmoduleParser", "dymReader", "dcrparser", "dsemParser", " dcmStreamer", "dtermStreamer", "dpmparser", "dtermParser", "ddcReader", "dcmBuilder", "dmmWriter", "dymparser", "dmmParser", " dcmPlugin", "dmoduleBuilder", "dcmWriter", "ddcParser", " dpmJar", "dmcParser", "dmodulePlugin", "dpmJar", "pdcmReader", "dpmParser", " dcmReader", " dpmLoader", "DcmReader", "dcyParser", "ddcLoader", "dymParser", "dcyarser", " dpmReader", "pdymparser", "pdymReader", "dpmPlugin", " dcmJar", " dcmPar", "DcmJar", "dtermPlugin", "dcpParser", "dcpparser", " dpmPar", " dcmLoader", "pdcmParser", "dpmPar", " dpmBuilder", "dmcJar", "dmoduleReader", " dpmStreamer", "dpmBuilder", " dcmBuilder", " dcmarser", "dymJar", "dcmStreamer", "dmmReader", "dcrWriter", "dcmPlugin", "dmcPar", "dcmJar", "ddcPlugin", " dpmParser", "Dcmparser", "DcmParser", "dsemReader", "dcmarser", "dcmPar", "dcrPar", "DcmWriter", "pdymParser", "dmmarser", "dcmReader", "dtermReader", "dcrReader", "dpmReader", "pdcmJar", "dcrJar"], "ds": ["ys", "ks", "dc", "ipes", "Ds", "des", "d", "points", "dd", "ils", "ld", "ss", "ws", "gd", "src", "pd", "conn", "cdn", "gs", "client", "ns", "ads", "fd", "ros", "Db", "asi", "data", "iss", "di", "os", "bs", "DS", "tx", "drivers", "sys", "js", "vs", "eps", "sync", "dt", "xs", "plugins", "ins", "dds", "da", "rs", "cs", "Ts", "amps", "dr", "ls", "df", "Os", "ays", "session", "docs", "utils", "db", "details", "parts", "services", "is", "tes", "ts", "nas", "ps", "s", "dat", "uds"], "pdReader": ["wdRead", "pcParser", "dsreader", "pbParser", "pcLoader", "pdreader", "pbReader", "xdreader", "xdWriter", "hdreader", "pdRead", "pcReader", "dsRead", "pdLoader", "hdRead", "pidParser", "pbLoader", "hdWriter", "wdReader", "pdParser", "pidScan", "pcScan", "dsLoader", "pbScan", "pcRead", "pcWriter", "wdLoader", "hdReader", "pidReader", "wdWriter", "pidLoader", "xdReader", "dsWriter", "dsReader", "pdScan", "xdRead"], "out": ["default", "later", "d", "net", "with", "result", "down", "now", "doc", "model", "over", "Out", "call", "writer", "sys", "sync", "name", "dot", "log", "flush", "cli", "temp", "image", "list", "obj", "file", "ssl", "err", "array", "img", "group", "store", "line", "pass", "co", "outer", "io", "conn", "lib", "object", "gen", "to", "OUT", "auto", "class", "child", "exp", "ex", "key", "point", "pool", "cache", "at", "copy", "ext", "page", "parent", "url", "user", "write", "inc", "term", "in", "client", "login", "base", "oder", "sum", "external", "exec", "word", "full", "o", "builder", "manager", "order", "s", "null", "connection", "output", "w", "as", "data", "again", "outs", "inner", "flow", "password", "session", "up", "lock", "db", "code", "device"], "dcmEncParam": ["dcmElParameter", "dcmDecParam", "dpmDecParam", "dcmEngType", "dcmDecParameter", "dcmEnVar", "dcmDecPar", "dcmElVar", "dcmEncType", "dcmElType", "dcmencParam", "dpmEncParam", "dcmEnPar", "dcmEncSm", "dcmEngParam", "dcmEnParam", "dcmElParam", "dcmAccParameter", "dcmDecSm", "dpmEncSm", "dcmencParameter", "dpmDecParameter", "dcmEngVar", "dcmAccParam", "dcmencSm", "dpmEncParameter", "dcmAccSm", "dpmDecSm", "dcmEnParameter", "dcmEncPar", "dcmEncVar", "dcmEncParameter", "dcmEnType", "dcmEngParameter"], "pdWriter": ["hdOutput", "pdContent", "pxContent", "PDOutput", "pxReader", "PDReader", "PDWriter", "PDContent", "pxWriter", "tdReader", "ddWR", "dsWrite", "hdWriter", "pxOutput", "ddWrite", "ddOutput", "hdWrite", "pdOutput", "pdWrite", "hdWR", "pdWR", "tdWriter", "dsOutput", "tdContent", "dsWriter", "tdOutput", "ddWriter", "dsWR"]}}
{"id1": "14518760", "id2": "2102737", "code1": "    public void connect(final URLConnectAdapter urlAdapter) {\n        if (this.connectSettings == null) {\n            throw new IllegalStateException(\"Invalid Connect Settings (is null)\");\n        }\n        final HttpURLConnection httpConnection = (HttpURLConnection) urlAdapter.openConnection();\n        BufferedReader in;\n        try {\n            in = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n            final StringBuilder buf = new StringBuilder(200);\n            String str;\n            while ((str = in.readLine()) != null) {\n                buf.append(str);\n                buf.append('\\n');\n            }\n            final ConnectResult result = new ConnectResult(httpConnection.getResponseCode(), buf.toString());\n            final Map<String, List<String>> headerFields = httpConnection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : headerFields.entrySet()) {\n                final String key = entry.getKey();\n                final List<String> val = entry.getValue();\n                if ((val != null) && (val.size() > 1)) {\n                    System.out.println(\"WARN: Invalid header value : \" + key + \" url=\" + this.connectSettings.getUrl());\n                }\n                if (key != null) {\n                    result.addHeader(key, val.get(0), val);\n                } else {\n                    result.addHeader(\"Status\", val.get(0), val);\n                }\n            }\n            this.lastResult = result;\n        } catch (IOException e) {\n            throw new ConnectException(e);\n        }\n    }\n", "code2": "    private String getContents(Server server, String uri) throws TechnicalException {\n        try {\n            URL url = new URL(\"http://localhost:\" + PORT + uri);\n            return StreamUtils.getStreamContent(url.openStream());\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new TechnicalException(e);\n        }\n    }\n", "label": 0, "substitutes": {"urlAdapter": ["webapter", "httpConnector", "webConnector", "httpConfig", "httpapter", "urlConfig", "webConfig", " urlConnection", "webConnection", "urlapter", "urlConnector", "urlConnection", "webAdapter", " urlConfig", " urlapter", " urlConnector", "httpAdapter"], "httpConnection": ["webClient", " httpClient", "httpsConnector", "httpConnector", "httpConnect", "HTTPConn", " httpConnect", "urlConnect", "httpsConnection", " httpconnection", "httpsConnect", " httpInterface", "httpsconnection", "httpInterface", "httpClient", " httpConn", "urlconnection", "webConnection", "HTTPConnect", "httpconnection", " httpconn", "httpconn", "urlConnector", "urlClient", "HTTPconn", "urlConnection", "urlConn", "httpsConn", "urlconn", "httpConn", " httpConnector", "webConnect", "httpsInterface", "webconnection", "urlInterface", "HTTPConnection"], "in": ["source", "read", "reader", "h", "url", "input", "inc", "din", "id", "win", "connection", "buffer", "min", "doc", "nin", "conn", "l", "con", "out", "b", "login", "f", "as", "gen", "In", "pin", "again", "re", "r", "fac", "isin", "inner", "ins", "ini", "a", "m", "ex", "kin", "rec", "cin", "c", "socket", "i", "IN", "err", "builder", "inn", "is", "bin", "s", "fa", "ac"], "buf": ["cb", "tmp", "url", "queue", "binary", "txt", "la", "uc", "buffer", "buff", "cf", "br", "Buffer", "cat", "pb", "cas", "fp", "b", "aux", "bc", "fd", "base", "cv", "data", "bytes", "ctx", "box", "config", "cur", "func", "grab", "bb", "ob", "runner", "text", "seq", "uf", "abs", "temp", "bag", "auc", "string", "ab", "wb", "map", "builder", "array", "header", "fb", "conv", "nb", "bu", "rb", "coll", "pkg"], "str": ["dec", "wr", "STR", "read", "url", "reader", "arr", "br", "iter", "l", "char", "b", "st", "fr", "f", "data", "r", "enc", "er", "cur", "e", "s", "exp", "spec", "cl", "Str", "text", "sr", "pr", "hr", "dr", "lc", "tr", "string", "cr", "list", "obj", "sp", "rev", "i", "err", "rr", "stri", "line", "coll", "sl"], "result": ["next", "source", "value", "continue", "default", "user", "our", "success", "Result", "complete", "function", "extra", "message", "output", "view", "this", "object", "root", "part", "pack", "ver", "row", "data", "summary", "future", "response", "r", "resource", "master", "ret", "repl", "server", "info", "event", "results", "report", "json", "runner", "job", "status", "up", "done", "session", "pass", "obj", "error", "db", "err", "builder", "manager", "current", "valid", "res", "coll"], "headerFields": ["headerForms", "HeaderFields", "HeaderColumngs", "headerColumnsets", "headerPrefes", "headerColgs", "headerFieldsets", "headerSignments", "headerSignerences", "headerFieldments", " headerColumnments", " headerFieldes", "headerColumnes", "headerColsets", "headerColumnments", "HeaderColumnes", " headerColumnes", "headerColumngs", "headerFielderences", "headerPrefsets", "headerSignes", "headerColes", " headerColumns", "headerPrefs", " headerFielderences", "headerFieldgs", " headerColumnerences", "headerFormes", "HeaderColumns", "HeaderColumnsets", "HeaderFieldsets", "headerFormments", "headerCols", "HeaderFieldes", "headerSigns", " headerFieldments", "headerFormerences", "HeaderFieldgs", "headerColumnerences", "headerFieldes", "headerColumns", "headerPrefgs"], "entry": ["mission", "reader", "ner", "inc", "term", "pe", "la", "si", "ent", "ger", "ry", "letter", "ence", "cell", "part", "row", "ries", "r", "set", "pair", "second", "inner", "section", "element", "er", "inter", "ge", "member", "e", "enter", "lc", "se", "index", "string", "entity", "record", "or", "Entry", "value", "line", "ie"], "key": ["nice", "sel", "parent", "id", "link", "pe", "cy", "ee", "co", "k", "letter", "op", "part", "ver", "by", "Key", "style", "set", "match", "ie", "box", "KEY", "section", "element", "word", "x", "name", "ace", "step", "length", "text", "col", "ke", "string", "path", "index", "change", "lock", "error", "code", "check", "i", "title", "label", "service", "header", "type", "ce", "order", "field", "oy", "option", "reason", "value", "ip"], "val": ["sel", "split", "url", "default", "msg", "la", "alt", "len", "arr", "Val", "ee", "l", "ul", "lv", "part", "base", "loc", "p", "data", "elt", "serv", "al", "el", "element", "VAL", "section", "iv", "x", "va", "it", "eval", "unit", "values", "text", "sl", "pr", "fl", "ls", "li", "v", "col", "il", "string", "list", "aval", "vals", "obj", "error", "sol", "ol", "err", "vol", "Value", "arg", "vi", "valid", "item", "detail", "value", "line", "pl", "bl"], "lastResult": ["nextReturn", " lastStatus", " lastResponse", "nextResponse", "prevResult", "lastReturn", "nextResult", " lastReturn", "lastResponse", "prevResponse", "lastStatus", "nextStatus", "prevReturn", "prevStatus"]}}
{"id1": "17568209", "id2": "10697587", "code1": "    private static boolean CopyFile(File srcFile, File tagFile) throws IOException {\n        if (srcFile == null || tagFile == null) {\n            return false;\n        }\n        int length = 2097152;\n        File dirFile = new File(getFileFolder(tagFile.getAbsolutePath()));\n        if (!dirFile.exists()) {\n            dirFile.mkdirs();\n        }\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(tagFile.getAbsolutePath());\n        FileChannel inC = in.getChannel();\n        FileChannel outC = out.getChannel();\n        int i = 0;\n        while (true) {\n            if (inC.position() == inC.size()) {\n                inC.close();\n                outC.close();\n                break;\n            }\n            if ((inC.size() - inC.position()) < 20971520) length = (int) (inC.size() - inC.position()); else length = 20971520;\n            inC.transferTo(inC.position(), length, outC);\n            inC.position(inC.position() + length);\n            i++;\n        }\n        return true;\n    }\n", "code2": "    public static void copyFileNIO(File in, File out) throws IOException {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(in);\n            fos = new FileOutputStream(out);\n            FileChannel sourceChannel = fis.getChannel();\n            FileChannel targetChannel = fos.getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace(System.out);\n            }\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace(System.out);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"srcFile": ["sourceDir", "sourceUrl", "rcfile", "inputFolder", "inputfile", "srcFiles", "srcfile", "srcFolder", "rcDir", "sourceFILE", "viewFile", "rcFiles", "srcUrl", "viewFILE", "viewUrl", " srcFILE", " srcfile", "rcFolder", "sourcefile", "sourceFile", " srcFiles", "rcFilename", " srcUrl", "sourceFiles", "inputFilename", " srcFilename", "srcFILE", " srcDir", "srcFilename", "rcFile", " srcFolder", "viewfile", "inputFile", "srcDir"], "tagFile": ["logFILE", "logPath", "TagFile", "outBase", "tagPath", "ownFILE", "outFile", " tagFILE", "srcfile", "ownPath", "logfile", "outDir", " tagfile", "catPath", "outFILE", "tagfile", "TagDir", "tagDir", "outfile", "logFile", "modDir", " tagDir", "modFILE", "TagPath", "catFile", "ownfile", " tagBase", "srcFILE", "modFile", "TagBase", "catDir", "modfile", "Tagfile", "tagFILE", "catfile", "tagBase", "ownFile", " tagPath", "srcPath"], "length": ["size", "id", "split", "url", "h", "feed", "len", "range", "with", "build", "weight", "limit", "l", "ength", "join", "end", "diff", "pack", "loc", "L", "data", "j", "style", "zip", " Length", "match", "work", "angle", "child", "ime", "sequence", "section", "shape", "depth", "distance", "filename", "name", "iv", "full", "cost", "capacity", "partial", "height", "li", "time", "slice", "string", "count", "path", "load", "delay", "uri", "lock", "Length", "width", "speed", "character", "total", "position", "form", "value", "sl", "duration", "type"], "dirFile": ["buildBook", " directoryFiles", "dirDirectory", "parentFile", "DIRBase", "locFile", "dirBook", " dirfile", "locType", "parentType", " dirBase", "buildfile", "dirfile", "directoryFolder", "DIRFiles", " directoryfile", "directoryBook", "poFile", "directoryfile", " directoryFile", "parentfile", " dirFiles", "DIRFile", "locfile", "dirFiles", "locDirectory", "directoryFile", "poType", "parentDirectory", "dirBase", "poDirectory", " dirBook", "DIRfile", "dirType", "buildFolder", "pofile", "buildFile", " dirFolder", "dirFolder", " directoryBase"], "in": ["plus", "reader", "h", "id", "en", "input", "inc", "din", "arin", "win", "io", "l", "con", "this", "login", "f", "as", "In", "into", "pin", "n", "r", "again", "inner", "init", "ins", "o", "vin", "a", "up", "image", "c", "IN", "inside", "inn", "is", "lin", "bin", "on", "ac"], "out": ["inc", "write", "net", "extra", "down", "io", "output", "outer", "conn", "one", "w", "this", "ou", "on", "to", "OUT", "Out", "auto", "outs", "again", "writer", "inner", "off", "exec", "sync", "name", "o", "other", "ex", "timeout", "up", "point", "file", "or", "outside", "bin", "working", "s", "line"], "inC": [" inVC", "INc", "inL", "inB", "inputVC", "inputc", "InVC", "INC", " inL", " inP", "inputC", "intoL", "INI", "incCL", "intoC", "intoI", "isinCL", "INB", "InCL", " inFile", "uninCL", "inCL", " inU", "incO", "inVC", " inI", "outB", "diffc", "diffC", "incc", "InB", "inO", "InFile", "outL", "inN", "outc", "outP", " inB", "uninC", "uninc", "inc", "isinVC", "INL", " inCL", "InC", "INCL", "diffI", "innC", "INU", "outVC", "uninU", "inP", "inU", "innc", "inputFile", "isinC", " inO", "outCL", "inFile", "diffCL", "innCL", "intoc", " inN", "INO", "outN", "INN", "INP", "incC", "Inc", "inI", " inc", "innL", "INVC"], "outC": ["outCC", " outCC", "tagCD", "inChannel", "againChannel", "inL", "tagC", "outCL", "inCL", " outL", "againL", " outCR", "againC", "OutL", "OutE", "tagE", " outCD", "OUTCD", " outCL", "OutCD", "OUTCC", "outCD", " outChannel", "OUTC", "OUTL", " outE", "outL", "tagCR", "outChannel", "outE", "OutCR", "outCR", "againCL", "OutC", "OutCC"], "i": ["id", "si", "qi", "multi", "ind", "uli", "phi", "l", "b", "f", "di", "n", "zi", "I", "ti", "ni", "ai", "info", "ji", "it", "ui", "ci", "u", "o", "e", "ini", "li", "xi", "index", "slice", "count", "j", "c", "uri", "strength", "ii", "ori", "pi", "z", "ip", "p", "type"]}}
{"id1": "20852768", "id2": "3838437", "code1": "    private final Vector<Class<?>> findSubclasses(URL location, String packageName, Class<?> superClass) {\n        synchronized (results) {\n            Map<Class<?>, URL> thisResult = new TreeMap<Class<?>, URL>(CLASS_COMPARATOR);\n            Vector<Class<?>> v = new Vector<Class<?>>();\n            String fqcn = searchClass.getName();\n            List<URL> knownLocations = new ArrayList<URL>();\n            knownLocations.add(location);\n            for (int loc = 0; loc < knownLocations.size(); loc++) {\n                URL url = knownLocations.get(loc);\n                File directory = new File(url.getFile());\n                if (directory.exists()) {\n                    String[] files = directory.list();\n                    for (int i = 0; i < files.length; i++) {\n                        if (files[i].endsWith(\".class\")) {\n                            String classname = files[i].substring(0, files[i].length() - 6);\n                            try {\n                                Class<?> c = Class.forName(packageName + \".\" + classname);\n                                if (superClass.isAssignableFrom(c) && !fqcn.equals(packageName + \".\" + classname)) {\n                                    thisResult.put(c, url);\n                                }\n                            } catch (ClassNotFoundException cnfex) {\n                                errors.add(cnfex);\n                            } catch (Exception ex) {\n                                errors.add(ex);\n                            }\n                        }\n                    }\n                } else {\n                    try {\n                        JarURLConnection conn = (JarURLConnection) url.openConnection();\n                        JarFile jarFile = conn.getJarFile();\n                        Enumeration<JarEntry> e = jarFile.entries();\n                        while (e.hasMoreElements()) {\n                            JarEntry entry = e.nextElement();\n                            String entryname = entry.getName();\n                            if (!entry.isDirectory() && entryname.endsWith(\".class\")) {\n                                String classname = entryname.substring(0, entryname.length() - 6);\n                                if (classname.startsWith(\"/\")) classname = classname.substring(1);\n                                classname = classname.replace('/', '.');\n                                try {\n                                    Class c = Class.forName(classname);\n                                    if (superClass.isAssignableFrom(c) && !fqcn.equals(classname)) {\n                                        thisResult.put(c, url);\n                                    }\n                                } catch (ClassNotFoundException cnfex) {\n                                    errors.add(cnfex);\n                                } catch (NoClassDefFoundError ncdfe) {\n                                    errors.add(ncdfe);\n                                } catch (UnsatisfiedLinkError ule) {\n                                    errors.add(ule);\n                                } catch (Exception exception) {\n                                    errors.add(exception);\n                                } catch (Error error) {\n                                    errors.add(error);\n                                }\n                            }\n                        }\n                    } catch (IOException ioex) {\n                        errors.add(ioex);\n                    }\n                }\n            }\n            results.putAll(thisResult);\n            Iterator<Class<?>> it = thisResult.keySet().iterator();\n            while (it.hasNext()) {\n                v.add(it.next());\n            }\n            return v;\n        }\n    }\n", "code2": "    public static boolean copyFile(final File inFile, final File outFile) {\n        try {\n            FileChannel ic = new FileInputStream(inFile).getChannel();\n            FileChannel oc = new FileOutputStream(outFile).getChannel();\n            ic.transferTo(0, ic.size(), oc);\n            ic.close();\n            oc.close();\n            return true;\n        } catch (IOException e) {\n            SystemUtils.LOG.log(Level.INFO, \"SystemUtils.copyFile() Exception while copy file \" + inFile.getAbsolutePath() + \" to \" + outFile.getAbsolutePath(), e);\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"location": ["language", "source", "folder", "site", "connection", "xml", "LOC", "home", " Location", "base", "layer", "region", "class", "remote", "resource", "server", "address", "config", "Location", "module", "filename", "direction", "area", "string", "path", "node", "document", "image", "library", "uri", "command", "URL", "database", "collection"], "packageName": ["folderName", " packageSize", "componentCode", "componentFamily", " packageSummary", "componentname", "packageCode", "packagePath", "PackagePath", "packagename", "folderType", " packageCode", "componentName", "folderCode", "databaseName", "folderSize", "databaseFamily", " packagename", "databaseSummary", "Packagename", "pkgSize", "pkgType", "packageFamily", " packageType", "packageSize", "pkgName", "PackageName", "pkgCode", "packageSummary", "PackageSummary", " packagePath", "databasename", "databaseCode", "packageType", "databasePath", " packageFamily"], "superClass": [" superclass", "superCode", "Superclass", "perCode", "perclass", "SuperClass", "SuperCode", "superType", " superType", "perType", "subType", "superclass", " superCode", "SuperType", "perClass", "subClass", "subclass"], "thisResult": ["theseRes", "ThisReturn", "theseReturn", "thisRes", "ThisResult", " thisRes", "theseArray", "theseResult", "theseResults", "theseMap", "ThisMessage", "thisResults", "thisReturn", " thisResults", "thisMap", "thisArray", "theseMessage", " thisReturn", " thisArray", " thisMessage", "ThisResults", "ThisRes", "ThisArray", " thisMap", "thisMessage", "ThisMap"], "v": ["d", "br", "l", "ev", "V", "b", "f", "cv", "r", "var", "vs", "vp", "u", "m", "vals", "uv", "rev", "ii", "g", "ov", "vi", "array", "conv", "s", "p"], "fqcn": ["fixhn", "bqsdn", "bqhn", "fqns", "fqsdn", "Fqdn", "fetcn", "fqsns", "FQn", "bqsns", "fQn", "fvdn", "FQdn", "fqdn", "fvCN", "fqhn", "bqns", "Fqn", "fetdn", "bqshn", "Fqcn", "fetCN", "bqscn", "fixcn", "bqdn", "fqCN", "fqscn", "fQCN", "fixdn", "FQCN", "fetn", "fqshn", "fvn", "fQhn", "fQns", "fQdn", "bqcn", "fvcn", "fQcn", "FqCN", "fqn", "FQcn", "fixns"], "knownLocations": ["knowLanguages", "knownBlanguages", " knownLocation", "knownSlocation", "unknownBlanguages", "knownFlayers", "knowBlocation", " knownLoanguages", "knownLolutions", "knownClanguages", "knownLocation", " knownLoibraries", "knownlolutions", "unknownLolutions", "knownLoanguages", "unknownBlocation", " knownLibraries", "knownAllayers", "knownAllocation", "knownBlibraries", "knownSlibraries", "knownLoocation", "knowLocations", "unknownBlolutions", "knownLayers", " knownLoocations", "knownAllolutions", "knownBlocation", "knownlayers", "knownFlocation", "knowBlocations", "knownSlocations", "knownBlocations", "knownLoocations", "knownLococations", " knownLanguages", "knownBlayers", "knownFlanguages", "unknownLocation", "unknownLocations", "knowBlanguages", "knownClocations", "knownAllocations", "knownClibraries", " knownLoocation", "knownlocations", "knownLibraries", "knownClocation", "knowLibraries", "knownFlocations", "knownAllanguages", "knownlanguages", "knownBlolutions", "unknownLayers", "knownLococation", "unknownLanguages", "knownLanguages", "unknownBlayers", "knownLoibraries", "knownSlanguages", "knownLocibraries", "knowBlibraries", "knowLocation", "unknownBlocations", "knownLocanguages"], "loc": ["inc", "go", "lang", "uc", "ld", "ll", "iter", "co", "hi", "src", "fc", "l", "LOC", "lim", "val", "bc", "lr", "fe", "oc", "zip", "ctx", "sc", "tx", "Loc", "Location", "lo", "cur", "dir", "rc", "other", "ok", "exp", "cl", "length", "lc", "col", "sec", "il", "rl", "coord", "oci", "pos", "local", "lb", "coll", "pl"], "url": ["source", "host", "page", "route", "user", "link", "connection", "download", "director", "ll", "result", "io", "l", "ul", "http", "client", "lr", "channel", "base", "layer", "ref", "loader", "class", "r", "resource", "email", "archive", "server", "address", "config", "org", " URL", "filename", "name", "ur", "dir", "log", "fl", "ls", "li", "string", "path", "image", "uri", "file", "ssl", "URL", "database", "service", "Url", "www", "jar", "sl"], "directory": ["source", "folder", "d", "connection", "director", "result", "output", "Directory", "l", "out", "home", "description", "f", "loader", "layer", "data", "class", "tree", "resource", "archive", "server", "creator", "module", "machine", "filename", "name", "volume", "dir", "direction", "direct", "container", "category", "session", "path", "document", "library", "uri", "file", "record", "URL", "database", "manager", "service", "project", "collection"], "files": ["balls", "resources", "classes", "Files", "tests", "strings", "actions", "links", "events", "sections", "lines", "packs", "keys", "tools", "lib", "fs", "items", "books", "bugs", "sheets", "f", "facts", "data", "blocks", "bytes", "bs", "objects", "sites", "models", "children", "ports", "filename", "users", "boxes", "dir", "phones", "plugins", "ins", "images", "pages", "members", "locks", "names", "ls", "fields", "words", "rules", "docs", "headers", "thumbnails", "features", "ips", "file", "apps", "projects", "ids", "obs", "views"], "i": ["id", "h", "si", "multi", "qi", "ind", "iu", "hi", "io", "phi", "k", "y", "b", "diff", "f", "ij", "di", "I", "ti", "ni", "ai", "gi", "info", "oi", "inner", "ji", "iv", "ix", "ui", "ci", "u", "ini", "lc", "li", "xi", "col", "index", "ri", "j", "uri", "ori", "ii", "vi", "pi", "fi", "mi", "uni", "ip", "p", "ie"], "classname": ["catchname", "entryno", "entrysource", "stringtype", " classkey", "entrykey", "classkey", "functionname", "CLASSName", "stringno", "entryName", "stringname", "catchnamed", "filepath", " classpath", "classsource", "fileName", "classpath", "stringName", "stringfull", "typename", "classtype", "classimage", " classnamed", " classimage", "catchName", " classsource", "filename", "stringpath", "stringnamed", " className", "catchimage", "ClassName", "classfull", "typeimage", "typeName", "className", "entrypath", "filesource", "Classname", " classtype", " classfull", "typepath", "functionName", "fileno", "typenamed", "functionpath", "typekey", "Classnamed", "classnamed", "classno", "CLASSname", "functionnamed", "CLASSfull", "typetype", "Classpath"], "c": ["h", "dc", "cd", "d", "chain", "co", "cat", "k", "l", "con", "b", "css", "f", "ctrl", "cp", "n", "class", "r", "sc", "ac", "mc", "cn", "name", "ci", "cross", "u", "o", "esc", "cl", "t", "cs", "ch", "m", "lc", "com", "col", "abc", "or", "g", "ce", "cc", "ca", "cod", "s", "coll", "p", "C"], "conn": ["net", "connection", "open", "cf", "jp", "io", "ct", "http", "con", "fp", "client", "b", "Conn", "ctrl", "cp", "n", "enc", "ctx", "serv", "config", "ai", "cn", "conf", "init", "rc", "nt", "act", "ch", "cli", "apt", "col", "connect", "lock", "reg", "db", "rt", "j", "conv", "cc", "Connection", "ca", "coll"], "jarFile": ["zipFile", "searchfile", "javaFile", "Jarfile", " jarF", "JarF", "jarBlock", "zipDir", " jarfile", "searchBlock", " jarDir", "searchDir", "javaBlock", "zipfile", "jarfile", "javafile", "JarDir", "JarFile", "zipF", "jarDir", "searchFile", " jarBlock", "jarF", "javaDir"], "e": ["ea", "h", "en", "pe", "d", "ente", "ent", "be", "edge", "iter", "ee", "ed", "l", "ev", "que", "driver", "end", "f", "E", "p", "fe", "ec", "r", "her", "es", "esi", "he", "el", "element", "er", "ge", "event", "o", "de", "ae", "oe", "enter", "je", "se", "le", "eb", "ze", "err", "eu", "ce", "ele", "ie"], "entry": ["next", "page", "reader", "term", "d", "ent", "connection", "result", "cat", "ry", "l", "object", "cell", "part", "row", "f", "add", "data", "class", "r", "auto", "match", "ie", "archive", "ident", "info", "element", "section", "name", "component", "event", "country", "nt", "enter", "comment", "lc", "key", "index", "string", "image", "entity", "obj", "file", "record", "parse", "error", "or", "Entry", "service", "field", " Entry"], "entryname": [" entryName", "importsize", "entryno", "classsize", "importmin", "importinfo", " entrymin", "zipname", "Entrypart", "entersize", "elementpath", "entername", "zipName", "classpart", "entrysize", "servicename", "elementname", "zipnam", "zipimage", "entryName", "importname", "stringname", "Entryno", "serviceName", "serviceimage", " entrysize", "classpath", "stringName", " entryinfo", "Entryname", "elementpart", "elementsize", "stringimage", "elementno", "entryimage", "stringnam", "enterinfo", "className", "entrypath", "entrymin", "entrypart", " entrypath", "entrynam", "servicenam", "entermin", "entryinfo", "EntryName", "classno", "elementName"]}}
{"id1": "20531124", "id2": "13964622", "code1": "    public static Debugger getDebugger(InetAddress host, int port, String password) throws IOException {\n        try {\n            Socket s = new Socket(host, port);\n            try {\n                ObjectOutputStream out = new ObjectOutputStream(s.getOutputStream());\n                ObjectInputStream in = new ObjectInputStream(s.getInputStream());\n                int protocolVersion = in.readInt();\n                if (protocolVersion > 220) {\n                    throw new IOException(\"Incompatible protocol version \" + protocolVersion + \". At most 220 was expected.\");\n                }\n                byte[] challenge = (byte[]) in.readObject();\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes(\"UTF-8\"));\n                md.update(challenge);\n                out.writeObject(md.digest());\n                return new LocalDebuggerProxy((Debugger) in.readObject());\n            } finally {\n                s.close();\n            }\n        } catch (IOException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new UndeclaredThrowableException(e);\n        }\n    }\n", "code2": "    public void setImage(java.awt.Image img) {\n        if (imageName != null && imageName.length() > 0) {\n            try {\n                InputStream url = currentProject.getUrl(imageName).openStream();\n                image = new org.eclipse.swt.graphics.Image(getDisplay(), url);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            Display.getDefault().asyncExec(new Runnable() {\n\n                public void run() {\n                    redraw();\n                }\n            });\n        }\n    }\n", "label": 0, "substitutes": {"host": ["h", "url", "user", "Host", "connection", "username", "conn", "http", "home", "client", "driver", "base", "hello", "prefix", "server", "address", "config", "name", "ssh", "target", "instance", "localhost", "path", "docker", "connect", "socket", "uri", "service", "addr", "domain", "proxy", "null", "ip", "type"], "port": ["url", "PORT", "phone", "limit", "part", "profile", "channel", "version", "server", "address", "Port", "ports", "name", "pid", "target", "ort", "length", "pt", "index", "path", "point", "socket", "file", "nat", "pos", "priority", "pi", "position", "project", "padding", "ip", "p", "type"], "password": ["language", "token", "auth", "connection", "sword", "username", "message", "wd", "definition", "driver", "mode", "login", "channel", "phrase", "email", "prefix", "address", "KEY", "pad", "word", "filename", "name", "pattern", "Pass", "ping", "agent", "string", "path", "key", "MAC", "attribute", "command", "secret", "database", "Password", "crypt", "account", "wallet", "padding", "pass"], "s": ["opens", "ks", "sb", "h", "d", "ss", "ws", "l", "fs", "w", "http", "gs", "b", "sf", "f", "https", "p", "os", "bs", "server", "serv", "south", "sync", "sym", "ssh", "ins", "e", "o", "cs", "t", "m", "ls", "abs", "sin", "ops", "sp", "socket", "c", "ssl", "i", "g", "service", "sq", "ses", "ds", "is", "services", "ts", "S", "ps", "sl"], "out": ["parent", "h", "user", "d", "extra", "io", "output", "conn", "w", "object", "b", "dump", "client", "part", "as", "In", "OUT", "Out", "os", "outs", "n", "again", "prefix", "name", "o", "exp", "m", "copy", "temp", "up", "key", "pool", "obj", "socket", "c", "lock", "i", "err", "g", "array", "is", "conv", "bin", "line", "ext"], "in": ["source", "get", "reader", "h", "id", "url", "input", "inc", "din", "d", "ic", "win", "connection", "min", "nin", "l", "con", "b", "login", "as", "data", "In", "pin", "stream", "again", "serv", "isin", "inner", "init", "ins", "e", "vin", "gin", "m", "ex", "slice", "string", "socket", "c", "i", "IN", "inside", "err", "g", "inn", "rin", "ilo", "is", "bis", "bin", "ac", "pass"], "protocolVersion": ["ProtocolVERSION", "protoperationversion", "proversionLength", "protoseVersion", "protologyString", "proocolLength", "protinterfaceVERSION", "protinterfaceVersion", "protoseversion", "ProtocolString", "proocolVERSION", "protoperationPort", "protpointPort", "proversionVERSION", "protinterfaceLength", "protversionLength", "proversionversion", "protocolString", "protversionVersion", "protologyVersion", "protpointVersion", "protinterfaceversion", "proocolversion", "proversionVersion", "ProtocolVersion", "protoseVERSION", "protocolversion", "protologyversion", "protologyVERSION", "protoperationVersion", "protoperationVERSION", "ProtocolPort", "protocolVERSION", "protocolLength", "protocolPort", "protoseString", "protversionversion", "protpointVERSION", "protpointversion", "proocolVersion", "protversionVERSION", "Protocolversion"], "challenge": ["messocol", "gameenge", "gameester", "failester", "messword", "challword", " challace", "challest", "failword", "passester", " challester", "messester", "failenge", "messenge", "messest", "passest", "gameocol", "gameace", " challocol", "challester", "challace", "failest", "messace", "passenge", "challocol"], "md": ["dc", "um", "hash", "msg", "d", "mb", " Md", "cm", "dd", "ld", "hd", " MD", "mm", "ma", "vd", "sm", "wd", "cmd", "ms", "f", "mo", "mac", "bd", "di", "mand", "mag", "meta", "mc", "sha", "SHA", "mp", "rpm", "dm", "rm", "dh", "MD", "mt", "m", "M", "dr", "df", "od", "pm", "mg", "mad", "metadata", "nd", "amd", "sd", "nm"]}}
{"id1": "15464715", "id2": "22024581", "code1": "    private String sendQuery(String query) {\n        File xmlServerResponse = null;\n        String serverResponse = \"\";\n        try {\n            long start = Calendar.getInstance().getTimeInMillis();\n            System.out.println(\"\\n\\n++++++++++++++++++++++++++++++++++++++++++++++++++++\");\n            System.out.println(\"    consulta de busqueda -> \" + query);\n            URL url = new URL(query);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            while ((line = in.readLine()) != null) {\n                serverResponse += line;\n            }\n            long ahora = (Calendar.getInstance().getTimeInMillis() - start);\n            System.out.println(\" Tiempo transcurrido en la consulta (en milesimas) -> \" + ahora);\n            System.out.println(\"++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return serverResponse;\n    }\n", "code2": "    private static Collection<String> crossCheckFromOBOFile(String category) throws Exception {\n        Collection<String> miCol = new ArrayList<String>();\n        String revision = \"1.48\";\n        URL url = new URL(OboUtils.PSI_MI_OBO_LOCATION + \"?revision=\" + revision);\n        log.debug(\"url \" + url);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        int termCounter = 0;\n        int miCounter = 0;\n        int obsoleteCounter = 0;\n        int obsoleteCounterDef = 0;\n        int typedefCounter = 0;\n        int drugTerm = 0;\n        int psiTerm = 0;\n        String mi = null;\n        while ((inputLine = in.readLine()) != null) {\n            String temp;\n            temp = inputLine;\n            if (inputLine.startsWith(\"[Term]\")) {\n                termCounter++;\n            } else if (inputLine.matches(\"id:\\\\s+(MI:.*)\")) {\n                mi = temp.split(\"\\\\s+\")[1];\n                miCounter++;\n            } else if (inputLine.contains(\"is_obsolete: true\")) {\n                obsoleteCounter++;\n            } else if (inputLine.matches(\"def:.*?OBSOLETE.*\")) {\n                obsoleteCounterDef++;\n            } else if (inputLine.startsWith(\"[Typedef]\")) {\n                typedefCounter++;\n            } else if (inputLine.matches(\"subset:\\\\s+PSI-MI\\\\s+slim\")) {\n                psiTerm++;\n                if (category.equalsIgnoreCase(OboCategory.PSI_MI_SLIM)) miCol.add(mi);\n            } else if (inputLine.matches(\"subset:\\\\s+Drugable\")) {\n                drugTerm++;\n                if (category.equalsIgnoreCase(OboCategory.DRUGABLE)) miCol.add(mi);\n            }\n        }\n        Assert.assertEquals(948, termCounter);\n        Assert.assertEquals(948, miCounter);\n        Assert.assertEquals(53, obsoleteCounter);\n        Assert.assertEquals(53, obsoleteCounterDef);\n        Assert.assertEquals(1, typedefCounter);\n        Assert.assertEquals(844, psiTerm);\n        Assert.assertEquals(124, drugTerm);\n        in.close();\n        return miCol;\n    }\n", "label": 1, "substitutes": {"query": ["source", "select", "sql", "term", "xml", "reply", "range", "result", "message", "format", "request", "description", "data", "resource", "info", "qs", "module", "script", "name", "body", "qu", "report", "json", "password", "text", "comment", "content", "timeout", "time", "string", "answer", "uri", "error", "expression", "command", "Query", "search", "code", "parse", "q", "database", "question", "str", "filter", "series", "type"], "xmlServerResponse": ["xmlServerResult", "xmlServerResp", " xmlServerresponse", "xmlserverResp", " xmlServerResult", " xmlServerResp", "xmlserverResult", "xmlserverresponse", "xmlServerresponse", "xmlserverResponse"], "start": ["next", "get", "Start", "size", "id", "first", "last", "len", "range", "min", "now", "grade", "from", "end", "diff", "st", "part", "base", "set", "stop", "info", "ime", "started", "init", "ize", "step", "enter", "max", "offset", "run", "time", "art", "count", "load", "parse", "since", "check", "ish", "date", "starting", "create", "entry"], "url": ["source", "page", "reader", "input", "link", "user", "connection", "open", "buffer", "feed", "build", "io", "conn", "l", "http", "out", "b", "client", "f", "base", "channel", "stream", "zip", "resource", "org", "server", "log", "bel", "string", "image", "socket", "uri", "file", "ssl", "URL", "hub", "Url", "web", "sl"], "in": ["source", "read", "reader", "h", "id", "input", "inc", "din", "token", "io", "nin", "l", "out", "b", "client", "login", "f", "as", "data", "In", "stream", "again", "r", "server", "inner", "er", "body", "ins", "e", "container", "ini", "kin", "image", "c", "file", "socket", "i", "IN", "ssl", "inn", "ilo", "bin", "s"], "line": ["source", "page", "id", "link", "user", "write", "connection", "lf", "range", "lines", "message", "l", "letter", "definition", "char", "end", "LINE", "cell", "Line", "row", "f", "base", "data", "inline", "response", "r", "server", "word", "sync", "name", "ge", "unit", "log", "cl", "text", "comment", "lc", "key", "le", "string", "frame", "point", "pass", "file", "error", "code", "i", "header", "block", "character", "lin", "str", "ip", "sl", "entry"], "serverResponse": [" serverResp", "systemResp", "erverResponse", " serverRequest", "erverLine", "ServerResp", " serverresponse", "systemLine", "serverReply", "erverResp", " serverReply", "systemResponse", "erverReply", "ServerRequest", "systemReply", "serverLine", " serverLine", "serverResp", "serverRequest", "serverresponse", "erverresponse", "Serverresponse", "ServerResponse", "erverRequest"], "ahora": ["ohora", "ahacia", "jahoras", "amora", "yahoras", "jahora", "amta", "lahora", "yahora", "lahoras", " ahacia", "ohta", "ahta", "ahoras", "ohoras", "lahila", "yahila", "ahoria", "ahila", "jahoria", "jahila", "ohacia", "amacia", "yahoria", "amoras", "lahoria", " ahta", " ahoras"]}}
{"id1": "6326517", "id2": "12829110", "code1": "    public static final String hash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n            password = password + salt;\n            md.update(password.getBytes(\"utf8\"));\n            byte[] b = md.digest();\n            StringBuilder output = new StringBuilder(32);\n            for (int i = 0; i < b.length; i++) {\n                String temp = Integer.toHexString(b[i] & 0xff);\n                if (temp.length() < 2) {\n                    output.append(\"0\");\n                }\n                output.append(temp);\n            }\n            return output.toString();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static String encrypt(String data) throws IOException, NoSuchAlgorithmException {\n        Properties props = Configuration.getInstance().getProperties();\n        String algorithm = props.getProperty(\"com.makeabyte.jhosting.server.persistence.security.algorithm\");\n        String encryptedData = data;\n        boolean encrypt = Boolean.parseBoolean(props.getProperty(\"com.makeabyte.jhosting.server.persistence.security.encrypt\"));\n        if (encrypt) {\n            if (algorithm.equalsIgnoreCase(\"UTF-16LE\")) return encryptActiveDirectory(data);\n            MessageDigest md = java.security.MessageDigest.getInstance(algorithm);\n            md.reset();\n            md.update(data.getBytes());\n            encryptedData = md.digest().toString();\n        }\n        return encryptedData;\n    }\n", "label": 1, "substitutes": {"password": [" Password", "hash", "input", "user", "token", "auth", "connection", "sword", "username", "message", "wd", "PASS", "description", "data", "phrase", "prefix", "email", "config", "address", "pad", "sha", "word", "name", "pa", " passwords", "pattern", "paste", "text", "content", "words", "key", "string", "path", "seed", "cache", "code", "secret", "database", "sudo", "Password", "crypt", "account", "wallet", "store", "padding", "p", "pass"], "md": ["dc", "hash", "d", "mb", " Md", "cm", "dd", "material", "hd", " MD", "sm", "mm", "pd", "mem", "am", "gd", "vd", "cmd", "ms", "bm", "mo", "mac", "bd", "di", "arm", "po", "hm", "mand", "mag", "meta", "mc", "sha", "managed", "mp", "dm", "rm", "mod", "dh", "MD", "mt", "m", "nm", "key", "pm", "km", "mg", "mage", "Cmd", "grad", "metadata", "amd", "mi", "dig", "amp", "ad"], "b": ["sb", "cb", "bf", "d", "mb", "binary", "buffer", "buff", "br", "pb", "l", "f", "base", "bd", "bytes", "bs", "e", "bb", "ob", "a", "bar", "buf", "ba", "gb", "xb", "B", "ib", "emb", "orb", "ab", "c", "db", "bt", "wb", "fb", "nb", "boot", "bis", "lb", "s", "rb", "p", "bl"], "output": ["page", "plain", "tmp", "sb", "operation", "input", "export", "binary", "write", "append", "office", "buffer", "complete", "core", "result", "message", "outer", "format", "foo", "control", "out", "object", "letter", "ou", "console", "environment", "number", "application", "data", "response", "config", "address", "external", "exec", "module", "null", "Output", "target", "text", "job", "v", "offset", "content", "string", "obj", "cut", "fb", "tube", "ilo", "web", "unit"], "i": ["id", "si", "d", "multi", "qi", "k", "io", "l", "f", "di", "n", "bi", "zi", "I", "ti", "ie", "oi", "ai", "gi", "ji", "x", "init", "it", "ui", "u", "e", "ci", "o", "eni", "ix", "length", "t", "ini", "a", "m", "li", "v", "key", "index", "xi", "ri", "j", "c", "uri", "ii", "vi", "pi", "fi", "s", "ip", "p", "type"], "temp": ["tmp", "input", "txt", "token", "result", "extra", "iter", "flat", "letter", "pre", "out", "fake", "stable", "pack", "base", "number", "data", "hex", "tem", "zip", "enc", "clean", "prefix", "gi", "template", "wrap", "Temp", "dest", "exec", "unit", "json", "tc", "api", "ex", "lc", "v", "string", "c", "emp", "cut", "current", "vi", "form", "test", "null", "ext"]}}
{"id1": "2525895", "id2": "6330721", "code1": "    public static byte[] encode(String cryptPassword, byte[] credentials, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] cipherOut = cipher.doFinal(credentials);\n            byte[] ret = new byte[salt.length + cipherOut.length];\n            System.arraycopy(salt, 0, ret, 0, salt.length);\n            System.arraycopy(cipherOut, 0, ret, salt.length, cipherOut.length);\n            return ret;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "code2": "    public int setData(String mysql) {\n        int mycount = 0;\n        try {\n            conn.setAutoCommit(false);\n            mycount = 0;\n            stmt = conn.createStatement();\n            mycount = stmt.executeUpdate(mysql);\n        } catch (Exception e) {\n            mycount = -1;\n        } finally {\n            if (mycount > 0) {\n                try {\n                    conn.commit();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    conn.rollback();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return mycount;\n    }\n", "label": 0, "substitutes": {"cryptPassword": ["passwordPass", "passwordPassword", " cryptPass", "ryptPassword", " cryptpassword", "cryptpassword", "passwordSalt", " cryptString", " cryptSalt", "cryptString", "cryptPass", "ryptpassword", "passwordpassword", "ryptString", "passwordString", "cryptSalt", "ryptPass", "ryptSalt"], "credentials": ["scryptitors", "caboritors", "credeters", "scredentials", "scryptentials", "caborpassword", "cedentials", "credential", "screditors", "caborential", "Chedential", "criptpassword", "cedential", "Chedentials", "cipential", "caborentials", "Credentials", "cryptentials", "Credential", "cryptpassword", "ceduments", "scryptpassword", "Creduments", "criptitors", "credpassword", "chedentials", "cryptential", "chedential", "Credeters", "chedeters", "Cheduments", "creditors", "cedeters", "cryptitors", "scredential", "cipuments", "cheduments", "creduments", "scredpassword", "scryptential", "Chedeters", "cipeters", "criptentials", "cipentials", "criptential"], "salt": ["scipher", "essecret", "sodium", "psodium", "secalt", "seipher", "esALT", "ssecret", "esodium", "Sodium", " sodium", "palt", "Ssecret", "sesALT", "cunt", "sessecret", "sunt", "secALT", "seALT", "scALT", "scalt", "sesalt", "codium", "sipher", "pault", "secodium", "cALT", "seodium", "psulator", "sault", " sunt", "sulator", "ssault", " sALT", "Salt", "calt", " sault", "ssalt", "pALT", "psALT", "seculator", "sert", "scault", "sart", "psalt", "Sret", "seault", "SALT", " sret", "sret", "cert", "ssart", "cart", "pipher", "esalt", "sesodium", "ssALT", " sulator", " sart", "cault", "Sunt", "seert", "cret", "sealt", "sALT"], "digester": [" digitter", "Diger", " digcher", "signester", "diger", "genercher", "generest", "Digester", "generested", "Digested", "signitter", "Digitter", "digitter", "digest", "generester", " digest", "Digcher", "signer", "signest", "digested", "digcher", " diger", " digested", "Digest"], "random": ["reader", "general", "default", "rand", "user", "rar", "token", "network", "range", "chain", "nr", "gener", "ro", "right", "unique", "extra", "io", "regular", "out", "winner", "root", "gen", "normal", "worker", "serial", "r", "re", "remote", "clean", "auto", "server", "config", "resource", "inner", "creator", "reverse", "monkey", "init", "password", "exclusive", "seed", "reg", "or", "manager", "database", "crypt", "order", "ng", "inv", "author"], "i": ["id", "h", "si", "multi", "qi", "ind", "iu", "hi", "k", "io", "phi", "b", "f", "di", "n", "bi", "mu", "I", "ti", "oi", "ai", "gi", "ni", "x", "init", "it", "ui", "u", "e", "ci", "o", "ski", "ini", "m", "li", "v", "xi", "index", "ri", "count", "j", "c", "uri", "ii", "pi", "start", "chi", "z", "mi", "mini", "ip", "p"], "hash": ["host", "ash", "h", "id", "url", "memory", "msg", "input", "auth", "ha", "result", "message", "base", "data", "hex", "mac", "version", "phrase", "enc", "sum", "master", "her", "address", "sha", "kh", "password", "image", "seed", "cache", "check", "array", "secret", "header", "block", "Hash", "crypt", "value", "pass"], "maxKeySize": ["maxKeysize", "maxSecretLen", "maxHashLength", " maxCharLength", "maxBlockLength", "maxBlocksize", " maxKeyLength", "maxCharLength", "maxkeyLength", " maxSecretLen", "maxCharLen", "maxHashsize", "maxHashSIZE", " maxKeysize", "maxkeysize", " maxSecretSize", " maxSecretLength", "maxkeySIZE", " maxKeySIZE", "maxBlockLen", "maxSecretSize", "maxkeySize", "maxBlockSize", "maxCharsize", "maxKeyLen", "maxKeyLength", " maxKeyLen", "maxCharSize", " maxCharSize", " maxCharSIZE", " maxSecretsize", "maxSecretsize", "maxCharSIZE", "maxSecretLength", "maxKeySIZE", " maxCharsize", "maxHashSize"], "generator": ["generate", "genator", "Generater", "gener", "grinator", "ger", "Generator", "generinator", "Generate", "gate", "generater", "gator", "grer", "grate", " generate", "Generer", "grator", " generater", "genater", "Generating", " generer", "generer", "gating", "genating", "generating", "geninator", "genate", "Generinator"], "key": ["source", "id", " secret", "user", "net", "connection", "core", "keys", "k", "message", "sign", " seed", "client", "driver", " object", "mode", "row", "phrase", "Key", "enc", "pair", "server", "raw", "KEY", "name", "cer", "temp", " password", "seed", "cache", "pass", "file", "lock", "ssl", "code", "service", "secret", "ce", "crypt", "kid", "store", "ip", "type"], "cipher": ["scipher", " cryption", "conrypted", "cryption", "encrypt", "Crypted", " coder", "conryption", "encipher", "scoder", "Cairo", "encoder", "Cryption", "cairo", "conrypt", "coder", "crypted", "scryption", "encairo", "conipher", " crypt", "scairo", "scrypt", "Cipher", "encrypted", "Crypt", "crypt", "encryption"], "cipherOut": ["cipherIn", "cipOUT", "acipherOutput", "rcipherInt", "cipherInt", "cipherNew", "cipOutput", "Cipherout", "cipout", "cipherOUT", "Cipout", "rcengeInt", "rcipherout", "CipherOut", "rcipherOUT", "cipIn", "cursorIn", "cairoInt", "cursorOUT", "CipOut", "rcengeout", "rcengeOUT", "cipNew", "cengeInt", "rcipherOut", "acryptOutput", "cipherOutput", "cryptInt", "cengeout", "rcengeOut", "cairoout", "acryptIn", "acipherOut", "CipherNew", "cpherOut", "acipherout", "cpherNew", "cursorOut", "cipOut", "cryptIn", "CipherOUT", "CipNew", "cpherout", "cipherout", "cairoOut", "cpherIn", "cryptout", "acipherIn", "cairoNew", "cairoOutput", "acryptout", "cairoIn", "cengeOUT", "cairoOUT", "cryptOut", "acryptOut", "cryptOUT", "CipIn", "CipherIn", "cengeOut", "CipOUT", "cryptOutput"], "ret": ["value", "py", "tmp", "default", "memory", "bf", "rf", "alt", "continue", "success", "buffer", "rets", "len", "reply", "result", "output", "mem", "out", "val", "def", "base", "data", "phrase", "ref", "re", "response", "match", "repl", "info", "fun", "target", "bit", "temp", "back", "pass", "reg", "replace", "db", "rev", "arg", "secret", "Ret", "res", "exit", "RET", "ext"]}}
{"id1": "17972560", "id2": "948486", "code1": "    private void folderFileChooserActionPerformed(java.awt.event.ActionEvent evt) {\n        if (evt.getActionCommand().equals(JFileChooser.APPROVE_SELECTION)) {\n            File selectedFolder = folderFileChooser.getSelectedFile();\n            File collectionCopyFile;\n            String newDocumentName;\n            Document newDocument;\n            StringBuilder distinguisherReplacer = new StringBuilder();\n            int matchingFilenameDistinguisher;\n            String nextToken;\n            Term newTerm;\n            String userHome;\n            String fileSeparator;\n            int userOption;\n            ArrayList<File> folderTextFiles = new ArrayList<File>();\n            ArrayList<File> folderRejectedFiles = new ArrayList<File>();\n            HashSet<File> ignoredFiles = new HashSet<File>();\n            FileNameExtensionFilter textFileFilter = new FileNameExtensionFilter(\"Text Files\", \"txt\");\n            Scanner tokenizer = null;\n            FileChannel fileSource = null;\n            FileChannel collectionDestination = null;\n            HashMap<String, Integer> termHashMap = null;\n            Index collectionIndex = activeCollection.getIndex();\n            int documentTermMaxFrequency;\n            int currentTermFrequency;\n            for (File folderFile : selectedFolder.listFiles()) if (textFileFilter.accept(folderFile)) folderTextFiles.add(folderFile); else folderRejectedFiles.add(folderFile);\n            for (File selectedFile : folderTextFiles) {\n                newDocumentName = selectedFile.getName();\n                newDocument = new Document(newDocumentName);\n                if (activeCollection.containsDocument(newDocument)) {\n                    matchingFilenameDistinguisher = 1;\n                    newDocumentName = newDocumentName.concat(\"(\" + matchingFilenameDistinguisher + \")\");\n                    newDocument.setDocumentName(newDocumentName);\n                    while (activeCollection.containsDocument(newDocument)) {\n                        matchingFilenameDistinguisher++;\n                        newDocumentName = distinguisherReplacer.replace(newDocumentName.length() - 2, newDocumentName.length() - 1, new Integer(matchingFilenameDistinguisher).toString()).toString();\n                        newDocument.setDocumentName(newDocumentName);\n                    }\n                }\n                termHashMap = new HashMap<String, Integer>();\n                try {\n                    tokenizer = new Scanner(new BufferedReader(new FileReader(selectedFile)));\n                    tokenizer.useDelimiter(Pattern.compile(\"\\\\p{Space}|\\\\p{Punct}|\\\\p{Cntrl}\"));\n                    while (tokenizer.hasNext()) {\n                        nextToken = tokenizer.next().toLowerCase();\n                        if (!nextToken.isEmpty()) if (termHashMap.containsKey(nextToken)) termHashMap.put(nextToken, termHashMap.get(nextToken) + 1); else termHashMap.put(nextToken, 1);\n                    }\n                    documentTermMaxFrequency = 0;\n                    for (String term : termHashMap.keySet()) {\n                        newTerm = new Term(term);\n                        if (!collectionIndex.termExists(newTerm)) collectionIndex.addTerm(newTerm);\n                        currentTermFrequency = termHashMap.get(term);\n                        if (currentTermFrequency > documentTermMaxFrequency) documentTermMaxFrequency = currentTermFrequency;\n                        collectionIndex.addOccurence(newTerm, newDocument, currentTermFrequency);\n                    }\n                    newDocument.setTermMaxFrequency(documentTermMaxFrequency);\n                    activeCollection.addDocument(newDocument);\n                    userHome = System.getProperty(\"user.home\");\n                    fileSeparator = System.getProperty(\"file.separator\");\n                    collectionCopyFile = new File(userHome + fileSeparator + \"Infrared\" + fileSeparator + activeCollection.getDocumentCollectionName() + fileSeparator + newDocumentName);\n                    collectionCopyFile.createNewFile();\n                    fileSource = new FileInputStream(selectedFile).getChannel();\n                    collectionDestination = new FileOutputStream(collectionCopyFile).getChannel();\n                    collectionDestination.transferFrom(fileSource, 0, fileSource.size());\n                } catch (FileNotFoundException e) {\n                    System.err.println(e.getMessage() + \" This error should never occur! The file was just selected!\");\n                    return;\n                } catch (IOException e) {\n                    userOption = JOptionPane.showConfirmDialog(this, \"A file insertion has failed. If you want it to ignore this\" + \"file, press YES, else press NO to repeat the insertion\", \"FileInsertionFailure\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                    if (userOption == JOptionPane.NO_OPTION) {\n                        activeCollection.removeDocument(newDocument);\n                        for (String term : termHashMap.keySet()) {\n                            collectionIndex.removeAllOccurences(new Term(term), newDocument);\n                        }\n                        folderTextFiles.add(selectedFile);\n                    } else ignoredFiles.add(selectedFile);\n                } finally {\n                    try {\n                        if (tokenizer != null) tokenizer.close();\n                        if (fileSource != null) fileSource.close();\n                        if (collectionDestination != null) collectionDestination.close();\n                    } catch (IOException e) {\n                        System.err.println(e.getMessage());\n                    }\n                }\n            }\n            if (ignoredFiles.size() > 0) {\n                IgnoredFilesDialog ignoredFilesDialog = new IgnoredFilesDialog(ignoredFiles, this);\n                ignoredFilesDialog.setVisible(true);\n            }\n            processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));\n        } else if (evt.getActionCommand().equalsIgnoreCase(JFileChooser.CANCEL_SELECTION)) processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"evt": [" evte", "evts", "ekte", "evmt", "ekt", " Evts", "evT", " Evtz", "evte", " Evte", " Evt", " evts", " evtz", "emt", "evtz", " evT", "ekT", "emte", "ekmt", " evmt", " awte", "emmt", " awtz", " awt", "emT", " awts"], "selectedFolder": ["currentArea", "lectedFolder", " selectedDir", "lectedArea", " selectedArea", "selectedContainer", " selectedDirectory", "lectedContainer", "currentDirectory", "currentFolder", "currentFile", "currentContainer", "lectedDirectory", " selectedContainer", "selectedDir", "lectedDir", "currentDir", "lectedFile", "selectedArea", "selectedDirectory"], "collectionCopyFile": ["collectionActivefile", "collectionEditedSourceFile", "collectionEditedFile", " collectionCopyfile", " collectionCopySourceFile", "collectionActiveFile", "collectionActiveSourceFile", "collectionCopyfile", "collectionEditedfile", "collectionCopySourceFile"], "newDocumentName": ["newdocumentUrl", "newFileLine", "freshDocumentLength", "newDocumentDefinition", "newDocAlias", "newFeaturePath", "newProductname", " newDocumentInfo", "newMediaName", "oldDocumentName", "newFileDefinition", "newQuerySync", " newDocumentNames", "NEWDocumentAlias", "newFileUrl", "newDocumentNames", " newDirectoryDefinition", "newContextName", " newDocumentUrl", "newProductAlias", "newFileNames", "newDocUrl", "newDirectoryName", " newDocumentLine", "olddocumentname", "NEWDocAlias", "newDocumentLine", "initialDocumentInfo", "newProductName", "newFileName", "newDocumentSync", " newDocumentAlias", "olddocumentAlias", "newConnectionname", "newQueryInfo", "newDocumentAlias", "newdocumentname", "newdocumentPath", "newdocumentInfo", "freshApplicationname", "freshDocumentName", " newDocumentPath", " newDirectoryInfo", "newConnectionLength", "newDocname", "newDirectoryNames", "newFeatureName", "newFeatureUrl", "newDocSync", "newDocumentPath", "oldDocumentAlias", "newFileAlias", "newdocumentLine", "newApplicationLength", " newDocumentDefinition", "NEWDocumentSync", "NEWDocName", "newDirectoryInfo", "freshApplicationLength", "initialMediaName", " newDirectoryUrl", "newDocumentUrl", "newApplicationName", "NEWDocumentName", "newdocumentAlias", " newDirectoryLine", "newContextname", "newFilePath", "newContextLength", "initialMediaInfo", "newQueryAlias", "newdocumentNames", "newdocumentTime", "NEWDocSync", "newDocumentLength", " newDirectoryName", "newDocumentname", "newdocumentSync", " newDirectoryAlias", "newDirectoryUrl", "newQueryTime", "newQueryName", "newMediaInfo", "NEWDocumentTime", " newDirectoryPath", "oldDocumentname", "newDirectoryAlias", "newdocumentName", "freshApplicationName", "initialDocumentName", "newDocName", "newApplicationname", "newDirectoryLine", "newDirectoryPath", "newDocDefinition", "NEWDocTime", "newFileInfo", "olddocumentName", "newConnectionName", "freshDocumentname", "newDocTime", "newDocumentTime", "newDocPath", "newDirectoryDefinition", "newDocumentInfo", " newDirectoryNames"], "newDocument": ["viewdocument", "nextNumber", "differentdocument", "differentProduct", "olddocument", "oldDirectory", "nextNode", "nextDoc", "newProduct", "currentDocument", "freshDirectory", " newContent", "newContent", "nextProduct", "differentContent", "freshProduct", "differentDocument", "oldProduct", " newDoc", "freshDocument", "oldDocument", "newNode", "currentDoc", " newDocuments", " newProduct", "newNumber", "newSession", "differentDocuments", "NewFile", "NewDoc", "freshDoc", "nextDocument", "Newdocument", "NewDocument", "nextContent", "oldDoc", "newDocuments", "NewNode", "currentFile", "currentdocument", "viewDoc", "newFile", "differentSession", "viewDocument", " newdocument", "nextFile", " newNumber", "freshNumber", "oldSession", "newdocument", "freshSession", "newDoc", "differentDirectory", "nextdocument", " newFile", "nextDocuments", "newDirectory", " newNode", "viewDocuments", "oldDocuments", "NewDocuments"], "distinguisherReplacer": ["distinguisherPrefacer", "distinguisherPlacers", "distinguishersPlacer", "distinguishReplacer", "distinguishReplacement", "distinguisherPrefacement", "distinguisherReplacers", "distinguishreplacement", "distinguishRepliner", "distinguishReplacers", "distinguisherJoaser", "distinguisherJoacer", "distinguisherPlaser", "distinguishreplacer", "distinguishersReplaser", "distinguisherPlacer", "distinguisherPlformer", "distinguisherreplacer", "distinguisherrepliner", "distinguisherJoformer", "distinguishersReplformer", "distinguisherPrefiner", "distinguishersReplacement", "distinguisherreplacement", "distinguishreplacers", "distinguisherPlacement", "distinguishersPlaser", "distinguisherPliner", "distinguisherPrefformer", "distinguisherReplaser", "distinguishersReplacer", "distinguisherreplacers", "distinguisherReplformer", "distinguisherPrefaser", "distinguishersPlformer", "distinguisherReplacement", "distinguisherJoacement", "distinguisherPrefacers", "distinguishersPlacement", "distinguisherRepliner", "distinguishrepliner"], "matchingFilenameDistinguisher": ["matchingFilenameDistinctisher", "matchingFilenameDistinguishers", "matchingFilenameDistributer", "matchingFilenameRestinctisher", "matchingFilenameDistanguishes", "matchingFilenameDistinctiner", "matchingFilenameDistinctioninger", "matchingFilenameContinguiner", "matchingFilenameRestinguishedcher", "matchingFilenameChinctionisher", "matchingFilenameChinguinger", "matchingFilenameRestinguishedishing", "matchingFilenameDistinguishedisher", "matchingFilenameChinctionishes", "matchingFilenameDistinguer", "matchingFilenameContinguishers", "matchingFilenameDistortioniner", "matchingFilenameDistinguish", "matchingFilenameDistortionishers", "matchingFilenameDistinquinger", "matchingFilenameDistinguished", "matchingFilenameContortionishers", "matchingFilenameDistinctcher", "matchingFilenameDistanguisher", "matchingFilenameRestinctishers", "matchingFilenameDistinctioncher", "matchingFilenameChinguished", "matchingFilenameContinguisher", "matchingFilenameDistricishers", "matchingFilenameDistributish", "matchingFilenameDistortionish", "matchingFilenameDistinquisher", "matchingFilenameDistriccher", "matchingFilenameRestinguish", "matchingFilenameDistributishing", "matchingFilenameDistinctishers", "matchingFilenameRestinguisher", "matchingFilenameDistricishing", "matchingFilenameDistingucher", "matchingFilenameDistributcher", "matchingFilenameDistinctionishes", "matchingFilenameDistinguishedishing", "matchingFilenameDistinctionished", "matchingFilenameChinguishes", "matchingFilenameRestingucher", "matchingFilenameContortionisher", "matchingFilenameDistinguishedishers", "matchingFilenameDistinctionisher", "matchingFilenameDistinctish", "matchingFilenameDistinguishedcher", "matchingFilenameDistinctionishers", "matchingFilenameRestinguishers", "matchingFilenameDistributishers", "matchingFilenameRestinguishedish", "matchingFilenameRestinguishing", "matchingFilenameDistinguinger", "matchingFilenameRestincter", "matchingFilenameDistinguishediller", "matchingFilenameDistinguishing", "matchingFilenameChinctioninger", "matchingFilenameDistanguished", "matchingFilenameRestinctish", "matchingFilenameDistinctioniner", "matchingFilenameDistinquished", "matchingFilenameDistinguiner", "matchingFilenameChinguisher", "matchingFilenameRestinguiller", "matchingFilenameRestinguishedisher", "matchingFilenameDistricisher", "matchingFilenameDistortioniller", "matchingFilenameDistinquishes", "matchingFilenameDistortioncher", "matchingFilenameRestinguer", "matchingFilenameContingucher", "matchingFilenameRestinguishediller", "matchingFilenameDistinguishedish", "matchingFilenameDistributisher", "matchingFilenameDistinguiller", "matchingFilenameDistinctioniller", "matchingFilenameDistinguishes", "matchingFilenameContortioniner", "matchingFilenameDistinctionish", "matchingFilenameRestinguishedishers", "matchingFilenameDistinguisheder", "matchingFilenameContortioncher", "matchingFilenameDistanguinger", "matchingFilenameDistincter", "matchingFilenameDistortionisher", "matchingFilenameChinctionished"], "nextToken": ["NextTerm", "newWord", " nextTerm", "NextWord", "NextTokens", "nextWord", "nextTokens", "newToken", "newTokens", " nextWord", " nextTokens", "nextTerm", "NextToken"], "newTerm": [" nextText", "newterm", " newWord", " nextTerm", " newText", " nextterm", "nextWord", " nextWord", "nextterm", "nextText", "newText", "nextTerm", " newterm", "newWord"], "userHome": [" userLocation", "humanHome", "UserHome", "Userhome", " userhome", "humanLocation", "userLocation", "UserLocation", "userhome", "humanhome"], "fileSeparator": ["fileDelatation", "fileDelatate", "fileDelatator", "fileSeparate", "fileSepparator", "fileSeparateator", "fileSeparateation", "fileSepparation", "fileDelarate", "fileSeparation", "fileSepparater", "fileDelatater", "fileDelarater", "fileSeparateater", "fileSeparater", "fileSepparate", "fileDelarator", "fileSeparateate", "fileSepatator", "fileDelaration", "fileSepatater", "fileSepatate", "fileSepatation"], "userOption": [" userOptions", "userEnd", "userOpt", "useOptions", "useOpt", "fileOption", " userEnd", " userOpt", "fileEnd", "fileOpt", "useOption", "fileOptions", "useEnd", "userOptions"], "folderTextFiles": ["folderInputSources", "folderEmptyParents", " folderTextSources", "folderReadFile", "folderTEXTFiles", " folderTextBooks", "folderTextBooks", "folderReadFiles", " folderInputBooks", " folderTextParents", "folderTextPages", "folderEmptyFiles", "folderTEXTPages", "FolderTextPages", "foldertextFiles", "folderInputPages", "folderTEXTBooks", " folderInputFiles", "folderInputItems", "folderReadPages", "folderTextParents", " folderInputItems", "FolderReadFile", " folderInputPages", "folderTEXTFile", "foldertextParents", "foldertextItems", "FolderTextFile", " folderTextfiles", " folderTextItems", "FolderReadFiles", " folderInputfiles", "folderTextSources", "folderInputFiles", " folderInputSources", "folderInputParents", " folderInputParents", "FolderTextFiles", "foldertextBooks", "folderEmptySources", "folderInputBooks", "foldertextSources", "folderTEXTItems", "folderInputfiles", " folderTextPages", "folderTextItems", "folderEmptyfiles", "FolderReadPages", "foldertextPages", "foldertextfiles", "folderTextfiles", "folderTextFile"], "folderRejectedFiles": ["folderPrejectedPages", "folderRejectedItems", "folderReceivedFile", "folderPrejectionFiles", "folderPreceivedItems", "folderRecludedFiles", "folderRejectionFiles", "folderReceivedItems", "folderReruptedFile", "folderPreceivedFile", "folderPrejectedFile", "folderReruptedItems", "folderPrejectionItems", "folderRejectionDocuments", "folderRecludedFile", "folderReceivedFiles", "folderReruptedDocuments", "folderReruptedFiles", "folderRejectionPages", "folderPreceivedPages", "folderPrejectionFile", "folderPrejectionDocuments", "folderPrejectedDocuments", "folderRecludedItems", "folderRejectedDocuments", "folderReruptedPages", "folderReceivedPages", "folderRejectedPages", "folderRejectionItems", "folderRecludedDocuments", "folderRejectionFile", "folderPrejectedItems", "folderPreceivedFiles", "folderRejectedFile", "folderPrejectedFiles"], "ignoredFiles": ["ignoveredParents", "colorableFolder", "ignoveredFiles", "ignouredParents", "ignorableFolder", "coloredFiles", "ignouredFiles", "colorableParents", "ignoredFolder", "coloredParents", "coloredFS", "ignoveredFS", "colorableFiles", "ignorableFS", "ignorableFiles", "ignoveredFolder", "ignorableParents", "ignouredFS", "ignouredFolder", "ignoredParents", "colorableFS", "coloredFolder", "ignoredFS"], "textFileFilter": ["textLineFilter", "classfileParser", "classFileHandler", "textFileParser", "classfileFilter", "textMessageFilter", "classFileFilter", "textFilesFilter", "classFileParser", "classfileManager", "textFilesHandler", "textMessageHandler", "textStringReader", "textLineManager", "TextFilesHandler", "textFileReader", "TextFilesReader", "textFilesExt", "TextFileReader", "textStringHandler", "textFileHandler", "classFileManager", "textFileExt", "TextFileFilter", "TextFileExt", "textfileHandler", "textLineHandler", "TextFilesExt", "textFilesManager", "TextFilesFilter", "TextFileHandler", "textLineParser", "textfileParser", "textStringFilter", "classfileHandler", "textFileManager", "textMessageExt", "textFilesReader", "textFilesParser", "textMessageReader", "textfileFilter", "textStringExt", "textfileManager"], "tokenizer": ["initializer", " tokenize", " tokenization", "tokenization", "Tokenized", "Tokenize", "tokenized", "Tokenizer", " tokenized", "initialized", "tokenize", "Tokenization", "initialize", "initialization"], "fileSource": ["FileResource", "collectionService", "FileSources", "selectionSource", "selectionResource", "FileService", "fileResource", "selectionService", "collectionSource", "collectionResource", "FileSource", "fileService", "collectionSources", "selectionSources", "fileSources"], "collectionDestination": ["collectionOrdribution", "collectionDestinator", "archiveDestribution", "collectionDestinate", "archiveOrdribution", "collectionOrdinator", "collectionHomeinator", "archiveDestinator", "archiveOrdinator", "collectionOrdinate", "collectionOrdination", "collectiondestinate", "collectiondestination", "collectionHomeination", "collectionDestribution", "archiveOrdinate", "archiveDestinate", "archiveOrdination", "collectiondestinator", "collectionHomeinate", "collectionHomeribution", "archiveDestination", "collectiondestribution"], "termHashMap": ["termHandMap", " termHandArray", "termChSet", "termHashSet", "termHashList", "TermMatMap", "termCacheSet", "termHashArray", "TermMatSet", "termChArray", "termHMap", "termMatList", "termHList", "termHandList", " termHashSet", "TermHashList", " termHandSet", "TermMatList", "TermMatArray", "termShSet", "termCacheMap", "TermHashSet", "TermHashArray", "termShMap", "termCacheList", "termMatSet", "termCacheArray", "termHSet", " termHandList", "termHandArray", " termHashList", " termHandMap", "termMatMap", "termChMap", "termChList", " termHashArray", "termShArray", "termMatArray", "termHandSet", "TermHashMap", "termShList", "termHArray"], "collectionIndex": ["collIndex", "containerIndex", " collectionId", "collectionAddress", "collId", "containerindex", "containerAddress", " collectionindex", "collindex", "collectionindex", "collAddress", " collectionAddress", "collectionId", "containerId"], "documentTermMaxFrequency": ["documentTermLimitFraction", "documentTermLimitFrequent", "documentTermLimitRepidelity", "documentTermMaxFrequent", "documentTermMaxWidelity", "documentTermMaxFraction", "documentTermLimitReprequency", "documentTermMaxWrequency", "documentTermMaxfraction", "documentTermLimitReprequent", "documentTermMaxfidelity", "documentTermLimitRepraction", "documentTermMaxfrequent", "documentTermMaxfrequency", "documentTermMaxRepidelity", "documentTermMaxReprequency", "documentTermMaxReprequent", "documentTermMaxRepraction", "documentTermMaxFidelity", "documentTermMaxWraction", "documentTermMaxWrequent", "documentTermLimitFrequency", "documentTermLimitFidelity"], "currentTermFrequency": ["currentWordFreshold", "currentTermPrequently", "currentWordRefrance", "currentTermPrance", "currentTermFrance", "currentTermRefrequently", "currentTermPreshold", "currentWordRefrequently", "currentTermPrequency", "currentTermRefreshold", "currentWordFrance", "currentTermRefrance", "currentWordRefreshold", "currentWordRefrequency", "currentTermBFrequency", "currentTermRefrequency", "currentTermBFrequently", "currentWordFrequently", "currentTermBFrance", "currentTermBFreshold", "currentTermFreshold", "currentWordFrequency", "currentTermFrequently"], "folderFile": ["draftChild", "folderImage", " folderFolder", "FolderFile", "draftF", "directoryFolder", "draftFile", "containerFiles", "archiveFolder", "archiveLine", "folderFolder", "projectFolder", "folderLine", "containerfile", "projectChild", "Folderfile", "containerImage", "flatfile", "folderF", "archiveFile", "directoryfile", "archiveFiles", " folderFiles", "folderChild", "directoryLine", "flatFile", "draftFolder", "projectF", "archiveChild", "FolderFiles", "FolderImage", "archivefile", "directoryFile", "folderfile", "flatFolder", "archiveF", "projectFile", "directoryLocal", " folderImage", "folderLocal", " folderLine", " folderLocal", "directoryFiles", " folderfile", "containerFile", "flatLocal", "folderFiles"], "selectedFile": ["selectionPage", "copyFile", "copyFiles", " selectedDocument", "currentDocument", "copyFolder", " selectedFiles", " selectedPage", "copyDocument", "selectionFolder", "currentFolder", "currentFile", "selectionFiles", "currentPage", "selectedDocument", "selectionDocument", "selectedPage", "selectionFile", "selectedFiles"]}}
{"id1": "9221947", "id2": "6326517", "code1": "    private static boolean copyFile(String src, String dest) {\n        try {\n            File inputFile = new File(src);\n            File outputFile = new File(dest);\n            FileInputStream in = new FileInputStream(inputFile);\n            FileOutputStream out = new FileOutputStream(outputFile);\n            FileChannel inc = in.getChannel();\n            FileChannel outc = out.getChannel();\n            inc.transferTo(0, inc.size(), outc);\n            inc.close();\n            outc.close();\n            in.close();\n            out.close();\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public static final String hash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n            password = password + salt;\n            md.update(password.getBytes(\"utf8\"));\n            byte[] b = md.digest();\n            StringBuilder output = new StringBuilder(32);\n            for (int i = 0; i < b.length; i++) {\n                String temp = Integer.toHexString(b[i] & 0xff);\n                if (temp.length() < 2) {\n                    output.append(\"0\");\n                }\n                output.append(temp);\n            }\n            return output.toString();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"src": ["source", "head", "sel", "sb", "split", "url", "input", "txt", "upload", "download", "sit", "inf", "loc", "href", "stream", "remote", "resource", "sc", "archive", "config", "sub", "filename", "name", "rc", "inst", "ource", "sin", "string", "path", "image", "load", "uri", "file", "code", "dist", "img", "rb", "sl"], "dest": ["source", "folder", "route", "tmp", "later", "suff", "append", "result", "output", "flat", "join", "home", "end", " destination", "delete", "loc", "data", "thin", " Dest", "du", "sup", "filename", "desc", "dir", "target", "Dest", "temp", "done", "orig", "file", "replace", "comb", "wb", "opt", "dist", "destroy", "project", "test", "usr"], "inputFile": ["outputStream", "inputFolder", "inputfile", "outFile", "sourceFolder", " inputfile", " inputFolder", "outPage", "outputFolder", "sourcefile", "sourceFile", "outfile", "outputPage", "outFolder", " inputStream", "outStream", "inputPage", "sourcePage", "inputStream", "sourceStream"], "outputFile": ["outputStream", " outputfile", "inputfile", "outFile", "writeStream", "writefile", "outDir", "outDirectory", "externalDirectory", "configfile", " outputDir", "outputDirectory", "outfile", "externalfile", "inputPlace", "configFile", "configStream", "writeFile", "externalFile", "outputDir", " outputDirectory", "configPlace", "externalDir", "writePlace", "inputStream", "outputPlace", "outputfile"], "in": ["source", "plus", "reader", "id", "url", "input", "ince", "win", "pull", "min", "nin", "conn", "con", "inf", "this", "login", "include", "In", "pin", "again", "n", "enc", "config", "inner", "exec", "ir", "update", "init", "ins", "ini", "issue", "kin", "up", "index", "image", "cin", "lock", "socket", "i", "IN", "inside", "inn", "lin", "bin", "ic"], "out": ["parent", "default", "user", "net", "extra", "co", "io", "outer", "output", "conn", "lib", "app", "client", "ou", "n", "Out", "OUT", "outs", "again", "server", "call", "external", "writer", "inner", "off", "exec", "update", "init", "ins", "o", "other", "exp", "up", "point", "cache", "c", "file", "err", "at", "img", "self", "outside", "working", "bin", "inv", "option", "line", "p"], "inc": ["reader", "dc", "anc", "input", "ic", "ince", "iter", "inf", "include", "pin", "ec", "circ", "enc", "org", "irc", "config", "inner", "ir", "INC", "init", "ins", "rc", "inst", "ci", "keep", "ini", "lc", "issue", "rec", "up", "abc", "index", "Inc", "impl", "c", "inn", "asc", "nc", "cc", "inv", "acc", "imp", "ac"], "outc": ["outcon", "inp", "indc", " outci", " outC", "oudc", "ine", "incon", "oucon", "outci", " oute", "Outc", "outp", "oup", "Outci", "ouc", " outdc", "outC", "outdc", "oute", "ouC", " outp", "inC", " outcon", "OutC", "inci", "Oute"]}}
{"id1": "17551461", "id2": "10899860", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    public void copy(File in, File out) throws Exception {\n        FileChannel src = new FileInputStream(in).getChannel();\n        FileChannel dest = new FileOutputStream(out).getChannel();\n        src.transferTo(0, src.size(), dest);\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"inputFile": ["sourceDir", "outputStream", "inputfile", "InputDirectory", "imageFile", "imageStream", " inputfile", " inputDir", "InputStream", " inputDirectory", "sourceFile", "InputDir", "sourceStream", "InputFile", "imageChannel", "inputDirectory", " inputStream", "imagefile", "inputDir", "sourceDirectory", "inputStream", "outputfile"], "outputFile": ["outputStream", " outputfile", "inputPath", "targetStream", "Outputfile", " outputPath", "OutputStream", " outputStream", "outputFiles", "targetPath", "outputDirectory", "OutputFiles", "targetFiles", " outputFiles", "targetfile", " outputDirectory", "OutputFile", "targetFile", "inputDirectory", "targetDirectory", "outputPath", "inputStream", "outputfile"], "inputChannel": ["parentFile", "outputStream", "inputListener", " inputchannel", "httpCh", "InputListener", "inputCh", "InputSocket", "outputSocket", "InputCh", "outputchannel", "InputStream", "parentChan", "httpChannel", "parentStream", "outputCh", "outputChan", "outputListener", "InputFile", "InputChannel", "inputchannel", "inputChan", "parentSocket", " inputStream", "httpSocket", "httpChan", "InputChan", " inputSocket", "parentChannel", "inputSocket", " inputChan", "Inputchannel", "inputStream", " inputListener"], "outputChannel": ["outputStream", "outChan", "outputSocket", "OutputSocket", "OutputStream", " outputConnection", " outputSocket", " outputStream", "inputConnection", "outputChan", "outSocket", "inputChan", "OutputFile", "outputConnection", " outputChan", "outStream", "outChannel", "OutputChan", "OutputChannel", "OutputConnection", "inputStream"]}}
{"id1": "7902699", "id2": "7891900", "code1": "    public static List<String> getLevelIndex(URL fetchUrl) {\n        List<String> levelNames = new ArrayList<String>();\n        BufferedReader bufferedreader;\n        try {\n            URLConnection urlconnection = fetchUrl.openConnection();\n            urlconnection.setConnectTimeout(30000);\n            if (urlconnection.getContentEncoding() != null) {\n                bufferedreader = new BufferedReader(new InputStreamReader(urlconnection.getInputStream(), urlconnection.getContentEncoding()));\n            } else {\n                bufferedreader = new BufferedReader(new InputStreamReader(urlconnection.getInputStream(), \"utf-8\"));\n            }\n        } catch (IOException _ex) {\n            System.err.println(\"HexTD::readFile:: Can't read from \" + fetchUrl);\n            return levelNames;\n        }\n        String sLine1;\n        try {\n            while ((sLine1 = bufferedreader.readLine()) != null) {\n                if (sLine1.trim().length() != 0) {\n                    levelNames.add(sLine1);\n                }\n            }\n        } catch (IOException ex) {\n            Logger.getLogger(MapLoaderClient.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return levelNames;\n    }\n", "code2": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myUrl == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            InputStream in = myUrl.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["bachUrl", "refetchUr", "faitURL", "FetchUrl", "fachUr", "refachUrl", "forkUrl", "fractURL", "betchUrl", "betchURL", "Fetchurl", "FetchFile", "fetchFile", "betchurl", "fachUrl", "fractUrl", "FetchURL", "fachURL", "refetchURL", "refetchurl", "faitUr", "refachUr", "forkurl", "faiturl", "bachURL", "fetchurl", "forkURL", "refachurl", "faitUrl", "fractFile", "refetchUrl", "bachurl", "betchUr", "bachUr", "fetchUr", "fetchURL", "fracturl", "forkUr", "faitFile", "fachurl", "refachURL"], "levelNames": [" levelFeatures", "levelWords", " levelMembers", "levelnames", " levelnames", " levelWords", "levelInfo", "indexNames", "entrynames", "indexWords", "logFiles", "LevelNames", "indexKeys", "lognames", "levelsNames", "listNames", "fileMembers", "levelsFeatures", " levelList", " levelNs", "levelFiles", " levelKeys", "levelsTags", "entryNames", "LevelList", "LevelNs", "levelKeys", " levelFiles", "fileWords", "logStars", "lineNames", "levelList", "levelFeatures", " levelStars", "levelNs", "indexMembers", "levelsnames", "listList", "LevelInfo", " levelInfo", "levelMembers", "listInfo", "levelTags", "logNames", "levelStars", "entryTags", "lineFiles", " levelTags", "linenames", "entryFeatures", "listNs", "lineStars", "fileNames", "fileKeys"], "bufferedreader": ["Buffereder", "buffendedwriter", " buffererreader", " buffererReader", " buffenedstream", "buffererstream", "Buffenedreader", " buffenedwriter", "bufferingreader", "bufforedreader", "bufferredauthor", " bufferedstream", "buffendedReader", "Bufferedstream", "BufferedReader", "buffererReader", "buffenedauthor", " buffererwriter", "bufferredreader", "buffredReader", "bufferingReader", "buffleder", "buffenedwriter", "buffendedreader", "bufferedauthor", "bufferingwriter", "Buffenedwriter", "buffenedstream", "buffeneder", "buffendeder", "bufferredwriter", "bufferedstream", " buffererauthor", " bufferedReader", "Buffeneder", "buffenedreader", "bufferedwriter", "buffererauthor", "Buffenedstream", "bufferredReader", "buffredwriter", "buffledreader", "buffledwriter", " bufferedauthor", "buffredreader", "buffererreader", "Bufferedreader", "buffererwriter", " buffenedReader", " bufferedwriter", "buffenedReader", "buffledReader", "bufforedstream", "bufforedwriter", "BuffenedReader", " buffenedreader", "Bufferedwriter", "buffredstream", "buffereder", "bufferingstream", "bufforedReader", "bufferedReader"], "urlconnection": ["urlservice", "httpcommunication", "httpcontext", "urlconfig", "urlcontext", "lConnection", "webconn", "webconnect", "URLconn", "urlconnect", "httpConnection", "llconfig", "urlcommunication", "collconnection", " urlcontext", "URLConnection", "lconnection", " urlservice", "httpconfig", " urlconfig", "collConnection", " urlConnection", "webConnection", " urlconnect", "httpconnection", "lconnect", "httpconn", " urlconn", "httpconnect", "urlConnection", "llconnect", "collconnect", "URLconnection", "urlconn", "llConnection", "URLcommunication", "webcommunication", "elcontext", "URLservice", "collconfig", "lservice", "webconnection", "lconn", "elconn", "webconfig", "elconnection", "llconnection", "elconnect"], "sLine1": ["sL2", "sBlock2", "pLine6", "sLine2", " sBlock1", "sline1", "sBlock0", "sBlockOne", "sUnit1", "sLWeb", " sLU", " sBlockOne", "sLineWeb", "pLin6", " sLineOnce", " sLOne", "sline2", "sByte6", "pLine1", "sPass1", "sLookOne", "sBlock1", "sLin1", "pLin1", "sLineOnce", "sBlockOnce", "sL1", " sL2", "slineWeb", "sLin6", "sL0", " sLine0", "sLookOnce", "sLinOne", " sL1", " sBlockOnce", "sPassOne", "sUnitOne", "sUnit6", "sLook0", "sLU", "sLineU", "sByte0", "sLine0", "sLin2", "sByteOnce", " sLine2", " sBlock0", "sline0", "sByte1", "sByteOne", "sLineOne", " sLineU", "sPass2", "sPassU", "sBlockWeb", "sLine6", " sLineOne", "sLinU", "pLineOne", "pLinOne", "sLook1", "sLOne"]}}
{"id1": "22095676", "id2": "17180286", "code1": "    public static String addTag(String tag_id, String tag_description, String tag_text, String tag_author, String application_code) {\n        String so = OctopusErrorMessages.UNKNOWN_ERROR;\n        if (tag_id == null || tag_id.trim().equals(\"\")) {\n            return OctopusErrorMessages.TAG_ID_CANT_BE_EMPTY;\n        }\n        if (tag_id.trim().equals(application_code)) {\n            return OctopusErrorMessages.TAG_ID_TOO_SHORT;\n        }\n        if (!StringUtil.isAlphaNumerical(StringUtil.replace(StringUtil.replace(tag_id, \"-\", \"\"), \"_\", \"\"))) {\n            return OctopusErrorMessages.TAG_ID_MUST_BE_ALPHANUMERIC;\n        }\n        if (!tag_id.startsWith(application_code)) {\n            return OctopusErrorMessages.TAG_ID_MUST_START + \" \" + application_code;\n        }\n        String tag_exist = exist(tag_id);\n        if (!tag_exist.equals(OctopusErrorMessages.DOESNT_ALREADY_EXIST)) {\n            return tag_exist;\n        }\n        if (tag_description != null && !tag_description.trim().equals(\"\")) {\n            tag_description = StringUtil.replace(tag_description, \"\\n\", \" \");\n            tag_description = StringUtil.replace(tag_description, \"\\r\", \" \");\n            tag_description = StringUtil.replace(tag_description, \"\\t\", \" \");\n            tag_description = StringUtil.replace(tag_description, \"<\", \"&#60;\");\n            tag_description = StringUtil.replace(tag_description, \">\", \"&#62;\");\n            tag_description = StringUtil.replace(tag_description, \"'\", \"&#39;\");\n        } else {\n            return OctopusErrorMessages.DESCRIPTION_TEXT_EMPTY;\n        }\n        if (tag_text != null && !tag_text.trim().equals(\"\")) {\n            tag_text = StringUtil.replace(tag_text, \"\\n\", \" \");\n            tag_text = StringUtil.replace(tag_text, \"\\r\", \" \");\n            tag_text = StringUtil.replace(tag_text, \"\\t\", \" \");\n            tag_text = StringUtil.replace(tag_text, \"<\", \"&#60;\");\n            tag_text = StringUtil.replace(tag_text, \">\", \"&#62;\");\n            tag_text = StringUtil.replace(tag_text, \"'\", \"&#39;\");\n        } else {\n            return OctopusErrorMessages.TRANSLATION_TEXT_EMPTY;\n        }\n        if (tag_author == null || tag_author.trim().equals(\"\")) {\n            return OctopusErrorMessages.MAIN_PARAMETER_EMPTY;\n        }\n        DBConnection theConnection = null;\n        try {\n            theConnection = DBServiceManager.allocateConnection();\n            theConnection.setAutoCommit(false);\n            String query = \"INSERT INTO tr_tag (tr_tag_id,tr_tag_applicationid,tr_tag_info,tr_tag_creationdate) \";\n            query += \"VALUES (?,?,'\" + tag_description + \"',getdate())\";\n            PreparedStatement state = theConnection.prepareStatement(query);\n            state.setString(1, tag_id);\n            state.setString(2, application_code);\n            state.executeUpdate();\n            String query2 = \"INSERT INTO tr_translation (tr_translation_trtagid, tr_translation_language, tr_translation_text, tr_translation_version, tr_translation_lud, tr_translation_lun ) \";\n            query2 += \"VALUES(?,'\" + OctopusApplication.MASTER_LANGUAGE + \"','\" + tag_text + \"',0,getdate(),?)\";\n            PreparedStatement state2 = theConnection.prepareStatement(query2);\n            state2.setString(1, tag_id);\n            state2.setString(2, tag_author);\n            state2.executeUpdate();\n            theConnection.commit();\n            so = OctopusErrorMessages.ACTION_DONE;\n        } catch (SQLException e) {\n            try {\n                theConnection.rollback();\n            } catch (SQLException ex) {\n            }\n            so = OctopusErrorMessages.ERROR_DATABASE;\n        } finally {\n            if (theConnection != null) {\n                try {\n                    theConnection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n                theConnection.release();\n            }\n        }\n        return so;\n    }\n", "code2": "    public static String encodePassword(String plainTextPassword) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n        messageDigest.update(plainTextPassword.getBytes(\"UTF-8\"));\n        byte[] digestBytes = messageDigest.digest();\n        String hex = null;\n        for (int i = 0; i < digestBytes.length; i++) {\n            hex = Integer.toHexString(0xFF & digestBytes[i]);\n            if (hex.length() < 2) sb.append(\"0\");\n            sb.append(hex);\n        }\n        return new String(sb);\n    }\n", "label": 0, "substitutes": {"tag_id": ["bug_id", " tag_name", "bug_type", "attribute_name", " tag_ids", "tag_entry", "attribute_code", "tagacid", "tagacID", " tag_entry", "tag_main", "tag67id", "tag67entry", "tagacname", "attribute_id", "tag_type", "tagactype", " tag_title", "tagaccode", "attribute_author", " tag_main", "tag_length", "tag67title", "bug_name", "bug_length", "tagaclength", "bug_code", "tag_code", "tag_ids", "bug_description", "tag67name", "tagacdescription", "tag_title", "tag_ID", "tag_name", " tag_ID", " tag_type"], "tag_description": ["post_description", "optionftotal", "tag_duration", "option_name", "tag_value", "tagppassword", "post_translation", "cat_description", "optionfexpression", "tag_comment", "tag24name", "attribute_password", "tag_entry", "tagJsecret", "attribute_summary", "ack_description", "tag_summary", "post_design", "tag_secret", "tag_total", " tag_duration", "tag__description", "tag_design", "attribute_design", "taggexpression", "blog_display", "tag_release", "tag_desc", "blog24display", "tag_layout", "date_summary", "bug_category", "bug_secret", "post_type", "tag_detail", "option_description", "ack_creation", " tag_layout", "ack_release", "taggoption", "option_total", "post_option", "cat_details", "tag_type", "post_definition", "tag_category", "bug_entry", "date_details", "tagJtext", "tag24comment", "tagJdescription", "tag24expression", "tagfdescription", "tag__duration", "taggdescription", "blog24description", "tagpdescription", "tag24total", "tick_release", "tag24description", "attributepdesign", "date_password", "tag_report", "tag_display", "tick_description", "date_length", "cat_definition", "tag_length", "blog_description", "tag_translation", "optionfdescription", "tick_summary", "tick_detail", "bug_name", "option_expression", "date_desc", "tagftotal", "tagfexpression", "blog_comment", "tag_creation", "post_summary", "bug_author", "attributepdescription", "bug_report", "taggtype", "tag_option", "date_description", "date_author", "attribute_description", "tagpdesign", "tagfname", "tag__text", "bug_description", "tagJentry", "tagpsummary", "optionfname", "tag_expression", "tag_details", "post_creation", "ack_value", "tag24display", "tag__layout", "attributepsummary", "attributeppassword", "tag_name", "bug_text", "cat_text", "tag_password", "post_expression", "tag_definition", "blog24comment"], "tag_text": ["tag___description", "tag___writer", "tag_comment", "ag_name", "ag64name", "ag64text", "tag_message", "tag64id", "tag64text", "tag_secret", "comment_text", "tag64secret", "tag_desc", "ag_author", "comment_comment", "ag64id", "tag___translation", "ag64author", " tag_translation", "tag_content", "ag_text", "tag___text", "tag_translation", "ag_id", "tag64name", " tag_secret", " tag_message", " tag_writer", "comment_desc", "tag_writer", "tag_name", "tag64author", "tag64message", "comment_content"], "tag_author": ["tag67author", "atom_from", "tag67version", "atom_id", "tag67from", "tag_from", "atom\u00b7author", "tag__id", "tag__author", "tag\u00b7from", "atom_author", "atom_version", "tag__version", "tag__from", "atom\u00b7id", "tag\u00b7version", "tag67id", "atom\u00b7from", "tag\u00b7id", "atom\u00b7version", "tag_version", "tag\u00b7author"], "application_code": ["application_uri", " application_address", " application_codes", "application_id", "applicationingcontent", "company_code", " application_url", "applicationflowcode", "application1address", "application24url", "application24code", "applicationCtext", "company_id", "applicationflowtext", "companyflowtext", "packageinglength", "package_Code", "packageingcode", "application_url", "companyflowid", "application_length", "package_code", "applicationflowuri", " application_Code", "companyflowuri", "applicationinglength", "application_address", "applicationflowid", "applicationelength", "application_Code", "application1url", "application1codes", " application_name", "applicationeCode", "package_content", "applicationecontent", "company_uri", "application24codes", "application_codes", "applicationingcode", "application1code", "application_name", "company_text", "applicationecode", "applicationCcode", "application24address", "applicationCCode", "packageingcontent", "application_text", "applicationingCode", "package_length", "applicationCname", "application_content", "companyflowcode", " application_text", "packageingCode"], "so": [" Error", "msg", " fault", " o", " result", " exception", "result", " exc", "sg", "Message", " results", "ERROR", " output", " mess", " out", " ERROR", " resp", " res", " sw", " success", " er", " failure", " reply", "Msg", " rc", "error", " orig", "err", " ans"], "tag_exist": ["tag_edit", "message1exist", "tag_existence", " tag_existence", " tag_purpose", "tag1existent", "tag67existence", "tag67edit", "bug_existent", "bug_cont", "message1missing", "tag_cont", "message_missing", "message_exist", "message_existent", "tag1delete", "tag_existent", "tag_missing", "tag67purpose", "tag1exist", "bug_exist", "tag1missing", " tag_edit", "tag_delete", "message_delete", "tag_purpose", "message1delete", "bug_existence", "tag67exist", "message1existent"]}}
{"id1": "10067028", "id2": "3708296", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            long size = in.size();\n            MappedByteBuffer buffer = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buffer);\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    public byte[] transfer(@Nullable final TransferListener transferListener) {\n        try {\n            InputStream inputStream = url.openStream();\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream(inputStream.available());\n            if (transferListener != null) {\n                inputStream = new ObservableInputStream(inputStream, transferListener);\n            }\n            ByteStreams.copy(InputSuppliers.asInputSupplier(inputStream), outputStream);\n            return outputStream.toByteArray();\n        } catch (IOException e) {\n            throw new UnhandledException(e);\n        }\n    }\n", "label": 0, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "src", "from", "object", "Source", "client", "base", "table", "stream", "remote", "resource", "server", "inner", "ources", "sync", "filename", "name", "ins", "target", "ource", "sin", "SOURCE", "internal", "slice", "path", "image", "string", "cache", "file", "service", "proxy", "use"], "destination": [" Destination", " Destinations", "destitution", "declinator", "declination", "Destinated", "distinated", "distination", "distitution", "declinations", "destinated", "declinated", "Destinator", "constinator", "constitution", "destinations", "Destinations", " Destinator", "constination", "destinator", "constinated", "distinator", " Destinated", "Destination", "Destitution"], "in": ["get", "reader", "id", "url", "input", "inc", "din", "token", "win", "pull", "min", "nin", "conn", "src", "con", "b", "this", "diff", "login", "base", "as", "data", "In", "pin", "again", "n", "r", "include", "thin", "stream", "server", "work", "isin", "inner", "info", "pc", "name", "init", "ins", "gin", "ini", "m", "issue", "up", "slice", "index", "cin", "image", "socket", "c", "file", "i", "IN", "err", "inside", "inn", "is", "bin", "pass"], "out": ["parent", "id", "plain", "write", "line", "net", "connection", "extra", "io", "output", "outer", "conn", "one", "w", "client", "ou", "part", "channel", "to", "no", "version", "OUT", "Out", "again", "n", "prefix", "outs", "server", "external", "writer", "inner", "off", "exec", "dest", "sync", "init", "o", "other", "target", "flush", "ex", "timeout", "up", "image", "pool", "vert", "cache", "obj", "file", "socket", "err", "at", "outside", "bin", "copy", "null", "ext"], "size": ["page", "export", "en", "write", "si", "len", "range", "scale", "weight", "limit", "sized", "end", "mode", "Size", "number", "loc", "SIZE", "bytes", "n", "sum", "address", "shape", "send", "depth", "name", "transfer", "sync", "e", "ize", "length", "flush", "capacity", "max", "content", "offset", "time", "count", "code", "seek", "width", "speed", "type", "order", "empty", "small", "clear", "unit"], "buffer": ["reader", "value", "url", "input", "queue", "feed", "buff", "iter", "Buffer", "output", "BB", "channel", "base", "layer", "data", "resource", "address", "info", "writer", "uffer", "null", "batch", "bb", "flow", "length", "wave", "FFER", "buf", "offset", "document", "cache", "map", "header", "texture", "bin", "copy"]}}
{"id1": "4140309", "id2": "11902597", "code1": "    public String encrypt(final char[] password, final String algorithm, final byte[] salt) {\n        final StringBuffer buffer = new StringBuffer();\n        MessageDigest digest = null;\n        int size = 0;\n        if (\"SHA\".equalsIgnoreCase(algorithm) || \"SSHA\".equalsIgnoreCase(algorithm)) {\n            size = 20;\n            if ((salt != null) && (salt.length > 0)) {\n                buffer.append(\"{SSHA}\");\n            } else {\n                buffer.append(\"{SHA}\");\n            }\n            try {\n                digest = MessageDigest.getInstance(\"SHA-1\");\n            } catch (final NoSuchAlgorithmException e) {\n                throw new IllegalStateException(\"Invalid algorithm\");\n            }\n        } else if (\"MD5\".equalsIgnoreCase(algorithm) || \"SMD5\".equalsIgnoreCase(algorithm)) {\n            size = 16;\n            if ((salt != null) && (salt.length > 0)) {\n                buffer.append(\"{SMD5}\");\n            } else {\n                buffer.append(\"{MD5}\");\n            }\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (final NoSuchAlgorithmException e) {\n                throw new IllegalStateException(\"Invalid algorithm\");\n            }\n        } else {\n            throw new UnsupportedOperationException(\"Not implemented\");\n        }\n        int outSize = size;\n        digest.reset();\n        try {\n            digest.update(new String(password).getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 Unsupported\");\n        }\n        if ((salt != null) && (salt.length > 0)) {\n            digest.update(salt);\n            outSize += salt.length;\n        }\n        final byte[] out = new byte[outSize];\n        System.arraycopy(digest.digest(), 0, out, 0, size);\n        if ((salt != null) && (salt.length > 0)) {\n            System.arraycopy(salt, 0, out, size, salt.length);\n        }\n        buffer.append(new String(Base64.encodeBase64(out)));\n        return buffer.toString();\n    }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Start filtering zgps...\");\n        final Config config = Gbl.createConfig(args);\n        final String CONFIG_MODULE = \"GPSFilterZGPS\";\n        File sourceFileSelectedStages = new File(config.findParam(CONFIG_MODULE, \"sourceFileSelectedStages\"));\n        File sourceFileZGPS = new File(config.findParam(CONFIG_MODULE, \"sourceFileZGPS\"));\n        File targetFile = new File(config.findParam(CONFIG_MODULE, \"targetFile\"));\n        System.out.println(\"Start reading selected stages...\");\n        FilterZGPSSelectedStages selectedStages = new FilterZGPSSelectedStages();\n        selectedStages.createSelectedStages(sourceFileSelectedStages);\n        System.out.println(\"Done. \" + selectedStages.getSelectedStages().size() + \" stages were stored\");\n        System.out.println(\"Start reading and writing zgps...\");\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFileZGPS)));\n            BufferedWriter out = new BufferedWriter(new FileWriter(targetFile));\n            out.write(in.readLine());\n            out.newLine();\n            String lineFromInputFile;\n            while ((lineFromInputFile = in.readLine()) != null) {\n                String[] entries = lineFromInputFile.split(\"\\t\");\n                if (selectedStages.containsStage(Integer.parseInt(entries[0]), Integer.parseInt(entries[1]), Integer.parseInt(entries[2]))) {\n                    out.write(lineFromInputFile);\n                    out.newLine();\n                    out.flush();\n                }\n            }\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"Could not find source file for selected stages.\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.out.println(\"IO Exception while reading or writing zgps.\");\n            e.printStackTrace();\n        }\n        System.out.println(\"Done.\");\n    }\n", "label": 0, "substitutes": {"password": ["source", "hash", "input", "url", "token", "auth", "sword", "username", "message", "wd", "channel", "data", "phrase", "email", "prefix", "address", "config", "pad", "word", " passwords", "pattern", "text", "session", "key", "string", "path", "seed", "attribute", "code", "secret", "Password", "crypt", "account", "wallet", "value", "padding", "pass"], "algorithm": ["Algo", " Algebra", "acgorith", "allignment", "calgorithm", "ALignment", "ulgebra", "organignment", "ALgo", "ulgorith", "calgebra", "ALgorith", "acgorithm", "dalgebra", "palgebra", "Algebra", "realgorith", "halgorithm", "elignment", "allgorithm", "organgorithm", "malgorith", "calgo", "acgebra", "aggo", "malgebra", "aggorith", "elgebra", "palgo", "palgorith", "calocol", "ulgorithm", "Alignment", "Algorith", " Algo", "algebra", "algo", " algebra", "alocol", "allgebra", "ALgorithm", "malignment", "aggorithm", "alignment", "allgorith", "calignment", "dalgo", "Algorithm", " alignment", "palgorithm", "elgorithm", " Algorith", " algorith", "Alocol", "organgebra", "aggebra", "ulignment", "halgorith", "acgo", "realgorithm", "organocol", "algorith", "halignment", "dalgorith", "malgorithm", "realgebra", "calgorith", "palignment", "realgo", "elgorith", "dalgorithm", "ALgebra", " Algorithm", "halgebra"], "salt": ["psodium", "dsugar", "singALT", "isodium", "sass", "Sodium", "sllet", "servicesALT", "dsalt", "nalt", "sesALT", "isalt", "seALT", "isALT", "sesatter", "hlet", "ansoff", "slert", "ansal", "slort", "sort", "isort", "sesave", "inul", "seert", "psort", "nodium", "inalt", "Satter", "ssal", " soff", "todium", "wsort", "dsunt", " sALT", "Salt", "slal", "sesunt", "esass", "dodium", "sart", "hul", "satter", "sesiter", "servicesunt", "wsodium", "siter", "wsALT", "sesodium", " sal", "dass", "essecret", " save", "tALT", "ssecret", "halt", "hart", "sslet", "ssave", " sass", "singodium", "ssALT", "sesalt", "sul", " sunt", "save", "bodium", "sert", "sesass", "slodium", "ssort", "tart", "slalt", "psalt", "gsalt", "slALT", "sugar", "bort", "dalt", "dart", "nass", "hal", "slart", "dALT", "sloff", "sALT", " sert", "sesugar", "isatter", "sodium", "batter", "servicesugar", "slunt", "dsALT", "singart", "sssecret", "servicesalt", "wsalt", "soff", "dort", "hunt", "sessecret", "sunt", "inart", " sul", "balt", "seart", "slatter", "talt", " ssecret", "ssalt", "psALT", "inunt", "isass", "hort", "SALT", "slet", "gssecret", "gsass", "nort", "singalt", " sart", "esalt", "gsALT", "sal", "ansunt", "ssass", "ansalt", "esiter", "sealt"], "buffer": ["source", "page", "reader", "url", "input", "queue", "binary", "memory", "write", "buff", "result", "iter", "Buffer", "message", "output", "view", "letter", "b", "bc", "row", "base", "loader", "data", "response", "server", "writer", "shared", "uffer", "exec", "sync", "transfer", "null", "surface", "bb", "flush", "text", "FFER", "buf", "bar", "window", "string", "image", "document", "seed", "cache", "pool", "code", "builder", "array", "header", "block", "secret", "empty", "bin", "stack", "copy", "port", "shell"], "digest": ["Diger", "digger", "decest", "mdester", "digester", " digger", "digests", "signester", "signests", " digress", "Digests", " diginer", "Digger", " digests", "integester", "Digword", "mdest", "Digher", "diffested", " digse", " Diger", "legher", "Digress", "diger", "diginer", "leginer", "legest", "digse", "generest", "signse", "decer", "differ", "digress", " Digest", "Digester", "diffester", "integest", "Digested", "mdmaster", " Digger", "Digitter", "Diginer", "decester", "decested", "digitter", " digmaster", "integword", " digher", "generword", "generester", "mder", "Digmaster", "signress", "digher", " digester", "legester", "integitter", "digword", "Digse", "signer", "signest", "diffest", "digested", " diger", " Digester", " digested", "digmaster", "Digest", "generitter"], "size": ["now", "end", "number", "address", "sync", "name", "max", "count", "width", "position", "small", "scale", "weight", "security", "iz", "Size", "SIZE", "shape", "esc", "length", "se", "zero", "start", "en", "len", "core", "loc", "false", "sum", "external", "x", "send", "ize", "capacity", "i", "use", "shift", "fee", "from", "sized", "here", "six", "member", "large", "ci", "offset", "sec", "code", "speed", "pos", "form", "empty", "sn", "any", "unit"], "outSize": [" outLen", "inAddress", "inLine", "inCode", "inLen", "outAddress", "outputLength", "againAddress", "outLine", "OUTLen", " outC", "OUTSize", "blockSize", "blockLength", "againLine", "outputC", "outputLen", "outLen", "againLen", "OUTAddress", "inLength", "inSize", "againCode", "againSize", "againLength", "outputSize", "outC", "outCode", "outLength", "blockC", "outputCode", "OUTLine", "blockLen", " outLength"], "out": ["source", "shift", "parent", "url", "user", "result", "extra", "min", "output", "io", "view", "in", "diff", "part", "base", "OUT", "again", "Out", "external", "writer", "inner", "off", "update", "word", "x", "name", "full", "batch", "exp", "flush", "comment", "all", "window", "index", "image", "list", "cache", "code", "err", "array", "secret", "group", "empty", "copy", "line", "pass"]}}
{"id1": "20841292", "id2": "10673772", "code1": "    public void fileCopy(File src, File dest) throws IOException {\n        if (!dest.exists()) {\n            final File parent = new File(dest.getParent());\n            if (!parent.exists() && !parent.mkdirs()) {\n                throw new IOException();\n            }\n            if (!dest.createNewFile()) {\n            }\n        }\n        FileInputStream is = null;\n        FileOutputStream os = null;\n        try {\n            is = new FileInputStream(src);\n            os = new FileOutputStream(dest);\n            final FileChannel srcChannel = is.getChannel();\n            final FileChannel dstChannel = os.getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } finally {\n            try {\n                if (is != null) {\n                    is.close();\n                }\n            } finally {\n                if (os != null) {\n                    os.close();\n                }\n            }\n        }\n    }\n", "code2": "    private File extractResource(String resourceName, File destDir) {\n        File file = new File(destDir, resourceName);\n        InputStream in = getClass().getResourceAsStream(resourceName);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(file);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n        return file;\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "tmp", "url", "upload", "sit", "conn", "this", "b", "in", "st", "root", "loc", "data", "stream", "class", "resource", "sc", "server", "config", "sub", "filename", "desc", "rc", "inst", "s", "fn", "Dest", "buf", "sin", "slice", "path", "obj", "file", "ssl", "dist", "img", "copy", "rb", "rest", "sl"], "dest": ["source", "folder", "route", "tmp", "later", "dc", "trans", "default", "d", "txt", "cat", "output", "cdn", "out", "home", "this", "st", "root", "delete", "to", "data", "cp", "class", "zip", "slave", " Dest", "sup", "name", "desc", "usr", "dir", "target", "de", "nt", "cont", "transform", "Dest", "temp", "done", "sort", "slice", "orig", "path", "obj", "file", "comb", "wb", "opt", "dist", "destroy", "project", "null", "rest"], "parent": ["source", "Parent", "folder", "plain", "id", "user", "cat", "home", "object", "this", "client", "root", "part", "loc", "layer", "data", "directory", "class", "remote", "master", "resource", "ctx", "child", "ac", "fat", "cot", "desc", "dir", "pa", "target", "unit", "container", "instance", "temp", "image", "pool", "pointer", "cache", "point", "file", "c", "current", "valid", "op", "null", "cmp", "p"], "is": ["get", "nis", "id", "si", "be", "isa", "ss", "fs", "ais", "isl", "out", "in", "ist", "app", "ms", "css", "hide", "as", "was", "iss", "are", "bs", "ris", "serv", "ai", "info", "isin", "ir", "x", "ics", "iv", "has", "isi", "init", "it", "ins", "ci", "iris", "IS", "cs", "api", "mis", "abs", "ls", "sin", "isc", "ri", "lis", "ios", "ops", "ori", "its", "i", "or", "ois", "us", "ar", "Is", "obs", "osi", "bis", "iso", "ps", "s", "ip", "ib", "does", "ie"], "os": ["los", "oses", "io", "acs", "oser", "object", "ns", "ros", "OS", "ou", "bos", "op", "oes", "as", "oa", "bs", "ot", "ens", "es", "js", "vs", "oss", "oos", "oS", "ui", "o", "aos", "Os", "nos", "ose", "ios", "ops", "ori", "i", "ol", "ols", "or", "pos", "us", "cos", "ds", "obs", "boot", "osi", "iso", "ps", "s", "so"], "srcChannel": ["sourceConnection", "srcchannel", " srcQueue", "sourceChan", "rcChan", " srcChan", "destChan", "configChannel", "configchannel", "configChan", "rcStream", " srcStream", " srcConnection", " srcCh", "rcchannel", "destchannel", "srcChan", "rcChannel", "srcQueue", "configStream", "rcCh", "srcCh", "destQueue", "sourceQueue", "rcConnection", "srcStream", "destChannel", " srcchannel", "sourceCh", "sourcechannel", "sourceChannel", "srcConnection"], "dstChannel": ["dntchannel", "destClient", "dntChan", "dstStream", "dstsChan", " dstStream", "ddestchannel", "DestHandler", "Destchannel", "DstClient", "ddestChannel", "ddsMember", "drcChannel", "ddsChan", "destChan", "dndchannel", "drcChan", "DstChannel", "ddsChannel", "drcMember", "dntChannel", "destchannel", "dntStream", "dstHandler", " dstChan", "dstChan", " drcChannel", "dstsStream", " destChannel", "ddestHandler", "destHandler", " destChan", "destStream", "DestChannel", "dstschannel", "drcchannel", "dndChan", "dstClient", "dstMember", "dndChannel", "drcHandler", " drcMember", "destChannel", "Dstchannel", " destchannel", "drcClient", "DestClient", "ddestClient", "DstHandler", "dstchannel", " destStream", " dstchannel", "dndMember", " drcchannel", " drcChan", " dstMember", "dstsChannel", "ddschannel"]}}
{"id1": "22197335", "id2": "460892", "code1": "    private void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "sb", "url", "input", "txt", "upload", "download", "sit", "inf", "b", "loc", "stab", "stream", "sc", "config", "dest", "sup", "filename", "ins", "rc", "inst", "ls", "sin", "slice", "path", "rl", "obj", "file", "uri", "files", "sq", "dist", "img", "sn", "proxy", "s", "rb"], "dst": ["sdst", " dsts", "dsts", "dST", "dsrc", "nsts", "adct", "rdft", "nst", "Ddest", "adst", "sdsrc", "ndest", "rdsrc", "rdct", "adft", "DST", "rdst", "Dsts", " ddest", " dST", "dft", "dct", "adsrc", "Dst", "nST", "ddest", "sdft", "sdct"], "in": ["source", "reader", "id", "url", "input", "inc", "din", "ln", "trans", "win", "pull", "nin", "conn", "con", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "stream", "inner", "init", "ins", "gin", "ini", "kin", "sin", "up", "cin", "socket", "file", "i", "IN", "inside", "inn", "rin", "is", "lin", "bin"], "out": ["parent", "trans", "inc", "net", "io", "output", "outer", "conn", "lib", "w", "client", "part", "data", "n", "Out", "OUT", "outs", "again", "server", "raw", "call", "writer", "off", "exec", "sync", "o", "other", "exp", "log", "ex", "post", "up", "pool", "obj", "cache", "file", "i", "err", "cos", "at", "img", "self", "bin", "copy", "ext"], "buf": ["cb", "tmp", "queue", "bf", "bh", "uc", "buffer", "buff", "br", "lim", "b", "cmd", "bc", "fd", "loc", "cv", "base", "data", "bd", "ref", "bytes", "ctx", "box", "raw", "pad", "off", "func", "batch", "rc", "bb", "length", "seq", "uf", "cap", "bag", "orig", "c", "vec", "fb", "ff", "bn", "bin", "rb", "bp"], "len": ["size", "split", "en", "id", "num", "ln", "lf", "ind", "iter", "min", "limit", "lim", "l", "end", "val", "fd", "part", "f", "base", "Len", "data", "no", "n", "enc", "off", "el", "body", "nt", "length", "cap", "lc", "li", "fl", "le", "all", "dy", "count", "c", "rev", "err", "pos", "fin", "line"]}}
{"id1": "20536502", "id2": "23186914", "code1": "    public void testSavepoint4() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.execute(\"CREATE TABLE #savepoint4 (data int)\");\n        stmt.close();\n        con.setAutoCommit(false);\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"iteration: \" + i);\n            PreparedStatement pstmt = con.prepareStatement(\"INSERT INTO #savepoint4 (data) VALUES (?)\");\n            pstmt.setInt(1, 1);\n            assertTrue(pstmt.executeUpdate() == 1);\n            Savepoint savepoint = con.setSavepoint();\n            assertNotNull(savepoint);\n            assertTrue(savepoint.getSavepointId() == 1);\n            try {\n                savepoint.getSavepointName();\n                assertTrue(false);\n            } catch (SQLException e) {\n            }\n            pstmt.setInt(1, 2);\n            assertTrue(pstmt.executeUpdate() == 1);\n            pstmt.close();\n            pstmt = con.prepareStatement(\"SELECT SUM(data) FROM #savepoint4\");\n            ResultSet rs = pstmt.executeQuery();\n            assertTrue(rs.next());\n            assertTrue(rs.getInt(1) == 3);\n            assertTrue(!rs.next());\n            pstmt.close();\n            rs.close();\n            con.rollback(savepoint);\n            pstmt = con.prepareStatement(\"SELECT SUM(data) FROM #savepoint4\");\n            rs = pstmt.executeQuery();\n            assertTrue(rs.next());\n            assertTrue(rs.getInt(1) == 1);\n            assertTrue(!rs.next());\n            pstmt.close();\n            rs.close();\n            con.rollback();\n        }\n        con.setAutoCommit(true);\n    }\n", "code2": "    public void save(Connection conn, boolean commit) throws SQLException {\n        PreparedStatement stmt = null;\n        if (!isValid()) {\n            String errorMessage = \"Unable to save invalid DAO '\" + getClass().getName() + \"'!\";\n            if (log.isErrorEnabled()) {\n                log.error(errorMessage);\n            }\n            throw new SQLException(errorMessage);\n        }\n        try {\n            if (isNew()) {\n                primaryKey = createNewPrimaryKey();\n                stmt = conn.prepareStatement(getInsertSql());\n            } else {\n                stmt = conn.prepareStatement(getUpdateSql());\n            }\n            setValues(stmt);\n            int rowCount = stmt.executeUpdate();\n            if (rowCount != 1) {\n                primaryKey = OvUuid.NULL_UUID;\n                if (commit) {\n                    conn.rollback();\n                }\n                String errorMessage = \"Invalid number of rows changed!\";\n                if (log.isErrorEnabled()) {\n                    log.error(errorMessage);\n                }\n                throw new SQLException(errorMessage);\n            } else {\n                if (commit) {\n                    conn.commit();\n                }\n            }\n        } finally {\n            OvJdbcUtils.closeStatement(stmt);\n        }\n    }\n", "label": 1, "substitutes": {"stmt": ["Stmon", "pst", " stmr", "Stmp", "Stmr", "pmt", "stMT", "StMT", " stlt", " stm", "stst", "stmp", "strMT", "stm", "stlt", " stmon", " stMT", "stmr", "pmp", "strmp", "Stlt", " stst", "stmon", "Stst", "strmt", " stmp", "Stm", "pm", "putmr", "strlt", "putmt", "putm", "Stmt", "putmon"], "i": ["id", "h", "num", "si", "multi", "qi", "counter", "hi", "phi", "k", "yi", "in", "b", "part", "f", "number", "di", "n", "r", "bi", "I", "ti", "oi", "ai", "gi", "info", "x", "ui", "u", "e", "ci", "eni", "step", "t", "m", "li", "v", "xi", "index", "ri", "count", "j", "c", "uri", "ii", "vi", "pi", "is", "start", "fi", "chi", "mi", "p"], "pstmt": [" postm", "psthmm", "postm", "pthmt", "rthmn", "tptmn", "Pctmot", "pvnl", "pstnl", "Pstm", "psthmt", "pstst", " pfm", "pzm", " pstmd", "pctct", "pthMT", "pthnl", "pftts", "pustmr", "pstrMT", "pptmt", " pftmt", "pstret", " pstm", "pstmb", "rstmt", "pctmb", " pftm", "pctmr", "Pstret", "Pctmt", "pstrst", "Pstnt", "pstmr", "pfrMT", " pestnl", "pstMT", "Pctret", "pspmt", "pctm", "pstts", "pstrts", "pspmot", "pvnt", "pptm", "pstmn", "pustmt", "Pstst", "Pctct", "pstm", " pstts", "pssret", "Pstmb", "Pctnl", "pustmn", "postmm", "pmtmn", "tstmp", "Pctnt", "rthnl", "pestmt", "Pctmb", " pestm", "pstnm", "pmtm", "Pctm", " postmt", "psthmr", "pptmp", "rstMT", " pftts", "tptmp", "pthm", "pfmd", "pfm", "pctnt", "pspst", "psthnl", "pstrmt", "pssm", "pvct", "pestnl", "Pstpm", " pfmd", "pspm", "psthm", "tstmt", "pestm", "Pstct", " pestmt", "tstmn", "pfrmn", "pmtmt", "pctret", "Pstmp", " postmr", " pestnm", "pctmm", "rstnl", "pctpm", "pfmp", "postmr", " pstnm", "postmn", "pftmb", "pstmot", "pthmn", "pzmp", "pstmp", "rstmn", "pstpm", "pctmd", "Pstmt", "pmtmb", " pstmm", "pctmn", "pfrnl", "pzmt", "pstrnl", " pstmp", "psthct", "pctmp", "tstm", "pthnm", "pstrm", "tptmt", " pftmn", " pstnl", "pctmt", "rthMT", " pfmt", "pfrmt", "pspmb", "psthnt", " postmm", "pptmd", "pstmd", "Pstmn", "Pctmn", "pftmt", "pftm", "pustm", "pstnt", "pstct", "pstrmn", "pctmot", "pctts", "pctnl", "pstrpm", "rthmt", "Pctpm", "pptmn", "pvmt", "postmt", " pstmr", "Pstnl", "pzret", "Pctmp", "pssmp", "Pstmot", "tptm", "pstmm", "pftmot", "pftmn", "pssmt", "postmp", "Pctst", " pstmn", "pctnm", " pfmp", "pfmt", "psppm", "pestnm", " postmn", "pctst"], "savepoint": ["savingPoint", " savep", "avepointer", "savPoint", "savpoint", "avep", "savingpoint", "Savepoints", "Savepoint", "savepointer", "savp", "savep", "savingpoints", "savepoints", "avePoint", "savePoint", "savpointer", "avepoint", " savepoints", "SavePoint", "Savepointer", " savepointer", "savingpointer", " savePoint", "Savep"], "rs": ["ums", "Rs", "hs", "RC", "ys", "ks", "relations", "rys", "ows", "ra", "rx", "errors", "runs", "acks", "co", "RS", "rss", "yrs", "con", "gs", "ros", "ars", "ms", "row", "issues", "r", "bs", "ubs", "changes", "ris", "repl", "RR", "eers", "vs", " rows", "xs", "ack", "asts", "rc", "results", "ins", "pps", "spec", "cs", "sr", "hr", "pr", "ls", "dr", "ays", "rows", "rl", "maps", "reg", "rt", "rd", "rors", "mr", "details", "vers", "rr", "ras", " RS", "obs", "ats", "ts", "kr", "ps", "res", "rics"]}}
{"id1": "13902980", "id2": "11036037", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(String srcFilename, String destFilename) throws IOException {\n        int bytes_read = 0;\n        byte[] buffer = new byte[512];\n        FileInputStream fin = null;\n        FileOutputStream fout = null;\n        try {\n            fin = new FileInputStream(srcFilename);\n            try {\n                fout = new FileOutputStream(destFilename);\n                while ((bytes_read = fin.read(buffer)) != -1) {\n                    fout.write(buffer, 0, bytes_read);\n                }\n            } finally {\n                try {\n                    if (fout != null) {\n                        fout.close();\n                        fout = null;\n                    }\n                } catch (IOException e) {\n                }\n            }\n        } finally {\n            try {\n                if (fin != null) {\n                    fin.close();\n                    fin = null;\n                }\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfile", "infilename", "outFile", "infiles", "inFile", "inputfiles", "inputfilename", "outfiles", " infilename", "infp", " infp", "inputfp", "outfilename", "Infiles", " infiles", "InFile", "outfp", "Infilename", "inputFile", "Infile"], "outfile": ["outputfp", "outFile", "infilename", "Outname", "newfile", "OutFile", "outputfilename", " outFile", "newname", "infp", "newfolder", "outfilename", "Outfile", " outfolder", "newFile", " outname", "outfolder", " outfp", "outputfolder", "outfp", "Outfolder", "infolder", "outname", " outfilename", "outputfile"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "min", "nin", "conn", "con", "b", "login", "as", "base", "data", "In", "pin", "into", "re", "r", "inas", "thin", "again", "ac", "isin", "inner", "init", "ins", "vin", "gin", "ini", "a", "m", "sin", "cin", "image", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "bin", "s", "ic", "pass"], "out": ["source", "parent", "inc", "write", "net", "co", "io", "output", "outer", "conn", "lib", "one", "client", "home", "ou", "base", "on", "to", "no", "In", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "ex", "post", "timeout", "session", "up", "job", "point", "image", "cache", "socket", "file", "obj", "error", "err", "or", "bin", "copy", "exit", "line"], "buffer": ["source", "size", "reader", "split", "url", "queue", "input", "write", "binary", "feed", "len", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "base", "layer", "data", "bytes", "server", "raw", "address", "uffer", "transfer", "null", "padding", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "count", "border", "seed", "cache", "fb", "value", "type"], "read": ["play", "select", "next", " write", "size", "reader", "ad", "input", "get", "write", "inc", "id", "feed", "len", "Read", "ind", "iter", " skip", "fill", "READ", "ride", "io", "limit", "end", "tell", "f", "sleep", "find", "n", "work", "raw", "exec", "x", "sync", "send", "reading", "_", "length", "allow", "run", "close", "se", "slice", "count", "pass", "load", "connect", "parse", "i", "seek", "check", "wait", "lex", "current", " copy", "start", " count", "ip", "add", "copy", " Read", "use", "reads"], "success": ["successful", "continue", "roll", "default", "warning", "first", "better", "successfully", "open", " succeed", "complete", "growth", "result", "right", "message", "Success", "true", "flash", "winner", " succ", "model", " successful", "cess", "data", "fast", "again", "response", "primary", "xx", "rolled", " Success", "method", "func", "results", "failed", "initial", "comment", "danger", "content", "status", "done", "path", "respons", "error", "fail", "modified", "valid", "construct", "ccess", "rolling", "follow", "ceed", "good", "value", "null", "pass"]}}
{"id1": "6644160", "id2": "1760352", "code1": "    public void saveHiddenNames(HashSet names) throws SQLException {\n        Connection conn = AppLayerDatabase.getInstance().getPooledConnection();\n        PreparedStatement ps = null;\n        try {\n            conn.setAutoCommit(false);\n            Statement stmt = conn.createStatement();\n            stmt.executeUpdate(\"DELETE FROM HIDDENBOARDNAMES\");\n            stmt.close();\n            stmt = null;\n            ps = conn.prepareStatement(\"INSERT INTO HIDDENBOARDNAMES (boardname) VALUES (?)\");\n            for (Iterator i = names.iterator(); i.hasNext(); ) {\n                String bName = (String) i.next();\n                ps.setString(1, bName);\n                ps.executeUpdate();\n            }\n            ps.close();\n            conn.commit();\n            conn.setAutoCommit(true);\n        } catch (Throwable t) {\n            logger.log(Level.SEVERE, \"Exception during save\", t);\n            try {\n                conn.rollback();\n            } catch (Throwable t1) {\n                logger.log(Level.SEVERE, \"Exception during rollback\", t1);\n            }\n            try {\n                conn.setAutoCommit(true);\n            } catch (Throwable t1) {\n            }\n        } finally {\n            AppLayerDatabase.getInstance().givePooledConnection(conn);\n            try {\n                if (ps != null) ps.close();\n            } catch (Throwable t1) {\n            }\n            ;\n        }\n    }\n", "code2": "    public static int deleteContract(String likePatten) {\n        Connection conn = null;\n        PreparedStatement psmt = null;\n        StringBuffer SQL = new StringBuffer(200);\n        int deleted = 0;\n        SQL.append(\" DELETE FROM JHF_ALIVE_CONTRACT \").append(\" WHERE   ORDER_ID LIKE  ? \");\n        try {\n            conn = JdbcConnectionPool.mainConnection();\n            conn.setAutoCommit(false);\n            conn.setReadOnly(false);\n            psmt = conn.prepareStatement(SQL.toString());\n            psmt.setString(1, \"%\" + likePatten + \"%\");\n            deleted = psmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            if (null != conn) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    System.out.println(\" error when roll back !\");\n                }\n            }\n        } finally {\n            try {\n                if (null != psmt) {\n                    psmt.close();\n                    psmt = null;\n                }\n                if (null != conn) {\n                    conn.close();\n                    conn = null;\n                }\n            } catch (SQLException e) {\n                System.out.println(\" error  when psmt close or conn close .\");\n            }\n        }\n        return deleted;\n    }\n", "label": 1, "substitutes": {"names": ["paces", "strings", "keys", "ons", "parents", "nets", "params", "b", "ns", "types", "as", "appings", "blocks", "n", "objects", "changes", "prefix", "stars", "rooms", "groups", "name", "xs", "users", "na", "results", "AMES", "members", "nam", "words", "list", "headers", "cache", "maps", "ans", "apps", "files", "beans", "ids", "tags", "s", "ames", "Names", "terms"], "conn": ["dc", "sql", "connection", "cm", "util", "ht", "core", "co", "cat", "ct", "http", "con", "pg", "client", "ns", "Conn", "loc", "po", "cp", "n", "os", "enc", "ctx", "org", "server", "config", "dn", "can", "mc", "cn", "pc", "exec", "conf", "oss", "ci", "nt", "act", "log", "coll", "pr", "ch", "cli", "lc", "ann", "session", "col", "cr", "pool", "connect", "orp", "c", "cache", "db", "rt", "ssl", "lock", "oci", "socket", "impl", "reg", "g", "cc", "cms", "obj", "Connection", "ca", "nc", "port", "ad", "p"], "ps": ["ks", "points", "pe", "ss", "ws", "jp", "pb", "pl", "ons", "fs", "pre", "params", "gs", "pg", "ns", "ms", "css", "http", "po", "ups", "cp", "pub", "os", "bs", "changes", "posts", "qs", "pc", "vs", "eps", "ports", "ppa", "xs", "tp", "pa", "pps", "cs", "PS", "pr", "ls", "Ps", "pt", "pse", "pm", "ops", "sp", "ips", "details", "pp", "aps", "pos", "ras", "pers", "ds", "ts", "pas", "s", "p"], "stmt": ["strgr", " stgr", "strmd", "Stmm", "stgr", "stMT", "stmm", "Stmb", " stmd", " stlt", " stm", "strmb", "strv", "symt", "strMT", "stm", "stmd", "stlt", "sthgr", "sypt", "symb", " stMT", "stpt", "sthMT", "stmb", "sthmb", " stmm", "sym", "putv", "strmm", "strmt", " stpt", "Stm", " stv", "sthmt", "strlt", "putmt", "putm", " stmb", "putlt", "Stpt", "strm", "Stmt", "Stmd", "stv"], "i": ["id", "si", "multi", "qi", "abi", "ami", "iter", "hi", "phi", "io", "ati", "l", "b", "f", "di", "n", "bi", "mu", "I", "oi", "ti", "ai", "gi", "info", "x", "it", "ui", "ci", "e", "u", "eni", "api", "ini", "xi", "li", "ri", "wei", "j", "ori", "ii", "vi", "pi", "is", "chi", "ip", "p", "ie"], "bName": ["BZone", "cNames", "lbKey", "cString", "bInfo", "lbName", "bNames", "BName", " bKey", "buInfo", " bZone", "cKey", "cName", " bInfo", "bZone", "BInfo", "lbString", "bString", "lbNames", " bString", "bKey", "buZone", " bNames", "buName"]}}
{"id1": "15723802", "id2": "14807299", "code1": "    void createAgentProgram(PrintStream ps, String agentName, String agentID) throws IOException, ConfigException {\n        Agent agent = service.getAgent(agentName);\n        File instanceDir = getInstanceDir();\n        double agent_timeout_seconds = engine.getTimeout();\n        String ii = \"\\\"\";\n        String agentScript = \"agent-\" + agentName + \".py\";\n        String serviceScript = \"service.py\";\n        Set<String> taskNames = agent.getTasks().keySet();\n        File scriptDir = getService().getScriptDir();\n        final boolean embedScripts = true;\n        {\n            ps.println(\"#!/bin/sh\");\n            ps.println(\"umask 0077\");\n        }\n        for (String taskName : taskNames) {\n            Task task = getService().getTask(taskName);\n            String script = task.getScriptContent();\n            if (embedScripts) {\n                ps.println();\n                ps.println(\"cat > \" + task.getFile() + \" << \" + ii + \"EOF_\" + task.getFile() + ii);\n                ps.println(script);\n                ps.println(\"EOF_\" + task.getFile());\n            } else {\n                File taskScriptFile = new File(instanceDir, task.getFile());\n                PrintStream xs = new PrintStream(taskScriptFile);\n                xs.print(script);\n                xs.close();\n            }\n        }\n        {\n            PrintStream ss = null;\n            if (embedScripts) {\n                ps.println();\n                ps.println(\"cat > \" + serviceScript + \" << \" + ii + \"EOF_\" + serviceScript + ii);\n                ss = ps;\n            } else {\n                File serviceScriptFile = new File(instanceDir, serviceScript);\n                ss = new PrintStream(serviceScriptFile);\n            }\n            service.createServiceScript(ss);\n            if (embedScripts) ps.println(\"EOF_\" + serviceScript); else ss.close();\n        }\n        {\n            URL url = new URL(engine.getAgentContextURL() + \"/\" + engine.getAgentURLPath());\n            log.debug(\"url for agent = \" + url.toExternalForm());\n            PrintStream as = null;\n            if (embedScripts) {\n                ps.println();\n                ps.println(\"cat > \" + agentScript + \" << \" + ii + \"EOF_\" + agentScript + ii);\n                as = ps;\n            } else {\n                File agentScriptFile = new File(instanceDir, agentScript);\n                as = new PrintStream(agentScriptFile);\n            }\n            String tab[] = { \"\", \"    \", \"        \", \"            \", \"                \", \"                    \" };\n            int i = 0;\n            as.println(tab[i] + \"from wrapper import ZSIWrapper\");\n            as.println(tab[i] + \"from service import Service\");\n            as.println(tab[i] + \"import threading\");\n            as.println(tab[i] + \"from sys import exit\");\n            as.println();\n            as.println(tab[i] + \"URL=\" + ii + url.toString() + ii);\n            as.println(tab[i] + \"agentID=\" + ii + agentID + ii);\n            as.println(tab[i] + \"instanceID=\" + instanceID);\n            as.println(tab[i] + \"instanceKey=\" + ii + key + ii);\n            as.println(tab[i] + \"timeout=\" + ii + agent_timeout_seconds + ii);\n            as.println(tab[i] + \"stop_flag=0\");\n            as.println(tab[i] + \"kill_flag=0\");\n            as.println();\n            as.println(tab[i] + \"# Need extra port for each thread, \" + \"ZSIWrapper (actually ZSI) not thread save\");\n            as.println(tab[i] + \"port0=ZSIWrapper(URL, agentID, instanceID, instanceKey, timeout)\");\n            as.println(tab[i] + \"port0.setAgentStatus(\" + Status.RUNNING.ordinal() + \")\");\n            as.println();\n            as.println(tab[i] + \"def create_namespace(service) :\");\n            as.println(tab[i] + \"    \" + ii + \"create a namespace for injection \" + \"into a task script and returns it.\" + ii);\n            as.println(tab[i] + \"# first get most (not all) variables\");\n            as.print(tab[i] + \"    arglist = [ \");\n            int counter = 0;\n            for (VarAttributes va : attributesMap.values()) {\n                counter++;\n                String varname = va.getName();\n                if (Constants.VAR_STDOUT.equals(varname)) continue;\n                VarTypeEnum vartype = va.getType();\n                switch(vartype) {\n                    case DOUBLE:\n                    case STRING:\n                    case LONG:\n                    case BOOLEAN:\n                    case CHOICE:\n                        as.print(tab[i] + \"    '\" + varname + \"'\");\n                        if (counter != attributesMap.size()) as.println(\",\\\\\");\n                        break;\n                    case FILES:\n                        break;\n                    default:\n                        throw new RuntimeException(\"unkown data type in switch\");\n                }\n            }\n            as.println(\"]\");\n            as.println(tab[i] + \"    vars=port0.getManyVars(arglist)\");\n            as.println(tab[i] + \"    namesp = vars \");\n            as.println(tab[i] + \"    namesp[ 'service' ] = service \");\n            as.println(tab[i] + \"    return namesp\");\n            as.println();\n            for (String taskName : taskNames) {\n                Task task = getService().getTask(taskName);\n                boolean background = task.isBackground();\n                as.println(tab[i] + \"def task_\" + taskName + \"():\");\n                {\n                    i++;\n                    as.println(tab[i] + \"try :\");\n                    if (background) {\n                        as.println(tab[i] + \"    # as ZSIWrapper is not task save,\" + \" create a new one\");\n                        as.println(tab[i] + \"    port_task=ZSIWrapper(URL, agentID, \" + \"instanceID, instanceKey, timeout)\");\n                        as.println(tab[i] + \"    service = Service(port_task)\");\n                    } else {\n                        as.println(tab[i] + \"    # this is foreground, \" + \"use port0 from current task\");\n                        as.println(tab[i] + \"    service = Service(port0)\");\n                    }\n                    as.println(tab[i] + \"    globals = create_namespace(service)\");\n                    as.println(tab[i] + \"    locals = { }\");\n                    as.println(tab[i] + \"    execfile('\" + task.getFile() + \"', globals, locals )\");\n                    as.println(tab[i] + \"except :\");\n                    as.println(tab[i] + \"    port0.setTaskStatus('\" + taskName + \"', \" + Status.FAILED.ordinal() + \" )\");\n                    as.println(tab[i] + \"else :\");\n                    as.println(tab[i] + \"    if kill_flag :\");\n                    as.println(tab[i] + \"        task_exit_status = \" + Status.FAILED.ordinal());\n                    as.println(tab[i] + \"    elif stop_flag :\");\n                    as.println(tab[i] + \"        task_exit_status = \" + Status.TERMINATED.ordinal());\n                    as.println(tab[i] + \"    else :\");\n                    as.println(tab[i] + \"        task_exit_status = \" + Status.FINISHED.ordinal());\n                    as.println(tab[i] + \"    port0.setTaskStatus('\" + taskName + \"', task_exit_status )\");\n                    as.println();\n                    i--;\n                }\n            }\n            as.println(tab[i] + \"try:\");\n            i++;\n            as.println(tab[i] + \"tasklist = []\");\n            as.println(tab[i] + \"action=None\");\n            as.println(tab[i] + \"while action != '\" + Agent.STOP + \"' and action != '\" + Agent.KILL + \"' and action != '\" + Agent.FINISH + \"' :\");\n            {\n                i++;\n                as.println(tab[i] + \"# print 'ACTION=', action\");\n                as.println(tab[i] + \"action = port0.getAction()\");\n                as.println(tab[i] + \"\");\n                as.println(tab[i] + \"# cleanup tasklist (only to save memory)\");\n                as.println(tab[i] + \"# In two cycles, don't change list during iter.\");\n                as.println(tab[i] + \"to_be_removed = []\");\n                as.println(tab[i] + \"for tr2 in tasklist:\");\n                as.println(tab[i] + \"    if (not tr2.isAlive()):\");\n                as.println(tab[i] + \"        to_be_removed.append(tr2)\");\n                as.println(tab[i] + \"for tr3 in to_be_removed:\");\n                as.println(tab[i] + \"    # print 'old task removed: ',tr3.getName()\");\n                as.println(tab[i] + \"    tasklist.remove(tr3)\");\n                as.println(tab[i] + \"\");\n                as.println(tab[i] + \"if action == None :\");\n                as.println(tab[i] + \"    # print 'processing None'\");\n                as.println(tab[i] + \"    None\");\n                as.println(tab[i] + \"if action == '\" + Agent.FINISH + \"' :\");\n                as.println(tab[i] + \"    # print 'processing FINISH'\");\n                as.println(tab[i] + \"    None\");\n                as.println(tab[i] + \"elif action == '\" + Agent.STOP + \"' :\");\n                as.println(tab[i] + \"    stop_flag=1\");\n                as.println(tab[i] + \"    # print 'processing STOP'\");\n                String onStop = agent.onStop;\n                if (onStop != null) {\n                    String function = \"task_\" + onStop;\n                    as.println(tab[i] + \"    \" + function + \"()\");\n                }\n                as.println(tab[i] + \"\");\n                as.println(tab[i] + \"elif action == '\" + Agent.KILL + \"' :\");\n                as.println(tab[i] + \"    kill_flag=1\");\n                as.println(tab[i] + \"    # print 'processing KILL'\");\n                String onKill = agent.onKill;\n                if (onKill != null) {\n                    String function = \"task_\" + onKill;\n                    as.println(tab[i] + \"    \" + function + \"()\");\n                }\n                as.println(tab[i] + \"    # This would be the place \" + \"to kill external programs\");\n                as.println(tab[i] + \"    port0.setAgentStatus(\" + Status.FAILED.ordinal() + \")\");\n                as.println(tab[i] + \"    # exit without waiting for bg threads\");\n                as.println(tab[i] + \"    exit(13)\");\n                as.println(tab[i] + \"\");\n                for (String taskName : taskNames) {\n                    Task task = getService().getTask(taskName);\n                    boolean background = task.isBackground();\n                    as.println(tab[i] + \"elif action == '\" + Agent.TASK + taskName + \"':\");\n                    String function = \"task_\" + taskName;\n                    if (background) {\n                        as.println(tab[i] + \"    # create, register and start task\");\n                        as.println(tab[i] + \"    t = threading.Thread(target=\" + function + \", name='\" + function + \"')\");\n                        as.println(tab[i] + \"    tasklist.append(t)\");\n                        as.println(tab[i] + \"    t.start()\");\n                    } else {\n                        as.println(tab[i] + \"    \" + function + \"()\");\n                    }\n                }\n                as.println(tab[i] + \"else :\");\n                as.println(tab[i] + \"    print 'undefined case in agent script iov0j23fds, \" + \"action=', action\");\n                i--;\n            }\n            as.println();\n            as.println(tab[i] + \"# wait for running background tasks\");\n            as.println(tab[i] + \"# print 'remaining threads (inclides demonic ones!):'\" + \", threading.activeCount()\");\n            as.println(tab[i] + \"# for tr in threading.enumerate():\");\n            as.println(tab[i] + \"#    print 'remaining thread: ',\" + \" tr.getName()\");\n            as.println(tab[i] + \"for tr2 in tasklist:\");\n            as.println(tab[i] + \"    # print 'joining with ',tr2.getName()\");\n            as.println(tab[i] + \"    tr2.join()\");\n            i--;\n            as.println(tab[i] + \"# Set agent status\");\n            as.println(tab[i] + \"except :\");\n            as.println(tab[i] + \"    port0.setAgentStatus(\" + Status.FAILED.ordinal() + \")\");\n            as.println(tab[i] + \"else :\");\n            as.println(tab[i] + \"    if kill_flag :\");\n            as.println(tab[i] + \"        agent_exit_status = \" + Status.FAILED.ordinal());\n            as.println(tab[i] + \"    elif stop_flag :\");\n            as.println(tab[i] + \"        agent_exit_status = \" + Status.TERMINATED.ordinal());\n            as.println(tab[i] + \"    else :\");\n            as.println(tab[i] + \"        agent_exit_status = \" + Status.FINISHED.ordinal());\n            as.println(tab[i] + \"    port0.setAgentStatus( agent_exit_status )\");\n            if (embedScripts) ps.println(\"EOF_\" + agentScript); else as.close();\n        }\n        for (String agentFileName : agent.getFilesSet()) {\n            ps.println();\n            File agentRelFile = new File(agentFileName);\n            File directory = agentRelFile.getParentFile();\n            if (directory != null) {\n                ps.println(\"mkdir -p \" + directory.getPath());\n            }\n            ps.println(\"cat > \" + agentFileName + \" << \" + ii + \"EOF_\" + agentFileName + ii);\n            File file = new File(scriptDir, agentFileName);\n            byte bytes[] = FileUtils.readFileToByteArray(file);\n            ps.write(bytes);\n            ps.println();\n            ps.println(\"EOF_\" + agentFileName);\n        }\n        if (embedScripts) {\n            ps.println(\"SKIP=`awk '/^__ARCHIVE_FOLLOWS__/ { print NR + 1; exit 0; }' $0`\");\n            ps.println(\"tail -n +$SKIP $0 | gzip -dc | tar x \");\n            ps.println(\"python -u \" + agentScript);\n            ps.println(\"exit 0\");\n            ps.println(\"__ARCHIVE_FOLLOWS__\");\n            java.io.InputStream istream = this.getClass().getClassLoader().getResourceAsStream(\"sc/fgrid/agent.tar.gz\");\n            IOUtils.copy(istream, ps);\n        } else {\n            String pypath = engine.getAgentPythonPath();\n            ps.println(\"export PYTHONPATH=\" + ii + pypath + ii);\n            ps.println(\"python -u \" + agentScript);\n            ps.println(\"exit 0\");\n        }\n    }\n", "code2": "    public void testRetrieve() throws DigitalObjectManager.DigitalObjectNotFoundException, URISyntaxException, IOException {\n        DigitalObjectManager man = new FedoraObjectManager(\"fedoraAdmin\", \"fedoraAdminPass\", \"http://localhost:7910/fedora\");\n        DigitalObject r = man.retrieve(new URI(\"demo:dc2mods.1\"));\n        String title = r.getTitle();\n        List<Metadata> met = r.getMetadata();\n        InputStream content = r.getContent().read();\n        StringWriter theString = new StringWriter();\n        IOUtils.copy(content, theString);\n        assertNotNull(theString.toString(), \"Content should not be null\");\n        assertNotNull(title, \"The title should be set\");\n        assertNotNull(met.get(0).getContent(), \"There should be some metadata\");\n    }\n", "label": 1, "substitutes": {"ps": ["ils", "lines", "pipe", "ns", "pc", "vs", "eps", "log", "cs", "PS", "post", "ls", "pse", "pm", "pp", "files", "ts", "pas", "pass", "py", "ons", "pd", "css", "ep", "po", "pex", "os", "print", "posts", "ins", "Ps", "sp", "ras", "pers", "pi", "res", "pl", "parent", "als", "proc", "points", "pe", "lets", "fs", "http", "params", "gs", "ups", "cp", "qs", "ports", "pid", "per", "pr", "ping", "pro", "ops", "ds", "process", "s", "null", "p", "ks", "pull", "pes", "ws", "out", "pg", "ms", "ppa", "pa", "plugins", "tp", "pps", "amps", "ips", "its", "details", "pos", "proxy"], "agentName": ["serviceId", "agentNAME", "agencyName", "interfaceType", " agentId", "interfaceNAME", "serviceName", "AgentName", "interfaceId", "AgentId", "agencyId", "AgentID", "serviceID", "interfaceID", " agentType", " agentNAME", "agentType", "serviceNAME", "agentId", "AgentType", "interfaceName", "agencyID"], "agentID": [" agentURI", " agentId", "serviceURI", "serviceId", "serviceName", "AgentName", "serviceID", "AgentURI", "AgentId", "agentId", "AgentID", "agentURI"], "agent": ["active", "operator", "ant", "link", "connection", "admin", "plugin", "gent", "engine", "man", "ct", "client", "app", "model", "base", "agents", "data", "handler", "server", "config", "activity", "exec", "machine", "monitor", "action", "station", "ace", "Agent", "act", "agency", "session", "media", "image", "connect", "sp", "command", "service", "account", "bot", "proxy", "ad", "ie"], "instanceDir": ["instanceLoc", "exampleVol", "anceDirectory", "imageFile", "anceFolder", "uploadDIR", "exampleDir", "uploadDir", "anceDur", "instanceVol", "storageDIR", "testDir", "anceDir", "uploadLoc", "testName", "imageFolder", "imageDirectory", "instanceDIR", "anceLoc", "instanceDirectory", "instanceFile", " instanceFile", "anceFile", "instanceName", "instanceFolder", "imageDir", "storageDir", "exampleDIR", "anceVol", "anceName", "testVol", "testDIR", " instanceDirectory", "uploadDur", "instanceDur", "anceDIR", "storageDur", "storageLoc", " instanceFolder", "exampleName"], "agent_timeout_seconds": ["agent_cache_seconds", "agent_timeout_second", "agent_timeout_duration", "agent_cache_second", "agent_cache_duration", "agent_cache_sec", "agent_timeout_sec"], "ii": ["ei", "ice", "si", "qi", "abi", "uni", "CI", "ind", "hi", "yi", "inf", "model", "version", "di", "tif", "zi", "zip", "prefix", "ni", "ji", "ai", "info", "gi", "address", "ti", "gui", "init", "dir", "ui", "ci", "ix", "ani", "api", "ini", "cli", "timeout", "li", "xi", "iri", "mini", "index", "slice", "image", "cin", "uri", "iii", "cci", "service", "secret", "vi", "II", "img", "fi", "agi", "ig", "chi", "qa", "sci", "ie"], "agentScript": ["serviceCode", " serviceCode", " serviceFile", "agentCode", "ServiceScript", "ServiceCode", "ServiceFile", "serviceFile", "agentFile"], "serviceScript": ["ServiceConfig", "serviceText", "servicescript", "spaceCode", "featurescript", "agentCode", "featureScript", "ServiceFile", "serviceFile", "serverCode", "sourceSocket", "skillConfig", "serviceCode", "siteCode", "agentText", " servicescript", "serverScript", "sourceFile", "serviceSocket", "ServiceCode", "skillFile", "spaceFile", " serviceSocket", "skillSocket", "ServiceSocket", "siteScript", " serviceCode", " serviceFile", " serviceText", "ServiceScript", "spacescript", "serverFile", "serverText", "featureFile", " serviceConfig", "serviceConfig", "sourcescript", "skillScript", "featureSocket", "siteFile", "Servicescript", "spaceScript", "sourceScript", "agentFile"], "taskNames": ["askNames", "taskFiles", "TaskFiles", "askNumbers", "askTypes", "TaskNumbers", "threadNumbers", "taskMaps", "TaskTypes", "taskNumbers", "askFiles", "threadNames", " taskNumbers", "threadTypes", "threadMaps", "TaskNames", " taskFiles", "taskTypes", "TaskMaps", "askMaps"], "scriptDir": ["criptDb", "serviceDirectory", "criptPath", "scriptDirectory", " scriptDb", "serviceDb", "criptDir", " scriptPath", "scriptPath", "servicePath", " scriptDirectory", "serviceDir", "scriptDb", "criptDirectory"], "taskName": ["taskKey", "askNames", "askName", "deviceName", " taskKey", "fileName", "deviceKey", "devicename", "fileKey", "askname", " taskLine", "fileLine", "taskLine", "askKey", " taskname", "TaskLine", "TaskKey", "TaskNames", "deviceNames", "TaskName", "fileNames", "taskname"], "task": ["Task", "route", "contract", "input", "link", "network", "complete", "plugin", "game", "message", "thread", "out", "request", "object", "client", "pack", "worker", "remote", "work", "slave", "resource", "child", "config", "role", "address", "master", "server", "module", "activity", "tag", "name", "action", "sync", "event", "skill", "target", "device", "password", "instance", "job", "session", "key", "image", "ask", "error", "command", "problem", "service", "type", "project", "test", "unit"], "script": ["source", "play", "input", "cript", "output", "css", "model", "Script", "javascript", "data", "style", "zip", "resource", "sc", "config", "template", "address", "exec", "js", "tag", "sync", "module", "query", "scope", "pattern", "patch", "esc", "log", "password", "text", "pic", "content", "timeout", "key", "variable", "slice", "string", "scripts", "image", "code", "command", "lua", "service", "proxy", "ct", "test", "p"], "embedScripts": ["morphScripts", "attachScriptions", "embedScriptes", "embedcriptures", "videoScriptes", "videocriptes", "embedScriptments", "embedcriptes", "embedScripted", " embedcriptures", "embedScriptings", "attachScripts", "embedSecondgs", " embedScripted", "embedScriptures", "embedProgrames", "embedcriptions", "embedScriptd", "embedcriptments", "embedStreamed", "embedConfigments", "videoScripto", "embedcriptgs", "videocriptings", "embedStructments", " embedcripts", "morphStreams", "embedConfigs", "videoScripts", "embedScriptions", "morphStreames", "embedStreamd", "morphScripted", "embedConfiges", "embedProgramo", "videocripts", "embedSecondches", "videoScriptgs", "embedScriptches", "embedcriptches", "videoScriptings", "attachStructes", "embedscriptgs", "embedscripted", "embedStructs", "embedcripto", "embedConfigions", "attachStructments", "embedSecondes", "embedStructions", "embedScripto", "embedscripts", "embedscriptches", "embedcriptings", "morphScriptes", "morphScriptd", "embedStreames", "embedPrograms", "embedscriptings", "videocriptches", "morphStreamed", "videocripto", "embedStreams", " embedScriptures", "videocriptgs", "embedScriptgs", "embedProgramings", "embedcriptd", "embedscriptd", "embedscriptes", "embedscriptures", "morphStreamd", "embedcripts", "attachStructions", "embedStructed", "attachStructs", "embedSeconds", "embedStructures", " embedcripted", "attachScriptes", " embedcriptes", "videoScriptches", " embedScriptes", "embedscripto", "embedcripted", "attachScriptments", "embedStructes"], "taskScriptFile": ["TaskStyleFile", "taskSignGlobal", "taskEscPath", "TaskStylefile", "TaskStyleGlobal", "courseStructPath", "taskSyncFile", "taskSyncBody", "taskSyncfile", "taskEscFile", "taskScriptPath", "taskEscBody", "taskStructfile", "taskStreamGlobal", "TaskScriptfile", "TaskScriptFile", "taskSignFile", "taskStyleGlobal", "courseScriptFile", "taskScriptBody", "taskStyleFile", "taskScriptfile", "courseStructBody", "taskStylefile", "taskStreamLine", "taskSignLine", "taskEscfile", "TaskScriptGlobal", "taskStructPath", "courseScriptfile", "taskScriptGlobal", "taskScriptLine", "taskStructBody", "TaskScriptLine", "taskSignfile", "taskStreamFile", "courseStructfile", "taskStyleLine", "taskSyncPath", "taskStructFile", "courseStructFile", "courseScriptBody", "taskStreamfile", "TaskStyleLine", "courseScriptPath"], "xs": ["px", "hs", "aws", " xp", "rx", "events", "pes", "ils", "xd", "ws", "rss", "wx", "fs", "gs", "css", "Tx", "ns", "fe", "codes", "xes", "ctx", "xc", "outs", "qs", "gets", "js", "xx", "eps", "x", "vs", "ins", "icks", "pps", "rs", "cs", "iffs", "ls", "apps", "xp", "ses", "ds", "views"], "ss": ["su", "fts", "ks", "test", "sb", "si", "ws", "rss", "cas", "fs", "sw", "pg", "css", "sf", "ns", "ros", "ms", "iss", "ess", "bs", "stats", "sc", "ass", "serv", "uss", "os", "WS", "qs", "ics", "eps", "vs", "ssh", "oss", "xx", "js", "s", "pps", "cs", "rs", "sv", "ls", "pse", "SS", "sp", "ssl", "hess", "\u00df", "service", "us", "ses", "ds", "services", "ng", "ts", "ys", "sl", "pass"], "serviceScriptFile": ["serviceScriptBook", "serviceTextF", "serviceJSONFile", "bankscriptUrl", "serviceSignBook", "serviceSignFile", "securitySignBook", "servicescriptStream", "bankScriptFile", "bankScriptUrl", "securityScriptFile", "serviceFormBook", "bankScriptF", "servicescriptFile", "serviceJSONLine", "serviceTextStream", "serviceCodeFile", "bankScriptStream", "serviceFormfile", "serviceFormLine", "serviceScriptUrl", "bankscriptStream", "securityScriptfile", "securityScriptLine", "serviceCodeStream", "serviceSignLine", "servicescriptF", "serviceScriptLine", "serviceScriptStream", "serviceCodeF", "serviceScriptF", "bankscriptFile", "serviceTextFile", "serviceTextUrl", "securityScriptBook", "securitySignfile", "serviceScriptfile", "serviceCodeUrl", "serviceJSONfile", "securitySignLine", "servicescriptUrl", "serviceSignfile", "serviceJSONBook", "securitySignFile", "serviceFormFile", "bankscriptF"], "url": ["source", "host", "page", "id", "link", "browser", "connection", "feed", "xml", "l", "http", "bc", "base", "f", "https", "data", "ver", "ref", "stream", "channel", "response", "resource", "server", "call", "config", "address", "update", "name", "action", "gl", "api", "text", "location", "string", "path", "image", "uri", "ssl", "db", "URL", "service", "Url", "www", "blog", "proxy", "web", "coll", "sl"], "as": ["aws", " ts", "acs", "http", "out", "pack", "was", "to", "As", "bs", "outs", "ass", " to", "vs", "parser", " rs", "a", "asa", "pos", " os", "ras", "is", " es", " us", " is", "www", "pas"]}}
{"id1": "5055545", "id2": "8481623", "code1": "    public static void copy(File fromFile, File toFile) throws IOException {\n        if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFile.getAbsolutePath());\n        if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFile.getAbsolutePath());\n        if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFile.getAbsolutePath());\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        String parent = toFile.getParent();\n        if (parent == null) parent = System.getProperty(\"user.dir\");\n        File dir = new File(parent);\n        if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n        if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent);\n        if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        from_file = checkFile(from_file);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fromFile": ["sourceDir", " fromFolder", " fromStream", "apiPath", "leftFile", "toFiles", "FromPage", "remoteFile", "apiFiles", "startPage", "newfile", "newStream", "remoteFiles", "formFolder", "FromDir", "FromStream", "fromStream", "forLibrary", "startfile", " fromFilename", "fromFolder", "forPage", "leftFiles", "startFolder", "sourcefile", "sourceFile", "leftDir", "fromLibrary", "startFile", " fromLibrary", "toFilename", "newDir", "formfile", "fromPage", "fromfile", "FromFolder", "sourceFiles", "forFile", "sourcePath", "newFile", " fromFiles", "newFolder", "toDir", "formPage", "fromFilename", "FromLibrary", " fromfile", "apiFile", "Fromfile", "fromFiles", "apifile", "formFile", " fromDir", " fromPage", "remotePath", "forDir", "leftFilename", "sourcePage", " fromPath", "fromPath", "forFolder", "fromDir", "FromFile"], "toFile": ["ToFile", "Tofile", "toDirectory", "sourceFolder", "toFiles", "targetStream", "toFolder", " toFolder", "toPlace", "templateFile", "ToLibrary", " tofile", "templatePlace", " toLibrary", "TODir", "TOFolder", " toPath", " toDir", " toFiles", "sourcefile", "targetPlace", "sourceFile", "toStream", "ToFolder", "templateStream", "TOfile", "ToDirectory", "soPath", "ToFiles", "ToPath", "toDir", "toLibrary", "targetFile", "ToDir", "templateDir", " toPlace", "soFile", "soDir", "fromDirectory", "toPath", "fromFiles", "tofile", " toDirectory", "targetDir", " toStream", "sourceDirectory", "TOFile", "fromDir", "sofile"], "parent": ["source", "host", "Parent", "page", "div", "id", "memory", "inc", "user", "term", "connection", "complete", "function", "parents", "am", "any", "home", "client", "owner", "root", "part", "loc", "p", "region", "directory", "tree", "master", "resource", "handler", "child", "par", "fat", "address", "ac", "name", "ppa", "pa", "it", "large", "old", "per", "unit", "patch", "api", "content", "session", "key", "pt", "rule", "path", "point", "pool", "pointer", "cache", "string", "file", "uri", "search", "and", "current", "valid", "option", "test", "port", "null", "ip", "location", "type"], "dir": ["folder", "div", "dec", "dc", "id", "url", " directory", "user", "d", "rel", "dep", "dict", "director", "iter", "cat", "dev", "doc", "DIR", "wd", "out", "object", "home", "fd", "root", "part", "loc", "base", "ver", "data", "directory", "di", "def", "dis", "dn", "der", "ir", "fun", "cur", "name", "direction", "da", "mod", "container", "per", "keep", "dr", "up", "col", "path", "file", "db", "manager", "dist", "md", "group", "entry", "coll", "Dir"], "from": ["source", "get", "via", "left", "url", "link", "pe", "connection", "cm", "range", "with", "io", "conn", "one", "http", "view", "out", "client", "in", "con", "of", "ou", "part", "normal", "base", "without", "po", "From", "by", "find", "auto", "stream", "data", "class", "server", "address", "low", "module", "component", "name", "ci", "o", "two", "per", "api", "max", "ch", "se", "c", "file", "parse", "flo", "or", "vol", "ce", "start", "form", "who", "when", "add", "empty", "on", "so"], "to": ["source", "via", "page", "size", "su", "site", "url", "about", "token", "office", "connection", "not", "with", "top", "co", "tto", "io", "output", "ma", "TO", "one", "http", "thro", "out", "client", "b", "To", "part", "base", "op", "po", "no", "by", "on", "auto", "server", "eto", "until", "name", "o", "two", "target", "see", "per", "log", "api", "too", "cache", "socket", "db", "file", "flo", "or", "pi", "who", "store", "copy", "so", "type"], "buffer": ["page", "read", "reader", "size", "queue", "memory", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "limit", "layer", "number", "data", "bytes", "available", "resource", "server", "address", "writer", "pad", "uffer", "transfer", "null", "batch", "length", "flush", "comment", "wave", "buf", "offset", "variable", "border", "seed", "cache", "character", "header", "block", "position", "bin", "vector", "port", "duration"], "bytesRead": ["BytesAct", " bytesLength", "tesNeed", "BytesWrite", "usersReader", "tesRead", "bytesReader", " bytesCount", "filesUse", "BytesWritten", "usersLoad", "tesWrite", "BytesUse", "usersCount", "bytesUse", "BytesNeed", "bytesWritten", "tesLength", "filesNeed", "filesWrite", " bytesLoad", "bytesAct", "filesRead", "stringsRead", "BytesLength", "stringsReader", "tesUse", "bytesLoad", " bytesWritten", "tesWritten", "bytesLength", "bytesNeed", "usersRead", " bytesReader", " bytesAct", "bytesCount", "stringsLoad", "bytesWrite", "tesAct", "stringsCount", "BytesRead"]}}
{"id1": "18778239", "id2": "12764800", "code1": "    public void init() {\n        File[] configsDirectories = { XPontusConstantsIF.XPONTUS_PLUGINS_DATA_DIR, XPontusConstantsIF.XPONTUS_PREFERENCES_DIR, XPontusConstantsIF.XPONTUS_DATABASE_CONFIG_DIR, XPontusConstantsIF.XPONTUS_PLUGINS_DIR, XPontusConstantsIF.XPONTUS_CACHE_DIR };\n        for (int i = 0; i < configsDirectories.length; i++) {\n            if (!configsDirectories[i].exists()) {\n                configsDirectories[i].mkdirs();\n            }\n        }\n        String[] locations = { \"/net/sf/xpontus/configuration/editorPanel.properties\", \"/net/sf/xpontus/configuration/general.properties\", \"/net/sf/xpontus/configuration/mimetypes.properties\" };\n        try {\n            for (String loc : locations) {\n                String outName = FilenameUtils.getName(loc);\n                File output = new File(XPontusConstantsIF.XPONTUS_PREFERENCES_DIR, outName);\n                if (!output.exists()) {\n                    if (loc.equals(locations[0])) {\n                        Properties hackProps = new Properties();\n                        InputStream is = getClass().getResourceAsStream(loc);\n                        hackProps.load(is);\n                        Font hackFont = UIManager.getFont(\"EditorPane.font\");\n                        StrBuilder strFont = new StrBuilder();\n                        strFont.append(hackFont.getFamily() + \",\" + hackFont.getStyle() + \",\" + hackFont.getSize());\n                        hackProps.put(\"EditorPane.Font\", strFont.toString());\n                        OutputStream out = new FileOutputStream(output);\n                        hackProps.store(out, null);\n                        out.close();\n                        is.close();\n                    } else {\n                        InputStream is = getClass().getResourceAsStream(loc);\n                        OutputStream out = new FileOutputStream(output);\n                        IOUtils.copy(is, out);\n                        out.close();\n                        is.close();\n                    }\n                }\n                if (!outName.equals(\"mimetypes.properties\")) {\n                    Properties m_properties = PropertiesConfigurationLoader.load(output);\n                    Iterator it = m_properties.keySet().iterator();\n                    while (it.hasNext()) {\n                        Object m_key = it.next();\n                        Object m_value = m_properties.get(m_key);\n                        XPontusConfig.put(m_key, m_value);\n                    }\n                }\n            }\n        } catch (Exception err) {\n            err.printStackTrace();\n        }\n        Properties m_props = PropertiesConfigurationLoader.load(XPontusConfigurationConstantsIF.EDITOR_PREFERENCES_FILE);\n        String[] f = m_props.get(\"EditorPane.Font\").toString().split(\",\");\n        String family = f[0].trim();\n        String style1 = f[1].trim();\n        int style = Integer.parseInt(style1);\n        int size = Integer.parseInt(f[2].trim());\n        Font m_font = new Font(family, style, size);\n        XPontusConfig.put(\"EditorPane.Font\", m_font);\n        Map map = new HashMap();\n        map.put(ROLE, this);\n        PropertiesHolder.registerProperty(XPontusSettings.KEY, map);\n        DockableContainerFactory.setFactory(new XPontusDockableContainerFactory());\n        FileHistoryList.init();\n        initDefaultSettings();\n    }\n", "code2": "    public static void extractZipFile(String filename) {\n        try {\n            byte[] buf = new byte[1024];\n            ZipInputStream zipinputstream = null;\n            ZipEntry zipentry;\n            zipinputstream = new ZipInputStream(new FileInputStream(filename));\n            zipentry = zipinputstream.getNextEntry();\n            while (zipentry != null) {\n                String entryName = zipentry.getName();\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(entryName);\n                String directory = newFile.getParent();\n                if (directory == null) {\n                    if (newFile.isDirectory()) break;\n                }\n                fileoutputstream = new FileOutputStream(entryName);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n                zipentry = zipinputstream.getNextEntry();\n            }\n            zipinputstream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"configsDirectories": ["configionsdirections", "configsConnectories", "configoresdirectories", "configsdirecturations", "configsdirectirs", "configionsDirectirs", "configsDirectistries", "configsDistors", "configesDirectors", "configionsdirectories", "configesDirectorers", "configionsDirecturers", "configoresdirectors", "configsDirecturations", "configesdirectories", "configionsDirectORY", "configsDirecturers", "configsdirectories", "configsdirectapters", "configsDistirs", "configsdirections", "configionsDirectories", "configsInstructistries", "configsDistories", "configsdirectorers", "configoresDirectors", "configoresdirectistries", "configsConnections", "configesdirectorers", "configionsdirectORY", "configsdirectORY", "configsDirectapters", "configsCreatORY", "configsConnectapters", "configsInstructors", "configsdirectives", "configionsdirectives", "configsConnecturers", "configionsdirecturers", "configionsdirectirs", "configsCreatories", "configsConnectORY", "configsDisturers", "configsConnectives", "configionsDirectives", "configsRECTories", "configsCreations", "configsRECTapters", "configoresdirecturations", "configsInstructories", "configsdirectors", "configsDirectORY", "configsConnectirs", "configsConnectorers", "configoresDirectories", "configsDirectors", "configsInstructurations", "configsConnecturations", "configionsdirectors", "configesDirectories", "configsDirectirs", "configesDirectapters", "configsRECTors", "configsConnectistries", "configsDirections", "configsConnectors", "configoresDirectistries", "configionsDirectors", "configesdirectors", "configsRECTorers", "configionsDirections", "configsDirectives", "configesdirectapters", "configoresDirecturations", "configsdirectistries", "configsDirectorers", "configsCreatives", "configsdirecturers"], "i": ["id", "si", "multi", "d", "qi", "abi", "uli", "iu", "hi", "k", "io", "phi", "y", "in", "b", "val", "end", "di", "n", "mu", "I", "ti", "oi", "ai", "gi", "info", "inner", "x", "name", "ix", "init", "ui", "ci", "u", "o", "e", "eni", "ini", "lc", "li", "v", "xi", "key", "ri", "index", "count", "slice", "j", "c", "uri", "ii", "pi", "start", "fi", "mi", "s", "ip", "p", "ie"], "locations": ["Lococations", "locATIONS", "Locions", "locals", "LOCations", "LocATIONS", "LOCings", " locings", "LOCocations", "locings", "locions", " locals", "Locations", "LOCions", "lococations", "LOCals", "Locals", " lococations", "LOCATIONS", " locions", " locATIONS", "Locings"], "loc": ["bas", "sel", "url", "ln", "la", "lit", "lang", "rel", "co", "hi", "pl", "src", "l", " locale", "LOC", "lim", "http", "in", " locals", "b", "home", "cho", " local", "base", "remote", "serial", "ctx", "sc", " location", "config", "tx", "info", "Loc", "Location", "lo", "tag", "name", "filename", "dir", "rc", "ob", "exp", "cl", "log", "stat", "ko", "ch", "location", "lc", "col", "path", " Loc", "lock", "c", "file", "err", "vol", "label", "pos", "local", "valid", " LOC", "str", "coll", "p", "sci", "lat"], "outName": ["outFile", "OUTExt", "OutFile", "inFile", "OUTname", "OutName", " outFile", " outNames", "outExt", "OutNames", " outPath", "inname", "inName", "outNames", "outPath", "inExt", "inNames", " outExt", " outname", "OUTPath", "inPath", "outname", "OUTName", "Outname"], "output": ["next", "page", "plain", "tmp", "export", "input", "display", "write", "default", "office", "network", "connection", "xml", "complete", "settings", "result", "exit", "outer", "format", "control", "object", "ou", "root", "console", "model", "profile", "application", "fe", "summary", "again", "response", "resource", "remote", "config", "address", "external", "module", "filename", "Output", "full", "o", "target", "log", "job", "temp", "four", "il", "image", "document", "cache", "file", "ilo", "web", "put", "null", "unit"], "hackProps": ["hackPropproperties", "bugProgs", "hackproperties", "bugPerb", "hackProms", "bugPerPS", "hackProperties", "hackPerms", "bugPerproperties", "bugPerps", "hackprogs", "hackProproperties", "bugProms", "hackPerps", "hackPropperties", "bugProproperties", "hackTemproperties", "bugProps", "bugprocs", "hackPercs", "hackProtcs", "hackTemb", "bugprops", "bugProperties", "hackPerperties", "hackPerb", "hackProPS", "bugproperties", "hackprocs", "hackProcs", "hackPropb", "hackPropps", "hackTemperties", "hackPerproperties", "hackProtperties", "bugProPS", "hackPerPS", "hackProgs", "bugPerperties", "bugProcs", "hackPropPS", "hackProb", "hackPropgs", "hackPropcs", "bugproms", "hackproms", "hackProtms", "hackprops", "hackProtps", "hackTemps", "bugProb"], "is": ["get", "nis", "id", "url", "ils", "isa", "io", "ais", "http", "isl", "in", "as", "isp", "was", "iss", "sis", "os", "ris", "serv", "es", "ir", "ics", "has", "js", "isi", "init", "iris", "IS", "mis", "abs", "isc", "il", "lis", "ios", "image", "ori", "its", "uri", "im", "err", "or", "ii", "us", "bis", "Is", "cms", "ar", "iso", "ip", "ic"], "hackFont": ["cleanFontSize", "hackText", "hackFloat", "bugColor", "bugFontSize", "cleanText", "cheatFontSize", " hackStyle", "cleanFamily", "cheatRect", " hackFontSize", " hackRect", "hackColor", "ckRect", "hackType", "cheatColor", "bugFamily", "cleanFont", "ckFloat", "ckFont", "ckFontSize", "cheatFloat", "HackFont", "hackFamily", "cheatType", "bugText", "cheatFamily", "bugFont", "HackType", " hackFloat", "cheatStyle", "cheatText", "HackStyle", " hackColor", "hackRect", "HackFontSize", "hackStyle", "hackFontSize", " hackText", "cheatFont", " hackType"], "strFont": ["StrFamily", " strText", "STRUTF", "stringFont", "strfont", " strUTF", "strFontSize", "strUTF", "StrText", "StrFontSize", "stringfont", "Strfont", "strFamily", "StrFont", "stringFontSize", "STRfont", "STRFont", "StrUTF", " strFontSize", "stringFamily", "stringText", " strFamily", "strText", "STRFamily", " strfont"], "out": ["source", "page", "parent", "plain", "msg", "user", "result", "co", "extra", "io", "outer", "conn", "doc", "in", "object", "client", "this", "part", "model", "base", "data", "OUT", "Out", "clean", "outs", "again", "serv", "child", "writer", "config", "exec", "full", "o", "ch", "job", "temp", "string", "path", "image", "list", "pool", "cache", "obj", "file", "error", "err", "code", "array", "cos", "img", "group", "bin", "str", "ext"]}}
{"id1": "6814854", "id2": "370982", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"infile": ["inputfile", "infilename", "outFile", "infiles", "inFile", "inputfiles", "inputfilename", "outfiles", " infilename", "infp", " infp", "inputfp", "outfilename", "Infiles", " infiles", "InFile", "outfp", "Infilename", "inputFile", "Infile"], "outfile": ["outputfp", "outFile", "infilename", "Outname", "newfile", "OutFile", "outputfilename", " outFile", "newname", "infp", "newfolder", "outfilename", "Outfile", " outfolder", "newFile", " outname", "outfolder", " outfp", "outputfolder", "outfp", "Outfolder", "infolder", "outname", " outfilename", "outputfile"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "min", "nin", "conn", "con", "b", "login", "as", "base", "data", "In", "pin", "into", "re", "r", "inas", "thin", "again", "ac", "isin", "inner", "init", "ins", "vin", "gin", "ini", "a", "m", "sin", "cin", "image", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "bin", "s", "ic", "pass"], "out": ["source", "parent", "inc", "write", "net", "co", "io", "output", "outer", "conn", "lib", "one", "client", "home", "ou", "base", "on", "to", "no", "In", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "ex", "post", "timeout", "session", "up", "job", "point", "image", "cache", "socket", "file", "obj", "error", "err", "or", "bin", "copy", "exit", "line"], "buffer": ["source", "size", "reader", "split", "url", "queue", "input", "write", "binary", "feed", "len", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "base", "layer", "data", "bytes", "server", "raw", "address", "uffer", "transfer", "null", "padding", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "count", "border", "seed", "cache", "fb", "value", "type"], "read": ["play", "select", "next", " write", "size", "reader", "ad", "input", "get", "write", "inc", "id", "feed", "len", "Read", "ind", "iter", " skip", "fill", "READ", "ride", "io", "limit", "end", "tell", "f", "sleep", "find", "n", "work", "raw", "exec", "x", "sync", "send", "reading", "_", "length", "allow", "run", "close", "se", "slice", "count", "pass", "load", "connect", "parse", "i", "seek", "check", "wait", "lex", "current", " copy", "start", " count", "ip", "add", "copy", " Read", "use", "reads"], "success": ["successful", "continue", "roll", "default", "warning", "first", "better", "successfully", "open", " succeed", "complete", "growth", "result", "right", "message", "Success", "true", "flash", "winner", " succ", "model", " successful", "cess", "data", "fast", "again", "response", "primary", "xx", "rolled", " Success", "method", "func", "results", "failed", "initial", "comment", "danger", "content", "status", "done", "path", "respons", "error", "fail", "modified", "valid", "construct", "ccess", "rolling", "follow", "ceed", "good", "value", "null", "pass"]}}
{"id1": "7422454", "id2": "10415388", "code1": "    public void run() {\n        if (name == null) {\n            System.err.println(\"Must set file name for retrieval\");\n            return;\n        }\n        if (handle == null) {\n            System.err.println(\"Must set CCNHandle\");\n            return;\n        }\n        if (htmlPane == null) {\n            System.err.println(\"Must set JEditorPane\");\n            return;\n        }\n        JFrame frame = new JFrame();\n        JFileChooser chooser = new JFileChooser();\n        File f = null;\n        chooser.setCurrentDirectory(null);\n        int returnVal = chooser.showSaveDialog(frame);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            f = chooser.getSelectedFile();\n        } else {\n            htmlPane.setText(\"Save File cancelled\");\n            return;\n        }\n        boolean overwrite = false;\n        try {\n            if (f.exists()) {\n                htmlPane.setText(\"Overwriting contents of \" + f.getPath());\n                overwrite = true;\n            } else {\n                f.createNewFile();\n            }\n            if (f.canWrite()) {\n            } else {\n                htmlPane.setText(\"The ContentExplorer is unable to write the content to the specified file.\");\n                return;\n            }\n        } catch (IOException e) {\n            System.err.println(\"could not create \" + f.getPath() + \" for saving content to filesystem\");\n            htmlPane.setText(\"could not create \" + f.getPath() + \" for saving content to filesystem\");\n        }\n        try {\n            if (!overwrite) htmlPane.setText(\"saving \" + name + \" to \" + f.getCanonicalPath()); else htmlPane.setText(\"overwriting contents of \" + f.getCanonicalPath() + \" to save \" + name);\n            CCNFileInputStream fis = new CCNFileInputStream(name, handle);\n            FileOutputStream output = new FileOutputStream(f);\n            byte[] buffer = new byte[readsize];\n            int readcount = 0;\n            int readtotal = 0;\n            while ((readcount = fis.read(buffer)) != -1) {\n                readtotal += readcount;\n                output.write(buffer, 0, readcount);\n                output.flush();\n            }\n            htmlPane.setText(\"Saved \" + name + \" to \" + f.getCanonicalPath());\n        } catch (Exception e) {\n            htmlPane.setText(\"Could not save \" + name + \" to \" + f.getPath() + \" This may be a prefix for an object or just may not be available at this time.\");\n            System.err.println(\"Could not retrieve file: \" + name);\n        }\n    }\n", "code2": "    public static void copyFileNIO(String src, String dst) {\n        try {\n            FileChannel srcChannel = new FileInputStream(src).getChannel();\n            FileChannel dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"frame": ["next", "h", "frames", "cf", "flower", "panel", "view", "jo", "object", "b", "sf", "fp", "state", "fr", "fe", "ctx", "handler", "e", "framework", "flow", "fram", "iframe", "fl", "df", "v", "Frame", "up", "window", "close", "document", "image", "session", "j", "c", "file", "lock", "fb", "ce", "fi", "form", "coll", "p"], "chooser": ["poose", "closer", "Choosen", "quosen", "chosen", "quicer", "Choose", "quose", " choicer", "promoser", "pooser", " choosed", "clane", "choser", "closed", "promosen", "choane", " choose", "Choane", "poosed", "Choosed", "choosen", "choosed", "poosen", "promosed", "promose", "chose", " choosen", "close", "choose", "choicer", "closen", "quoser", "chane", "Chooser", "Choicer"], "f": ["folder", "h", "rf", "url", "bf", "d", "feed", "cf", "io", "fo", "l", "fs", "fc", "w", "fp", "b", "sf", "fd", "inf", "elf", "fr", "of", "tf", "this", "fe", "ref", "fw", "n", "r", "handler", "info", "el", "x", "conf", "name", "full", "e", "framework", "o", "fn", "t", "F", "a", "m", "df", "fold", "v", "path", "j", "c", "file", "i", "fb", "g", "fen", "field", "form", "s", "fa", "coll", "p", "fx"], "returnVal": ["resultval", " returnValue", " returnVAL", "replyValue", " returnval", "ReturnNum", "returnValue", "errorVol", "returnval", "returnNum", "errorVal", "returnVAL", " returnNum", "replyVol", "ReturnVal", "replyVal", "ReturnValue", "resultValue", "resultNum", "Returnval", "returnVol", "replyVAL", " returnVol", "resultVal", "errorVAL", "errorValue"], "overwrite": ["overcreate", "Overcreate", "oversync", "underwrite", " overwriting", "overwritten", "interwrite", "underflow", "underwriting", "overflow", "interflow", "interride", "broadwritten", " override", "underwritten", "underride", "Overwriting", " oversync", "Overwritten", "override", "Overwrite", "intersync", "broadcreate", "overwriting", "undercreate", " overflow", "undersync", "broadwrite", "interwriting", "broadwriting"], "fis": ["fileins", "fisi", " fisc", "fins", "pisi", "fileis", "Fiss", "pins", "fiss", "fios", " fios", "fileisi", "lios", "fileios", "Fis", "pios", "fisc", "pis", "bisi", "lis", "bins", "liss", "Fios", "bios", "lisc", "bis", " fiss", "Fisc"], "output": ["next", "page", "input", "write", "handle", "result", "control", "out", "data", "response", "resource", "config", "writer", "filename", "Output", "o", "flow", "prot", "m", "temp", "v", "path", "image", "pool", "file", "current"], "buffer": ["page", "read", "reader", "split", "memory", "queue", "reference", "buff", "iter", "Buffer", "message", "limit", "b", "channel", "layer", "number", "data", "table", "available", "server", "address", "pad", "uffer", "shape", "transfer", "batch", "bb", "length", "flush", "wave", "cap", "buf", "variable", "slice", "count", "document", "cache", "width", "header", "block", "total", "position"], "readcount": ["workcount", "readsize", "worksize", " readsize", "workCount", "Readcount", "writesize", "playCount", " readCount", "writeCount", "playtotal", "readCount", "writetotal", "playsize", "ReadCount", "writecount", "Readsize", "playcount"], "readtotal": ["tasksum", "url", "open", "io", "taskscale", "this", "worktotal", "config", "tasktotal", "edit", "worksum", "s", "_", " readscale", "readsum", " readsum", "window", "readscale", "process", "add", "copy", "workscale"]}}
{"id1": "23413733", "id2": "11540200", "code1": "    public static void copyFile(File from, File to) throws Exception {\n        if (!from.exists()) return;\n        FileInputStream in = new FileInputStream(from);\n        FileOutputStream out = new FileOutputStream(to);\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int bytes_read;\n        while (true) {\n            bytes_read = in.read(buffer);\n            if (bytes_read == -1) break;\n            out.write(buffer, 0, bytes_read);\n        }\n        out.flush();\n        out.close();\n        in.close();\n    }\n", "code2": "    public File uploadImage(InputStream inputStream, String fileName, String sessionId) {\n        File file = new File(PathConfig.getInstance().sessionFolder(sessionId) + File.separator + fileName);\n        FileOutputStream fileOutputStream = null;\n        try {\n            FileUtils.touch(file);\n            fileOutputStream = new FileOutputStream(file);\n            IOUtils.copy(inputStream, fileOutputStream);\n        } catch (IOException e) {\n            logger.error(\"Save uploaded image to file occur IOException.\", e);\n            throw new FileOperationException(\"Save uploaded image to file occur IOException.\", e);\n        } finally {\n            try {\n                if (fileOutputStream != null) {\n                    fileOutputStream.close();\n                }\n            } catch (IOException e) {\n                logger.error(\"Close FileOutputStream Occur IOException while save a uploaded image.\", e);\n            }\n        }\n        return file;\n    }\n", "label": 1, "substitutes": {"from": ["source", "left", "parent", "url", "user", "connection", "with", "range", "io", "origin", "client", "of", "part", "without", "base", "From", "by", "data", "address", "bean", "name", "o", "old", "m", "up", "path", "before", "c", "file", "or", "vol", "ce", "at", "start", "form", "add", "entry"], "to": ["source", "about", "token", "office", "top", "output", "io", "TO", "toc", "To", "as", "po", "by", "os", "eto", "template", "dest", "name", "o", "s", "target", "copy", "temp", "too", "socket", "file", "flo", "database", "at", "two", "so", "p", "tom"], "in": ["source", "read", "reader", "id", "url", "input", "inc", "din", "win", "pull", "io", "nin", "con", "b", "login", "f", "as", "In", "into", "again", "n", "r", "stream", "isin", "inner", "exec", "init", "ins", "old", "gin", "ini", "m", "up", "image", "cin", "c", "file", "socket", "i", "err", "IN", "inside", "inn", "is", "lin", "bin"], "out": ["size", "inc", "write", "with", "extra", "io", "output", "outer", "conn", "w", "b", "client", "this", "as", "by", "In", "n", "Out", "OUT", "outs", "again", "data", "writer", "inner", "off", "exec", "x", "sync", "ins", "o", "flow", "exp", "flush", "ex", "up", "cache", "socket", "file", "i", "err", "at", "bin", "s", "line"], "buffer": ["source", "read", "reader", "queue", "memory", "input", "binary", "feed", "buff", "iter", "result", "Buffer", "message", "limit", "request", "layer", "channel", "base", "data", "bytes", "raw", "address", "pad", "uffer", "shape", "sequence", "transfer", "null", "batch", "length", "flush", "buf", "offset", "slice", "count", "border", "seed", "cache", "character", "header", "block", "zero", "texture", "position", "bin", "value", "padding"], "bytes_read": ["bytes_size", "bytes_load", " bytes_size", " bytes_written", "bytes___read", "bytes___size", "bytes_wait", "bytes___load", "bytes_ride", "bytes_Read", "bytes_add", "bytes___check", "bytes_length", " bytes_add", " bytes_length", " bytes_Read", " bytes_wait", " bytes_load", "bytes_written", "bytes_check", " bytes_check", " bytes_ride"]}}
{"id1": "10194322", "id2": "5410594", "code1": "    public static void publish(String server, String id, String passwd, String path, String html) throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + server);\n        FTPClient f = new FTPClient();\n        f.connect(server);\n        if (f.login(id, passwd) == false) {\n            logger.info(\"Fail to login with id=\" + id);\n            throw new LoginFailException(id, passwd);\n        }\n        f.changeWorkingDirectory(path);\n        logger.info(\"Start to upload\");\n        f.storeFile(\"index.html\", new ByteArrayInputStream(html.getBytes(\"utf-8\")));\n        logger.info(\"Upload index.html\");\n        f.storeFile(\"main.css\", new FileInputStream(\"web/main.css\"));\n        logger.info(\"Upload main.css\");\n        f.storeFile(\"cafelibrary.js\", new FileInputStream(\"web/cafelibrary.js\"));\n        logger.info(\"Upload cafelibrary.js\");\n        f.makeDirectory(\"img\");\n        f.changeWorkingDirectory(\"img\");\n        for (int i = 0; i <= 5; i++) {\n            String fileName = \"favorite_star_\" + i + \".png\";\n            f.storeFile(fileName, new FileInputStream(\"web/img/\" + fileName));\n            logger.info(\"Upload \" + fileName);\n        }\n        f.logout();\n        f.disconnect();\n    }\n", "code2": "    @Override\n    public void insert(Connection conn) throws SQLException {\n        PreparedStatement objectInsert = null;\n        String sqlString = null;\n        int newID = 0;\n        try {\n            conn.setAutoCommit(false);\n            sqlString = \"SELECT NEXTVAL(OBJ_SEQ) AS NEXTVAL\";\n            objectInsert = conn.prepareStatement(sqlString);\n            ResultSet r = objectInsert.executeQuery(sqlString);\n            newID = r.getInt(\"NEXTVAL\");\n            sqlString = \"INSERT INTO OBJECTS\" + \"(\" + \"OBJ_ID,\" + \"OBJ_NAME,\" + \"OBTY_CDE\" + \")\" + \"VALUES\" + \"(\" + \"?,\" + \"?,\" + \"?\" + \")\" + \"\";\n            objectInsert = conn.prepareStatement(sqlString);\n            objectInsert.setInt(1, newID);\n            objectInsert.setString(2, getRoomKey());\n            objectInsert.setString(3, \"ROOM\");\n            objectInsert.executeUpdate();\n            sqlString = \"INSERT INTO ROOMS\" + \"(\" + \"\";\n            conn.commit();\n        } catch (SQLException e) {\n            e.printStackTrace();\n            if (conn != null) {\n                try {\n                    System.err.print(\"Transaction is being rolled back\");\n                    conn.rollback();\n                } catch (SQLException excep) {\n                    excep.printStackTrace();\n                }\n            }\n        } finally {\n            if (objectInsert != null) {\n                objectInsert.close();\n            }\n            conn.setAutoCommit(true);\n        }\n    }\n", "label": 0, "substitutes": {"server": ["host", "folder", "site", "url", "Server", "connection", "username", "ser", "peer", "http", "client", "root", "model", "ver", "hello", "directory", "version", "system", "slave", "email", "serv", "address", "handler", "resource", "er", "password", "api", "enter", "erver", "localhost", "string", "node", "seed", "ssl", "uri", "service", "manager", "database", "www", "domain", "port", "ip"], "id": ["head", "parent", "ad", "url", "did", "user", "d", "oid", "auth", "mid", "plugin", "username", "http", "end", "aid", "login", "Id", "part", "email", "ident", "info", "name", "ui", "pid", "json", "api", "key", "string", "image", "file", "uri", "code", "db", "error", "vid", "ids", "start", "kid", "ID", "sid", "null", "ip", "type"], "passwd": [" passpass", "asswd", "assw", "Passpassword", " passw", "passwordw", "passpass", "Passpass", "PASSwd", "PASSpassword", "PASSw", "passwordwd", "PASSword", "asspassword", " passpassword", "password", "asspass", "passw", "passwordword", " password", "passwordpassword", "Password", "passpassword", "Passw", "Passwd"], "path": ["host", "folder", "page", "url", "link", "upload", "xml", "http", "PATH", "home", "client", "Path", "root", "base", "loader", "directory", "ref", "prefix", "archive", "config", "template", "name", "dir", "full", "password", "text", "temp", "index", "image", "uri", "file", "code", "project", "port", "location", "type"], "html": ["source", "page", "HTML", "h", "url", "hash", "sql", "msg", "web", "htm", "xml", "message", "view", "format", "http", "flash", "article", "data", "summary", "ref", "email", "template", "info", "js", "hot", "body", "php", "json", "api", "index", "help", "sp", "db", "title", "details", "tml", "www", "detail"], "f": ["af", "page", "host", "h", "rf", "url", "bf", "d", "feed", "cf", "io", "fo", "l", "fs", "w", "fc", "lib", "fp", "b", "sf", "inf", "client", "fd", "fr", "fing", "tf", "of", "fe", "fw", "r", "fac", "info", "x", "er", "conf", "aff", "full", "e", "framework", "o", "t", "F", "m", "df", "v", "j", "c", "file", "fb", "g", "fen", "q", "fm", "self", "form", "fed", "z", "fab", "p", "fx"], "i": ["my", "si", "d", "qi", "multi", "uni", "phi", "hi", "io", "yi", "y", "in", "b", "part", "number", "di", "n", "zi", "mu", "I", "bi", "ti", "oi", "ai", "info", "gi", "inner", "ji", "x", "name", "init", "ix", "ui", "u", "e", "o", "ci", "eni", "batch", "ini", "xi", "v", "li", "index", "ri", "slice", "image", "gu", "j", "c", "uri", "ii", "vi", "pi", "start", "field", "fi", "chi", "mi", "mini", "ip", "p", "ie"], "fileName": ["filePart", " fileUrl", "linkDie", "FilePath", " fileLen", "imageLen", "fileUrl", "imageName", "imageUrl", " fileType", "fileType", "placeUrl", "FileType", "linkType", "fileDie", "linkPath", " filePath", "FileDie", "FilePart", "FILEPart", "placeLen", "imagePath", "placeName", "filePath", "FileName", "linkName", "FILEPath", " filePart", "FILEUrl", "FileUrl", "imageType", "FILEName", " fileDie", "fileLen"]}}
{"id1": "1218380", "id2": "274159", "code1": "    public static void main(String[] args) {\n        try {\n            Object o = Naming.lookup(\"Server\");\n            IServer serverStub = (IServer) o;\n            File srcDir = new File(args[0]);\n            File dstDir = new File(args[1]);\n            File[] srcFiles = srcDir.listFiles();\n            long position = 0;\n            for (File f : srcFiles) {\n                if (f.isDirectory()) continue;\n                try {\n                    FileChannel srcChannel = new FileInputStream(f).getChannel();\n                    String fileName = dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName();\n                    FileChannel dstChannel = new FileOutputStream(fileName).getChannel();\n                    System.out.println(\"Coping \" + fileName);\n                    ByteBuffer buffer = ByteBuffer.allocate(65536);\n                    int nr = 0;\n                    srcChannel.position(nr);\n                    nr = srcChannel.read(buffer);\n                    while (nr > -1) {\n                        buffer.flip();\n                        byte[] bytes = new byte[buffer.limit()];\n                        buffer.get(bytes);\n                        position = serverStub.write(bytes, position);\n                        buffer.clear();\n                        nr = srcChannel.read(buffer);\n                    }\n                    System.out.println(\"Done \");\n                    srcChannel.close();\n                    dstChannel.close();\n                } catch (IOException e) {\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        } catch (NotBoundException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"o": ["d", "oid", "io", "k", "l", "out", "object", "b", "op", "po", "no", "n", "os", "oa", "r", "oo", "oi", "bo", "vo", "er", "e", "ob", "ingo", "uto", "t", "oe", "ko", "m", "OO", "od", "O", "Obj", "obj", "c", "i", "or", "ando", "s", "so", "p"], "serverStub": ["serverStubs", "serverStob", "ServerTubs", "serverFubs", "serverBubs", "serverStrob", "serverstob", "erverStrob", "serverBub", "erverStrub", "serverTob", "ServerStub", "ServerTub", "serverTab", "serverTUB", "serverstub", "serverStrubs", "erverStrubs", "serverFUB", "serverstubs", "serverBUB", "ServerTUB", "serverBab", "serverTub", "ServerTab", "ServerStab", "serverFub", "serverStUB", "erverStUB", "serverStrub", "serverStab", "serverStrUB", "serverstUB", "erverStubs", "erverStob", "serverTubs", "erverStub", "ServerStUB", "serverFab", "erverStrUB", "ServerStubs"], "srcDir": ["sourceDir", "srcFile", " srcDirectory", "rcFile", " srcFolder", "rcFolder", "sourceFolder", "srcDirectory", "srcFolder", "rcDir", " srcFile", "sourceFile", "rcDirectory", "sourceDirectory"], "dstDir": ["destDIR", "drcDirectory", "dostDir", "dstDirectory", "dostDirectory", "drcDir", "dostDIR", "DrcDir", "DrcFile", "destDirectory", "DrcDIR", "dstFile", "dostFile", "dstFolder", "dstsFolder", "dndDir", "dstDIR", "dstsDIR", "DstFile", "DstDirectory", "dstsDir", "drcDIR", "DstDir", "destDir", "DrcFolder", "drcFile", "DstDIR", "DrcDirectory", "dndFile", "dndDirectory", "DstFolder", "destFolder", "dndDIR", "dstsDirectory", "drcFolder"], "srcFiles": ["sourceDir", "sourcefiles", "rcDir", "rcFiles", "sourceNames", "rcfiles", "sourceFile", "srcNames", " srcfiles", "srcfiles", "sourceFiles", " srcNames", " srcFile", "srcFile", "rcFile", "rcNames"], "position": ["next", "adjust", "head", "select", "parent", "size", "operation", "page", "nl", "open", "range", "iter", "pose", "result", "limit", "object", "request", "move", "loc", "number", "resolution", "response", "r", "resource", "address", "sequence", "Position", "random", "transfer", "patch", "length", "capacity", "job", "area", "offset", "release", "index", "string", "count", "point", "insert", "pointer", "sort", "image", "numbered", "i", "seek", "coord", "speed", "pos", "reset", "item", "type", "manager", "block", "osition", "order", "location", "duration", "unit"], "f": ["folder", "h", "rf", "bf", "d", "feed", "lf", "cf", " F", "function", "l", "fs", "fc", "fp", "b", "sf", "fd", "fr", "part", "tf", "fe", "directory", "n", "r", "info", "name", "filename", "dir", "u", "e", "fn", "t", "F", "m", "v", "j", "c", "file", "i", "fb", "files", "fen", " df", "s", "fa", "p", "fx"], "srcChannel": ["sbchannel", "remotechannel", "srcchannel", "srcBuffer", "sslchannel", "srcClient", "rcChan", " srcChan", "sbChannel", "remoteClient", "inputConsole", " srcConsole", " srcConnection", " srcCh", "rcchannel", "srcChan", "rcChannel", "inputChannel", "sbConnection", "rcConsole", "sslBuffer", "rcCh", "inputchannel", "srcCh", "inputChan", "sbCh", " srcBuffer", "syncConnection", "remoteChannel", "syncChannel", "rcClient", "rcConnection", "srcConsole", " srcchannel", " srcClient", "rcBuffer", "sslChannel", "syncchannel", "sslChan", "syncBuffer", "srcConnection"], "fileName": ["FileInfo", " fileUrl", " fileNum", "fName", "FilePath", "fileUrl", "fPath", "Filename", " filePath", "filename", " filename", "fname", "fileInfo", "fileNum", " fileInfo", "filePath", "FileName", "FILEname", "FileNum", "FILENum", "FileUrl", "FILEName", "FILEInfo", "fUrl"], "dstChannel": [" dndChannel", "drcManager", "ddestchannel", " dndSocket", "ddestChannel", " dstClient", "drcChannel", "drdChannel", "dndchannel", "dstsClient", "dsrcManager", "dsrcchannel", "dstsManager", " drcClient", "ddestConnection", "drdchannel", " drcChannel", "drdConnection", "ddestSocket", "dstSocket", "drcchannel", "dstschannel", "dsrcChannel", " dstSocket", " drcManager", "dstClient", "dndSocket", "dndChannel", " dndConnection", "dsrcClient", "dstManager", "drcClient", " dstConnection", "dstchannel", " dstchannel", " drcchannel", "dstConnection", "drdSocket", " dstManager", " dndchannel", "dndConnection", "dstsChannel"], "buffer": ["reader", "size", "processor", "queue", "memory", "binary", "counter", "reference", "buff", "repeat", "iter", "result", "player", "Buffer", "extra", "limit", "audio", "this", "b", "base", "layer", "data", "loader", "number", "channel", "r", "cover", "resource", "handler", "server", "address", "writer", "uffer", "sequence", "er", "transfer", "null", "batch", "flush", "wave", "comment", "FFER", "buf", "bar", "offset", "slice", "border", "seed", "cache", "file", "builder", "array", "header", "block", "rate", "copy", "pause"], "nr": ["next", "size", "ru", "nl", "num", "rf", "gr", "rx", "uni", "len", "counter", "range", "iter", "eno", "arity", "radius", "lr", "loc", "number", "rn", "no", "n", "r", "nor", "sequence", "inter", "usr", "NR", "nt", "length", "sr", "hr", "nu", "adr", "offset", "nos", "index", "pointer", "rl", "mr", "err", "i", "coord", "pos", "rr", "nb", "order", "ng", "sn", "nil", "inv", "nm", "nc", "rb", "ner", "umber"], "bytes": ["resources", "classes", "cells", "size", "strings", "binary", "Bytes", "pieces", "runs", "lines", "packs", "items", "bps", "b", "bc", "data", "fe", "blocks", "zip", "bs", "objects", "outs", "es", "address", "gets", "vs", "body", "pages", "values", "buf", "rules", "units", "rows", "les", "vals", "its", "limits", "features", "files", "pos", "bits", "tes", "seconds", "reads"]}}
{"id1": "4140309", "id2": "14356579", "code1": "    public String encrypt(final char[] password, final String algorithm, final byte[] salt) {\n        final StringBuffer buffer = new StringBuffer();\n        MessageDigest digest = null;\n        int size = 0;\n        if (\"SHA\".equalsIgnoreCase(algorithm) || \"SSHA\".equalsIgnoreCase(algorithm)) {\n            size = 20;\n            if ((salt != null) && (salt.length > 0)) {\n                buffer.append(\"{SSHA}\");\n            } else {\n                buffer.append(\"{SHA}\");\n            }\n            try {\n                digest = MessageDigest.getInstance(\"SHA-1\");\n            } catch (final NoSuchAlgorithmException e) {\n                throw new IllegalStateException(\"Invalid algorithm\");\n            }\n        } else if (\"MD5\".equalsIgnoreCase(algorithm) || \"SMD5\".equalsIgnoreCase(algorithm)) {\n            size = 16;\n            if ((salt != null) && (salt.length > 0)) {\n                buffer.append(\"{SMD5}\");\n            } else {\n                buffer.append(\"{MD5}\");\n            }\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (final NoSuchAlgorithmException e) {\n                throw new IllegalStateException(\"Invalid algorithm\");\n            }\n        } else {\n            throw new UnsupportedOperationException(\"Not implemented\");\n        }\n        int outSize = size;\n        digest.reset();\n        try {\n            digest.update(new String(password).getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 Unsupported\");\n        }\n        if ((salt != null) && (salt.length > 0)) {\n            digest.update(salt);\n            outSize += salt.length;\n        }\n        final byte[] out = new byte[outSize];\n        System.arraycopy(digest.digest(), 0, out, 0, size);\n        if ((salt != null) && (salt.length > 0)) {\n            System.arraycopy(salt, 0, out, size, salt.length);\n        }\n        buffer.append(new String(Base64.encodeBase64(out)));\n        return buffer.toString();\n    }\n", "code2": "    public String getRandomGUID() {\n        MessageDigest md5 = null;\n        String valueBeforeMD5 = \"\";\n        String retValue = \"\";\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            InetAddress id = InetAddress.getLocalHost();\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            rand = random.nextLong();\n            sbValueBeforeMD5.append(id.toString());\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            retValue = sb.toString();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error:\" + e);\n        }\n        return retValue;\n    }\n", "label": 1, "substitutes": {"password": ["source", "hash", "input", "url", "token", "auth", "sword", "username", "message", "wd", "channel", "data", "phrase", "email", "prefix", "address", "config", "pad", "word", " passwords", "pattern", "text", "session", "key", "string", "path", "seed", "attribute", "code", "secret", "Password", "crypt", "account", "wallet", "value", "padding", "pass"], "algorithm": ["Algo", " Algebra", "acgorith", "allignment", "calgorithm", "ALignment", "ulgebra", "organignment", "ALgo", "ulgorith", "calgebra", "ALgorith", "acgorithm", "dalgebra", "palgebra", "Algebra", "realgorith", "halgorithm", "elignment", "allgorithm", "organgorithm", "malgorith", "calgo", "acgebra", "aggo", "malgebra", "aggorith", "elgebra", "palgo", "palgorith", "calocol", "ulgorithm", "Alignment", "Algorith", " Algo", "algebra", "algo", " algebra", "alocol", "allgebra", "ALgorithm", "malignment", "aggorithm", "alignment", "allgorith", "calignment", "dalgo", "Algorithm", " alignment", "palgorithm", "elgorithm", " Algorith", " algorith", "Alocol", "organgebra", "aggebra", "ulignment", "halgorith", "acgo", "realgorithm", "organocol", "algorith", "halignment", "dalgorith", "malgorithm", "realgebra", "calgorith", "palignment", "realgo", "elgorith", "dalgorithm", "ALgebra", " Algorithm", "halgebra"], "salt": ["psodium", "dsugar", "singALT", "isodium", "sass", "Sodium", "sllet", "servicesALT", "dsalt", "nalt", "sesALT", "isalt", "seALT", "isALT", "sesatter", "hlet", "ansoff", "slert", "ansal", "slort", "sort", "isort", "sesave", "inul", "seert", "psort", "nodium", "inalt", "Satter", "ssal", " soff", "todium", "wsort", "dsunt", " sALT", "Salt", "slal", "sesunt", "esass", "dodium", "sart", "hul", "satter", "sesiter", "servicesunt", "wsodium", "siter", "wsALT", "sesodium", " sal", "dass", "essecret", " save", "tALT", "ssecret", "halt", "hart", "sslet", "ssave", " sass", "singodium", "ssALT", "sesalt", "sul", " sunt", "save", "bodium", "sert", "sesass", "slodium", "ssort", "tart", "slalt", "psalt", "gsalt", "slALT", "sugar", "bort", "dalt", "dart", "nass", "hal", "slart", "dALT", "sloff", "sALT", " sert", "sesugar", "isatter", "sodium", "batter", "servicesugar", "slunt", "dsALT", "singart", "sssecret", "servicesalt", "wsalt", "soff", "dort", "hunt", "sessecret", "sunt", "inart", " sul", "balt", "seart", "slatter", "talt", " ssecret", "ssalt", "psALT", "inunt", "isass", "hort", "SALT", "slet", "gssecret", "gsass", "nort", "singalt", " sart", "esalt", "gsALT", "sal", "ansunt", "ssass", "ansalt", "esiter", "sealt"], "buffer": ["source", "page", "reader", "url", "input", "queue", "binary", "memory", "write", "buff", "result", "iter", "Buffer", "message", "output", "view", "letter", "b", "bc", "row", "base", "loader", "data", "response", "server", "writer", "shared", "uffer", "exec", "sync", "transfer", "null", "surface", "bb", "flush", "text", "FFER", "buf", "bar", "window", "string", "image", "document", "seed", "cache", "pool", "code", "builder", "array", "header", "block", "secret", "empty", "bin", "stack", "copy", "port", "shell"], "digest": ["Diger", "digger", "decest", "mdester", "digester", " digger", "digests", "signester", "signests", " digress", "Digests", " diginer", "Digger", " digests", "integester", "Digword", "mdest", "Digher", "diffested", " digse", " Diger", "legher", "Digress", "diger", "diginer", "leginer", "legest", "digse", "generest", "signse", "decer", "differ", "digress", " Digest", "Digester", "diffester", "integest", "Digested", "mdmaster", " Digger", "Digitter", "Diginer", "decester", "decested", "digitter", " digmaster", "integword", " digher", "generword", "generester", "mder", "Digmaster", "signress", "digher", " digester", "legester", "integitter", "digword", "Digse", "signer", "signest", "diffest", "digested", " diger", " Digester", " digested", "digmaster", "Digest", "generitter"], "size": ["now", "end", "number", "address", "sync", "name", "max", "count", "width", "position", "small", "scale", "weight", "security", "iz", "Size", "SIZE", "shape", "esc", "length", "se", "zero", "start", "en", "len", "core", "loc", "false", "sum", "external", "x", "send", "ize", "capacity", "i", "use", "shift", "fee", "from", "sized", "here", "six", "member", "large", "ci", "offset", "sec", "code", "speed", "pos", "form", "empty", "sn", "any", "unit"], "outSize": [" outLen", "inAddress", "inLine", "inCode", "inLen", "outAddress", "outputLength", "againAddress", "outLine", "OUTLen", " outC", "OUTSize", "blockSize", "blockLength", "againLine", "outputC", "outputLen", "outLen", "againLen", "OUTAddress", "inLength", "inSize", "againCode", "againSize", "againLength", "outputSize", "outC", "outCode", "outLength", "blockC", "outputCode", "OUTLine", "blockLen", " outLength"], "out": ["source", "shift", "parent", "url", "user", "result", "extra", "min", "output", "io", "view", "in", "diff", "part", "base", "OUT", "again", "Out", "external", "writer", "inner", "off", "update", "word", "x", "name", "full", "batch", "exp", "flush", "comment", "all", "window", "index", "image", "list", "cache", "code", "err", "array", "secret", "group", "empty", "copy", "line", "pass"]}}
{"id1": "14832470", "id2": "3404757", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static <T> List<T> getServices(String service) {\n        String serviceUri = \"META-INF/services/\" + service;\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        try {\n            Enumeration<URL> urls = loader.getResources(serviceUri);\n            if (urls.hasMoreElements()) {\n                List<T> services = new ArrayList<T>(1);\n                do {\n                    URL url = urls.nextElement();\n                    _LOG.finest(\"Processing:{0}\", url);\n                    try {\n                        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        try {\n                            while (true) {\n                                String line = in.readLine();\n                                if (line == null) break;\n                                T instance = (T) _parseLine(loader, line);\n                                if (instance != null) services.add(instance);\n                            }\n                        } finally {\n                            in.close();\n                        }\n                    } catch (Exception e) {\n                        _LOG.warning(\"ERR_PARSING_URL\", url);\n                        _LOG.warning(e);\n                    }\n                } while (urls.hasMoreElements());\n                if (services.size() == 1) return Collections.singletonList(services.get(0));\n                return Collections.unmodifiableList(services);\n            }\n        } catch (IOException e) {\n            _LOG.severe(\"ERR_LOADING_RESROUCE\", serviceUri);\n            _LOG.severe(e);\n        }\n        return Collections.emptyList();\n    }\n", "code2": "    public InputStream getDaoConfig(String connectionType) throws IOException {\n        URL url = null;\n        if (connectionType.equals(SQL.ORACLE)) {\n            url = DTSWFDBConfig.class.getResource(\"oracle.xml\");\n        } else if (connectionType.equals(SQL.SQL2K)) {\n            url = DTSWFDBConfig.class.getResource(\"sql2k.xml\");\n        } else if (connectionType.equals(SQL.CACHE)) {\n            url = DTSWFDBConfig.class.getResource(\"cache.xml\");\n        }\n        return url.openStream();\n    }\n", "label": 0, "substitutes": {"service": ["source", "route", "size", "id", "link", "si", "connection", "plugin", "username", "function", "license", "description", "model", "base", "data", "class", "storage", "resource", "ie", "serv", "config", "info", "server", "element", "name", "method", "scope", "report", "se", "key", "sort", "string", "path", "rule", "seed", "sp", "uri", "file", "Service", "start", "str", "type"], "serviceUri": ["servicePUri", "resourceUrris", "ServiceUris", "resourceUURI", "serviceUURI", "serviceCuli", "serviceIris", "ServiceFileRI", "serviceUuli", "serviceUrri", "serviceCris", "serviceUrris", "ServiceURI", "resourceUris", "serviceURI", "servicePURI", "serviceURri", "serviceIRI", "servicePUURI", "resourceURI", "serviceFileris", "resourceIri", "ServiceUri", "serviceUi", "serviceUris", "servicePUris", "serviceURuli", "ServiceFileri", "serviceUsri", "serviceIi", "serviceCRI", "ServiceFileuli", "serviceCri", "resourceUrri", "serviceURris", "ServiceUuli", "ServiceFileris", "serviceFileri", "resourceUri", "serviceUsris", "serviceUrRI", "resourceUrRI", "resourceUi", "serviceUsRI", "serviceFileuli", "resourceIris", "serviceURRI", "resourceIRI", "resourceIURI", "serviceIri", "serviceFileRI", "serviceUsi", "serviceIURI", "serviceUsURI"], "loader": ["folder", "reader", "user", "link", "lang", "connection", "buffer", "io", "conn", "CL", "l", "lib", "out", "driver", "layer", "loc", "worker", "loaded", "class", "system", "resource", "handler", "server", "config", "info", "inner", "bean", "er", "container", "log", "cl", "parser", "lc", "Loader", "up", "path", "pool", "load", "cache", "file", "context", "lock", "err", "impl", "builder", "LOAD", "loading", "ll", "entry"], "urls": ["slls", "urles", "pathls", "llings", "collings", "URLes", "URLings", "downloadls", "httpings", "slches", "colls", "downloadings", "urlls", "lls", "llls", "https", "collls", "downloads", "URLs", "pathings", "slings", "paths", "httpes", "httpls", "URLls", "lles", "sles", "URLches", "urlches", "urlings", "httpches", "colles", "sls"], "services": ["resources", "classes", "works", "states", "tests", "strings", "reports", "events", "ils", "sections", "pieces", "packages", "lines", "settings", "packs", "keys", "items", "http", "params", "stores", "types", "styles", "ries", "ions", "forces", "storage", "sites", "models", "drivers", "devices", "groups", "ports", "users", "plugins", "results", "images", "lists", "values", "requires", "ls", "versions", "rules", "Services", "utils", "features", "ips", "apps", "projects", "files", "details", "modules", "s", "collection"], "url": ["source", "route", "reader", "id", "link", "user", "feed", "connection", "xml", "l", "http", "b", "lr", "base", "f", "data", "layer", "loc", "resource", "email", "server", "rail", "address", "serv", "el", "element", "ur", "log", "ls", "li", "string", "rule", "path", "image", "load", "obj", "uri", "file", "i", "ssl", "socket", "URL", "item", "Url", "str", "sl", "entry"], "in": ["source", "read", "reader", "id", "input", "inc", "din", "user", "xml", "io", "nin", "l", "out", "b", "fr", "login", "f", "as", "In", "stream", "n", "r", "again", "inner", "el", "er", "it", "ins", "ini", "kin", "image", "impl", "c", "socket", "file", "i", "IN", "err", "inn", "is", "lin", "bin", "s", "ac", "entry"], "line": ["source", "page", "reader", "link", "pe", "connection", "feed", "lf", "lines", "message", "l", "letter", "out", "LINE", "cell", "Line", "row", "f", "base", "data", "ine", "part", "inline", "style", "response", "r", "zip", "raw", "el", "e", "unit", "log", "cl", "text", "job", "lc", "le", "string", "file", "code", "header", "lin", "str", "ip", "sl", "entry"], "instance": ["page", "parent", "default", "office", "connection", "ances", "division", "Instance", "result", "example", "definition", "object", "client", "owner", "equality", "model", "data", "version", "class", "resource", "slave", "server", "config", "info", "inner", "shared", "section", "alias", "component", "inst", "ci", "member", "container", "parser", "anti", "index", "node", "image", "entity", "obj", "c", "parse", "record", "ance", "builder", "array", "project", "collection"]}}
{"id1": "20004216", "id2": "14356579", "code1": "        public boolean check(Object credentials) {\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5) {\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                } else {\n                    md.update(username.getBytes(StringUtil.__ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StringUtil.__ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StringUtil.__ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                md.reset();\n                md.update(method.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StringUtil.__ISO_8859_1));\n                byte[] ha2 = md.digest();\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StringUtil.__ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StringUtil.__ISO_8859_1));\n                byte[] digest = md.digest();\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n            } catch (Exception e) {\n                log.warn(LogSupport.EXCEPTION, e);\n            }\n            return false;\n        }\n", "code2": "    public String getRandomGUID() {\n        MessageDigest md5 = null;\n        String valueBeforeMD5 = \"\";\n        String retValue = \"\";\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            InetAddress id = InetAddress.getLocalHost();\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            rand = random.nextLong();\n            sbValueBeforeMD5.append(id.toString());\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            retValue = sb.toString();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Error:\" + e);\n        }\n        return retValue;\n    }\n", "label": 1, "substitutes": {"credentials": ["chedmissions", "chedents", "cronential", "cargentials", "coururation", "Credmissions", "creditsential", "cribents", "chedlins", "courmissions", "chedlaus", "credlaus", "courential", "carpmissions", "criblines", "chedkins", "cribential", "carguration", "condaentials", "Credlins", "creditsences", "Credents", "Chedential", "condalaus", "Credential", "carpuration", "cronentials", "cronmissions", "chedential", "crafential", "Cheduration", "crafkins", "cheduration", "Credlaus", "Credlines", "cribentials", "Chedents", "credmissions", "credential", "cntential", "Chedlaus", "credents", "Chedentials", "condalins", "Creduration", "Chedences", "condaences", "credlines", "carpentials", "cntmissions", "credences", "crafentials", "chedentials", "cargents", "cronlins", "cronences", "creduration", "chedences", "Chedlins", "Credences", "courentials", "cargential", "cntentials", "creditsentials", "condaential", "Credkins", "Credentials", "chedlines", "credlins", "craflines", "cribkins", "carpential", "cntences", "Chedlines", "credkins", "Chedkins", "criburation", "Chedmissions", "creditslaus"], "password": [" Password", "hash", "user", "token", "auth", "sword", "nick", "username", "message", "wd", "security", "cmd", "channel", "phrase", " username", "prefix", "server", "address", "word", "alias", "name", "method", "ssh", "device", "param", "text", "session", " credential", "key", "string", "path", "agent", "uri", "code", "attribute", "secret", "sudo", "Password", "crypt", "account", "staff", "pass"], "md": ["cd", "d", "dd", "ld", "hd", "mm", "doc", "mac", "hm", "meta", "old", "mod", "nt", "ok", "od", "pm", "mr", "nd", "amd", "em", " cmd", "msg", "lf", "mid", "ht", "dev", "pd", "mode", "bd", "mc", "gm", "dm", "de", "MD", "mail", "html", "self", "ad", "mn", "dc", "om", "my", "ind", " MD", "sm", "ma", "cmd", "git", "bm", "n", "mand", "mag", "module", "sha", "sym", "kg", "_", "mt", "ml", "mg", "Cmd", "ds", "metadata", "nm", "s", "pkg", "mb", "cm", "wd", "ms", "mo", "di", "mu", "dn", "body", "mp", "rm", " dd", "m", "db", "ng", "mi"], "ha1": ["vaone", "shaOne", "ha4", "la3", "haX", "ha3", "HA81", "HAOne", "haone", "va0", "haOne", "wa1", "la1", "va2", "wa8", "sha81", "la4", "wa3", "va1", "shaone", "HAX", "ha0", "sha0", "ya1", "wa2", "sha1", "la8", "sha8", "HA2", "HA1", "sha4", "la2", "HAone", "vaX", "shaX", "ha8", "ya81", "sha3", "va4", "sha2", "ha81", "yaOne", "ya2", "la0"], "ha2": ["ha6", "ha4", "na1", "wa1", "la1", "wa0", "va2", "na4", "la4", "va1", "ha0", "na2", "sha0", "wa2", "sha1", "va6", "sha4", "la2", "sha6", "va4", "sha2", "la0", "na6", "wa4"], "digest": ["decert", "decest", "digitested", "digester", "DigEST", "decher", "ngEST", "digitest", "Digher", "Digert", "digEST", "Digester", "Digested", "ngest", "digher", " digester", "digitester", "decEST", "digested", "ngher", "digert", " digested", "Digest", "ngert"]}}
{"id1": "4551648", "id2": "6405249", "code1": "    public HttpResponse execute(HttpHost host, HttpRequest req, HttpContext ctx) throws IOException, ClientProtocolException {\n        HttpResponse resp = backend.execute(host, req, ctx);\n        if (assessor.isFailure(resp)) {\n            throw new UnsuccessfulResponseException(resp);\n        }\n        return resp;\n    }\n", "code2": "    public static String generateHexadecimalCodedString(String stringToBeCoded) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n        digest.update(stringToBeCoded.getBytes());\n        byte[] hashedKey = digest.digest();\n        final int radix = 16;\n        String result = \"\";\n        for (byte b : hashedKey) {\n            int unsignedByte = b + 128;\n            result += Integer.toString(unsignedByte, radix);\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"host": ["head", "h", "url", "Host", "connection", "ost", "conn", "http", "client", "cmd", "request", "home", "driver", "object", "base", "hard", "mac", "ref", "handler", "server", "address", "config", "name", "target", "localhost", "connect", "context", "service", "hub", "addr", "self", "domain", "proxy", "port", "ip"], "req": ["reader", "cb", "gr", "proc", "rx", "rep", "jp", "conn", " requ", "request", "client", "fr", "def", "exc", "loader", "data", "ref", "r", " request", "response", "config", "Request", "exec", "query", "requ", "report", "Requ", "rh", "temp", "rec", "quest", "obj", "err", "q", "rr", "res", "entry"], "ctx": ["cb", "rx", "hw", " cx", "cm", "cu", "cf", "vc", "jp", "conn", "cas", "client", "fp", "bc", "loc", "cv", "exc", "cp", "ref", "xc", "tx", "config", "pc", "exec", "conf", "ci", "scope", "tc", "cl", "cs", " context", "obj", "c", "context", "Context", "conv", "cc", "ca", "cmp"], "resp": ["page", "hop", "respond", "cb", "rel", "success", "rep", "reply", "result", "jp", "conn", "fc", "http", "object", "fp", "val", "request", "model", "f", "ref", "re", "response", "comp", "ret", "serv", "comm", " response", "body", "exp", "json", "api", "rh", "temp", "v", "rec", "Response", "esp", "respons", "sp", "obj", "rev", "prev", "html", "err", "fb", "Resp", "pp", "error", "rr", "grad", "proxy", "res", "cmp", "p"]}}
{"id1": "12689310", "id2": "6633988", "code1": "    public HashMap<String, String> prepareDataFile(String fileName) {\n        File originalDataFile = new File(fileName);\n        String tableName = new String();\n        String line = new String();\n        BufferedReader br;\n        BufferedWriter bw;\n        long recordsNumber;\n        File tempDataFile;\n        HashMap<String, String> tableFileMap = new HashMap<String, String>();\n        String filePath = new String();\n        try {\n            br = new BufferedReader(new InputStreamReader(new FileInputStream(originalDataFile)));\n            if (br.ready()) {\n                if ((line = br.readLine()) != null) {\n                    do {\n                        tableName = \"temp_\" + getTableName(line);\n                        tempDataFile = new File(\"./Data/\" + tableName + \".txt\");\n                        tempDataFile.createNewFile();\n                        tableFileMap.put(tableName, tempDataFile.getCanonicalPath());\n                        recordsNumber = getRecordNumber(line);\n                        bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempDataFile)));\n                        for (long i = 0; i < recordsNumber; i++) {\n                            bw.write(br.readLine() + \"\\r\\n\");\n                        }\n                        bw.close();\n                    } while ((line = br.readLine()) != null);\n                }\n                br.close();\n                return tableFileMap;\n            }\n        } catch (Exception e) {\n            ExceptionHandler.handleExcptin(e);\n        }\n        return null;\n    }\n", "code2": "    public byte[] generatePassword(String clave) {\n        byte[] password = { 00 };\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(clave.getBytes());\n            password = md5.digest();\n            return password;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password;\n    }\n", "label": 0, "substitutes": {"fileName": ["FileInfo", " fileTime", "FilePath", "fileType", "FILETime", "FileType", "FILEType", "resourcename", "Filename", "filename", "FileTime", "fileInfo", "resourceName", " fileInfo", "resourceType", "FileName", "FILEname", "FILEPath", "resourcePath", "FILEName", "FILEInfo", "fileTime"], "originalDataFile": ["originalTablePlace", "OriginalDataFiles", "OriginalDataFile", "originalFileFile", "originalTableFile", "origDataPage", "origTablePage", "originalDataPage", "OriginalFileFile", "OriginalFilePlace", "originalCacheLine", "originalFilePlace", "originalFilePage", "originalCacheFile", "OriginalFilePage", "originalFileFiles", "origDataLine", "origTableFiles", "originalFileLine", "originalDataPlace", "originalDataFiles", "originalCacheFiles", "originalCachePage", "origDataFile", "originalTableFiles", "origTableFile", "origDataFiles", "origTableLine", "OriginalFileFiles", "OriginalDataPage", "originalTableLine", "originalDataLine", "originalTablePage", "OriginalDataPlace"], "tableName": ["TABLEName", "sectionPath", "TableLine", "tableKey", "sectionName", "sectionPart", " tableType", " tableLine", "TableNumber", "TABLEname", "TABLEKey", "fileType", " tablePart", "fileKey", "TableName", " tableNumber", " tablename", "fileLine", "filename", "TableKey", "tablePath", " tablePath", "TableType", "tablename", "tableType", "modelType", " tableKey", "modelNumber", "TablePath", "TABLEType", "tableNumber", "modelPath", "tablePart", "modelName", "tableLine", "TablePart"], "line": ["page", "entry", "sel", "id", "nl", "url", "link", "user", "pe", "lf", "range", "lines", "message", "l", "letter", "one", "end", "val", "LINE", "description", "cell", "Line", "part", "row", "model", "base", "data", "ine", "no", "inline", "style", "lo", "word", "name", "log", "cl", "text", "comment", "job", "lc", "status", "time", "li", "le", "string", "frame", "rule", "day", "key", "load", "file", "parse", "code", "db", "error", "label", "date", "header", "block", "pos", "lin", "position", "str", " Line", "sl", "unit"], "br": ["HR", "ber", "ner", "brush", "reader", "cb", "gr", "bf", "oper", "bh", "browser", "arr", "be", "bg", "ger", "fore", "http", "Br", "b", "ler", "bc", "lr", "fr", "ver", "bm", "BR", " tr", "ref", "r", "rib", "nor", "ir", "er", "cur", "ur", "bridge", "sl", "pr", "hr", "bar", "dr", "sr", "tr", "ch", "vr", "cr", "obj", "sp", "j", "mr", "err", "yr", "fb", "mer", "bro", "img", "form", "fin", "str", "rb", "jar", "wr", "bl"], "bw": ["abw", "bbsw", "lbwt", "BW", "bsw", "bh", "brwb", " bwo", "Bh", "bwa", "Bwb", "bbw", "Bwo", "Biw", " bws", "bbwh", "abws", "bW", " bwh", "bbh", "bbW", "briw", "bwb", " biw", "absw", "bbwt", "lbwa", "Bws", " bwb", "abwh", " bsw", "Bw", "bbwa", "brwo", "bwo", "bwh", "bbws", " bwa", "bws", " bW", "bwt", " bwt", "lbws", "lbw", "brw", "biw", " bh"], "recordsNumber": ["recrecordNumber", "recordNumbers", "recordCount", "cordsNumber", "callsCollection", "increordnumber", "recordsnumber", "recowsnumber", "recordNum", "recordordsName", "recowsNumbers", "callsCount", "recowsNumber", "increordsCount", "recordrecordNumber", "increordCount", "recallsNumber", "increordsNumbers", "recallsNum", "recrecordName", "recipesCount", "increordsNumber", "recitionsNumber", "recordrecordName", "increordsnumber", "recitionsCount", "recrecordNum", "recallsCount", "recodesNumber", "recordsNumbers", "recipesNumbers", "cordsNum", "recordrecordCount", "cordsCount", "recordName", "recowsCount", "callsNum", "recordrecordNum", "recipesnumber", "recordsCount", "recallsName", "recipesNumber", "increordNumbers", "recordordsNum", "increordNumber", "recordsCollection", "recodesNum", "recordNumber", "recrecordCount", "callsNumber", "recallsCollection", "recordsName", "recordordsCount", "recordnumber", "recordsNum", "cordsCollection", "recitionsCollection", "recodesCount", "recordordsNumber", "recodesCollection", "recitionsNum"], "tempDataFile": [" tempDataStream", "tempFilePlace", "tempDatabaseF", "tempTableFolder", "tempFilePath", " tempCodeFile", " tempCodePlace", "temTableLine", " tempTableF", "TempDataPlace", "temDataPlace", "originalDataPlace", "tempDataPlace", "tempFileFile", "tempDataFolder", "temTablePlace", "temDataLine", "TempDataFile", " tempDataPlace", "tempActionPlace", "temDataDirectory", "tempInfoPlace", "tempInfoFile", "originalFileFile", "tempTablePath", "temDataFile", "tempFileLine", "tempFileDirectory", "temTableDirectory", " tempCodeStream", "tempCodePlace", "originalDataFILE", " tempDataF", " tempTableFile", "tempDataDirectory", "TempDataDirectory", " tempTablePlace", "tempCodePath", "tempTableStream", "tempDataLine", "tempFileF", "originalFileFolder", "tempDataFILE", "TempFileDirectory", "temTableFile", "originalFilePlace", "tempCodeFile", "tempDiskFILE", "tempActionFile", "tempActionFolder", "tempDiskPlace", "tempTableLine", "TempFilePlace", " tempDataPath", "tempFileStream", "tempTableF", "tempFileFolder", "tempDataF", " tempTableDirectory", "tempTableDirectory", " tempCodePath", "tempDataPath", "tempDataStream", "tempDiskFolder", "TempFileFolder", "tempActionFILE", "originalDataFolder", " tempDataDirectory", "originalFileFILE", "tempFileFILE", "tempTableFile", "TempFileFile", "tempTablePlace", "tempInfoDirectory", "tempDatabaseFile", "tempInfoFolder", "tempInfoLine", "TempDataFolder", "tempDatabasePlace", "tempDiskFile", "tempDatabaseDirectory", "tempCodeStream"], "tableFileMap": ["tableFileSet", "tableFileCache", "tableLineStore", "tableTableList", "tableLineList", "tableNameSet", "dataFileMaps", "tableNameCache", "tablePlaceArray", "tableTableArray", "dataFileArray", "tableTableHeader", "dataFileSet", "tableFormatMap", "tableMessageList", "tableNameMap", "dataFileMap", "tableFormatList", "dataFileCache", "tableTableCache", "dataTableArray", "tablePlaceSet", "tableMessageHeader", "dataLineCache", "tableFileHeader", "tableBodyStore", "dataFileHeader", "tableTableStore", "tableBodyMap", "dataTableMap", "tableTableMaps", "dataTableSet", "dataFileList", "tableTableMap", "dataTableHeader", "tableLineCache", "tableFormatMaps", "dataTableCache", "dataTableMaps", "tableMessageMap", "dataTableList", "tableLineMap", "tablePlaceMap", "dataLineList", "tableFileArray", "tableBodyList", "tableFileMaps", "tableMessageMaps", "dataLineMap", "tableFileStore", "tableFileList", "tableFormatHeader", "tableTableSet", "tableBodyCache", "tablePlaceCache", "dataFileStore", "tableNameArray", "dataLineStore"], "filePath": ["FileInfo", "filepath", "Filepath", " filepath", "tablepath", "tablePath", "fileInfo", "tableInfo", "FilePath", " fileInfo", "FileName"], "i": ["id", "h", "si", "multi", "qi", "uli", "hi", "phi", "io", "l", "y", "in", "b", "f", "di", "bi", "r", "zi", "I", "ti", "oi", "gi", "ai", "info", "x", "it", "ui", "u", "e", "ci", "o", "m", "li", "v", "xi", "key", "ri", "index", "j", "c", "uri", "ii", "vi", "pi", "fi", "chi", "z"]}}
{"id1": "10789070", "id2": "6842462", "code1": "    public List<Datastream> getFiles(final String pFile) throws IOException {\n        List<Datastream> tDatastreams = new ArrayList<Datastream>();\n        new File(this.getTmpExtractDirName()).mkdir();\n        ZipFile tZipFile = new ZipFile(pFile);\n        Enumeration tEntries = tZipFile.entries();\n        ZipEntry tEntry = null;\n        File tFile = null;\n        String tFileLocation = \"\";\n        LocalDatastream tLocalDs = null;\n        while (tEntries.hasMoreElements()) {\n            tEntry = (ZipEntry) tEntries.nextElement();\n            if (tEntry.isDirectory()) {\n                continue;\n            }\n            tFileLocation = this.getTmpExtractDirName() + System.getProperty(\"file.separator\") + tEntry.getName();\n            tFile = new File(tFileLocation);\n            LOG.debug(\"Saving \" + tEntry.getName() + \" to \" + tFile.getPath());\n            tFile.getParentFile().mkdirs();\n            IOUtils.copy(tZipFile.getInputStream(tEntry), new FileOutputStream(tFile));\n            tLocalDs = new LocalDatastream(tFile.getName().split(\"\\\\.\")[0], FindMimeType.getMimeType(tFile.getName().split(\"\\\\.\")[1]), tFileLocation);\n            tLocalDs.setLabel(tEntry.getName());\n            tDatastreams.add(tLocalDs);\n        }\n        return tDatastreams;\n    }\n", "code2": "    private void playAudio(String mediaUrl) {\n        try {\n            URLConnection cn = new URL(mediaUrl).openConnection();\n            InputStream is = cn.getInputStream();\n            mediaFile = new File(this.getCacheDir(), \"mediafile\");\n            FileOutputStream fos = new FileOutputStream(mediaFile);\n            byte buf[] = new byte[16 * 1024];\n            Log.i(\"FileOutputStream\", \"Download\");\n            do {\n                int numread = is.read(buf);\n                if (numread <= 0) break;\n                fos.write(buf, 0, numread);\n            } while (true);\n            fos.flush();\n            fos.close();\n            Log.i(\"FileOutputStream\", \"Saved\");\n            MediaPlayer.OnCompletionListener listener = new MediaPlayer.OnCompletionListener() {\n\n                public void onCompletion(MediaPlayer mp) {\n                    mp.release();\n                    Log.i(\"MediaPlayer.OnCompletionListener\", \"MediaPlayer Released\");\n                }\n            };\n            mixPlayer.setOnCompletionListener(listener);\n            FileInputStream fis = new FileInputStream(mediaFile);\n            mixPlayer.setDataSource(fis.getFD());\n            mixPlayer.prepare();\n            Log.i(\"MediaPlayer\", \"Start Player\");\n            loading = false;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"pFile": ["inputfile", "eSourceFile", "PPlace", "pythonFolder", "PFile", "pythonPlace", " pfile", "pFolder", "lpFILE", "lpFolder", "inputFILE", "eFILE", " pFILE", "inputSourceFile", "eFile", "PFolder", "pythonFile", "lpFile", "pythonFILE", "PFILE", " pSourceFile", "lpPlace", "efile", "pFILE", "pPlace", "pfile", "pSourceFile", "inputFile"], "tDatastreams": ["tDatastREAMs", "tDatastructments", "tDatASTreaml", "tDatastStreames", "tDatastStreamls", "tDatastStreamments", "tDatASTREAMes", "tDatasteades", "tDatastREAMments", "tDatastStreaml", "tDatASTreamments", "tDatASTREAMs", "tDatastREAMls", "tDatASTREAMments", "tDataststreams", "tDatastreamments", "tDataststreaml", "tDatasteadments", "tDatASTreams", "tDatasteads", "tDataststreamls", "tDatastreamps", "tDataststreames", "tDatastREAMl", "tDatastructs", "tDatASTREAMls", "tDatastREAMps", "tDatastepes", "tDatastepps", "tDatasteps", "tDatASTREAMps", "tDatASTreamls", "tDatastreamls", "tDatastructps", "tDatastepments", "tDatasteadls", "tDatastStreams", "tDatastructes", "tDatastREAMes", "tDatastreaml", "tDatASTreamps", "tDatASTreames", "tDatastreames", "tDatASTREAMl"], "tZipFile": ["tPackageFile", "tTempFiles", "tTempFile", "TzipFiles", "tIPfile", "tZipFiles", "tPackageFiles", "tZipBase", "tzipFolder", "tzipfile", "tzipFiles", " tZipfile", "tBoxFile", "tBoxFiles", " tZFile", "tMailBase", " tZipBase", " tZFiles", "tBoxfile", "tSaxFile", "tZipfile", "TZipFile", "tZipFolder", " tMailfile", " tMailFiles", "tTempDir", " tZipFolder", "TzipFile", "tZFiles", " tZFolder", "Tzipfile", "tIPFolder", "tZipDir", "tTempFolder", " tZDir", "tPackagefile", "TZipFiles", "TZipFolder", "tIPFiles", "tzipFile", "tSaxFiles", " tZipFiles", "tIPFile", "tSaxDir", "tMailFile", "TZipfile", "tZFile", "tMailFiles", " tZipDir", "tzipBase", "tZFolder", "tBoxBase", " tMailBase", "TzipFolder", "tPackageFolder", "tZDir", "tSaxFolder", "tMailfile", " tMailFile"], "tEntries": ["tLastry", "tEurs", "tSequories", "tEntrys", "tSequents", "TEnances", "tExtries", "TEnries", "tfExtlements", "tLastlements", "tOrdurs", "tfExtents", "tSequlements", " tEurs", "tExtents", "tEnturs", "TEnlements", "tEntances", "tEntories", "tEnlements", " tEnturs", "tLastances", "tENTories", "tErys", "tIntry", " tErys", "tENTlements", "tLastries", "tIntances", " tEntlections", "tExtlements", "tEnances", "tfExtories", "TEntries", "tEntents", "tENTents", "tOrdrys", " tEntrys", "tfEntents", "tfEntories", "tIntries", "tEries", "TEntlements", "tOrdries", "tSequries", "tEnries", "TEntances", "tElections", " tElections", "tENTries", "tEntlections", "tfExtries", "tEntlements", "tEnry", "tExtories", "tOrdlections", "tfEntries", "TEnry", "tIntlements", " tEries", "TEntry", "tfEntlements"], "tEntry": ["TFile", "tEnt", " tInfo", "tentry", "tfEvent", "templateAdd", "ntEntry", "pAdd", " tModule", " tEnter", "ntFile", "nElement", "TEvent", "TEnt", " tEnt", "tfEntry", "tfFile", "templateFile", "ptEntry", "fInfo", "pElement", "fFile", "pEntry", " tAdd", "theEntry", "TEnter", "fEntry", "tModule", "ntEnter", "TInfo", "eFile", "ptFile", "tfEnt", "TModule", "nFile", "eElement", "Tentry", "theElement", "tElement", "tAdd", "nEntry", "tInfo", "tEvent", "ptAdd", "pentry", "TAdd", "eEntry", "pInfo", "eEnt", "nEnter", "fEnt", "theFile", "ntElement", "pModule", "tEnter", "templateEnter", "templateEntry", "TElement", "ptElement", "theEvent", " tentry", "TEntry", "theEnt"], "tFile": ["TFile", "fLibrary", "taFile", "TDir", "tLibrary", "taDirectory", "tfFolder", "tfEntry", "tefile", "ttFile", " tFolder", "pFolder", "pEntry", "tChild", " tfile", "tfStream", "tfChild", "taSourceFile", "tStream", "pPlace", "pFactory", " tFull", " tSourceFile", "pDirectory", "tFiles", " tPlace", "ptDir", "ptFull", "tPlace", "tfFilename", "ttChild", "tDirectory", "TDirectory", " tStream", " tChild", " tFactory", "teDirectory", " tFiles", "TSourceFile", "TEntry", "tFolder", "tfSourceFile", "tffile", "ttStream", "TFull", " tPath", "teFactory", " tDirectory", "tfPlace", "ptSourceFile", "TFilename", "tFilename", "ptFile", "ptLibrary", "taFilename", "tPath", "pSourceFile", " tDir", "tFactory", "tafile", "taFiles", "tfFile", "tfile", "ptEntry", "fFile", "tFull", "tDir", "fEntry", "fSourceFile", "TFiles", "Tfile", "pLibrary", "tSourceFile", "pfile", "ttPath", "tfPath", "teFile"], "tLocalDs": ["tExternalDS", "tLocalD", "TRemoteNs", "TRemoteDF", "TLocalDS", "tExternalDs", "tSimpleDS", "TRemoteDS", "TLocalDs", "tPersonalD", "tPrivateD", "tPersonalDS", "tPrivateDs", "tShortDS", "TLocalds", "tRemoteDe", "TLocalVs", "tNewVs", "tRemoteVs", "tNewDs", "tGlobalDs", "tLocalVs", "tExternalFiles", "tExternalD", "tRemoteDS", "tSimpleDF", "tRemoteNs", "tGlobalDS", "tRemoteds", "tRemoteFiles", "tLocalds", " tLocalD", "tRemoteD", "tPrivateNs", "tSimpleNs", "tRemoteDs", "tLocalFiles", " tGlobalDs", "tNewds", "TRemoteds", "TRemoteD", "tGlobalD", "tLocalDF", " tGlobalDS", " tLocalFiles", "tSimpleDs", "tPrivateDS", "tLocalDS", "tLocalDe", "tPersonalDs", " tLocalDS", "tPrivateDF", "tShortDs", "TLocalDF", "tGlobalFiles", "TLocalD", "tShortds", "TRemoteDs", "TLocalDe", "tNewDS", " tGlobalD", "TLocalNs", "tPrivateDe", "tRemoteDF", "tLocalNs", "tPersonalDe", "TRemoteDe", "TRemoteVs", "tShortVs", " tGlobalFiles"], "tFileLocation": ["sfileName", " tFilePath", " tFileName", "sFileName", "tMessagePath", "tfileLoc", "tFileArea", "tfileName", " tFilesName", "tMessageName", "tSourceFileLoc", "tSourceFileLocation", "sfileLoc", "sFileLocation", "tFileLoc", "tFolderLoc", "tTaskLoc", " tFileLoc", "tFilelocation", "tResourceLocation", "tFileName", "tTaskLocation", "tfilePosition", "treeFileName", "pSourceFileLoc", "sfileLocation", "tMessageLoc", "tFilesLoc", "tFolderPosition", "pFileLoc", "tFilePosition", "treeFilelocation", "tFolderArea", "tCodelocation", "pFilePosition", "tFilesLocation", "tFilesPath", "tMessagelocation", "tResourceName", "tSourceFileArea", "tTaskName", "treeFileLocation", "tFolderLocation", "tfileLocation", "pSourceFilePosition", "tCodeName", "tFilePath", " tFilesLoc", "tMessageLocation", " tFilesLocation", "tfileArea", "pFileArea", "pSourceFileLocation", "sFileLoc", "tResourceLoc", "tSourceFilePosition", "tFilesName", "tCodeLocation", "pFileLocation", " tFilesPath", "tResourcePath", "pSourceFileArea"]}}
{"id1": "7044128", "id2": "6744825", "code1": "    public static String setErrorServer(String newServer) {\n        String old = errorServerURL;\n        try {\n            URL url = new URL(newServer);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setInstanceFollowRedirects(false);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder page = new StringBuilder();\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                page.append(line);\n            }\n            rd.close();\n            if (!page.toString().equals(\"maRla\")) throw new ConfigurationException(\"URL given for error server is invalid\", ConfigType.ErrorServer);\n        } catch (UnknownHostException ex) {\n            System.out.println(\"Accepting setting for error sever, unable to check\");\n        } catch (MalformedURLException ex) {\n            throw new ConfigurationException(\"URL given for error server ('\" + newServer + \"') appears invalid\", ConfigType.ErrorServer, ex);\n        } catch (IOException ex) {\n            throw new ConfigurationException(\"URL given for error server could not be reached\", ConfigType.ErrorServer, ex);\n        }\n        errorServerURL = newServer;\n        return old;\n    }\n", "code2": "    private static String getTextFromURL(HttpServletRequest req, String urlString) {\n        StringBuffer buffer = new StringBuffer();\n        if (!urlString.startsWith(\"http\")) {\n            String requestURL = req.getRequestURL().toString();\n            urlString = requestURL.substring(0, requestURL.lastIndexOf(\"/\")) + urlString;\n        }\n        try {\n            URL url = new URL(urlString);\n            BufferedReader input = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            while ((line = input.readLine()) != null) {\n                buffer.append(line);\n                buffer.append(Constants.LF);\n            }\n        } catch (FileNotFoundException nf) {\n            log.error(\"File not found: \" + urlString, nf);\n        } catch (Exception e) {\n            log.error(\"Exception while reading file: \" + urlString, e);\n        }\n        return buffer.toString();\n    }\n", "label": 1, "substitutes": {"newServer": ["oldURL", "cleanServer", "oldUrl", " newMaster", "cleanUrl", " newURL", "longURL", "NEWSite", "oldSite", "NewURL", "cleanAddress", "newAddress", "oldserver", "NEWURL", "Newserver", "newserver", "longUrl", " newserver", "cleanserver", " newSite", "NEWServer", "NEWMaster", "oldMaster", "oldServer", "longServer", "NewUrl", "newUrl", "NEWUrl", "NewServer", "newMaster", "newSite", "NEWserver", "oldAddress", " newAddress", "newURL", " newUrl"], "old": ["get", "sel", "id", "none", "default", "last", "ld", "build", "expected", "ore", "now", "l", "original", "pre", "older", "end", "diff", "base", "clean", "bad", "update", "name", "full", "post", "lc", "back", "orig", "replace", "prev", "or", "OLD", "current", " Old", "ignore", "addr", "test", "Old"], "url": ["host", "nl", "connection", "rel", "ld", "ll", "l", "http", "bc", "lr", "fr", "loc", "r", "org", "resource", "server", "config", "el", "ur", "gl", "log", "cl", "bel", "fl", "ls", "path", "rl", "impl", "ssl", "db", "uri", "fb", "URL", "Url", "www", "web", "pl", "sl"], "conn": ["Config", "cb", "ln", "connection", "open", "auth", "cm", "co", "http", "con", "client", "cdn", "fd", "Conn", "fr", "loc", "rn", "cp", "n", "oa", "ctx", "org", "server", "serv", "ai", "cn", "pc", "conf", "exec", "ci", "rc", "nt", "cl", "ch", "cli", "cr", "connect", "c", "ssl", "rt", "db", "conv", "cc", "Connection", "ca", "nc", "rb", "ad", "Con"], "rd": ["wr", "reader", "ru", "rf", "ra", "rx", "dd", "ld", "xd", "ro", "rss", "pd", "ird", "fd", "fr", "red", "rn", "bd", "r", "rob", "rg", "rc", "erd", "rm", "rs", "rod", "rh", "dr", "adr", "hr", "art", "rl", "rw", "rt", "rid", "raf", "rr", "dra", "rb", "RD"], "page": ["host", "route", "site", "pe", "net", "office", "feed", "buffer", "xml", "result", "pl", "wiki", "view", "http", "article", "out", "pg", "age", "root", "row", "base", "channel", "po", "data", "response", "r", "server", "address", "word", "name", "body", "paper", "ge", "per", "pages", "log", "api", "content", "v", "pm", "string", "Page", "sp", "html", "record", "db", "code", "pp", "aa", "www", "blog", "web", "copy", "ip", "p"], "line": ["source", "sel", "link", "write", "pe", "feed", "lf", "lines", "message", "l", "letter", "one", "out", "end", "LINE", "cell", "column", "Line", "row", "f", "part", "base", "data", "inline", "response", "strip", "word", "sync", "name", "ge", "e", "log", "cl", "text", "comment", "content", "lc", "col", "string", "frame", "pass", "file", "error", "code", "parse", "header", "lin", "str", "ip", "sl", "entry"], "errorServerURL": ["errorSiteUrl", " errorClientURI", "errorClientSSL", "errorServerUrl", "ErrorClientSSL", "ErrorServerUrl", "errorServiceUrl", " errorClientID", " errorClientUrl", "errorClientID", "errorSiteID", " errorServerURI", "ErrorClientURI", "errorServerURI", "errorserverUrl", "errorServerID", "ErrorClientUrl", "errorServerSSL", " errorClientURL", "errorSiteURI", "errorServiceID", "ErrorServerSSL", " errorServerUrl", "errorClientUrl", "errorServiceSSL", "errorserverURI", "errorserverSSL", "ErrorServerURI", "ErrorClientURL", " errorServerID", "errorClientURL", "errorServiceURL", "errorClientURI", "errorServiceURI", "ErrorServerURL", "errorSiteURL", "errorserverURL"]}}
{"id1": "8205040", "id2": "22197364", "code1": "    @Override\n    public Template updateTemplate(Template template) {\n        template.setContent(getTemplateContent(template.getScreen()));\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"name\", template.getName()));\n        params.add(new BasicNameValuePair(\"content\", template.getContent()));\n        params.add(new BasicNameValuePair(\"shared\", template.isShared() + \"\"));\n        params.add(new BasicNameValuePair(\"keywords\", template.getKeywords()));\n        try {\n            String saveRestUrl = configuration.getBeehiveRESTRootUrl() + \"account/\" + userService.getAccount().getOid() + \"/template/\" + template.getOid();\n            HttpPut httpPut = new HttpPut(saveRestUrl);\n            addAuthentication(httpPut);\n            UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params, \"UTF-8\");\n            httpPut.setEntity(formEntity);\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpResponse response = httpClient.execute(httpPut);\n            if (HttpServletResponse.SC_OK == response.getStatusLine().getStatusCode()) {\n                resourceService.saveTemplateResourcesToBeehive(template);\n            } else if (HttpServletResponse.SC_NOT_FOUND == response.getStatusLine().getStatusCode()) {\n                return null;\n            } else {\n                throw new BeehiveNotAvailableException(\"Failed to update template:\" + template.getName() + \", Status code: \" + response.getStatusLine().getStatusCode());\n            }\n        } catch (Exception e) {\n            throw new BeehiveNotAvailableException(\"Failed to save screen as a template: \" + (e.getMessage() == null ? \"\" : e.getMessage()), e);\n        }\n        return template;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public InputStream openStream(URL url) throws IOException {\n        List<String> lines = IOUtils.readLines(url.openStream());\n        for (String line : lines) {\n            Matcher m = PATTERN.matcher(line);\n            if (m.matches()) {\n                String origUrl = m.group(1);\n                log.info(\"Loading content from: \" + origUrl);\n                return new HttpUtil<InputStream>() {\n\n                    @Override\n                    public InputStream handleResponse(InputStream response) throws IOException {\n                        return new ByteArrayInputStream(IOUtils.toByteArray(response));\n                    }\n                }.get(new URL(origUrl));\n            }\n        }\n        log.error(\"No origUrl found for url: \" + url);\n        return null;\n    }\n", "label": 0, "substitutes": {"template": ["translation", "result", "model", "directory", "style", "resource", "email", "name", "temp", "missing", "slice", "image", "file", "project", "site", "layout", "xml", "buffer", "widget", "object", "application", "table", "tem", "Template", "it", "pattern", "t", "instance", "plate", "cache", "html", "database", "copy", "theme", "source", "page", " Template", "parent", "route", "tmp", "http", "license", "controller", "custom", "base", "f", "set", "server", "plane", "module", "e", "v", "node", "i", "service", "metadata", "p", "language", "ami", "game", "message", "view", "format", "environment", "profile", "data", "match", "config", "machine", "zone", "body", "target", "container", "api", "content", "document", "tm", "form", "empty", "type"], "params": ["options", "resources", "relations", "points", "ctx", "settings", "lines", "eters", "pins", "http", "properties", "items", "styles", "css", "data", "resource", "objects", "changes", "par", "meta", "posts", "models", "config", "shared", "vs", "eps", "groups", "body", "plugins", "query", "results", "param", "json", "members", "api", "rs", "names", "rules", "ls", "words", "media", "list", "Parameters", "apps", "details", "array", "files", "ras", "parts", "pi", "services", "ams", "ps", "copy", "ip", "server"], "saveRestUrl": ["createResourcePath", "saveRestURL", "createRestPath", "saveRestLocation", "saveResourceLocation", "saverestUrl", "createRestURL", "createResourceUrl", "saverestURL", "saveBaseUrl", "saveResourceUrl", " saveConstUrl", " saveConstUr", "saveResourceUr", " saveRestURL", "createRestLocation", "saveResourcePath", " saveRestUr", " saveConstURL", " saveRestCall", "saveBaseLocation", "saveConstURL", "saverestLocation", "saverestUr", " saveConstCall", "saveResourceCall", "saveConstUr", "createResourceLocation", "saveRestCall", "saverestCall", "saveConstCall", "saveRestUr", "saverestPath", "saveBasePath", "createResourceURL", "saveConstUrl", "saveRestPath", "saveBaseURL", "saveResourceURL", "createRestUrl"], "httpPut": ["Httpput", "phpPUT", "HttpGet", " httpPUT", "HttpPut", " httpPush", "httpGet", "HTTPput", "HttpPush", "HTTPPush", " httpCopy", "httpput", "httpPush", " httpPost", "httpPost", "HttpPUT", "phpPost", "internalPut", "phpPut", "HTTPPut", "HttpCopy", "internalPost", " httpGet", "httpCopy", "httpPUT", "internalput", "internalGet", " httpput", "HttpPost", "HTTPCopy", "phpGet", "phpput"], "formEntity": ["FormSource", "formEl", "formBody", "jsonEl", "formatEntry", "formatEntity", "jsonBody", "formatSource", "FormEl", " formEnt", "formSource", "formatEnt", "FormEnt", " formEntry", " formEl", "jsonEntity", "FormEntry", " formBody", " formSource", "jsonEnt", "FormBody", "formEnt", "FormEntity", "formEntry"], "httpClient": ["ttpCase", "HttpGet", "HttpCall", "jsonCall", "Httpclient", "httpclient", "ttpClient", "phpClient", "httpGet", "ttpclient", " httpCase", "phpResource", "httpResource", "httpCase", "phpclient", "jsonClient", " httpCall", " httpResource", "jsonGet", "phpCase", "HttpClient", " httpGet", "httpCall", "ttpResource", "jsonclient", " httpclient"], "response": ["next", "get", "page", "parent", "respond", "connection", "feed", "success", "reply", "ception", "result", "function", "message", "output", "view", "http", "flash", "request", "object", "client", "description", "model", "environment", "channel", "application", "onse", "data", "version", "tree", "resource", "handler", "server", "es", "writer", "method", "body", "json", "api", "initial", "status", "session", "Response", "index", "document", "image", "pool", "error", "i", "resp", "service", "received", "collection"]}}
{"id1": "4140309", "id2": "3377427", "code1": "    public String encrypt(final char[] password, final String algorithm, final byte[] salt) {\n        final StringBuffer buffer = new StringBuffer();\n        MessageDigest digest = null;\n        int size = 0;\n        if (\"SHA\".equalsIgnoreCase(algorithm) || \"SSHA\".equalsIgnoreCase(algorithm)) {\n            size = 20;\n            if ((salt != null) && (salt.length > 0)) {\n                buffer.append(\"{SSHA}\");\n            } else {\n                buffer.append(\"{SHA}\");\n            }\n            try {\n                digest = MessageDigest.getInstance(\"SHA-1\");\n            } catch (final NoSuchAlgorithmException e) {\n                throw new IllegalStateException(\"Invalid algorithm\");\n            }\n        } else if (\"MD5\".equalsIgnoreCase(algorithm) || \"SMD5\".equalsIgnoreCase(algorithm)) {\n            size = 16;\n            if ((salt != null) && (salt.length > 0)) {\n                buffer.append(\"{SMD5}\");\n            } else {\n                buffer.append(\"{MD5}\");\n            }\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (final NoSuchAlgorithmException e) {\n                throw new IllegalStateException(\"Invalid algorithm\");\n            }\n        } else {\n            throw new UnsupportedOperationException(\"Not implemented\");\n        }\n        int outSize = size;\n        digest.reset();\n        try {\n            digest.update(new String(password).getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 Unsupported\");\n        }\n        if ((salt != null) && (salt.length > 0)) {\n            digest.update(salt);\n            outSize += salt.length;\n        }\n        final byte[] out = new byte[outSize];\n        System.arraycopy(digest.digest(), 0, out, 0, size);\n        if ((salt != null) && (salt.length > 0)) {\n            System.arraycopy(salt, 0, out, size, salt.length);\n        }\n        buffer.append(new String(Base64.encodeBase64(out)));\n        return buffer.toString();\n    }\n", "code2": "    public void execute() throws BuildException {\n        Enumeration list = getIndividualTests();\n        String srcRptFile = \"\";\n        String destRptFile = \"\";\n        while (list.hasMoreElements()) {\n            J3DPerfUnitTest test = (J3DPerfUnitTest) list.nextElement();\n            if (test.shouldRun(getProject())) {\n                try {\n                    execute(test);\n                    try {\n                        srcRptFile = getProject().resolveFile(\".\").getAbsolutePath() + \"\\\\\" + test.getName() + \".txt\";\n                        destRptFile = getProject().resolveFile(test.getName() + \".txt\", new File(test.getTodir())).getAbsolutePath();\n                        FileChannel srcChannel = new FileInputStream(srcRptFile).getChannel();\n                        FileChannel dstChannel = new FileOutputStream(destRptFile).getChannel();\n                        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                        srcChannel.close();\n                        dstChannel.close();\n                        if (!srcRptFile.equals(destRptFile)) {\n                            new File(srcRptFile).delete();\n                        }\n                    } catch (IOException e) {\n                    }\n                } catch (BuildException e) {\n                    e.printStackTrace();\n                } catch (CloneNotSupportedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"password": ["source", "hash", "input", "url", "token", "auth", "sword", "username", "message", "wd", "channel", "data", "phrase", "email", "prefix", "address", "config", "pad", "word", " passwords", "pattern", "text", "session", "key", "string", "path", "seed", "attribute", "code", "secret", "Password", "crypt", "account", "wallet", "value", "padding", "pass"], "algorithm": ["Algo", " Algebra", "acgorith", "allignment", "calgorithm", "ALignment", "ulgebra", "organignment", "ALgo", "ulgorith", "calgebra", "ALgorith", "acgorithm", "dalgebra", "palgebra", "Algebra", "realgorith", "halgorithm", "elignment", "allgorithm", "organgorithm", "malgorith", "calgo", "acgebra", "aggo", "malgebra", "aggorith", "elgebra", "palgo", "palgorith", "calocol", "ulgorithm", "Alignment", "Algorith", " Algo", "algebra", "algo", " algebra", "alocol", "allgebra", "ALgorithm", "malignment", "aggorithm", "alignment", "allgorith", "calignment", "dalgo", "Algorithm", " alignment", "palgorithm", "elgorithm", " Algorith", " algorith", "Alocol", "organgebra", "aggebra", "ulignment", "halgorith", "acgo", "realgorithm", "organocol", "algorith", "halignment", "dalgorith", "malgorithm", "realgebra", "calgorith", "palignment", "realgo", "elgorith", "dalgorithm", "ALgebra", " Algorithm", "halgebra"], "salt": ["psodium", "dsugar", "singALT", "isodium", "sass", "Sodium", "sllet", "servicesALT", "dsalt", "nalt", "sesALT", "isalt", "seALT", "isALT", "sesatter", "hlet", "ansoff", "slert", "ansal", "slort", "sort", "isort", "sesave", "inul", "seert", "psort", "nodium", "inalt", "Satter", "ssal", " soff", "todium", "wsort", "dsunt", " sALT", "Salt", "slal", "sesunt", "esass", "dodium", "sart", "hul", "satter", "sesiter", "servicesunt", "wsodium", "siter", "wsALT", "sesodium", " sal", "dass", "essecret", " save", "tALT", "ssecret", "halt", "hart", "sslet", "ssave", " sass", "singodium", "ssALT", "sesalt", "sul", " sunt", "save", "bodium", "sert", "sesass", "slodium", "ssort", "tart", "slalt", "psalt", "gsalt", "slALT", "sugar", "bort", "dalt", "dart", "nass", "hal", "slart", "dALT", "sloff", "sALT", " sert", "sesugar", "isatter", "sodium", "batter", "servicesugar", "slunt", "dsALT", "singart", "sssecret", "servicesalt", "wsalt", "soff", "dort", "hunt", "sessecret", "sunt", "inart", " sul", "balt", "seart", "slatter", "talt", " ssecret", "ssalt", "psALT", "inunt", "isass", "hort", "SALT", "slet", "gssecret", "gsass", "nort", "singalt", " sart", "esalt", "gsALT", "sal", "ansunt", "ssass", "ansalt", "esiter", "sealt"], "buffer": ["source", "page", "reader", "url", "input", "queue", "binary", "memory", "write", "buff", "result", "iter", "Buffer", "message", "output", "view", "letter", "b", "bc", "row", "base", "loader", "data", "response", "server", "writer", "shared", "uffer", "exec", "sync", "transfer", "null", "surface", "bb", "flush", "text", "FFER", "buf", "bar", "window", "string", "image", "document", "seed", "cache", "pool", "code", "builder", "array", "header", "block", "secret", "empty", "bin", "stack", "copy", "port", "shell"], "digest": ["Diger", "digger", "decest", "mdester", "digester", " digger", "digests", "signester", "signests", " digress", "Digests", " diginer", "Digger", " digests", "integester", "Digword", "mdest", "Digher", "diffested", " digse", " Diger", "legher", "Digress", "diger", "diginer", "leginer", "legest", "digse", "generest", "signse", "decer", "differ", "digress", " Digest", "Digester", "diffester", "integest", "Digested", "mdmaster", " Digger", "Digitter", "Diginer", "decester", "decested", "digitter", " digmaster", "integword", " digher", "generword", "generester", "mder", "Digmaster", "signress", "digher", " digester", "legester", "integitter", "digword", "Digse", "signer", "signest", "diffest", "digested", " diger", " Digester", " digested", "digmaster", "Digest", "generitter"], "size": ["now", "end", "number", "address", "sync", "name", "max", "count", "width", "position", "small", "scale", "weight", "security", "iz", "Size", "SIZE", "shape", "esc", "length", "se", "zero", "start", "en", "len", "core", "loc", "false", "sum", "external", "x", "send", "ize", "capacity", "i", "use", "shift", "fee", "from", "sized", "here", "six", "member", "large", "ci", "offset", "sec", "code", "speed", "pos", "form", "empty", "sn", "any", "unit"], "outSize": [" outLen", "inAddress", "inLine", "inCode", "inLen", "outAddress", "outputLength", "againAddress", "outLine", "OUTLen", " outC", "OUTSize", "blockSize", "blockLength", "againLine", "outputC", "outputLen", "outLen", "againLen", "OUTAddress", "inLength", "inSize", "againCode", "againSize", "againLength", "outputSize", "outC", "outCode", "outLength", "blockC", "outputCode", "OUTLine", "blockLen", " outLength"], "out": ["source", "shift", "parent", "url", "user", "result", "extra", "min", "output", "io", "view", "in", "diff", "part", "base", "OUT", "again", "Out", "external", "writer", "inner", "off", "update", "word", "x", "name", "full", "batch", "exp", "flush", "comment", "all", "window", "index", "image", "list", "cache", "code", "err", "array", "secret", "group", "empty", "copy", "line", "pass"]}}
{"id1": "22197335", "id2": "305886", "code1": "    private void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "sb", "url", "input", "txt", "upload", "download", "sit", "inf", "b", "loc", "stab", "stream", "sc", "config", "dest", "sup", "filename", "ins", "rc", "inst", "ls", "sin", "slice", "path", "rl", "obj", "file", "uri", "files", "sq", "dist", "img", "sn", "proxy", "s", "rb"], "dst": ["sdst", " dsts", "dsts", "dST", "dsrc", "nsts", "adct", "rdft", "nst", "Ddest", "adst", "sdsrc", "ndest", "rdsrc", "rdct", "adft", "DST", "rdst", "Dsts", " ddest", " dST", "dft", "dct", "adsrc", "Dst", "nST", "ddest", "sdft", "sdct"], "in": ["source", "reader", "id", "url", "input", "inc", "din", "ln", "trans", "win", "pull", "nin", "conn", "con", "login", "f", "as", "data", "In", "pin", "again", "n", "r", "stream", "inner", "init", "ins", "gin", "ini", "kin", "sin", "up", "cin", "socket", "file", "i", "IN", "inside", "inn", "rin", "is", "lin", "bin"], "out": ["parent", "trans", "inc", "net", "io", "output", "outer", "conn", "lib", "w", "client", "part", "data", "n", "Out", "OUT", "outs", "again", "server", "raw", "call", "writer", "off", "exec", "sync", "o", "other", "exp", "log", "ex", "post", "up", "pool", "obj", "cache", "file", "i", "err", "cos", "at", "img", "self", "bin", "copy", "ext"], "buf": ["cb", "tmp", "queue", "bf", "bh", "uc", "buffer", "buff", "br", "lim", "b", "cmd", "bc", "fd", "loc", "cv", "base", "data", "bd", "ref", "bytes", "ctx", "box", "raw", "pad", "off", "func", "batch", "rc", "bb", "length", "seq", "uf", "cap", "bag", "orig", "c", "vec", "fb", "ff", "bn", "bin", "rb", "bp"], "len": ["size", "split", "en", "id", "num", "ln", "lf", "ind", "iter", "min", "limit", "lim", "l", "end", "val", "fd", "part", "f", "base", "Len", "data", "no", "n", "enc", "off", "el", "body", "nt", "length", "cap", "lc", "li", "fl", "le", "all", "dy", "count", "c", "rev", "err", "pos", "fin", "line"]}}
{"id1": "21393871", "id2": "13842042", "code1": "    public String call() throws Exception {\n        InputStream stream = url.openStream();\n        StringBuffer sb = new StringBuffer();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line);\n        }\n        return sb.toString();\n    }\n", "code2": "    @Override\n    protected Properties loadFile(String fileName) {\n        Properties prop = new Properties();\n        try {\n            URL url = new File(fileName).toURI().toURL();\n            final InputStream input = url.openStream();\n            prop.load(input);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return prop;\n    }\n", "label": 0, "substitutes": {"stream": ["source", "read", "url", "input", "trans", "feed", "Stream", "open", "buffer", "pipe", "src", "thread", "out", "in", "object", "this", "sw", "driver", "channel", "f", "loader", "data", "response", "resource", "server", "raw", "writer", "per", "filter", "string", "pool", "socket", "file", "ssl", "context", "form", "stack", "port", "null", "coll", "sl"], "sb": ["cb", "url", "bf", "mb", "bh", "binary", "buffer", "sth", "buff", "lines", "sg", "ws", "bg", "BB", "pb", "src", "b", "sf", "bc", "kb", "bm", "bd", "ruby", "abb", "bs", "obb", "erb", "bb", "SB", " SB", "ob", "sv", "ls", "buf", "gb", "xb", "B", "eb", "ib", "bsp", "ab", "ssl", "db", "bt", "wb", "fb", "builder", "nb", "lb", "web", "s", "rb", "bp"], "reader": ["ner", "read", "url", "input", "rx", "Reader", "feed", "buffer", "result", "iter", "ser", "ro", "io", "l", "in", "b", "ler", "row", "f", "worker", "r", "handler", "server", "editor", "writer", "er", "rer", "body", "bb", "reading", "rot", "per", "bird", "parser", "ri", "i", "rr", "rb", "entry"], "line": ["source", "next", "page", "sel", "value", "url", "link", "feed", "len", "lf", "lines", "iter", "message", "l", "letter", "out", "object", "char", "b", "LINE", "cell", "end", "Line", "part", "f", "number", "base", "data", "no", "row", "inline", "style", "r", "response", "raw", "word", "name", "body", "log", "cl", "text", "comment", "content", "key", "string", "pass", "obj", "code", "i", "err", "header", "block", "lin", "look", "str", " Line", "sl", "entry"]}}
{"id1": "11108280", "id2": "7273182", "code1": "    public static String generateCode(String seed) {\n        try {\n            Security.addProvider(new FNVProvider());\n            MessageDigest digest = MessageDigest.getInstance(\"FNV-1a\");\n            digest.update((seed + UUID.randomUUID().toString()).getBytes());\n            byte[] hash1 = digest.digest();\n            String sHash1 = \"m\" + (new String(LibraryBase64.encode(hash1))).replaceAll(\"=\", \"\");\n            return sHash1;\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"Internal error:\" + e.getMessage());\n            return null;\n        }\n    }\n", "code2": "    public synchronized String encrypt(String text) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        md.update(text.getBytes());\n        byte raw[] = md.digest();\n        String hash = \"\";\n        for (int i = 0; i < raw.length; i++) {\n            byte temp = raw[i];\n            String s = Integer.toHexString(new Byte(temp));\n            while (s.length() < 2) {\n                s = \"0\" + s;\n            }\n            s = s.substring(s.length() - 2);\n            hash += s;\n        }\n        return hash;\n    }\n", "label": 1, "substitutes": {"seed": ["source", "id", "hash", "rand", "url", "token", "buffer", "fee", "prime", "username", "message", "params", "state", "root", "number", "data", "phrase", "bytes", "zip", "sum", "prefix", "config", "address", "Salt", "random", "sequence", "name", "cookie", "length", "password", "text", "eed", "key", "slice", "string", "delay", "uri", "code", "secret", "crypt", "alpha", "type"], "digest": ["digler", "Diger", "hasheter", "generate", "digester", "digests", "signester", "digcode", "DigEST", " digests", "Digeter", "diger", "Digler", "signEST", " digcode", "digeter", "generest", " digeter", "hashEST", "digEST", "Digester", " digate", " digEST", "hashler", " digler", "genercode", "generests", "hasher", "digate", "hashate", " digester", "hashests", "hashcode", "signer", "signest", "hashest", "hashester", " diger", "Digest"], "hash1": [" hashOne", "kh1", "Hashone", "sumOne", "Hash64", "sumone", " hashed", "khed", " hashone", "Hashed", "Hash1", "hashed", "hashone", "HashOne", "khone", "sum1", " hash64", "hashOne", "kh64", "hash64"], "sHash1": ["shash6", "shash2", " sHash2", " sHashOne", "shash1", " sHash6", " sSHA2", "sWave31", "sHashOne", " sSHAOne", "shashOne", "sSHA2", " shash6", "sWave1", " sHash31", "sHOne", "sH1", "sHash31", "sWave6", "sHash2", "sH2", " sSHA1", "sHash6", "sSHA1", " shash31", "sPh1", "sPh31", " shash1", "sSHAOne", "sPh6", "shash31"]}}
{"id1": "8921742", "id2": "3108499", "code1": "    public FTPSource(SourceDetail sourceDetail) throws SourceException {\n        this.sourceDetail = sourceDetail;\n        localPathMap = new HashMap<String, String>();\n        client = new FTPClient();\n        try {\n            client.connect(sourceDetail.getHost());\n            client.login(sourceDetail.getUser(), sourceDetail.getPassword());\n            workingDirectory = new File(ConfigManager.getGUIConfig().getWorkingDirectoryName() + File.separator + sourceDetail.getName());\n            workingDirectory.mkdir();\n        } catch (Exception e) {\n            throw new SourceException(e);\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"sourceDetail": ["sourceDetector", "serviceDetain", "sourceContailed", "sourceExail", "sourceDisdetail", "configExdetail", "sourceNain", "sourceInfoill", "sourceExain", "sourceAttailed", "serviceDetill", "sourceProtill", "sourceDetain", "sourceDisail", "sourceInfoil", "sourceInfodetail", " sourceDetector", "sourceInfoailed", "sourceNill", "sourceMetailed", "sourceExailed", "sourceDetill", "configDetil", "serviceAttailed", "sourceDisector", "configDetdetail", "sourceExtalt", "sourceContil", " sourceDetailed", " sourceDetil", "sourceExdetail", "sourcePartail", "configDetailed", " sourceDetalt", " sourceProtill", "sourceExtdetail", "configMetail", "sourceNail", "sourceDirail", "configExail", " sourceExtalt", "sourceDirailed", "sourcePartailed", "configDetain", "sourceExtailed", "sourceDirdetail", " sourceExtector", "sourceExtector", "sourceDisailed", "sourceAttail", "configExain", "sourceDetil", "sourceProtdetail", "sourceMetext", "sourceExtill", "serviceAttill", "sourceDetext", "sourceDetailsdetail", "sourceProtain", " sourceDetdetail", " sourceProtailed", "sourceDetalt", "sourceDetailsail", "configDetail", "configExailed", "sourceDetdetail", "sourceExtail", "sourceAttector", "sourceExtain", "configDetext", "sourceProtailed", "configMetext", "serviceAttain", " sourceProtail", "sourceProtalt", " sourceDetill", "sourceDirain", "serviceAttail", " sourceExtailed", "sourceInfoail", "sourceMetail", "sourceDetailed", "sourceMetil", " sourceExtail", "configMetailed", " sourceExtdetail", "serviceDetailed", "sourceContext", " sourceProtil", "sourceNailed", "sourceDetailsailed", "sourceAttdetail", " sourceProtdetail", "sourceContail", "sourcePartext", "sourceAttain", "sourceProtail", "sourcePartill", "configMetil", "sourceAttill", "serviceDetail", "sourceDetailsalt", "sourceProtil", "sourcePartil"], "localPathMap": [" localPathData", "localpathMap", "localContextData", "localFileData", "localPathList", "localContextMap", " localContextList", "localpathmap", " localContextmap", "localFileMap", "localPathData", "localpathList", " localPathmap", " localPathList", " localContextData", "localFilemap", " localContextMap", "localPathmap", "localContextList", "localpathData", "localFileList", "localContextmap"], "client": ["source", "net", "connection", "util", "open", "plugin", "co", "conn", "http", "con", "app", "this", "cell", "console", "cp", "remote", "resource", "handler", "server", "call", "config", "contact", "force", "project", "ace", "api", "Client", "cli", "session", "pool", "connect", "cache", "socket", "ssl", "secure", "manager", "local", "service", "ce", "proxy", "web", "port", "use"], "workingDirectory": ["workdirectory", "WorkingFile", "testingFolder", "workingDir", "testingDir", "workFile", " workingFolder", "workDir", " workingDir", "workDirectory", " workingFile", "workingFolder", "testingdirectory", "workingFile", "workingdirectory", "testingDirectory", " workingdirectory", "WorkingDir", "workFolder", "WorkingFolder", "WorkingDirectory"]}}
{"id1": "8731413", "id2": "22991420", "code1": "    public ImportFromFile() {\n        JFrame jf = new JFrame();\n        JFileChooser fc = new JFileChooser(KTH.data._path);\n        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        int returnVal = fc.showOpenDialog(jf);\n        File file = null;\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            file = fc.getSelectedFile();\n            KTH.data._path = file.getParent();\n            System.out.println(file.getAbsolutePath() + \"\\n\");\n        } else {\n        }\n        if (file != null) {\n            File f = new File(KTH.data.getHomeDir() + File.separator + KTH.data.katalogName);\n            System.out.println(f + (f.exists() ? \" is found \" : \" is missing \"));\n            if (f.exists() && !IOUtils.isNewerContent(file, f)) {\n            } else {\n                try {\n                    IOUtils.copyFile(file, f, true);\n                } catch (Exception e) {\n                    KTH.out.err(e);\n                }\n            }\n            KTH.dc2.removeDc(\"Import\");\n        } else {\n        }\n    }\n", "code2": "    public void notifyIterationEnds(final IterationEndsEvent event) {\n        log.info(\"moving files...\");\n        File source = new File(\"deqsim.log\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"deqsim.log\"));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move deqsim.log to its iteration directory.\");\n            }\n        }\n        int parallelCnt = 0;\n        source = new File(\"deqsim.log.\" + parallelCnt);\n        while (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"deqsim.log.\" + parallelCnt));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move deqsim.log.\" + parallelCnt + \" to its iteration directory.\");\n            }\n            parallelCnt++;\n            source = new File(\"deqsim.log.\" + parallelCnt);\n        }\n        source = new File(\"loads_out.txt\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"loads_out.txt\"));\n            try {\n                IOUtils.copyFile(source, destination);\n            } catch (FileNotFoundException e) {\n                log.info(\"WARNING: Could not copy loads_out.txt to its iteration directory.\");\n            } catch (IOException e) {\n                log.info(\"WARNING: Could not copy loads_out.txt to its iteration directory.\");\n            }\n            destination = new File(\"loads_in.txt\");\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move loads_out.txt to loads_in.txt.\");\n            }\n        }\n        source = new File(\"linkprocs.txt\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"linkprocs.txt\"));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move linkprocs.txt to its iteration directory.\");\n            }\n        }\n    }\n", "label": 1, "substitutes": {"jf": ["bf", "jfd", " jfs", "jjfd", "ojfd", "bc", "jrf", "jfile", "jjcf", "ojf", "bfile", "gf", "Jf", "ojfs", "gc", "gfile", "jcf", "jjf", "jfs", "ojcf", "Jrf", "jc", "grf", "Jfile", " jfd", " jcf", "jjfs", "Jc", "brf"], "fc": ["xf", "af", "dc", "rf", "bf", "uc", "lf", "cf", "vc", "fs", "con", " FC", "fp", "sf", "fd", "bc", "fr", "cv", "wic", "fe", "ec", "ctrl", "fw", "circ", "xc", "enc", "mc", "pc", "FC", "GF", "cl", "fn", "fl", "lc", "jc", "abc", "il", "CF", "c", "flo", "fb", "fm", "cc", "fi", "ct", "nc", "fa", "fx"], "returnVal": ["resultval", " returnValue", " returnval", "ReturnNum", "returnValue", "returnval", "returnNum", " returnNum", "ReturnVal", "ReturnValue", "resultValue", " returnTx", "openTx", "resultNum", "Returnval", "openVal", "openval", "ReturnTx", "openValue", "resultVal", "returnTx"], "file": ["cf", "l", "sf", "model", "directory", "resource", "info", "name", "log", "cl", " files", "le", "image", "files", "fa", "line", "folder", "bf", "place", "feed", "lf", "lib", "object", "b", "po", "future", "handler", "child", "it", "F", "found", "il", "pool", "cache", "c", "live", "local", "FILE", "self", "fi", "source", "page", "parent", "url", "pe", "function", "fo", "http", "fp", "base", "work", "el", "x", "filename", "full", "e", "o", "path", "null", "p", "h", "ile", "File", "letter", "fr", "fe", "where", "dir", "document", " File", "db", "form", "unit"], "KTH": ["NKTH", " KATH", "KITT", "JETH", " KAST", "KOTH", "JTH", "HKCOM", " KTh", " KCOM", " Kth", "KSTh", "SKCH", "KINGth", " KETH", "kATH", "KINGTH", "KTh", "kAST", "KSth", "KINGITT", "SKATH", " KITT", "HKITT", "KETH", "SKETH", " KOTH", " KTD", "KSOTH", "ELCOM", "HKTH", "AKth", "NKTD", "OKTh", "KCOM", "kTH", "SKAST", " KTHER", "SKTH", "SKTHER", "ELTH", "KATH", "AKETH", "NKth", "KTD", "AKTH", "KTHER", "Kth", "HKth", "OKTH", "OKth", "KAST", "NKETH", "Jth", "AKTD", "HKTh", "ELTh", "ELth", "kTHER", "KINGTh", "KCH", "KSTH", " KCH", "OKOTH", "JCH", "SKth"], "data": ["language", "resources", "div", "parent", "next", "reader", "site", "general", "default", "input", "memory", "user", "layout", "admin", "output", "join", "this", "state", "root", "model", "base", "loader", "di", "storage", "system", "style", "resource", "server", "config", "info", "writer", "module", "body", "DATA", "management", "da", "results", "json", "api", "internal", "media", "cache", "apps", "service", "database", "group", "design", "dat"], "_path": ["_dir", " _dir", " _cat", " _location", "_Path", "_location", " _Path", " _name", "_cat", "_name"], "f": ["af", "folder", "h", "rf", "url", "d", "feed", "cf", "function", "File", "fo", "l", "fs", "w", "foo", "fp", "b", "sf", "fd", "fr", "base", "fe", "n", "x", "fun", "name", "filename", "dir", "u", "e", "o", "flow", "fn", "t", "F", "found", "m", "df", "fold", "v", "fl", "path", "j", "c", "i", "fb", "g", "fen", "s", "fa", "p", "fx"]}}
{"id1": "20585148", "id2": "2021569", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"ftp.domain.com\");\n            client.login(\"admin\", \"secret\");\n            String filename = \"/testing/data.txt\";\n            boolean deleted = client.deleteFile(filename);\n            if (deleted) {\n                System.out.println(\"File deleted...\");\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public boolean getFile(String local, String remote) throws IOException {\n        boolean result = false;\n        GridFTP ftp = new GridFTP();\n        ftp.setDefaultPort(port);\n        System.out.println(this + \".getFile \" + remote);\n        try {\n            ftp.connect(host);\n            ftp.login(username, password);\n            int reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                System.err.println(\"FTP server refused connection.\");\n                return false;\n            }\n            ftp.get(local, remote);\n            ftp.logout();\n            result = true;\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        System.out.println(this + \".getFile return \" + result);\n        return result;\n    }\n", "label": 1, "substitutes": {"client": ["host", "get", "parent", "contract", "url", "web", "connection", "util", "cm", "plugin", "build", "open", "cf", "co", "cat", "conn", "grid", "http", "con", "out", "app", "request", "end", "cell", "console", "base", "cp", "class", "remote", "clean", "handler", "server", "call", "use", "pc", "x", "force", "project", "cl", "api", "google", "Client", "cli", "session", "close", "quit", "connect", "secure", "c", "file", "cache", "i", "command", "cloud", "and", "ssl", "socket", "friend", "ce", "proxy", "test", "p"], "filename": ["folder", "journal", "url", "SourceFile", "connection", "download", "dll", "username", "output", "fp", "fd", "login", "f", "application", "data", "directory", "summary", "Filename", "email", "kl", "ename", "name", "password", "fn", "content", "whatever", "kn", "ername", "string", "path", "il", "file", "uri", "title", "that", "files", "database", "FILE", "which", "metadata", "figure", "nil", "location", "fil"], "deleted": ["seplaced", "eselet", "dege", "delet", "disge", "duplaced", "deslete", "declet", "delete", "seleted", "declete", "disleted", "decge", "duleted", "deled", "deplaced", "decleted", "eselete", "desled", "selete", "eseleted", "dislet", "seled", "dulete", "esege", "dislete", "desplaced", "desleted", "duled"]}}
{"id1": "5671908", "id2": "10697587", "code1": "    private static String readGeoJSON(String feature) {\n        StringBuffer content = new StringBuffer();\n        try {\n            URL url = new URL(feature);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = rd.readLine()) != null) {\n                content.append(line);\n            }\n            conn.disconnect();\n        } catch (Exception e) {\n        }\n        return content.toString();\n    }\n", "code2": "    public static void copyFileNIO(File in, File out) throws IOException {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(in);\n            fos = new FileOutputStream(out);\n            FileChannel sourceChannel = fis.getChannel();\n            FileChannel targetChannel = fos.getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace(System.out);\n            }\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace(System.out);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"feature": ["source", "route", "id", "browser", "feed", "range", "edge", "format", "Features", "license", "request", "bug", "fr", "model", "layer", "base", "cover", "resource", "config", "info", "address", "filename", "name", "query", "feat", "report", " Feature", "family", "frame", "image", "document", "features", "uri", "error", "file", "grain", "attribute", "service", "Feature", "figure", "project", "concept", "type"], "content": ["default", "connection", "feed", "buffer", "xml", "Content", "result", "car", "core", "message", "output", "format", "object", "client", "column", "const", "layer", "loader", "data", "cover", "response", "clean", "resource", "server", "address", "config", "work", "ontent", "writer", "section", "word", "body", "event", "report", "cont", "json", "container", "comment", "job", "string", "document", "node", "load", "cache", "file", "code", "array", "header", "value"], "url": ["page", "nl", "link", "web", "connection", "feed", "pull", "build", "l", "http", "b", "lr", "fr", "base", "f", "layer", "r", "resource", "aur", "server", "org", "config", "update", "ur", "rc", "log", "bel", "sl", "fl", "rl", "c", "file", "ssl", "uri", "URL", "Url", "www", "blog", "gl", "str", "coll", "ll"], "conn": ["contract", "cb", "connection", "auth", "not", "cm", "open", "cf", "core", "ct", "http", "con", "client", "cmd", "fd", "Conn", "fr", "loc", "loader", "rn", "cp", "n", "enc", "ctx", "org", "ai", "cn", "pc", "conf", "exec", "sync", "ci", "rc", "nt", "act", "coll", "Connect", "ch", "cli", "lc", "ann", "close", "col", "cr", "connect", "c", "ssl", "db", "rt", "err", "conv", "cc", "Connection", "ca", "nc", "cmp"], "rd": ["reader", "dc", "cd", "ra", "rx", "d", "Reader", "ded", "dig", "dd", "ld", "xd", "ro", "vd", "pd", "td", "wd", "ird", "fd", "lr", "fr", "rn", "bd", "r", "rer", "rc", "erd", "rm", "rs", "rod", "rh", "dr", "hr", "ri", "cr", "rl", "rt", "rr", "ds", "nd", "dra", "rb", "rest", "RD"], "line": ["page", "reader", "continue", "value", "link", "pe", "connection", "feed", "lf", "lines", "message", "l", "letter", "one", "object", "char", "val", "column", "cell", "LINE", "Line", "part", "row", "end", "data", "response", "raw", "el", "word", "name", "ge", "e", "unit", "cl", "text", "comment", "lc", "key", "le", "string", "point", "file", "record", "code", "err", "header", "character", "block", "lin", "str", "sl", "entry"]}}
{"id1": "21044331", "id2": "22854233", "code1": "    private static byte[] getKey(String password) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest messageDigest = MessageDigest.getInstance(Constants.HASH_FUNCTION);\n        messageDigest.update(password.getBytes(Constants.ENCODING));\n        byte[] hashValue = messageDigest.digest();\n        int keyLengthInbytes = Constants.ENCRYPTION_KEY_LENGTH / 8;\n        byte[] result = new byte[keyLengthInbytes];\n        System.arraycopy(hashValue, 0, result, 0, keyLengthInbytes);\n        return result;\n    }\n", "code2": "    public String getMd5() {\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(string.getBytes());\n            byte[] result = md5.digest();\n            for (int i = 0; i < result.length; i++) {\n                hexString.append(Integer.toHexString((result[i] & 0xFF) | 0x100).toLowerCase().substring(1, 3));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"password": ["hash", "input", "token", "auth", "sword", "username", "message", "wd", "PASS", "number", "data", "phrase", "prefix", "address", "KEY", "word", "name", " passwords", "pattern", "text", "words", "key", "string", "path", "seed", "code", "attribute", "secret", "Password", "crypt", "account", "wallet", "value", "padding", "p", "pass"], "messageDigest": ["MessageDigest", "messageDesignested", "messagediger", " messageDester", "profileDigest", "messageModgest", "profiledigest", " messageDigEST", "messageDest", "messageModEST", "profileDigEST", "messageSignester", "messageHashester", "messageDigester", " messageDest", "messageDener", "profileDiggest", "profiledigester", "messageDigEST", "messageMixer", "messageDesignester", "messageHashest", "messageSignest", "messageDigener", "messageSignener", "messagedigEST", "messageHashener", "MessageDesigner", "messageDesigner", "profilediggest", "messageSignEST", "messageDigested", "messageHashEST", "messagedigested", "MessageDigested", "messageDesignest", "messageMixested", "messageMixest", "messageDEST", "messageDgest", "messageDester", "messagedigester", "messagedigest", "MessageDesignested", " messageDigester", " messageDener", "messageModest", "MessageDigester", "profileDigester", "MessageDiger", " messageDEST", "messageMixester", " messageDigener", "MessageDesignester", "messageModester", "messageDiger", "messagediggest", "profiledigEST", "MessageDesignest", "messageDiggest"], "hashValue": ["keyKey", "sumValue", " hashVal", "keyBuffer", "hashKey", "ashKey", "hashVal", "keyValue", " hashKey", "ashData", "ashVal", "hashBuffer", "keyVal", "hashData", "sumKey", "keyData", " hashBuffer", "ashValue", " hashData", "sumVal", "sumBuffer"], "keyLengthInbytes": ["keyLenincompatible", "keyLeninbytes", "keyLengthinbytes", "keyLengthIncompatible", "keyLengthINbytes", "keyLengthINcompatible", "keyLenInbytes", "keyLenInbits", "keyLengthinbits", "keyLengthInBytes", "keyLeninbits", "keyLengthincompatible", "keyLengthInbits", "keyLenInBytes", "keyLengthINbits", "keyLengthINBytes", "keyLengthinBytes", "keyLenIncompatible", "keyLeninBytes"], "result": ["source", "parent", "hash", "default", "success", "buffer", "Result", "message", "output", "card", "diff", "root", "pack", "table", "data", "response", "match", "resource", "master", "round", "feature", "ret", "address", "pair", "word", "results", "length", "transform", "found", "comment", "key", "list", "lock", "cache", "replace", "pass", "mask", "array", "secret", "valid", "dist", "test", "value", "entry"]}}
{"id1": "19999376", "id2": "15193222", "code1": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "code2": "    @Override\n    public void copy(final String fileName) throws FileIOException {\n        try {\n            if (opened) {\n                fileChannel.position(0);\n            } else {\n                fileChannel = new FileInputStream(file).getChannel();\n            }\n            FileChannel dstChannel = null;\n            try {\n                dstChannel = new FileOutputStream(fileName).getChannel();\n                dstChannel.transferFrom(fileChannel, 0, fileChannel.size());\n            } finally {\n                try {\n                    if (dstChannel != null) {\n                        dstChannel.close();\n                    }\n                } catch (Exception exception) {\n                }\n            }\n            if (opened) {\n                fileChannel.position(currentPositionInFile);\n            } else {\n                fileChannel.close();\n            }\n        } catch (IOException exception) {\n            throw HELPER_FILE_UTIL.fileIOException(\"failed copy \" + file + \" to \" + fileName, null, exception);\n        }\n    }\n", "label": 1, "substitutes": {"zipfile": ["zipFile", "zFile", "Zipdir", "zfile", "clipfile", "zentry", "zipfiles", "clipfiles", "zipdir", "gzdir", "Zipfiles", " zipfiles", "zipentry", "Zipfile", "clipFile", "Zipstream", "clipstream", "gzFile", "Zipentry", "gzentry", " zipstream", " zipFile", "zdir", "ZipFile", "gzfile", "zipstream"], "entry": ["next", "source", "folder", "route", "reader", "draft", "id", "export", "input", "link", "queue", "si", "line", "connection", "feed", "xml", "plugin", "ry", "audio", "lock", "in", "object", "cell", "ries", "base", "data", "directory", "zip", "system", "her", "archive", "server", "address", "info", "inner", "element", "module", "name", "dir", "it", "e", "country", "nt", "container", "log", "cel", "parser", "api", "enter", "comment", "se", "session", "path", "image", "cache", "install", "file", "record", "uri", "error", "or", "parse", "Entry", "service", "sea", "add", "ie"], "outputDir": ["inputFolder", " outputDIR", "outFile", " outputdir", "writeDIR", "inputdir", "inputDIR", "writeFolder", "outDir", "outDirectory", "exitDIR", "outputFolder", "exitDir", "outDIR", "outputDirectory", "outputDIR", "writeDir", "writeDirectory", "outFolder", "targetFolder", "exitdir", " outputDirectory", "targetFile", "inputDirectory", "targetDirectory", "outputdir", "targetDir", "inputDir", "exitDirectory", "inputFile"], "outputFile": [" outputfile", "inputfile", "inputFolder", "outFile", "inputPath", " outputPath", "outLine", "inputLine", "OutputPath", "outDir", "outDirectory", "outputLine", "outputFolder", "inputJar", "outputDirectory", " outputFolder", "responseFile", "OutputDir", "outputJar", " outputLine", " outputDirectory", "OutputFile", "responsefile", "inputDirectory", "outStream", "responseFolder", "responseDir", " outputJar", "inputDir", "outputPath", "OutputJar", "inputFile", "outputfile"], "inputStream": [" inputReader", "outputSteam", " inputChannel", "inputSteam", "InputStream", " inputView", " inputSteam", " inputFile", "inputReader", "InputView", "inputView", "outputReader", "outputChannel", "inputChannel", "InputFile", "InputChannel", "outputView", "InputSteam", "InputReader", "inputFile"], "outputStream": ["outputSteam", "inputSteam", "OutputSteam", "execStream", " outputChannel", "OutputStream", "execFile", "inputStreamer", "outputChannel", "inputChannel", " outputSteam", "OutputFile", "OutputStreamer", "execStreamer", "OutputChannel", "inputFile", "outputStreamer", "execSteam"]}}
{"id1": "17847880", "id2": "518901", "code1": "    public static boolean saveToTempFile(Context context, String filePath, DirType dirType, String tempSavePath, boolean secrete) {\n        FileOutputStream fos = null;\n        InputStream in = null;\n        byte[] buffer = new byte[1024];\n        int readLength = 0;\n        boolean result = false;\n        try {\n            try {\n                File f = new File(context.getFilesDir().getAbsolutePath() + File.separator + tempSavePath);\n                if (f.exists()) {\n                    context.deleteFile(tempSavePath);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            fos = context.openFileOutput(tempSavePath, Context.MODE_WORLD_READABLE);\n            logger.error(\"tempfile:\" + tempSavePath);\n            if (dirType == DirType.assets) {\n                AssetManager assetManager = context.getAssets();\n                in = assetManager.open(filePath);\n            } else if (dirType == DirType.file && Constant.getUpdateDataPath() != null) {\n                in = new FileInputStream(Constant.getUpdateDataPath() + File.separator + filePath);\n            } else if (dirType == DirType.sd && Constant.getSdPath() != null) {\n                in = new FileInputStream(Constant.getSdPath() + File.separator + filePath);\n            } else if (dirType == DirType.extSd && Constant.getExtSdPath() != null) {\n                in = new FileInputStream(Constant.getExtSdPath() + File.separator + filePath);\n            }\n            if (in == null) {\n                return false;\n            }\n            readLength = in.read(buffer);\n            if (readLength >= ZipToFile.encrypLength && secrete) {\n                byte[] encrypByte = new byte[ZipToFile.encrypLength];\n                System.arraycopy(buffer, 0, encrypByte, 0, ZipToFile.encrypLength);\n                byte[] temp = CryptionControl.getInstance().decryptECB(encrypByte, ZipToFile.rootKey);\n                System.arraycopy(temp, 0, buffer, 0, ZipToFile.encrypLength);\n            }\n            while (readLength > 0) {\n                fos.write(buffer, 0, readLength);\n                fos.flush();\n                readLength = in.read(buffer);\n            }\n            result = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (fos != null) {\n                try {\n                    fos.flush();\n                    fos.close();\n                } catch (Exception e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public void fetchFile(String ID) {\n        String url = \"http://www.nal.usda.gov/cgi-bin/agricola-ind?bib=\" + ID + \"&conf=010000++++++++++++++&screen=MA\";\n        System.out.println(url);\n        try {\n            PrintWriter pw = new PrintWriter(new FileWriter(\"MARC\" + ID + \".txt\"));\n            if (!id.contains(\"MARC\" + ID + \".txt\")) {\n                id.add(\"MARC\" + ID + \".txt\");\n            }\n            in = new BufferedReader(new InputStreamReader((new URL(url)).openStream()));\n            in.readLine();\n            String inputLine, stx = \"\";\n            StringBuffer sb = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.startsWith(\"<TR><TD><B>\")) {\n                    String sts = (inputLine.substring(inputLine.indexOf(\"B>\") + 2, inputLine.indexOf(\"</\")));\n                    int i = 0;\n                    try {\n                        i = Integer.parseInt(sts);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    if (i > 0) {\n                        stx = stx + \"\\n\" + sts + \" - \";\n                    } else {\n                        stx += sts;\n                    }\n                }\n                if (!(inputLine.startsWith(\"<\") || inputLine.startsWith(\" <\") || inputLine.startsWith(\">\"))) {\n                    String tx = inputLine.trim();\n                    stx += tx;\n                }\n            }\n            pw.println(stx);\n            pw.close();\n        } catch (Exception e) {\n            System.out.println(\"Couldn't open stream\");\n            System.out.println(e);\n        }\n    }\n", "label": 0, "substitutes": {"context": ["options", "source", "folder", "parent", "foundation", "reader", "translation", "input", "queue", "connection", "cf", "settings", "function", "view", "cas", "request", "client", "driver", "bc", "environment", "base", "application", "loader", "version", "stream", "storage", "system", "ctx", "resource", "contact", "config", "tx", "component", "event", "rc", "container", "tc", "kernel", "instance", "text", "path", "document", "cache", "c", "command", "support", "Context", "manager", "service", "database", "current", "ce", "self", "cms", "project", "stack", "concept"], "filePath": ["fileStream", "inputPath", "inputId", "linepath", "basePath", "FilePath", " fileStream", "modelBody", "FILEBody", " fileName", "filepath", " fileType", "singleLocation", "fileType", "saveLocation", " filepath", "lineLoc", "FileId", "fileCh", "fileName", "FILEType", "FileType", " fileLoc", "FILELoc", "singleStream", "singlePath", "modelpath", "savePath", "modelCh", "fileLoc", "fileBody", "basepath", "fileId", "baseBody", "saveStream", "linePath", "resourceName", " fileLocation", "resourceType", "FileName", "FILEpath", "FILEPath", "FILECh", "Filepath", "lineType", "savepath", "FileStream", "resourcePath", "fileLocation", "inputpath", "resourcepath", "modelPath", "baseCh", "singlepath", "inputStream", " fileId"], "dirType": ["fileStyle", "entryTypes", "entryType", "directoryTypes", "dirtype", "libTyp", " dirBase", "directoryTyp", "DIRPath", "directorytype", "directorType", "fileBase", "fileType", "directortype", "dirTitle", "DirTitle", "libType", "fileTyp", "directorTitle", "directoryStyle", "libtype", "DirType", "directionTyp", "DIRStyle", "dirTypes", " dirTypes", "dirTyp", " dirTyp", "dirPath", "Dirtype", "entryTyp", "directoryPath", " dirStyle", "DirPath", "directoryTYPE", "directionType", "DirTyp", "directorTyp", "dirBase", "dirTYPE", "DIRType", " dirTYPE", "fileTYPE", "libTitle", "DirStyle", "DIRtype", "fileTypes", "directionStyle", "entryTYPE", "directionBase", "directoryType", "dirStyle"], "tempSavePath": ["TempFileDir", "tempStorePart", "TempSaveDir", "tempSetDir", "tempSetpath", "tempSetPath", "fakeStoreType", "tempSaveLocation", "currentsavePoint", "TempSaveLocation", "tempFilePath", "tempStoreHome", "tempsaveCase", "currentsaveCase", " tempSetDir", "TempSavePoint", "tempFileFile", "fakeSavePath", "currentSaveFile", "TempFilePath", "tempSaveType", "tempStoreType", "TempSaveUrl", "tempSaveHome", "currentSavePath", "tempSaveCase", "tempCopyPoint", "tempFileCase", "fakeSaveHome", "tempApplyCase", "tempImportUrl", "tempApplyPoint", "currentsaveFile", "tempWriteLocation", "tempCopyLocation", "tempClosePath", "tempApplyFile", "tempSaveName", "tempsaveFile", "tempCloseHome", "tempWritePath", "tempFileLocation", "tempFileDir", "TempFilePoint", "tempCreatepath", "tempWritePoint", "tempStorePath", "fakeSavePart", "tempImportType", "tempCopyUrl", "tempCopyPath", "tempSaveFile", "fakeStorePart", "tempSaveUrl", "TempFileLocation", "tempSavePoint", "tempCloseType", "tempFilePoint", " tempSaveDir", "tempApplyPath", "tempFileUrl", "tempsavePath", " tempSetpath", "tempImportPath", " tempSetPath", " tempSetName", "TempFileUrl", "tempsavePoint", "tempImportPoint", " tempSaveName", "tempSavePart", "tempSavepath", " tempSavepath", "tempImportHome", "tempCreateName", "tempClosePart", "tempCreatePath", "currentsavePath", "tempImportpath", "tempImportName", "tempSetName", "fakeSaveType", "tempWriteDir", "fakeStoreHome", "tempImportDir", "TempSavePath", "currentSavePoint", "tempImportLocation", "fakeStorePath", "tempImportPart", "tempCreateDir", "tempSaveDir", "currentSaveCase"], "secrete": ["sicrete", "secstract", "discrete", "siccrete", "secourage", "SECcrete", "SECurate", "discourage", "sicstract", "SECstract", "seccrete", "disccrete", "sicourage", "securitystract", "sicuous", "secidental", "SECidental", "securityrete", "discurate", "secuous", "sicidental", "securate", "sicurate", "SECourage", "securityuous", "SECuous", "SECrete", "securityidental"], "fos": ["sfos", "Fops", "infOS", " fops", " fOS", "Fos", "fops", "infos", "fios", "sfis", " fis", " fios", " faos", "Faos", "Fis", "FOS", "fOS", "faos", "sfios", "fis", "infios", "Fios", "sfops", "infaos"], "in": ["source", "get", "read", "reader", "url", "input", "inc", "din", "binary", "token", "connection", "with", "min", "io", "nin", "conn", "con", "out", "this", "b", "diff", "part", "login", "as", "data", "In", "pin", "again", "include", "into", "re", "thin", "resource", "serv", "config", "isin", "exec", "init", "ins", "vin", "cl", "gin", "ini", "m", "cli", "session", "cin", "image", "impl", "socket", "ssl", "file", "i", "IN", "err", "or", "inn", "ar", "lin", "bin", "ac"], "buffer": ["source", "read", "reader", "url", "queue", "memory", "binary", "input", "reference", "buff", "iter", "Buffer", "message", "output", "limit", "audio", "request", "b", "bc", "base", "data", "table", "phrase", "bytes", "response", "available", "resource", "server", "address", "writer", "info", "uffer", "transfer", "batch", "length", "flush", "text", "wave", "initial", "buf", "offset", "slice", "document", "seed", "cache", "header", "block", "texture", "position", "bin", "stack", "copy"], "readLength": ["writeDuration", "loadlength", "writePath", "loadWidth", "readLen", "ReadDuration", "Readlength", " readDuration", "readWidth", "ReadLength", "writeLength", " readWidth", "loadLength", "loadLen", "readDuration", "writeWidth", "ReadPath", "readlength", " readLen", " readPath", "readPath", "writelength", " readlength", "writeLen"], "f": ["af", "folder", "h", "rf", "feed", "cf", "function", "io", "fo", "l", "fc", "fs", "w", "fp", "b", "sf", "fd", "fr", "fe", "n", "fac", "handler", "info", "conf", "aff", "e", "fn", "F", "m", "df", "v", "j", "c", "file", "i", "raf", "g", "fm", "fed", "s", "fa", "p", "fx"], "assetManager": ["assAssetManager", "assAssetmanager", "AssetsManagement", "assetteDirector", "AssetsManager", "AssetMan", "assetMan", "AssetsDirector", "asseticMan", "assetManagement", "assetteManager", "assAssetDirector", "asseticDirector", "assAssetManagement", "assetteManagement", "assettemanager", "Assetmanager", "AssetDirector", "AssetManager", "assetsmanager", "assetsDirector", "AssetManagement", "assetmanager", "assetsMan", "Assetsmanager", "assetsManager", "assetsManagement", "AssetsMan", "assetDirector", "assAssetMan", "asseticManager", "asseticmanager"], "encrypByte": ["encrybChar", "encryfByte", "encriperChar", "encrybByte", "encripBit", "encrypeBit", "encryfBytes", "encrypeByte", "encrifBit", "encrifBytes", "encrifByte", "encrypeChar", "encrypeWord", "enccypByte", "enccyperByte", "encriperBit", "encryfBit", "encripChar", "enccypBytes", "enccyperChar", "enccypChar", "encripBytes", "encrifWord", "encriperByte", "encrypaByte", "enccypWord", "encryperChar", "encryperBytes", "encrypChar", "encrypeBytes", "encrybWord", "encrypBit", "encrypaBit", "encripByte", "encripWord", "encryperBit", "encrypBytes", "encrybBit", "encriperWord", "encrypWord", "encryperByte", "encryperWord", "encryfChar", "enccyperBytes", "encrypaWord", "encryfWord", "enccyperWord", "encrypaChar"], "temp": ["get", "div", "tmp", "export", "txt", "safe", "porary", "iter", "extra", "flat", "pre", "fake", "stable", "pack", "ctrl", "hex", "tem", "storage", "clean", "enc", "wrap", "Temp", "init", "full", "cel", "tc", "api", "partial", "ex", "lc", "col", "cache", "emp", "local", "wait", "unsigned", "current", "img", "empty", "test", "mini"], "result": ["successful", "default", "success", "Result", "complete", "expected", "output", "out", "include", "data", "response", "r", "match", "resource", "ret", "full", "results", "rc", "found", "content", "status", "lock", "load", "accept", "res", "exit"]}}
{"id1": "14164924", "id2": "2226035", "code1": "    @Override\n    public void copy(File source, File dest) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = (new FileInputStream(source)).getChannel();\n            out = (new FileOutputStream(dest)).getChannel();\n            in.transferTo(0, source.length(), out);\n        } catch (FileNotFoundException e) {\n            throw new IOException(\"Wrong source or destination path for backup operation!\");\n        } finally {\n            if (out != null) {\n                out.close();\n            }\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    public boolean performOk() {\n        this.setPropertyValue(\"bea.home\", this.beaHome.getText());\n        this.setPropertyValue(\"bea.domain\", this.domainDirectory.getText());\n        Display.getDefault().syncExec(new Runnable() {\n\n            public void run() {\n                saveWLHome();\n                for (final TabControl control : tabControls) {\n                    control.performOk(WLPropertyPage.this.getProject(), WLPropertyPage.this);\n                }\n                if (isEnabledJCLCopy()) {\n                    final File url = new File(WLPropertyPage.this.domainDirectory.getText());\n                    File lib = new File(url, \"lib\");\n                    File log4jLibrary = new File(lib, \"log4j-1.2.13.jar\");\n                    if (!log4jLibrary.exists()) {\n                        InputStream srcFile = null;\n                        FileOutputStream fos = null;\n                        try {\n                            srcFile = toInputStream(new Path(\"jcl/log4j-1.2.13.jar\"));\n                            fos = new FileOutputStream(log4jLibrary);\n                            IOUtils.copy(srcFile, fos);\n                            srcFile.close();\n                            fos.flush();\n                            fos.close();\n                            srcFile = toInputStream(new Path(\"/jcl/commons-logging-1.0.4.jar\"));\n                            File jcl = new File(lib, \"commons-logging-1.0.4.jar\");\n                            fos = new FileOutputStream(jcl);\n                            IOUtils.copy(srcFile, fos);\n                        } catch (IOException e) {\n                            Logger.log(Logger.ERROR, \"Could not copy JCL jars file to Bea WL\", e);\n                        } finally {\n                            try {\n                                if (srcFile != null) {\n                                    srcFile.close();\n                                    srcFile = null;\n                                }\n                                if (fos != null) {\n                                    fos.flush();\n                                    fos.close();\n                                    fos = null;\n                                }\n                            } catch (IOException e) {\n                            }\n                        }\n                    }\n                }\n                if (isEnabledJSTLCopy()) {\n                    File url = new File(WLPropertyPage.this.domainDirectory.getText());\n                    File lib = new File(url, \"lib\");\n                    File jstlLibrary = new File(lib, \"jstl.jar\");\n                    if (!jstlLibrary.exists()) {\n                        InputStream srcFile = null;\n                        FileOutputStream fos = null;\n                        try {\n                            srcFile = toInputStream(new Path(\"jstl/jstl.jar\"));\n                            fos = new FileOutputStream(jstlLibrary);\n                            IOUtils.copy(srcFile, fos);\n                        } catch (IOException e) {\n                            Logger.log(Logger.ERROR, \"Could not copy the JSTL 1.1 jar file to Bea WL\", e);\n                        } finally {\n                            try {\n                                if (srcFile != null) {\n                                    srcFile.close();\n                                    srcFile = null;\n                                }\n                                if (fos != null) {\n                                    fos.flush();\n                                    fos.close();\n                                    fos = null;\n                                }\n                            } catch (final IOException e) {\n                                Logger.getLog().debug(\"I/O exception closing resources\", e);\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return super.performOk();\n    }\n", "label": 1, "substitutes": {"source": ["parent", "reader", "site", "route", "url", "input", "id", "size", "connection", "reference", "iter", "origin", "src", "from", "object", "Source", "client", "base", "directory", "stream", "remote", "class", "storage", "resource", "server", "archive", "config", "inner", "ources", "sequence", "sync", "name", "filename", "target", "ource", " sources", "temp", "back", "sin", "SOURCE", "slice", "string", "path", "image", "before", "file", "uri", "service", "current", "ce", "start", "proxy", "project", "copy", "use", "type"], "dest": ["folder", "route", "die", "tmp", "later", "default", "txt", "dep", "result", "down", "pipe", "src", "home", " destination", "delete", "config", "name", "desc", "dir", "target", "de", "Dest", "temp", "done", "orig", "file", "comb", "wb", "coord", "opt", "dist", "img", "destroy", "bin", "test", "exit"], "in": ["plus", "parent", "reader", "id", "url", "input", "inc", "din", "win", "pull", "min", "io", "nin", "conn", "src", "one", "con", "b", "this", "login", "channel", "f", "as", "data", "In", "pin", "again", "n", "r", "thin", "work", "isin", "inner", "info", "pc", "x", "sync", "name", "init", "it", "ins", "o", "gin", "a", "m", "up", "slice", "image", "cin", "lock", "socket", "c", "file", "i", "IN", "err", "or", "inside", "inn", "rin", "bin", "proxy", "s", "ac", "pass"], "out": ["parent", "inc", "write", "user", "net", "connection", "extra", "io", "output", "conn", "nin", "outer", "w", "lib", "b", "client", "this", "object", "ou", "part", "channel", "f", "no", "In", "OUT", "Out", "n", "again", "outs", "server", "call", "external", "writer", "off", "x", "sync", "name", "init", "o", "target", "exp", "ext", "ex", "temp", "up", "all", "image", "cache", "c", "socket", "file", "i", "err", "obj", "or", "at", "outside", "bin", "copy", "null", "pass"]}}
{"id1": "2972950", "id2": "14196271", "code1": "    private void proxyMediaServlet(String url, HttpServletRequest req, HttpServletResponse resp) {\n        try {\n            URL u = new URL(\"http://mediaserver:8080/sagex\" + url);\n            log.debug(\"Proxy Media: \" + u.toString());\n            URLConnection c = u.openConnection();\n            c.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.1) Gecko/2008072820 Firefox/3.0.1\");\n            OutputStream os = resp.getOutputStream();\n            IOUtils.copy(c.getInputStream(), os);\n            os.flush();\n            resp.flushBuffer();\n        } catch (Throwable t) {\n            log.error(\"Failed to get url: \" + url, t);\n            try {\n                resp.sendError(500, t.getMessage());\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private synchronized File zipTempFile(File tempFile) throws BlogunityException {\n        try {\n            File zippedFile = new File(BlogunityManager.getSystemConfiguration().getTempDir(), tempFile.getName() + \".zip\");\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zippedFile));\n            byte[] readBuffer = new byte[2156];\n            int bytesIn = 0;\n            FileInputStream fis = new FileInputStream(tempFile);\n            ZipEntry anEntry = new ZipEntry(tempFile.getName());\n            zos.putNextEntry(anEntry);\n            while ((bytesIn = fis.read(readBuffer)) != -1) {\n                zos.write(readBuffer, 0, bytesIn);\n            }\n            fis.close();\n            zos.close();\n            return zippedFile;\n        } catch (Exception e) {\n            throw new BlogunityException(I18NStatusFactory.create(I18N.ERRORS.FEED_ZIP_FAILED, e));\n        }\n    }\n", "label": 1, "substitutes": {"url": ["source", "host", "page", "route", "id", "connection", "rel", "ll", "src", "l", "http", "request", "fr", "loc", "base", "f", "href", "ref", "remote", "zip", "resource", "org", "server", "address", "el", "name", "ur", "gl", "location", "ls", "string", "media", "path", "image", "rl", "rule", "html", "uri", "ssl", "file", "URL", "service", "Url", "proxy", "web", "sl"], "req": ["cb", "proc", "rx", "ro", "cgi", "conn", "src", "w", "request", "b", "fr", "ref", "re", "r", "ctx", "Request", "conf", "query", "requ", "Requ", "rec", "quest", "obj", "err", "rr", "q", "res", "rb"], "resp": ["page", "respond", "rel", "rep", "reply", "result", "conn", "http", "out", "request", "client", "ref", "re", "response", "r", "ctx", "zip", "server", "ret", "serv", "esi", "body", "e", "report", "cl", "api", "df", "esp", "rec", "Response", "v", "respons", "pool", "sp", "obj", "rev", "cache", "html", "err", "wb", "Resp", "prev", "pp", "rr", "inv", "res", "cmp", "p"], "u": ["su", "ru", "uc", "util", "cu", "iu", "l", "ul", "uu", "http", "this", "fp", "b", "ue", "ou", "client", "f", "n", "mu", "tu", "U", "yu", "hu", "ur", "ui", "o", "t", "m", "nu", "up", "chu", "lu", "ut", "uri", "uv", "i", "us", "eu", "bu", "p"], "c": ["h", "dc", "d", "uc", "cm", "cu", "cy", "cf", "co", "conn", "l", "ct", "fc", "con", "w", "client", "b", "bc", "f", "p", "ec", "cp", "enc", "xc", "mc", "pc", "exec", "cn", "ci", "e", "o", "cl", "t", "cs", "ch", "cli", "lc", "v", "cr", "i", "cc", "z", "cmp", "ac", "C"], "os": ["los", "ys", "ks", "des", "ies", "ss", "io", "conn", "fs", "http", "out", "OS", "bos", "as", "oc", "oa", "bs", "outs", "ens", "es", "dos", "ors", "vs", "oss", "oos", "o", "e", "aos", "s", "cs", "rs", "ls", "Os", "nos", "ios", "ops", "i", "us", "ds", "cos", "is", "osi", "ps", "res"]}}
{"id1": "22075658", "id2": "22328844", "code1": "    public static InputStream getResponse(String pURL, String pUserName, String pPassword, OutputStream pResponseOutputStream, String pHttpMethodType) throws Exception {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        URL url = new URL(pURL);\n        int port = url.getPort();\n        if (-1 == port) {\n            port = url.getDefaultPort();\n        }\n        if (url.getProtocol().equals(HTTPS_PROTOCOL)) {\n            Protocol httpsProtocol = new Protocol(HTTPS_PROTOCOL, new EasySSLProtocolSocketFactory(), port);\n            Protocol.registerProtocol(HTTPS_PROTOCOL, httpsProtocol);\n        }\n        HttpClient httpClient = new HttpClient();\n        httpClient.getParams().setParameter(\"http.socket.timeout\", HTTP_SOCKET_TIMEOUT);\n        HttpMethod httpMethod = getHttpMethod(pHttpMethodType, pURL);\n        if (null != pUserName && null != pPassword) {\n            httpClient.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(pUserName, pPassword));\n        }\n        try {\n            httpClient.executeMethod(httpMethod);\n            if (null != pResponseOutputStream) {\n                IOUtils.copy(httpMethod.getResponseBodyAsStream(), pResponseOutputStream);\n            }\n            return httpMethod.getResponseBodyAsStream();\n        } catch (Exception e) {\n            throw (e);\n        } finally {\n            httpMethod.releaseConnection();\n        }\n    }\n", "code2": "    protected void doBackupOrganize() throws Exception {\n        Connection con = null;\n        PreparedStatement ps = null;\n        ResultSet result = null;\n        String strSelQuery = \"SELECT organize_id,organize_type_id,organize_name,organize_manager,\" + \"organize_describe,work_type,show_order,position_x,position_y \" + \"FROM \" + Common.ORGANIZE_TABLE;\n        String strInsQuery = \"INSERT INTO \" + Common.ORGANIZE_B_TABLE + \" \" + \"(version_no,organize_id,organize_type_id,organize_name,organize_manager,\" + \"organize_describe,work_type,show_order,position_x,position_y) \" + \"VALUES (?,?,?,?,?,?,?,?,?,?)\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            try {\n                con = dbo.getConnection();\n                con.setAutoCommit(false);\n                ps = con.prepareStatement(strSelQuery);\n                result = ps.executeQuery();\n                ps = con.prepareStatement(strInsQuery);\n                while (result.next()) {\n                    ps.setInt(1, this.versionNO);\n                    ps.setString(2, result.getString(\"organize_id\"));\n                    ps.setString(3, result.getString(\"organize_type_id\"));\n                    ps.setString(4, result.getString(\"organize_name\"));\n                    ps.setString(5, result.getString(\"organize_manager\"));\n                    ps.setString(6, result.getString(\"organize_describe\"));\n                    ps.setString(7, result.getString(\"work_type\"));\n                    ps.setInt(8, result.getInt(\"show_order\"));\n                    ps.setInt(9, result.getInt(\"position_x\"));\n                    ps.setInt(10, result.getInt(\"position_y\"));\n                    int resultCount = ps.executeUpdate();\n                    if (resultCount != 1) {\n                        con.rollback();\n                        throw new CesSystemException(\"Organize_backup.doBackupOrganize(): ERROR Inserting data \" + \"in T_SYS_ORGANIZE_B INSERT !! resultCount = \" + resultCount);\n                    }\n                }\n                con.commit();\n            } catch (SQLException se) {\n                con.rollback();\n                throw new CesSystemException(\"Organize_backup.doBackupOrganize(): SQLException:  \" + se);\n            } finally {\n                con.setAutoCommit(true);\n                close(dbo, ps, result);\n            }\n        } catch (SQLException se) {\n            throw new CesSystemException(\"Organize_backup.doBackupOrganize(): SQLException while committing or rollback\");\n        }\n    }\n", "label": 0, "substitutes": {"pURL": [" pUrl", "pcURL", "paUrl", " pIP", "pIP", "nURL", "pStream", "paURI", "nUrl", "nURI", " pLocation", "pcURI", "PIP", "pcUrl", "PURL", "pLocation", "PURI", "nLocation", "paURL", "pcStream", "PUrl", "PStream", "paIP", "PLocation", "pUrl", " pURI", " pStream", "pURI"], "pUserName": ["pDeviceInfo", " pUserInfo", "pLoginName", " pFullInfo", "pUserInfo", "pTeamAddress", "pDeviceAddress", "pFullAddress", "pLoginKey", "pLongHalf", "eUSERNumber", "primaryUserCry", "pTeamNAME", "pUsername", "eUSERName", "primaryUserName", "primaryUSERCry", "pUSERKey", "pUSERCry", "eUserNumber", "pUserKey", "eUSERname", "pTeamName", "primaryUSERKey", "pFullName", "pFullInfo", " pUserAddress", "primaryUserKey", "pUserCry", "pApplicationname", "pUserNumber", "pUserAddress", "pStringName", "pFullNAME", "pLoginHalf", " pUserNAME", "pUserNAME", "pTeamInfo", "pUSERName", "eUsername", "pLongName", "pUSERNumber", "pDeviceName", "pUSERname", "primaryUSERHalf", "pDeviceNAME", "pStringNumber", "primaryUSERName", " pFullAddress", "pApplicationName", "pApplicationNumber", "pUSERHalf", "primaryUserHalf", " pFullName", " pFullNAME", "pLongKey", "pUserHalf", "eUserName", "pLoginCry", "pStringname", "pLongCry"], "pPassword": ["PLogin", "Ppassword", "pEmail", "paPass", "sLogin", "ppassword", "pPass", "PPass", "PEmail", "sPassword", "paSecret", "PPassword", "paPASS", "pPASS", " pPass", "PSecret", "spassword", " pLogin", "sPass", "pLogin", " pSecret", "tpEmail", " ppassword", "paPassword", "pSecret", "tpPass", " pPASS", "PPASS", "tpSecret", " pEmail", "tpPassword"], "pResponseOutputStream": ["pResponseInputView", "pResponseWriteForm", "pResponseInputstream", "pResponseApplicationstream", "pResponseBodystream", "pResponseBodyStream", "pResponseWriteView", "pResponseInputForm", "pRequestInputSteam", "pResponseOutputForm", "pResponseApplicationStream", "pResponseInputSteam", "pRequestInputView", "pResponseOutputSteam", "pRequestOutputSteam", "pRequestInputstream", "pRequestOutputstream", "pRequestOutputView", "pRequestInputStream", "pResponseWriteStream", "pResponseInputStream", "pRequestBodySteam", "pResponseApplicationView", "pRequestInputForm", "pResponseOutputstream", "pResponseOutputView", "pRequestOutputForm", "pRequestOutputStream", "pResponseApplicationSteam", "pRequestBodyStream", "pResponseApplicationForm", "pRequestBodystream", "pResponseBodySteam", "pResponseWriteSteam"], "pHttpMethodType": ["pHttpMType", "pHttpOperationClass", "pHttpMethodID", "pHTTPMethodType", "pHttpOperationId", "pHTTPMID", "pHttpContextClass", "phttpMethodName", "pHttpMClass", "pHttpOperationType", "pHTTPMName", "phttpOperationId", "pHttpMETHODId", "pHttpMethodName", "pHttpOperationID", "phttpOperationName", "pHttpContextName", "phttpMethodId", "pHTTPMethodID", "pHttpContextType", "pHttpMETHODtype", "pHTTPMethodClass", "pHttpMETHODType", "pHttpMID", "phttpOperationtype", "phttpMethodType", "pHttpMethodtype", "phttpMethodtype", "pHTTPMType", "pHTTPMClass", "phttpOperationType", "pHttpMName", "pHttpMtype", "pHttpMETHODName", "pHttpMId", "pHttpOperationName", "pHTTPMethodName", "pHttpContextID", "pHttpMethodClass", "pHttpOperationtype", "pHttpMethodId"], "bis": ["sb", "abi", " inf", "ais", "Im", " ins", "b", " io", "os", "bs", "oss", "ins", "bb", "IS", "abs", " ris", "ri", "ios", " In", "IN", " os", "us", "ses", "is", " cis", " bi", " inter"], "bos": ["binary", " oy", " bo", "oth", "OS", "bi", "os", "bs", "outs", "ocr", "zo", "oS", "bye", "ob", "aos", "ooo", "oe", "obe", "xb", "eb", " bio", " bom", "flo", "wb", "ses", " Bos", "soc", " bi"], "url": ["source", "host", "page", "SSL", "browser", "connection", "feed", "l", "http", "client", "base", "loc", "https", "resource", "org", "server", "address", "config", "el", " URL", "name", "method", "ur", "event", "gl", "ob", "log", "api", "bel", "fl", "location", "string", "path", "image", "rl", "socket", "file", "ssl", "uri", "fail", "URL", "Url", "www", "web", "line", "coll", "sl"], "port": ["host", "parent", "num", "PORT", "connection", "phone", "limit", "format", "client", "state", "part", "channel", "number", "version", "stream", "resource", "server", "address", "Port", "ports", "name", "method", "project", "target", "patch", "allow", "ort", "length", "api", "password", "timeout", "key", "sort", "index", "string", "count", "point", "pool", "slice", "path", "file", "uri", "width", "service", "pi", "position", "proxy", "test", "ip", "p", "type"], "httpsProtocol": ["sslProocol", "httpsprotport", "sslProtport", "httpProocol", "httpsProotype", "httpsPoport", "httpsProport", "httpProection", "httpsPrototype", "httpsProocol", "httpsprototype", "sslProistry", "httpsPoo", "httpProo", "httpsprotistry", "httpsProtport", "httpsProtistry", "httpProtocol", "httpsProistry", "sslProtocol", "httpsPoistry", "httpsprotection", "httpsProection", "httpProtection", "httpsPoection", "httpsproto", "sslProport", "httpProto", "httpsProo", "httpsProtection", "httpPrototype", "httpsPootype", "httpsProto", "httpsprotocol", "sslProtistry", "httpsPoocol", "httpProotype"], "httpClient": ["HTTPClient", "phpMethod", "phpClient", "httpConnection", " httpConnection", "httpsConnection", "httpsServer", "HTTPAPI", " httpCase", " httpCode", " httpAPI", "httpsContext", "httpsContainer", " httpContext", "httpServer", "HttpConnection", "httpCase", "httpContainer", "httpCode", "httpContext", " httpContainer", "phpServer", "HTTPServer", "httpsAPI", "httpsClient", "phpCase", "HttpClient", "httpsMethod", "httpsCode", " httpServer", "HttpCode", "HTTPContext", "phpContainer", "HttpServer", "httpAPI", "httpsCase"], "httpMethod": ["infoMethod", "infomethod", "webClient", "HttpOperation", "webBlock", " httpOperation", " httpUnit", "httpsBlock", "httpsmethod", "phpMethod", "phpClient", "phpClass", "HttpFunction", "HttpClass", "httpOperation", " httpBlock", " httpmethod", " httpFunction", "httpsOperation", "httpUnit", "httpServer", "httpmethod", "httpsUnit", "Httpmethod", "phpServer", "webMethod", "httpsClient", "HttpClient", "httpsMethod", "httpFunction", "httpClass", " httpServer", "HttpMethod", "phpOperation", "infoClient", "infoFunction", "webUnit", " httpClass", "httpBlock", "HttpServer", "phpBlock"]}}
{"id1": "5845421", "id2": "15607448", "code1": "    private void download(Downloadable downloadable, HttpServletResponse response) throws Exception {\n        String contentType = downloadable.getContentType();\n        try {\n            response.setContentType(contentType);\n            response.setHeader(\"Content-Disposition\", \"attachment;\" + \" filename=\" + new String(downloadable.getName().getBytes(), \"ISO-8859-1\"));\n            OutputStream os = response.getOutputStream();\n            IOUtils.copy(downloadable.getInputStream(), os);\n            os.flush();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"downloadable": ["Downloadble", "selecting", "downloadtable", " downloading", "filler", "downloador", " downloador", "downloading", "downloadal", "buildor", "Downloadible", "downloadables", "buildable", " downloadability", " downloadables", "downloadability", "stringer", "Downloadable", " downloadal", "Downloadal", " downloadtable", "dumpability", "fillability", "stringable", " downloadble", "varial", "dumpables", "stringtable", "stringability", "downloader", "selectability", "variable", "selectable", "filltable", "selectables", "Downloadability", " downloadible", " downloader", "dumpable", "fillable", "variability", "downloadble", "Downloador", "buildible", "buildability", "dumping", "varible", "downloadible"], "response": ["host", "page", "respond", "site", "en", "write", "connection", "success", "feed", "complete", "reply", "result", "message", "output", "http", "out", "request", "object", "client", "application", "data", "version", "resource", "server", "esi", "writer", "body", "full", "results", "e", "report", "json", "api", "fire", "wave", "status", "Response", "index", "document", "respons", "cache", "file", "error", "resp", "service", "res"], "contentType": ["ContentType", "ContentStyle", " contentUnit", "contentStyle", "inputName", "inputUnit", " contentName", "inputType", "mediaType", "contentInfo", "mediaName", " contentInfo", "mediaInfo", "contentName", "ContentInfo", "inputStyle", "ContentUnit", " contentStyle", "contentUnit", "ContentName"], "os": ["opens", "los", "ks", "des", "oses", "ss", "io", "fs", "out", "ms", "OS", "ros", "bos", "oa", "bs", "dos", "es", "ens", "outs", "vs", "oss", "oos", "o", "aos", "cs", "rs", "ls", "Os", "nos", "ios", "ops", "ips", "its", "i", "pos", "us", "is", "cos", "ds", "obs", "ps", "s", "ot"]}}
{"id1": "12435022", "id2": "1760354", "code1": "    protected void generateDiffResults(File outFile) throws IOException {\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream, outputCharset));\n        intlWrite(out, HTML_STRICT_DOCTYPE + \"<html><head><title>${Report.Title}</title>\\n\" + \"<meta http-equiv=\\\"Content-Type\\\"\" + \" content=\\\"text/html; charset=\" + outputCharset + \"\\\">\\n\" + \"<style type=\\\"text/css\\\">\\n\");\n        out.write(LOCDiff.getCssText());\n        writeCustomStyleInfo(out);\n        out.write(\"</style></head>\\n\" + \"<body>\\n\" + \"<div>\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border>\");\n            intlWrite(out, getAddedTableHeader());\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border>\");\n            intlWrite(out, getModifiedTableHeader());\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border>\");\n            intlWrite(out, getDeletedTableHeader());\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (unchangedTable.length() > 0) {\n            out.write(\"<table border>\");\n            intlWrite(out, getUnchangedTableHeader());\n            out.write(unchangedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        writeSummaryTable(out);\n        out.write(\"</div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n    }\n", "code2": "    public static int deleteOrderStatusHis(String likePatten) {\n        Connection conn = null;\n        PreparedStatement psmt = null;\n        StringBuffer SQL = new StringBuffer(200);\n        int deleted = 0;\n        SQL.append(\" DELETE FROM JHF_ORDER_STATUS_HISTORY \").append(\" WHERE   ORDER_ID LIKE  ? \");\n        try {\n            conn = JdbcConnectionPool.mainConnection();\n            conn.setAutoCommit(false);\n            conn.setReadOnly(false);\n            psmt = conn.prepareStatement(SQL.toString());\n            psmt.setString(1, \"%\" + likePatten + \"%\");\n            deleted = psmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            if (null != conn) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    System.out.println(\" error when roll back !\");\n                }\n            }\n        } finally {\n            try {\n                if (null != psmt) {\n                    psmt.close();\n                    psmt = null;\n                }\n                if (null != conn) {\n                    conn.close();\n                    conn = null;\n                }\n            } catch (SQLException e) {\n                System.out.println(\" error  when psmt close or conn close .\");\n            }\n        }\n        return deleted;\n    }\n", "label": 0, "substitutes": {"outFile": ["outputStream", "plainFile", "outputLog", "outputFILE", "inFile", "outDir", "outLog", "outputFile", "outFILE", "inLog", "plainFILE", " outDir", " outPath", " outLog", "outPath", "inStream", "outputDir", " outFILE", "inPath", "outputPath", "plainStream", "plainDir"], "outStream": ["outputStream", "outputLog", "fullFile", "fullStream", " outWriter", "outStreamer", "inFile", "OutFile", "outLog", "outputFile", "inWriter", "inLog", "fullWriter", " outLog", "inStreamer", "OutStreamer", "inStream", "fullStreamer", "OutStream", "outWriter", "OutWriter", "outputWriter"], "out": ["net", "result", "down", "extra", "doc", "Out", "resource", "call", "writer", "sync", "name", "log", "flush", "temp", "image", "obj", "file", "err", "group", "project", "line", "io", "outer", "conn", "lib", "one", "pre", "object", "app", "part", "gen", "by", "to", "table", "OUT", "remote", "editor", "off", "update", "t", "a", "ex", "job", "key", "all", "pool", "cache", "or", "at", "copy", "ext", "page", "parent", "user", "write", "http", "in", "client", "cmd", "this", "base", "version", "no", "n", "work", "server", "external", "exec", "word", "full", "o", "comment", "v", "global", "path", "error", "process", "req", "connection", "output", "view", "w", "again", "outs", "prefix", "config", "inner", "password", "session", "up", "window", "lock", "check", "code", "block"], "redlines": ["REDls", "redls", "badblocks", "badline", "badls", "redblocks", " redls", "badlines", " redblocks", "REDblocks", " redline", "REDline", "REDlines", "redline"]}}
{"id1": "2499054", "id2": "6330721", "code1": "    public String encryptToSHA(String info) {\n        byte[] digesta = null;\n        try {\n            MessageDigest alga = MessageDigest.getInstance(\"SHA-1\");\n            alga.update(info.getBytes());\n            digesta = alga.digest();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        String rs = byte2hex(digesta);\n        return rs;\n    }\n", "code2": "    public int setData(String mysql) {\n        int mycount = 0;\n        try {\n            conn.setAutoCommit(false);\n            mycount = 0;\n            stmt = conn.createStatement();\n            mycount = stmt.executeUpdate(mysql);\n        } catch (Exception e) {\n            mycount = -1;\n        } finally {\n            if (mycount > 0) {\n                try {\n                    conn.commit();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    conn.rollback();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return mycount;\n    }\n", "label": 0, "substitutes": {"info": ["source", "id", "url", "about", "txt", "token", "si", "auth", "buffer", "Info", "safe", "ami", "result", "now", "message", "fo", "http", "object", "inf", "b", "part", "f", "base", "data", "auto", "archive", "conf", "name", "information", "api", "text", "key", "string", "INFO", "image", "path", "obj", "error", "i", "secret", "is", "iso", "type"], "digesta": ["digella", "ditza", "digza", " digza", "ditetta", "labest", "Digesta", " digella", "labesta", "digetta", "ditella", " digetta", "Digestation", "digest", " digestation", " digest", "Digetta", "Digella", "ditesta", "labetta", "digestation", "ditestation", "ditest", "labella", "Digza", "Digest"], "alga": ["alphga", "alsba", "alsgas", " algo", "alda", "alphgo", "alg", "alna", "alsqa", "ggas", "ALda", "agpa", "arqa", "alphpa", "palba", "algas", "ALna", " algas", "aggo", "agg", " alpa", "alba", " alna", "palga", "algo", "gda", "palgas", "palqa", "gga", "ALgas", "agga", "ALga", "alphg", "alpa", "gna", "arba", " alda", " alg", "argas", "alqa", "alsga", "arga"], "rs": ["arms", "Rs", "hs", "RC", "ks", "resses", "ss", " codes", "ws", "RS", "params", "ns", " results", "ars", "ros", "ruby", "r", "codes", "rates", "ures", " rows", " params", "xs", " r", "rc", "ins", "results", " chars", "cs", "sr", "ls", " Rs", " details", "rors", "ras", " RS", "parts", "rings", "ig", "ps", "res", "ributes"]}}
{"id1": "12442447", "id2": "18042303", "code1": "    public ActionResponse executeAction(ActionRequest request) throws Exception {\n        ActionResponse resp = new ActionResponse();\n        BufferedReader in = null;\n        try {\n            URL url = new URL(URL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            int status = conn.getResponseCode();\n            if (status == 200) {\n                in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                while (true) {\n                    String line = in.readLine();\n                    if (line == null) break;\n                    resp.addResult(\"REMOTEVERSION\", line);\n                }\n            } else {\n                resp.setErrorCode(ActionResponse.GENERAL_ERROR);\n                resp.setErrorMessage(\"HTTP Error [\" + status + \"]\");\n            }\n        } catch (Exception e) {\n            resp.setErrorCode(ActionResponse.GENERAL_ERROR);\n            resp.setErrorMessage(e.getMessage());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n        return resp;\n    }\n", "code2": "    @Override\n    public void view(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        boolean found = false;\n        String name = getArgument(request.getPathInfo());\n        if (StringUtils.contains(name, '/')) {\n            File file = new File(config.getProperty(Config.MULTIMEDIA_PATH) + Config.FILE_SEPARATOR + name);\n            if (file.exists() && file.isFile()) {\n                found = true;\n                MagicMatch match = Magic.getMagicMatch(file, true);\n                response.setContentType(match.getMimeType());\n                FileInputStream in = new FileInputStream(file);\n                IOUtils.copyLarge(in, response.getOutputStream());\n                in.close();\n            }\n        } else if (!StringUtils.isBlank(name)) {\n            int articleId = NumberUtils.toInt(name);\n            if (articleId > 0) {\n                Article article = articleDao.load(articleId);\n                if (article != null) {\n                    found = true;\n                    sendArticle(request, response, article);\n                }\n            }\n        } else {\n            int page = NumberUtils.toInt(request.getParameter(\"page\"), 0);\n            Date fromDate = null;\n            String from = request.getParameter(\"from\");\n            if (StringUtils.isNotBlank(from)) {\n                try {\n                    fromDate = dayMonthYearEn.parse(from);\n                } catch (ParseException e) {\n                }\n            }\n            Date untilDate = null;\n            String until = request.getParameter(\"until\");\n            if (StringUtils.isNotBlank(until)) {\n                try {\n                    untilDate = dayMonthYearEn.parse(until);\n                } catch (ParseException e) {\n                }\n            }\n            sendArticleList(request, response, articleDao.list(request.getParameter(\"query\"), request.getParameter(\"author\"), request.getParameter(\"tags\"), request.getParameterValues(\"types\"), fromDate, untilDate, page, HITS_PER_PAGE, null));\n            found = true;\n        }\n        if (found != true) {\n            response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n", "label": 0, "substitutes": {"request": ["input", "user", "req", "verb", "xml", "message", "from", "client", "object", "this", "state", "re", "r", "resource", "call", "config", "info", "method", "query", "requ", "report", "json", "quest", "obj", "uri", "q", "rest", "type"], "resp": ["page", "respond", "msg", "req", "rel", "success", "rep", "reply", "rex", "result", "co", "jp", "wx", "view", "out", "app", "client", "cmd", "val", "fp", "fr", "exc", "onse", "fe", "ref", "re", "response", "remote", "ctx", "comp", "ret", "serv", "par", "repl", "server", "wp", "report", "json", "exp", "coll", "api", "job", "content", "rec", "Response", "esp", "eb", "obj", "html", "rev", "prev", "sp", "err", "error", "Resp", "www", "news", "res", "cmp", "ll"], "in": ["source", "reader", "id", "input", "inc", "ln", "din", "win", "connection", "cf", "io", "nin", "con", "out", "b", "fr", "login", "f", "as", "data", "In", "again", "n", "r", "re", "stream", "fac", "ai", "isin", "inner", "init", "ins", "gin", "ini", "m", "kin", "rec", "cin", "lock", "c", "socket", "file", "i", "IN", "err", "inside", "inn", "rin", "is", "lin", "fin", "bin", "s", "ac"], "url": ["host", "page", "connection", "rel", "feed", "download", "l", "http", "client", "fr", "base", "f", "loc", "resource", "org", "server", "config", "el", "cl", "log", "api", "sl", "fl", "ls", "lc", "path", "rl", "impl", "socket", "file", "uri", "ssl", "URL", "Url", "www", "web", "coll", "ll"], "conn": ["dc", "cb", "en", "net", "connection", "open", "uc", "cf", "con", "out", "ns", "Conn", "cp", "n", "enc", "ctx", "serv", "inner", "pc", "cn", "conf", " connection", "init", "ci", "rc", "nt", "stat", "ch", "cli", "ls", "sec", "col", "connect", "c", "ssl", "socket", "err", "g", "conv", "sn", "Connection", "ct", "nc", "coll"], "status": ["source", "size", "id", "num", "msg", "si", "cm", "success", "reply", "result", "exit", "message", "ity", "score", "state", "login", "version", "response", "Status", "zip", "prefix", "server", "stage", "js", "sync", "ix", "e", "json", "api", "stat", "sr", "cli", "job", "temp", "content", "index", "STAT", "code", "err", "ssl", "service", "wait", "fail", "error", "current", "level", "received", "uses", "type"], "line": ["source", "page", "entry", "value", "link", "write", "lf", "result", "lines", "message", "l", "letter", "out", "end", "LINE", "cell", "Line", "row", "f", "part", "data", "no", "model", "inline", "response", "r", "zip", "raw", "section", "e", "unit", "log", "text", "content", "lc", "job", "string", "file", "error", "code", "parse", "item", "lin", "str", "ip"]}}
{"id1": "6893385", "id2": "751335", "code1": "    @Override\n    public void end() {\n        m_zipFormatter.end();\n        IOUtils.closeQuietly(m_outputStream);\n        final FTPClient ftp = new FTPClient();\n        FileInputStream fis = null;\n        try {\n            if (m_url.getPort() == -1 || m_url.getPort() == 0 || m_url.getPort() == m_url.getDefaultPort()) {\n                ftp.connect(m_url.getHost());\n            } else {\n                ftp.connect(m_url.getHost(), m_url.getPort());\n            }\n            if (m_url.getUserInfo() != null && m_url.getUserInfo().length() > 0) {\n                final String[] userInfo = m_url.getUserInfo().split(\":\", 2);\n                ftp.login(userInfo[0], userInfo[1]);\n            } else {\n                ftp.login(\"anonymous\", \"opennmsftp@\");\n            }\n            int reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                LogUtils.errorf(this, \"FTP server refused connection.\");\n                return;\n            }\n            String path = m_url.getPath();\n            if (path.endsWith(\"/\")) {\n                LogUtils.errorf(this, \"Your FTP URL must specify a filename.\");\n                return;\n            }\n            File f = new File(path);\n            path = f.getParent();\n            if (!ftp.changeWorkingDirectory(path)) {\n                LogUtils.infof(this, \"unable to change working directory to %s\", path);\n                return;\n            }\n            LogUtils.infof(this, \"uploading %s to %s\", f.getName(), path);\n            ftp.setFileType(FTP.BINARY_FILE_TYPE);\n            fis = new FileInputStream(m_zipFile);\n            if (!ftp.storeFile(f.getName(), fis)) {\n                LogUtils.infof(this, \"unable to store file\");\n                return;\n            }\n            LogUtils.infof(this, \"finished uploading\");\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"Unable to FTP file to %s\", m_url);\n        } finally {\n            IOUtils.closeQuietly(fis);\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"ftp": ["ctsp", " ftplug", "ctps", "rtcp", "htcp", "gtm", "rtsp", "webtp", " fttp", " ftpoint", "ffm", "gtbase", " ftpool", "webpi", " ft3", " ftcp", " ftbase", "fuser", "ntcp", "fundf", "ctcp", "gtf", " ftps", " ftsp", "bff", "ftpoint", "lf3", "lfp", "FTplug", "fb", "ctp", " ftc", "dfplug", "fff", " ftf", "ffp", " ftP", "bfbase", "pullpi", "rtb", " ftport", "ftm", "pullp", "ptp", "pullpoint", "rttp", "fundp", "rtm", "ftbase", "fttp", "ftf", "webp", "ftplug", "bfp", "ctb", "ffc", "rtf", "ffpool", "ntpool", "ctport", "lff", "fund3", "ftuser", "dfb", "htm", "ftpool", "rtp", "cttp", "fp", "funduser", "fundcp", "FTb", "htf", "ffcp", "fundtp", "ftc", "ntp", "ftP", "FTP", "lftp", "ptps", "ftps", "ctf", " ftuser", "ftport", "fm", "ff", "urlf", "ftsp", "webpoint", " ftpi", " ftb", "dfp", "ctm", "ftcp", "fcp", "ftb", "bfm", " ftm", "ptport", "ftpi", "urlp", "gtp", "ptb", "htp", "FTp", "urlm", "pulltp", "ft3", "dfP", "ntc", "urlcp"], "fis": ["afiss", "flics", "fiss", "fais", "afais", "flis", "mib", " fisa", "afis", " fi", "bi", "tiss", "biss", "infisa", "fics", "tib", "afisa", "infiss", "mai", " fib", "tis", "fai", " fai", "mis", "infis", " fics", "bics", "miss", " fais", "fisa", "bis", "fli", "fi", "fib", "infais", " fiss", "tai", "fliss"], "userInfo": ["useInfo", "UserInf", "urlinfo", "userinfo", "stringData", "stringinfo", "useInf", "memberLi", "memberInfo", "memberInf", " userData", "useData", "userLi", "usersInf", "urlData", "userInf", "urlId", "useLi", "stringInfo", "userData", "UserId", " userInf", " userinfo", "usersId", "UserInfo", "usersInfo", " userId", "urlInfo", "Userinfo", "stringId", " userLi", "userId", "memberData", "usersinfo"], "reply": ["next", "respond", "id", "queue", "msg", "write", "link", "connection", "result", "message", "state", "ply", "base", "response", "prefix", "ret", "repl", "address", "info", "server", "send", "Reply", "action", " response", "sync", "query", "rc", "comment", "cause", "post", "status", "back", "ping", "dy", "respons", "answer", "uri", "error", "code", "err", "resp", "service", "subject", "reason", "type"], "path": ["next", "host", "source", "parent", "left", "value", "id", "route", "url", "anc", "link", "user", "token", "from", "wd", "PATH", "object", "home", "Path", "part", "bug", "base", "loc", "data", "p", "loader", "root", "directory", "clean", "work", "handler", "resource", "child", "enc", "info", "inner", "ath", "name", "filename", "dir", "full", "pattern", "patch", "target", "log", "ion", "text", "rh", "content", "temp", "key", "col", "index", "string", "point", "image", "pointer", "cache", "c", "uri", "file", "code", "context", "mount", "th", "test", "str", "location", "type"], "f": ["af", "folder", "h", "bf", "d", "feed", "lf", "l", "fs", "w", "fp", "b", "inf", "fr", "tf", "fe", "n", "r", "info", "conf", "u", "e", "o", "fn", "t", "F", "m", "df", "fl", "v", "j", "c", "file", "i", "fb", "g", "fen", "form", "fa", "p", "fx"]}}
{"id1": "20372195", "id2": "14134127", "code1": "    public static void copy(String a, String b) throws IOException {\n        File inputFile = new File(a);\n        File outputFile = new File(b);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void addFilesToExistingZip(File zipFile, String[] dirs, File[] files) throws IOException {\n        File tempFile = new File(zipFile.getAbsoluteFile() + \".temp\");\n        if (tempFile.exists()) tempFile.delete();\n        boolean renameOk = zipFile.renameTo(tempFile);\n        if (!renameOk) {\n            throw new RuntimeException(\"Could not rename the file \" + zipFile.getAbsolutePath() + \" to \" + tempFile.getAbsolutePath());\n        }\n        ZipInputStream zin = new ZipInputStream(new FileInputStream(tempFile));\n        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));\n        ZipEntry entry = zin.getNextEntry();\n        byte[] buf = new byte[1024];\n        while (entry != null) {\n            String entryName = entry.getName();\n            boolean inFiles = false;\n            for (int i = 0; i < files.length; i++) {\n                String fileName = dirs[i] + \"/\" + files[i].getName();\n                if (fileName.equals(entryName)) {\n                    inFiles = true;\n                    break;\n                }\n            }\n            if (!inFiles) {\n                out.putNextEntry(new ZipEntry(entryName));\n                int len;\n                while ((len = zin.read(buf)) > 0) out.write(buf, 0, len);\n            }\n            entry = zin.getNextEntry();\n        }\n        zin.close();\n        for (int i = 0; i < files.length; i++) {\n            InputStream in = new FileInputStream(files[i]);\n            out.putNextEntry(new ZipEntry(dirs[i] + \"/\" + files[i].getName()));\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            out.closeEntry();\n            in.close();\n        }\n        out.close();\n        tempFile.delete();\n    }\n", "label": 1, "substitutes": {"a": ["source", "sa", "an", "input", "A", "la", "audio", "am", "alpha", "app", "as", "f", "ai", "ac", "sta", "name", "pa", "e", "au", "ae", "area", "ba", "art", "ab", "file", "i", "aa", "ca", "s", "fa", "p"], "b": ["sb", "mb", "d", "be", "pb", "y", "end", "bc", "f", "base", "p", "abb", "bs", "r", "bad", "erb", "ub", "e", "bb", "ob", "abs", "beta", "job", "ba", "xb", "eb", "B", "emb", "ab", "db", "wb", "fb", "boot", "bis", "lb", "bin", "rb", "ib"], "inputFile": ["sourceDir", "parentFile", "inputFolder", "inputfile", "InputDirectory", "sourceFolder", " inputfile", " inputDir", " inputFolder", "Inputfile", " inputDirectory", "sourcefile", "sourceFile", "InputDir", "parentfile", "InputFile", "inputDirectory", "parentDirectory", "inputDir", "InputFolder", "parentDir"], "outputFile": ["inputPath", " outputfile", "inputfile", "Outputfile", " outputPath", "resourceFile", "outputFiles", " outputDir", "resourceFiles", "OutputFiles", "outputfile", " outputFiles", "OutputDir", "outputDir", "OutputFile", "resourcePath", "inputDir", "outputPath", "resourceDir", "resourcefile"], "in": ["source", "get", "reader", "id", "url", "input", "inc", "din", "win", "connection", "pull", "min", "nin", "l", "con", "login", "f", "as", "In", "into", "again", "n", "r", "pin", "isin", "inner", "init", "ins", "o", "e", "ini", "up", "sin", "image", "cin", "file", "i", "IN", "inside", "inn", "rin", "lin", "bin", "s", "ic"], "out": ["parent", "inc", "write", "user", "net", "outer", "io", "output", "one", "w", "client", "ou", "over", "to", "data", "n", "Out", "OUT", "outs", "again", "writer", "off", "exec", "sync", "o", "s", "ex", "temp", "v", "up", "image", "cache", "file", "error", "i", "err", "obj", "is", "at", "outside", "bin", "copy", "line"], "c": ["id", "cd", "d", "uc", "cy", "cu", "cm", "cf", "k", "fc", "l", "w", "char", "f", "ec", "n", "r", "enc", "xc", "ac", "pc", "x", "ci", "u", "rc", "e", "o", "esc", "cl", "t", "m", "lc", "ch", "v", "col", "index", "cr", "count", "pointer", "i", "code", "character", "cc", "ct", "line", "p", "C"]}}
{"id1": "8793826", "id2": "15034107", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"infile": ["inputfile", "infilename", " inFile", "infiles", "inFile", "inbase", "inputfiles", "inputfilename", " instream", "outfiles", " infilename", "Instream", "infp", " infp", "inputfp", "Inbase", "outfilename", " infiles", "InFile", "instream", "minbase", " inbase", "minstream", "outfp", "minfile", "Infile", "minFile"], "outfile": ["inputfile", "outFile", "infilename", " outdatabase", "outputpath", "inFile", "outputfilename", "outdatabase", "outputFile", " outFile", "outpath", "outfilename", "outputdatabase", " outfolder", "inputdatabase", "outfolder", "outputfolder", "infolder", "inputpath", "inputFile", " outpath", " outfilename", "outputfile"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "min", "nin", "conn", "con", "b", "login", "as", "data", "In", "pin", "into", "re", "r", "inas", "thin", "again", "ac", "isin", "inner", "init", "ins", "gin", "ini", "a", "m", "sin", "cin", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "lin", "bin", "s", "ic", "pass"], "out": ["parent", "inc", "write", "net", "co", "io", "output", "outer", "conn", "one", "lib", "client", "home", "ou", "base", "channel", "to", "no", "In", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "log", "ex", "post", "job", "session", "up", "timeout", "point", "image", "cache", "socket", "file", "obj", "error", "err", "or", "bin", "copy", "exit", "line", "pass"], "buffer": ["source", "size", "reader", "split", "url", "queue", "input", "write", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "base", "channel", "layer", "data", "bytes", "server", "raw", "address", "uffer", "transfer", "null", "padding", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "count", "border", "seed", "cache", "bin", "value", "type"], "read": ["play", "select", "next", " write", "size", "reader", "ad", "get", "inc", "write", "id", "feed", "len", "Read", "ind", "iter", " skip", "fill", "READ", "ride", "io", "limit", "end", "tell", "f", "sleep", "find", "n", "r", "work", "raw", "exec", "x", "sync", "send", "reading", "_", "length", "allow", "run", "se", "slice", "count", "pass", "load", "parse", "connect", "i", "seek", "check", "wait", "lex", "current", " copy", "start", " count", "ip", "add", "copy", " Read", "use", "reads"], "success": ["successful", "continue", "roll", "default", "warning", "first", "better", "successfully", "open", " succeed", "complete", "growth", "result", "right", "message", "Success", "true", "positive", "flash", "winner", " succ", "model", " successful", "cess", "data", "fast", "again", "response", "primary", "xx", "rolled", " Success", "method", "func", "results", "failed", "initial", "comment", "danger", "content", "status", "done", "path", "error", "fail", "valid", "construct", "ccess", "rolling", "follow", "ceed", "good", "value", "null", "pass"]}}
{"id1": "10361726", "id2": "3177725", "code1": "    void queryFile(String rendezvousProgram, String rendezvousMD5) {\n        try {\n            XMLConfigParser.readUrlHost();\n            String url = XMLConfigParser.urlHost;\n            String query;\n            String param1 = \"op=query\";\n            String param2 = \"program=\" + rendezvousProgram;\n            String param3 = \"md5=\" + rendezvousMD5;\n            query = String.format(\"%s&%s&%s\", param1, param2, param3);\n            openConnection(query, url);\n            String line = br.readLine();\n            NetworkLog.logMsg(NetworkLog.LOG_DEBUG, this, \"(Query) Response of the server: \" + line);\n            br.close();\n        } catch (MalformedURLException e) {\n            NetworkLog.logMsg(NetworkLog.LOG_ERROR, this, \"Error\" + e);\n        } catch (IOException e) {\n            NetworkLog.logMsg(NetworkLog.LOG_ERROR, this, e.getMessage());\n        }\n    }\n", "code2": "    public DBAccess(String pathToDb) {\n        if (instance != null) {\n            throw new IllegalStateException();\n        }\n        System.setProperty(\"derby.system.home\", pathToDb);\n        try {\n            boolean exists = new File(pathToDb).exists();\n            new EmbeddedDriver();\n            Properties props = new Properties();\n            if (exists) {\n                connection = DriverManager.getConnection(protocol + \"rmpDB;\", props);\n                connection.setAutoCommit(true);\n                Statement statement = connection.createStatement();\n                try {\n                } finally {\n                    statement.close();\n                }\n            } else {\n                connection = DriverManager.getConnection(protocol + \"rmpDB;create=true\", props);\n                connection.setAutoCommit(true);\n                URL url = Platform.getBundle(\"ru.spbu.dorms.geo.rmp\").getResource(\"sql/createdb.sql\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                StringBuilder query = new StringBuilder();\n                for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                    if (query.length() > 0) {\n                        query.append('\\n');\n                    }\n                    query.append(s);\n                }\n                reader.close();\n                Statement statement = connection.createStatement();\n                try {\n                    String[] statements = query.toString().split(\";(\\\\s)*\");\n                    for (String s : statements) {\n                        statement.execute(s);\n                    }\n                } finally {\n                    statement.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        instance = this;\n    }\n", "label": 0, "substitutes": {"rendezvousProgram": ["endiscoveryProgram", "renditingMAC", "rendiscoveryMAC", "endezvousMAC", "rendichoMAC", " rendiosityProgram", "rendezvousMODE", "rendichoprogram", "rendiosityMaterial", " rendiositySoftware", " rendiosityMODE", "rendrificationProgram", " rendezvousSoftware", "rendiscoveryURL", "rendezvousURL", "rendiscoveryprogram", "rendiscoveryProgram", "rendezvousSoftware", "rendrificationMODE", "rendezvousMAC", "rendezvousMaterial", "endezvousprogram", "renditingprogram", " rendezvousMODE", "rendlinessSoftware", "rendlinessProgram", "endezvousProgram", "rendlinessMaterial", "endiscoveryURL", " rendezvousMaterial", "endiscoveryprogram", "rendichoURL", "rendrificationSoftware", " rendiosityMaterial", "rendiosityProgram", "endiscoveryMAC", "rendezvousprogram", "rendiosityMODE", "renditingURL", "rendichoProgram", "rendrificationMaterial", "rendlinessMODE", "renditingProgram", "endezvousURL", "rendiositySoftware"], "rendezvousMD5": ["rendezvousIPDie", "rendluxMD0", "rendezvousSHAN", "rendezvousmdN", "renditeMDDie", "rendezvousURL0", "rendluxMD5", "rendluxMDLE", "rendezvousMDLE", "rendezvousIP2", "rendezvousIP5", "renditeMDN", "renditeSHADie", "renditeSHA5", "rendluxMAC3", "rendezvousSHALE", "rendezvousmd5", "rendezvousMAC5", "renditeMD5", "renditeSHA2", "rendezvousMDDie", "renditeMD2", "rendezvousSHADie", "rendezvousURL5", "rendluxMACLE", "rendezvousSHA5", "rendezvousSHA2", "rendezvousURL3", "rendezvousSHA3", "rendezvousmd2", "rendezvousMACLE", "rendezvousMAC3", "rendezvousURLLE", "rendezvousMD0", "rendezvousMD2", "rendezvousIPN", "rendezvousMD3", "rendezvousmdDie", "renditeSHAN", "rendezvousSHA0", "rendezvousMDN", "rendezvousMAC0", "rendluxMAC0", "rendluxMAC5", "rendluxMD3"], "url": ["host", "page", "route", "user", "link", "connection", "buffer", "ll", "br", "io", "l", "http", "channel", "base", "f", "loc", "response", "server", "address", "config", "name", "ur", "json", "log", "api", "location", "string", "path", "file", "uri", "error", "URL", "q", "service", "Url", "web", "str", "sl"], "query": ["source", "sql", "user", "xml", "range", "result", "message", "params", "request", "row", "data", "response", "clean", "server", "raw", "config", "ql", "qs", "random", "module", "script", "name", "body", "qu", "report", "filter", "json", "comment", "content", "timeout", "string", "rule", "cache", "answer", "uri", "parse", "error", "command", "Query", "search", "ask", "code", "header", "q", "sq", "block", "database", "question", "form", "str", "qa"], "param1": ["mark1", "par2", "mark0", "param51", " param4", "par5", " param51", " parameter51", "par1", "mark51", "mark4", "param4", "param5", " parameter4", "Param5", " parameter0", "Param2", " param5", " parameter1", "param0", " param0", "par3", "Param1", "Param3"], "param2": [" param4", "resource2", "params4", "par5", "par1", "prom62", "param62", "params1", "param4", "param5", "Param5", "resource5", " param62", "prom5", "params5", "Param62", "resource4", "Param2", "params2", " param5", "resource1", "Param4", "prom2", "prom4", "par4", "par2"], "param3": ["grade5", "gradethree", " param4", "grade3", "params3", "params4", "aramthree", "param15", "grade15", "aram3", "param5", "param4", "Param5", "params5", "aram5", "Param2", "params2", " param5", "paramthree", "Param4", "params15", "aram15", "paramsthree", "Param3"], "line": ["source", "page", "link", "connection", "lf", "xml", "buffer", "reply", "result", "lines", "message", "l", "end", "LINE", "Line", "row", "base", "data", "inline", "response", "server", " response", "name", "body", "e", "de", "log", "status", "string", "error", "code", "db", "header", "lin", "str", "ip", "entry"]}}
{"id1": "288695", "id2": "20372195", "code1": "    public void CopyFile(File source, File destination) throws Exception {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(source);\n            fos = new FileOutputStream(destination);\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                fos.write(buffer, 0, read);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copy(String a, String b) throws IOException {\n        File inputFile = new File(a);\n        File outputFile = new File(b);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "io", "src", "from", "in", "this", "Source", "base", "table", "directory", "stream", "remote", "resource", "ie", "server", "address", "info", "ources", "filename", "name", "e", "target", "ource", "sin", "SOURCE", "slice", "string", "image", "file", "uri", "i", "service", "scene", "proxy", "use", "unit"], "destination": ["deadinated", "deadination", "Desturation", "destiner", "combinated", "deaduration", "Destinated", "desturation", "Destiner", "destinated", "dinations", "combination", "diination", "diinations", "Destinator", "deadiner", "diinated", "dinated", "destinations", "dinator", "Destinations", "dination", "combiner", "diinator", "comburation", "destinator", "Destination"], "fis": ["los", "fris", "infris", "fois", "Fos", "Fiss", "las", "fiss", "bos", "infos", "lois", "fios", "Fas", " fois", "biss", " fios", "bris", "Fris", "hos", "Fis", "his", "hiss", " fas", "infis", " fris", "hris", "Fois", "lis", "infios", "Fios", "lris", "bis", " fiss", "fas"], "fos": ["Foes", "los", " fros", " foses", "fose", "fus", " foes", " fou", "ufou", "ufos", "baos", "ufros", "pose", "bros", "fros", "Fos", "bos", "infos", "fios", "infus", " fios", " faos", " fus", "Faos", "poes", "lios", "bou", "Fis", "infis", "Fose", "loses", "faos", "lis", "ufis", "infios", "foses", "bus", "Fios", "bios", "pos", "Foses", "poses", "bis", "fou", "foes", " fose"], "buffer": ["reader", "url", "queue", "memory", "binary", "input", "write", "feed", "reference", "buff", "repeat", "iter", "result", "Buffer", "limit", "request", "b", "channel", "number", "layer", "data", "available", "resource", "address", "uffer", "shape", "transfer", "null", "batch", "flush", "length", "wave", "buf", "slice", "count", "document", "border", "seed", "cache", "header", "block", "total", "position", "bin"], "read": ["play", "get", "next", "reader", "en", "size", "id", "write", "d", "input", "feed", "len", "Read", "ind", "open", "iter", "READ", "io", "in", "b", "end", "f", "data", "rate", "find", "n", "work", "raw", "exec", "x", "send", "e", "reading", "_", "length", "allow", "text", "max", "se", "key", "run", "index", "close", "count", "pass", "load", "connect", "parse", "readable", "i", "check", "seek", "current", "type", "wait", "start", " count", "add", "ed", " Read", "use", " ride", "reads"]}}
{"id1": "19395766", "id2": "624490", "code1": "    public static String encodePassword(String password) {\n        try {\n            MessageDigest messageDiegest = MessageDigest.getInstance(\"SHA-1\");\n            messageDiegest.update(password.getBytes(\"UTF-8\"));\n            return Base64.encodeToString(messageDiegest.digest(), false);\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"Ha habido un error mientras se almacenaba la clave de acceso.\");\n            throw new Error(e);\n        } catch (UnsupportedEncodingException e) {\n            log.error(\"Ha habido un error mientras se almacenaba la clave de acceso.\");\n            throw new Error(e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"password": ["hash", "input", "token", "auth", "sword", "result", "username", "message", "wd", "definition", "params", "PASS", "login", "data", "phrase", "prefix", "email", "address", "word", "name", " passwords", "pattern", "Pass", "text", "words", "key", "string", "path", "encrypted", "code", "secret", "database", "Password", "crypt", "account", "padding", "p", "pass"], "messageDiegest": ["messageDiegress", "messDiega", " messageDiecest", "messdiegent", " messageDiechant", "messageFineger", "messagediechant", " messageDiegent", " messageLettercest", "messagediegent", "messageDiechant", "MessageDieger", "messageExgress", "MessageLettergest", "messageFinegest", "messDiegest", "messDieger", "messageDeathcest", "messageDiega", "messagediegest", "messdiegest", "messageDieger", " messageLetterchant", "messageLettergress", "messDiegent", "MessageDiegest", "messageLettergent", "messageLetterchant", "MessageLettergent", "messageExger", "MessageDiegress", "messageDiecest", "messageLettergest", "messageExgent", " messageLettergest", "messagediecest", "messageDeathgest", "MessageDiegent", "MessageLettergress", "messdiega", "messageFinega", "MessageLetterger", "messageDiegent", "messageDeathgent", "messageLetterger", "messagediega", "messageExgest", "messageFinegress", "messageLettercest", "messageDeathchant", "messdieger", "messageFinegent", " messageLettergent", "messagedieger"]}}
{"id1": "5467907", "id2": "15193222", "code1": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    @Override\n    public void copy(final String fileName) throws FileIOException {\n        try {\n            if (opened) {\n                fileChannel.position(0);\n            } else {\n                fileChannel = new FileInputStream(file).getChannel();\n            }\n            FileChannel dstChannel = null;\n            try {\n                dstChannel = new FileOutputStream(fileName).getChannel();\n                dstChannel.transferFrom(fileChannel, 0, fileChannel.size());\n            } finally {\n                try {\n                    if (dstChannel != null) {\n                        dstChannel.close();\n                    }\n                } catch (Exception exception) {\n                }\n            }\n            if (opened) {\n                fileChannel.position(currentPositionInFile);\n            } else {\n                fileChannel.close();\n            }\n        } catch (IOException exception) {\n            throw HELPER_FILE_UTIL.fileIOException(\"failed copy \" + file + \" to \" + fileName, null, exception);\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "sb", "url", "input", "upload", "download", "sit", "conn", "http", "in", "b", "this", "st", "root", "loc", "data", "stream", "storage", "resource", "sc", "config", "dest", "iv", "filename", "rc", "inst", "copy", "ls", "sin", "slice", "path", "image", "obj", "file", "uri", "files", "dist", "img", "s", "rb", "sl"], "dst": [" dsts", "dsts", "Ddest", "adst", "Dcr", "tdot", "adcr", "dcr", "dbds", " dcr", "fdst", "dbot", "addest", "fdds", "dds", "dbst", "dot", "adsts", "dbput", "Dsts", "dput", " ddest", "fdot", "tdds", "Dst", "fdput", "ddest", "tdst", "tdput"], "inChannel": ["inConnection", "againCamera", "againChan", "innerStream", "outChan", "binStream", "incStream", "loginChan", " inChan", "binchannel", "againChannel", "INChannel", " inStream", "inMessage", "inChan", " inContext", "incChan", "incCamera", "INchannel", "inputConnection", "inCamera", "outchannel", "binConnection", "innerConnection", "outMessage", "binChan", "INChan", " inConnection", "InChan", "inputChannel", "inputchannel", "inchannel", "inStream", "inputChan", "Inchannel", "INConnection", "loginChannel", "incChannel", "INStream", "outStream", "InContext", "inContext", " inMessage", "innerChannel", "InStream", "binChannel", "loginCamera", "outConnection", "inputMessage", "InChannel", "againStream", "innerChan", "inputStream", " inchannel", "loginStream", "outContext"], "outChannel": ["inConnection", "againChan", "outputStream", "outChan", " outChan", " outQueue", " outWriter", "againChannel", " outchannel", "againQueue", "Outchannel", "inChan", "offContext", "outputchannel", "inWriter", " outGate", "offWriter", "offChannel", "outchannel", "offChan", " outConnection", "outputChan", "OutChan", "outputChannel", "inputChannel", "OutChannel", "inputchannel", "inchannel", "inStream", "inputChan", " outContext", "outQueue", "againConnection", "outStream", "inputStream", "inContext", "OutStream", "outWriter", "outGate", "outConnection", "againStream", "outContext", "inGate", "againchannel", " outStream", "againGate", "inQueue"], "result": ["ure", "successful", "folder", "continue", "default", "compl", "success", "Result", "complete", "math", "function", "true", "card", "diff", "f", "data", "future", "response", "false", "match", "work", "ret", "r", "cash", "func", "event", "results", "length", "comment", "found", "ault", "status", "done", "cache", "error", "err", "or", "array", "current", "valid", "cup", "test", "res", "use", "pass"]}}
{"id1": "21682040", "id2": "11036037", "code1": "    public void extractFrinika() throws Exception {\n        FileInputStream fis = new FileInputStream(frinikaFile);\n        progressBar.setIndeterminate(true);\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry ze = zis.getNextEntry();\n        while (ze != null) {\n            showMessage(\"Extracting: \" + ze.getName());\n            File file = new File(installDirName + \"/\" + ze.getName());\n            if (ze.isDirectory()) file.mkdir(); else {\n                FileOutputStream fos = new FileOutputStream(file);\n                byte[] b = new byte[BUFSIZE];\n                int c;\n                while ((c = zis.read(b)) != -1) fos.write(b, 0, c);\n                fos.close();\n            }\n            ze = zis.getNextEntry();\n        }\n    }\n", "code2": "    public static void copy(String srcFilename, String destFilename) throws IOException {\n        int bytes_read = 0;\n        byte[] buffer = new byte[512];\n        FileInputStream fin = null;\n        FileOutputStream fout = null;\n        try {\n            fin = new FileInputStream(srcFilename);\n            try {\n                fout = new FileOutputStream(destFilename);\n                while ((bytes_read = fin.read(buffer)) != -1) {\n                    fout.write(buffer, 0, bytes_read);\n                }\n            } finally {\n                try {\n                    if (fout != null) {\n                        fout.close();\n                        fout = null;\n                    }\n                } catch (IOException e) {\n                }\n            }\n        } finally {\n            try {\n                if (fin != null) {\n                    fin.close();\n                    fin = null;\n                }\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fis": ["lbs", "afiss", "lais", "piss", "Fiss", "Fos", "fiss", "fais", "afos", "afis", "fios", "pbs", " fios", "Fis", "fbs", "pis", "lis", "liss", "afios", "Fios", " fais", " fbs", " fiss", "pais"], "zis": [" zins", " zos", "zais", "zas", " ziss", " zIS", "zipos", " zas", "zeiss", "zips", "zisa", "zenisa", "zipips", "zipis", "zenins", "zipais", "zipisi", "zeIS", " zips", "zenis", "zeniss", "ZIS", "zenisi", "zenos", "ziss", " zisi", "Zas", "zos", "zenips", "zIS", "zeas", "zenIS", "Zins", "zeis", "Ziss", "Zis", "zenais", "zisi", " zisa", "zins", "zipisa", " zais"], "ze": ["forge", "ice", "ette", "ipe", "zes", "za", "isse", "ld", "cf", "ee", "one", "ez", "que", "jo", "zy", "model", "ane", "lde", "ise", "fe", "ine", "zi", "zip", "zen", "ie", "ffe", "he", "el", "element", "zone", "zo", "ge", "ne", "liner", "e", "ace", "de", "ide", "ve", "cel", "oe", "sl", "kel", "je", "zz", "se", "ke", "zer", "ZE", "frame", "sk", "note", "code", "zed", "lex", "zie", "ede", "zee", "ce", "aze", "kee", "sea", "z", "lane", "te", "line", "ele", "entry"], "file": ["get", "folder", "parent", "die", "ile", "pe", "place", "feed", "connection", "cf", "function", "File", "l", "letter", "http", "out", "fp", "object", "f", "base", "fe", "data", "directory", "future", "zip", "single", "resource", "work", "force", "name", "dir", "it", "full", "e", "log", "jar", "le", "book", "up", "path", "cache", "files", "local", "FILE", "line", "unit"], "fos": ["Foos", "infOS", "infoss", "Fio", " foos", "foss", " fOS", "Fos", "Foss", "bos", "afos", "infos", "fios", " fios", "boss", "fio", "infoos", "FOS", "afoss", "fOS", "infio", "infis", "foos", "infios", "afios", "Fios", "bis", " fio", "afOS", " foss", "bOS"], "b": ["sb", "cb", "bf", "d", "mb", "buffer", "be", "buff", "br", "pb", "l", "bc", "f", "base", "bd", "bytes", "r", "bs", "abb", "x", "e", "bb", "ob", "a", "buf", "v", "ba", "gb", "xb", "eb", "ib", "emb", "B", "ab", "db", "i", "wb", "nb", "boot", "lb", "rb", "p", "bl"], "c": ["size", "dc", "id", "d", "uc", "cy", "cm", "cu", "cf", "k", "fc", "l", "w", "con", "bc", "f", "ec", "cp", "n", "r", "enc", "xc", "sc", "ac", "pc", "x", "ci", "e", "o", "esc", "cl", "a", "m", "lc", "col", "count", "cr", "code", "i", "ce", "cc", "nc", "p", "C"]}}
{"id1": "6413929", "id2": "18042303", "code1": "    public HogsCustomizer() {\n        m_filename = PathFinder.getCustsFile();\n        m_currenttaunts = new String[10];\n        m_textfields = new JTextField[10];\n        m_color = new Color(255, 255, 255);\n        boolean exists = (new File(m_filename)).exists();\n        m_inverted = false;\n        m_chooser = new JColorChooser();\n        AbstractColorChooserPanel[] panels = m_chooser.getChooserPanels();\n        m_chooser.removeChooserPanel(panels[0]);\n        m_chooser.removeChooserPanel(panels[2]);\n        m_chooser.setPreviewPanel(new JPanel());\n        Reader reader = null;\n        if (exists) {\n            try {\n                reader = new FileReader(m_filename);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        } else {\n            Object[] options = { \"Yes\", \"No, Thanks\" };\n            int n = JOptionPane.showOptionDialog(this, \"You do not have a customization file in your home directory.\\n                 \" + \"Would you like to create one?\", \"Hogs Customization\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n            if (n == 0) {\n                try {\n                    FileChannel srcChannel = new FileInputStream(HogsConstants.CUSTS_TEMPLATE).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(m_filename).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    System.exit(0);\n                }\n            } else {\n                System.exit(0);\n            }\n            try {\n                reader = new FileReader(m_filename);\n            } catch (FileNotFoundException e1) {\n                e1.printStackTrace();\n                System.exit(0);\n            }\n        }\n        try {\n            readFromFile(reader);\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n        Box mainpanel = Box.createVerticalBox();\n        mainpanel.add(buildTauntsPanel());\n        mainpanel.add(buildMouseStylePanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        mainpanel.add(buildColorPanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        mainpanel.add(buildButtonsPanel());\n        mainpanel.add(Box.createVerticalStrut(10));\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setContentPane(mainpanel);\n        this.pack();\n        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n        this.setLocation(dim.width / 2 - (this.getWidth() / 2), dim.height / 2 - (this.getHeight() / 2));\n        this.setTitle(\"Hogs Customizer\");\n        this.setVisible(true);\n    }\n", "code2": "    @Override\n    public void view(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        boolean found = false;\n        String name = getArgument(request.getPathInfo());\n        if (StringUtils.contains(name, '/')) {\n            File file = new File(config.getProperty(Config.MULTIMEDIA_PATH) + Config.FILE_SEPARATOR + name);\n            if (file.exists() && file.isFile()) {\n                found = true;\n                MagicMatch match = Magic.getMagicMatch(file, true);\n                response.setContentType(match.getMimeType());\n                FileInputStream in = new FileInputStream(file);\n                IOUtils.copyLarge(in, response.getOutputStream());\n                in.close();\n            }\n        } else if (!StringUtils.isBlank(name)) {\n            int articleId = NumberUtils.toInt(name);\n            if (articleId > 0) {\n                Article article = articleDao.load(articleId);\n                if (article != null) {\n                    found = true;\n                    sendArticle(request, response, article);\n                }\n            }\n        } else {\n            int page = NumberUtils.toInt(request.getParameter(\"page\"), 0);\n            Date fromDate = null;\n            String from = request.getParameter(\"from\");\n            if (StringUtils.isNotBlank(from)) {\n                try {\n                    fromDate = dayMonthYearEn.parse(from);\n                } catch (ParseException e) {\n                }\n            }\n            Date untilDate = null;\n            String until = request.getParameter(\"until\");\n            if (StringUtils.isNotBlank(until)) {\n                try {\n                    untilDate = dayMonthYearEn.parse(until);\n                } catch (ParseException e) {\n                }\n            }\n            sendArticleList(request, response, articleDao.list(request.getParameter(\"query\"), request.getParameter(\"author\"), request.getParameter(\"tags\"), request.getParameterValues(\"types\"), fromDate, untilDate, page, HITS_PER_PAGE, null));\n            found = true;\n        }\n        if (found != true) {\n            response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n", "label": 1, "substitutes": {"m_filename": ["m_location", "M_selection", "m__source", "mockpath", "m___directory", "rm_username", " m_source", "m_resource", "m__file", " m_file", "m_file", "rmOCKfilename", "mOCKusername", "rmOCKnom", "mocknom", "m_path", "m2directory", "m2filename", "p_filename", "m___file", " m_directory", "M_url", "p_content", "mOCKfilename", "m2content", "m_content", "rm_nom", " m__directory", "m_url", "mockusername", " m__source", "rm_path", " m__filename", " m__file", "mockfilename", "m_nom", "M_directory", "p_directory", "mOCKpath", "m_username", "m__directory", "M_username", "m__filename", "m___filename", "m_directory", "rmOCKpath", "m2location", "m___source", "M_resource", "m_selection", "mOCKnom", "p_location", "rm_filename", "rmOCKusername", "m_source", "M_filename"], "m_currenttaunts": ["m_currentTitle", "m_currentxtidy", "m_contenttpl", "m_currenttitle", "m_currentfontidy", "m_currenttitles", "m_currentxtpl", "m_contentfontpl", "m_currentTitles", "m_currentfontitle", "m_currentxtitle", "m_contenttitles", "m_currenttpl", "m_currenttidy", "m_contenttidy", "m_contentfontitles", "m_contentfontitle", "m_contentfontidy", "m_contenttitle", "m_currentfontitles", "m_currentfontpl", "m_currentxtitles", "m_currentTidy", "m_currentTpl"], "m_textfields": ["m_inputfields", "m_textboxes", "m_fontfields", "m_buttons", "m_buttonfield", "m_fontboxes", "m_inputfield", "m_texts", "m_fonts", "m_fontfield", "m_buttonboxes", "m_inputboxes", "m_textfield", "m_buttonfields", "m_inputs"], "m_color": ["m__color", "M__background", "M__bg", "M_color", "M_theme", "M__theme", "m__theme", "m__background", "m_background", "M_background", "m_bg", "M_bg", "m__bg", "M__color", "m_theme"], "exists": [" existence", "expist", "existitions", "exits", "Exits", "exist", "Exists", "existence", "EXits", "Exceptions", "expails", "EXist", "existizes", "EXists", "fist", "exizes", "Exizes", "fists", "Exist", "exitions", "existists", "existinates", "EXinates", " exits", "Exinates", "EXistence", "Existence", "EXizes", "exceptions", "fails", "expitions", "exails", "exinates", "existist", "existails", "fitions", "expists", "EXceptions", " exceptions"], "m_chooser": ["m_colosing", "m_close", "m_joose", "m_suppinder", "m_compicker", "m_joerer", "m_choose", "m_boosed", "m_noicker", "m_boer", "m_boinder", "m_joosed", "mockchoinder", "mockboinder", "m_composer", "m_colosite", "m_choer", "m_booser", "m_defosite", "mockchooser", "mockchoerer", "m_composed", "m_noose", "m_noosing", "m_comperer", "m_closing", "mockbooser", "m_choinder", "m_cler", "m_boicker", "m_deferer", "m_boose", "m_choosed", "m_compose", "m_composing", "mockboerer", "m_boerer", "m_supposite", "m_choosing", "m_jooser", "m_composite", "mockboosite", "m_boosing", "m_nooser", "m_definder", "m_choosite", "m_defoser", "mockchoosite", "m_closer", "m_boosite", "m_coloser", "m_supposer", "m_colose", "m_supperer", "m_choicker", "m_choerer"], "panels": ["panagers", "Panels", "Panars", "panes", "panars", "panators", "panices", "polels", "Panors", "cholets", "Panes", "parenices", "spanagers", "choators", "Panlets", "parenels", "polars", "choels", "panlets", "spanels", "panors", "choes", "choagers", "colators", "polices", "Panators", "spanices", " panices", "coles", "polors", "parenors", "choices", "spanes", " panagers", " panes", "Panices", "parenars", "colels", "collets"], "reader": ["source", "read", "h", "draft", "input", "wrapper", "rx", "Reader", "feed", "connection", "buffer", "result", "iter", "player", "io", "ry", "driver", "ler", "client", "lr", "part", "row", "f", "loader", "data", "worker", "stream", "r", "resource", "handler", "server", "author", "writer", "inner", "er", "rc", "e", "reading", "per", "parser", "instance", "dr", "key", "book", "ri", "image", "library", "file", "or", "service", "manager", "rr", "value", "null", "entry"], "options": ["opens", "comments", "value", "Options", "none", "open", "settings", "lines", "io", "optional", "example", "items", "params", "object", "types", "data", "no", "choice", "style", "multiple", "objects", "es", "changes", "info", "groups", "results", "e", "other", "o", "values", "text", "names", "content", "ops", "obj", "html", "details", "times", "files", "zero", "empty", "option", "ts", "ps", "s", "p", "type"], "n": ["en", "num", "nl", "ln", "d", "l", "y", "out", "b", "ns", "f", "number", "r", "ni", "dn", "nor", "adj", "ne", "u", "o", "s", "e", "nt", "fn", "t", "m", "nu", "norm", "count", "N", "don", "j", "c", "i", "g", "un", "pn", "nb", "sn", "z", "nc", "p"], "srcChannel": ["instChannel", "destClient", "srcchannel", "instGate", "inputClient", "inputButton", "srcClient", " srcButton", "rcChan", " srcChan", "destChan", "srcServer", "inputConnection", " srcServer", " srcStream", " srcConnection", "destchannel", "rcchannel", "srcChan", "rcChannel", " srcGate", "instStream", "inputChannel", "instChan", "inputchannel", "distChannel", "destServer", "destConnection", "inputChan", "rcConnection", "destChannel", "distChan", "distGate", "srcGate", "srcStream", "inputServer", " srcchannel", " srcClient", "rcButton", "distStream", "srcConnection", "srcButton"], "dstChannel": ["DndMessage", "ddestChan", "dstsChan", "ddestchannel", "DndButton", "Ddestchannel", "dostChannel", "dirstchannel", "DstButton", "ddestChannel", "drcChannel", "dndchannel", "DstChan", "dndContext", "dstFlow", "dostChan", "dndMessage", "drcMessage", "dirstChan", "dstContext", "DstChannel", "dostchannel", "dsrcchannel", "DdestFlow", "DstMessage", "dstButton", "Dstschannel", "Dndchannel", "dstsFlow", "DstFlow", "dstChan", "DndChannel", "dstMessage", "DstsContext", "dstsContext", "dndChan", "dstschannel", "drcchannel", "dsrcChannel", "drcButton", "dirstFlow", "dostContext", "DstsChan", "ddestFlow", "dsrcMessage", "dndChannel", "dirstChannel", "DstContext", "dsrcButton", "Dstchannel", "DdestChan", "DstsChannel", "DdestChannel", "dstchannel", "dndButton", "dstsChannel"]}}
{"id1": "21459233", "id2": "16190704", "code1": "    private static IProject createCopyProject(IProject project, String pName, IWorkspace ws, IProgressMonitor pm) throws Exception {\n        pm.beginTask(\"Creating temp project\", 1);\n        IPath destination = new Path(pName);\n        IJavaProject oldJavaproj = JavaCore.create(project);\n        IClasspathEntry[] classPath = oldJavaproj.getRawClasspath();\n        IProject newProject = ResourcesPlugin.getWorkspace().getRoot().getProject(pName);\n        newProject.create(null);\n        newProject.open(null);\n        IProjectDescription desc = newProject.getDescription();\n        desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n        newProject.setDescription(desc, null);\n        List<IClasspathEntry> newClassPath = new ArrayList<IClasspathEntry>();\n        for (IClasspathEntry cEntry : classPath) {\n            switch(cEntry.getEntryKind()) {\n                case IClasspathEntry.CPE_SOURCE:\n                    System.out.println(\"Source folder \" + cEntry.getPath());\n                    newClassPath.add(copySourceFolder(project, newProject, cEntry, destination));\n                    break;\n                case IClasspathEntry.CPE_LIBRARY:\n                    System.out.println(\"library folder \" + cEntry.getPath());\n                    newClassPath.add(cEntry);\n                    break;\n                case IClasspathEntry.CPE_PROJECT:\n                    System.out.println(\"project folder \" + cEntry.getPath());\n                    newClassPath.add(cEntry);\n                    break;\n                case IClasspathEntry.CPE_VARIABLE:\n                    System.out.println(\"variable folder \" + cEntry.getPath());\n                    newClassPath.add(cEntry);\n                    break;\n                default:\n                    System.out.println(\"container folder \" + cEntry.getPath());\n                    newClassPath.add(cEntry);\n            }\n        }\n        copyDir(project.getLocation().toString(), \"/translator\", newProject.getLocation().toString(), \"\", new ArrayList<String>() {\n\n            {\n                add(\"generated\");\n                add(\"classes\");\n                add(\".svn\");\n            }\n        });\n        newProject.refreshLocal(IResource.DEPTH_INFINITE, pm);\n        newProject.build(IncrementalProjectBuilder.AUTO_BUILD, pm);\n        newProject.touch(pm);\n        IJavaProject javaproj = JavaCore.create(newProject);\n        javaproj.setOutputLocation(new Path(\"/\" + newProject.getName() + \"/classes/bin\"), null);\n        javaproj.setRawClasspath(newClassPath.toArray(new IClasspathEntry[newClassPath.size()]), pm);\n        Map opts = oldJavaproj.getOptions(true);\n        javaproj.setOptions(opts);\n        javaproj.makeConsistent(pm);\n        javaproj.save(pm, true);\n        return newProject;\n    }\n", "code2": "    public static String exchangeForSessionToken(String protocol, String domain, String onetimeUseToken, PrivateKey key) throws IOException, GeneralSecurityException, AuthenticationException {\n        String sessionUrl = getSessionTokenUrl(protocol, domain);\n        URL url = new URL(sessionUrl);\n        HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();\n        String header = formAuthorizationHeader(onetimeUseToken, key, url, \"GET\");\n        httpConn.setRequestProperty(\"Authorization\", header);\n        if (httpConn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new AuthenticationException(httpConn.getResponseCode() + \": \" + httpConn.getResponseMessage());\n        }\n        String body = CharStreams.toString(new InputStreamReader(httpConn.getInputStream(), Charsets.ISO_8859_1));\n        Map<String, String> parsedTokens = StringUtil.string2Map(body, \"\\n\", \"=\", true);\n        parsedTokens = StringUtil.lowercaseKeys(parsedTokens);\n        return parsedTokens.get(\"token\");\n    }\n", "label": 0, "substitutes": {"project": ["source", "resources", "folder", "parent", "program", "contract", "Project", "input", "queue", "task", "connection", "product", "reference", "plugin", "build", "result", "output", "python", "lib", "view", "app", "home", "object", "client", "request", "base", "application", "profile", "directory", "future", "version", "class", "zip", "ruby", "resource", "prefix", "archive", "system", "config", "primary", "tool", "module", "name", "component", "target", "report", "text", "job", "book", "path", "document", "file", "context", "code", "command", "projects", "property", "database", "process", "subject", "proxy", "port", "p", "type"], "pName": ["pNames", "pname", " pVersion", "gNAME", " pNames", "packagename", "pVersion", "cpname", "PName", " pname", "gName", "PNames", "Pname", "cpVersion", " pNAME", " pInfo", "cpName", "packageName", "PNAME", "pNAME", "pInfo", "PVersion", "gname", "packageInfo", "cpNames", "PInfo"], "ws": ["works", "paces", "space", "widget", "wx", "wd", "w", "sw", "Ws", "wh", "work", "resource", "writer", "WS", "wp", " wh", " works", " swap", " wid", " wa", "workshop", "rw", "wordpress", "ww", " WS", "wid", "www", "RW", "wr"], "pm": [" mp", "lp", " pp", "PT", "P", "BM", "cm", "jp", "pb", "mm", "pd", "am", "ps", "fp", " pr", "ym", "po", "bm", "cp", "wm", "vim", "dp", "pc", "pa", "mp", "tp", "rpm", "gm", "dm", "rm", "pr", "m", "WM", "pt", " am", "TP", "mr", " p", "pp", " cm", "pi", "fm", "PM", "mi", "pl", " PM", "p"], "destination": ["destinate", "Desturation", "declination", " destinations", "desturation", "declinations", "decluration", "Destinate", " destinate", "continations", "contribution", "destinations", "Destinations", "contination", " destribution", " desturation", "continate", "destribution", "declribution", "Destination", "Destribution"], "oldJavaproj": ["oldJavaprobjs", "oldJavapROj", "oldJavarrojo", "oldJavaprobJ", "oldJavaprajs", "oldJavapROji", "oldJavatraji", "oldJavarrijs", "oldJavapriJ", "oldJavaprajo", "oldJavapraj", "oldJavaprojs", "oldJavaprobj", "oldJavaprijs", "oldJavatraJ", "oldJavatroJ", "oldJavatrojs", "oldJavaprojo", "oldJavaproji", "oldJavaprij", "oldJavarroJ", "oldJavapROJ", "oldJavatrajs", "oldJavapriji", "oldJavarrij", "oldJavaprijo", "oldJavapraJ", "oldJavarriJ", "oldJavarrojs", "oldJavapROjs", "oldJavaproJ", "oldJavarroj", "oldJavapraji", "oldJavaprobjo", "oldJavatroj", "oldJavatraj", "oldJavarrijo", "oldJavatroji"], "classPath": ["ClassData", " classList", "classList", "packagePath", "classPATH", " classpath", "ClassPATH", "classpath", "ClassPath", "packagePATH", "lassPath", "lasspath", "ClassList", "lassList", " classPATH", "classData", "packagepath", "lassData", " classData", "Classpath", "packageList"], "newProject": ["newproject", "oldProject", "sameProject", "Newproject", " newConfig", "oldDirectory", "oldFolder", "NewPath", "newsproject", "newText", "nextPath", "oldConfig", " newDirectory", "nowproject", "oldText", "nextZip", "nowProject", "newsFolder", "NewZip", "oldModule", " newZip", "oldZip", "newPath", "NewFile", "nextproject", "newJob", "nowConfig", "nowJob", "oldproject", "NewFolder", " newJob", "sameFolder", "newFile", "newFolder", "newsProject", "NewConfig", " newServer", "NewDirectory", "newZip", "newConfig", "oldFile", "NewJob", " newModule", " newText", "newServer", "oldServer", "newModule", "sameText", "NewModule", "sameproject", "NewProject", " newproject", " newPath", "NewServer", "newDirectory", " newFile", "nextProject", " newFolder", "newsConfig"], "desc": ["dec", "attr", "contract", "dc", "id", "en", "anc", "default", "des", "txt", "uc", "dep", "dev", " description", "doc", "src", "aux", "description", "loc", "def", "neg", "summary", "Desc", "sc", "config", "info", "meta", "dest", "sub", "sup", "name", "rc", "de", "esc", "nt", "text", "comment", "rec", "sec", "asc", "type", "dist", "Description", "bot", "ca", "env", "ext"], "newClassPath": ["NewFileTree", " newClassURL", "newPackageFile", "newResourcePath", " newPackagepath", "newClasspath", "NewClasspath", "newclassPath", "newResourceList", " newPackageFile", " newClassName", "newFileFolder", "newLanguagePath", "newClassArray", "newClassName", "newclasspath", "newClassFolder", "newClassTree", "newclassList", " newclassFolder", "newPackagepath", " newClassList", "newPackageName", "NewFilePath", "newPackageArray", " newClassArray", " newPackagePath", " newClassMember", " newclassList", "newPackageTree", "newResourceFolder", "newPackageMember", " newClassFile", "newclassName", "newFilepath", "newClassList", "NewFilepath", " newPackageArray", "NewFileList", "NewClassTree", "NewClassPath", "newFilePath", " newPackageURL", "newSiteTree", "newClassMember", " newPackageMember", "newPackagePath", "newclassMember", " newclassPath", "newLanguageMember", "newSitePath", " newClasspath", "newClassURL", "newLanguagepath", "newSitepath", " newclasspath", "newPackageURL", "NewClassList", "newFileList", "newclassFolder", "newSiteList", "newFileTree", "newResourcepath", " newPackageName", "newClassFile", "newclassArray", "newPackageList", " newClassFolder"], "cEntry": ["ecEnt", "fElement", " cEnter", "CEnt", "lcEnt", "lcElement", "CError", "cResource", "pElement", "pEntry", "pEnter", "ecEnter", "lcentry", "fentry", "fEnter", " cRoute", "fcEnt", "lentry", "cEnt", "fcEntry", "cEx", "lRoute", "cRoute", "lEntry", "CEntry", " cEx", "pError", "lcAdd", " cError", "cError", "fcentry", " centry", "lcRoute", "fcEnter", "fEnt", "crentry", "rcEntry", "fError", "centry", "lcData", "lcEnter", "rcEnt", "cacheElement", "ecEntry", "cEnter", "fcResource", "crEnt", " cAdd", "fcEx", " cResource", "CEx", "lEnt", "crEx", "crEntry", "CEnter", " cElement", "cElement", " cData", " cEnt", "lcResource", "cacheEntry", "fEntry", "Centry", "rcEnter", "ecError", "cacheEnt", "cData", "rcData", "CAdd", "pentry", "CElement", "lcEx", "lcError", "pEnt", "cacheEnter", "lcEntry", "cAdd"]}}
{"id1": "7550876", "id2": "7099534", "code1": "    public void test(TestHarness harness) {\n        harness.checkPoint(\"TestOfMD4\");\n        try {\n            Security.addProvider(new JarsyncProvider());\n            algorithm = MessageDigest.getInstance(\"MD4\", \"JARSYNC\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.provider\");\n            throw new Error(x);\n        }\n        try {\n            for (int i = 0; i < 64; i++) algorithm.update((byte) 'a');\n            byte[] md = algorithm.digest();\n            String exp = \"52f5076fabd22680234a3fa9f9dc5732\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testSixtyFourA\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.provider\");\n        }\n        try {\n            harness.verbose(\"NOTE: This test may take a while.\");\n            for (int i = 0; i < 536870913; i++) algorithm.update((byte) 'a');\n            byte[] md = algorithm.digest();\n            String exp = \"47d01fa6657f903280232d30b98da482\";\n            harness.check(exp.equals(Util.toHexString(md)), \"test536870913A\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.provider\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"a\".getBytes());\n            String exp = \"bde52cb31de33e46245e05fbdbd6fb24\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testA\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testA\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"abc\".getBytes());\n            String exp = \"a448017aaf21d8525fc10ae87aa6729d\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testABC\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testABC\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"message digest\".getBytes());\n            String exp = \"d9130a8164549fe818874806e1c7014b\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testMessageDigest\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testMessageDigest\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"abcdefghijklmnopqrstuvwxyz\".getBytes());\n            String exp = \"d79e1c308aa5bbcdeea8ed63df412da9\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testAlphabet\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testAlphabet\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".getBytes());\n            String exp = \"043f8582f241db351ce627e153e7f0e4\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testAsciiSubset\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testAsciiSubset\");\n        }\n        try {\n            byte[] md = algorithm.digest(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\".getBytes());\n            String exp = \"e33b4ddc9c38f2199c3e7b164fcc0536\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testEightyNumerics\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testEightyNumerics\");\n        }\n        try {\n            algorithm.update(\"a\".getBytes(), 0, 1);\n            clone = (MessageDigest) algorithm.clone();\n            byte[] md = algorithm.digest();\n            String exp = \"bde52cb31de33e46245e05fbdbd6fb24\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testCloning #1\");\n            clone.update(\"bc\".getBytes(), 0, 2);\n            md = clone.digest();\n            exp = \"a448017aaf21d8525fc10ae87aa6729d\";\n            harness.check(exp.equals(Util.toHexString(md)), \"testCloning #2\");\n        } catch (Exception x) {\n            harness.debug(x);\n            harness.fail(\"TestOfMD4.testCloning\");\n        }\n    }\n", "code2": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "label": 1, "substitutes": {"harness": [" harner", "borresh", " harrity", "arinvey", "houvey", "harler", "arity", "hansession", "harning", "hanment", "Harler", "harner", "harvey", "arinvest", "harservice", "borment", "harly", "arinment", " haress", "warness", "harresh", "warrity", "Harself", "warith", "hasystem", "carness", "earness", "warself", "haress", " harest", "arest", "carner", "carest", " harsystem", " harself", "warly", "houity", "hase", "harnesses", "houness", "garsession", "harity", "ighest", "garnesses", "arith", "borvey", "horvest", "fullness", "harith", "haity", "Harna", "horresh", " harning", "fullresh", " harly", "earse", "warment", "ighment", "garself", "arsession", " harvey", "harment", "hansystem", "garvey", "horness", "garness", "earity", " harment", "harna", "houess", "Harse", "Harning", "Harnesses", "harrity", " harler", "warservice", " harsession", " harna", "garler", "hanness", "hanself", "Harrity", "harself", "arinresh", "Harness", "hanith", "hanesses", "harest", " harity", "garess", "ighner", "garity", "arservice", "arinness", "Harly", "Harsystem", "haness", "warse", "garsystem", " harservice", " harse", "Harservice", "hanity", "harsystem", " harnesses", "carment", "harsession", "warna", "arment", "earning", "Harity", "warsession", "borness", "haservice", "harse", "garservice", "fullvey", "ighness", "horvey", "garment", " harresh", "arness", "harvest", "fullvest", "Harest", "arna"], "algorithm": ["aligorith", " alsystem", "Algo", " aluminum", "Alapter", "updategorithm", "allmbol", "allgo", "opersystem", "allapter", "alphgorithm", "updategorith", "aligngebra", "aruminum", "Algorithm", "alphknowledge", "omalrator", " alapter", " algorith", " alider", "halgorith", "aladdin", "opergebra", "aligment", "aligngment", "alpassword", "alider", "aluminum", "chalpassword", "halgment", "updaterator", "halgorithm", "aligebra", "allgorithm", "logaddin", "elgebra", "alapter", "allsystem", "algebra", " algebra", "Alpassword", "aligngorith", "unalgorithm", "alrator", "aligngorithm", "Alipher", "elider", "Alknowledge", "argorithm", " algo", "aligorithm", "chalipher", "Algebra", "alphpassword", "Alrator", "alknowledge", "logsystem", "unalchant", " aladdin", "alsystem", "alladdin", "almbol", "updatechant", "algorith", "halgebra", "elgorithm", "arrator", "loggorithm", "chalgorithm", " alrator", "omalgorithm", "omalgorith", "argorith", "algment", "alipher", "Algorith", "alchant", "opergorithm", "elsystem", "algo", "allgebra", "alphipher", " almbol", "chalknowledge", "logmbol", "Alchant", "unalrator", "omaluminum", "unalgorith", "operider"], "i": ["h", "id", "si", "d", "qi", "multi", "abi", "uli", "min", "iu", "phi", "k", "io", "yi", "y", "in", "b", "f", "base", "di", "bi", "zi", "n", "I", "ti", "ji", "ai", "info", "gi", "inner", "ni", "adi", "x", "ix", "it", "ui", "ci", "u", "o", "init", "ski", "ini", "m", "li", "v", "xi", "index", "ri", "slice", "gu", "j", "c", "uri", "ii", "pi", "is", "fi", "chi", "mi", "mini", "ip", "p", "ie"], "md": ["id", "dc", "msg", "cd", "mb", "d", "mid", "dd", "ld", "ind", "hd", "sm", "mm", "doc", "lim", "ma", "vd", "gd", "dev", "mem", "cmd", "ms", "diff", "mode", "magic", "mo", "bd", "data", "zip", "mand", "mag", "meta", "mc", "pad", "fun", "sha", "desc", "body", "dm", "MD", "m", "dr", "od", "pm", "oda", "help", "html", "mg", "db", "mad", "med", "metadata", "nd", "amd", "sd", "ng", "nm", "dig", "mn"], "exp": ["host", "div", "expl", "plus", "str", "msg", "inc", "lit", "xml", "rep", "doc", "mem", "lib", "format", "ez", "app", "Exp", "op", "prop", "isp", "imp", "EXP", "magic", "hex", "style", "zip", "enc", "comp", "box", "raw", "push", "fun", "exec", "script", "desc", "ix", "scope", "feat", "printf", "spec", "ef", "act", "api", "express", "ex", "orig", "sp", "reg", "file", "html", "code", "vec", "err", "xp", "np", "field", "expr", "form", "ng", "acc", "ip", "ext"]}}
{"id1": "14733077", "id2": "20833509", "code1": "    private static String encryptMD5(String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xff & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "code2": "    protected String doIt() throws java.lang.Exception {\n        StringBuffer sql = null;\n        int no = 0;\n        String clientCheck = \" AND AD_Client_ID=\" + m_AD_Client_ID;\n        if (m_deleteOldImported) {\n            sql = new StringBuffer(\"DELETE I_BPartner \" + \"WHERE I_IsImported='Y'\").append(clientCheck);\n            no = DB.executeUpdate(sql.toString());\n            log.fine(\"Delete Old Impored =\" + no);\n        }\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET AD_Client_ID = COALESCE(AD_Client_ID, \").append(m_AD_Client_ID).append(\"),\" + \" AD_Org_ID = COALESCE(AD_Org_ID, 0),\" + \" IsActive = COALESCE(IsActive, 'Y'),\" + \" Created = COALESCE(Created, current_timestamp),\" + \" CreatedBy = COALESCE(CreatedBy, 0),\" + \" Updated = COALESCE(Updated, current_timestamp),\" + \" UpdatedBy = COALESCE(UpdatedBy, 0),\" + \" I_ErrorMsg = '',\" + \" I_IsImported = 'N' \" + \"WHERE I_IsImported<>'Y' OR I_IsImported IS NULL\");\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Reset=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET GroupValue=(SELECT Value FROM C_BP_Group g WHERE g.IsDefault='Y'\" + \" AND g.AD_Client_ID=i.AD_Client_ID AND ROWNUM=1) \" + \"WHERE GroupValue IS NULL AND C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Group Default=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BP_Group_ID=(SELECT C_BP_Group_ID FROM C_BP_Group g\" + \" WHERE i.GroupValue=g.Value AND g.AD_Client_ID=i.AD_Client_ID ORDER BY g.IsDefault DESC LIMIT 1) \" + \"WHERE C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Group=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'\" + getMsg(\"ImportBPInvalidGroup\") + \". ' \" + \"WHERE C_BP_Group_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.config(\"Invalid Group=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET CountryCode=(SELECT CountryCode FROM C_Country c WHERE c.isactive='Y'\" + \" AND c.AD_Client_ID IN (0, i.AD_Client_ID) AND ROWNUM=1) \" + \"WHERE CountryCode IS NULL AND C_Country_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Country Default=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Country_ID=(SELECT C_Country_ID FROM C_Country c\" + \" WHERE i.CountryCode=c.CountryCode AND c.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Country_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Country=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'\" + getMsg(\"ImportBPInvalidCountry\") + \". ' \" + \"WHERE C_Country_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.config(\"Invalid Country=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"Set RegionName=(SELECT Name FROM C_Region r\" + \" WHERE r.IsDefault='Y' AND r.C_Country_ID=i.C_Country_ID\" + \" AND r.AD_Client_ID IN (0, i.AD_Client_ID) AND ROWNUM=1) \" + \"WHERE RegionName IS NULL AND C_Region_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Region Default=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"Set C_Region_ID=(SELECT C_Region_ID FROM C_Region r\" + \" WHERE r.Name=i.RegionName AND r.C_Country_ID=i.C_Country_ID\" + \" AND r.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Region_ID IS NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Region=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'\" + getMsg(\"ImportBPInvalidRegion\") + \". ' \" + \" WHERE C_Region_ID IS NULL \" + \" AND EXISTS (SELECT * FROM C_Country c\" + \" WHERE c.C_Country_ID=i.C_Country_ID AND c.HasRegion='Y')\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.config(\"Invalid Region=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET BPContactGreeting=NULL WHERE C_Greeting_ID IS NULL AND char_length(trim(BPContactGreeting)) = 0 AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Reset Greeting=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Greeting_ID=(SELECT C_Greeting_ID FROM C_Greeting g\" + \" WHERE i.BPContactGreeting=g.Name AND g.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE C_Greeting_ID IS NULL AND BPContactGreeting IS NOT NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Greeting=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||'\" + getMsg(\"ImportBPInvalidGreeting\") + \". ' \" + \"WHERE C_Greeting_ID IS NULL AND BPContactGreeting IS NOT NULL\" + \" AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.config(\"Invalid Greeting=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BPartner_ID=(SELECT C_BPartner_ID FROM C_BPartner p\" + \" WHERE i.Value=p.Value AND p.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE C_BPartner_ID IS NULL AND Value IS NOT NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Found BPartner=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET AD_User_ID=(SELECT AD_User_ID FROM AD_User c\" + \" WHERE i.ContactName=c.Name AND i.C_BPartner_ID=c.C_BPartner_ID AND c.AD_Client_ID=i.AD_Client_ID) \" + \"WHERE C_BPartner_ID IS NOT NULL AND AD_User_ID IS NULL AND ContactName IS NOT NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Found Contact=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_BPartner_Location_ID=(SELECT C_BPartner_Location_ID\" + \" FROM C_BPartner_Location bpl INNER JOIN C_Location l ON (bpl.C_Location_ID=l.C_Location_ID)\" + \" WHERE i.C_BPartner_ID=bpl.C_BPartner_ID AND bpl.AD_Client_ID=i.AD_Client_ID\" + \" AND DUMP(i.Address1)=DUMP(l.Address1) AND DUMP(i.Address2)=DUMP(l.Address2)\" + \" AND DUMP(i.City)=DUMP(l.City) AND DUMP(i.Postal)=DUMP(l.Postal) AND DUMP(i.Postal_Add)=DUMP(l.Postal_Add)\" + \" AND DUMP(i.C_Region_ID)=DUMP(l.C_Region_ID) AND DUMP(i.C_Country_ID)=DUMP(l.C_Country_ID)) \" + \"WHERE C_BPartner_ID IS NOT NULL AND C_BPartner_Location_ID IS NULL\" + \" AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Found Location=\" + no);\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Categoria_IVA_Codigo=\" + MCategoriaIva.CONSUMIDOR_FINAL + \" WHERE (C_Categoria_IVA_Codigo IS NULL OR C_Categoria_IVA_Codigo = 0) \" + \"  AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET C_Categoria_IVA_ID= \" + \" (SELECT C_Categoria_IVA_ID \" + \"  FROM C_Categoria_IVA c \" + \"  WHERE i.C_Categoria_IVA_Codigo=c.Codigo AND c.AD_Client_ID=i.AD_Client_ID \" + \" ) \" + \"WHERE C_Categoria_IVA_ID IS NULL \" + \"  AND I_IsImported='N'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET SalesRep_ID=(SELECT AD_User_ID \" + \"FROM AD_User u \" + \"WHERE u.Name = i.SalesRep_Name AND u.AD_Client_ID IN (0, i.AD_Client_ID)) \" + \"WHERE SalesRep_ID IS NULL \" + \"AND I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        log.fine(\"Set Country=\" + no);\n        int noInsert = 0;\n        int noUpdate = 0;\n        sql = new StringBuffer(\"SELECT I_BPartner_ID, C_BPartner_ID,\" + \"C_BPartner_Location_ID,COALESCE(Address1,Address2,City,RegionName,CountryCode),\" + \"AD_User_ID,ContactName \" + \"FROM I_BPartner \" + \"WHERE I_IsImported='N'\").append(clientCheck);\n        Connection conn = DB.createConnection(false, Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            log.info(\"En importBPartbner antes de hacer el update en c_BPartner\");\n            PreparedStatement pstmt_updateBPartner = conn.prepareStatement(\"UPDATE C_BPartner \" + \"SET Value=aux.Value\" + \",Name=aux.Name\" + \",Name2=aux.Name2\" + \",Description=aux.Description\" + \",DUNS=aux.DUNS\" + \",TaxID=aux.TaxID\" + \",NAICS=aux.NAICS\" + \",C_BP_Group_ID=aux.C_BP_Group_ID\" + \",Updated=current_timestamp\" + \",UpdatedBy=aux.UpdatedBy\" + \",IIBB=aux.IIBB\" + \" from (SELECT Value,Name,Name2,Description,DUNS,TaxID,NAICS,C_BP_Group_ID,UpdatedBy,IIBB FROM I_BPartner WHERE I_BPartner_ID=?) as aux\" + \" WHERE C_BPartner_ID=?\");\n            log.info(\"En importBPartbner despues de hacer el update en c_BPartner\");\n            PreparedStatement pstmt_insertLocation = conn.prepareStatement(\"INSERT INTO C_Location (C_Location_ID,\" + \"AD_Client_ID,AD_Org_ID,IsActive,Created,CreatedBy,Updated,UpdatedBy,\" + \"Address1,Address2,City,Postal,Postal_Add,C_Country_ID,C_Region_ID) \" + \"SELECT ?,\" + \"AD_Client_ID,AD_Org_ID,'Y',current_timestamp,CreatedBy,current_timestamp,UpdatedBy,\" + \"Address1,Address2,City,Postal,Postal_Add,C_Country_ID,C_Region_ID \" + \"FROM I_BPartner \" + \"WHERE I_BPartner_ID=?\");\n            PreparedStatement pstmt_insertBPLocation = conn.prepareStatement(\"INSERT INTO C_BPartner_Location ( \" + \"\tC_BPartner_Location_ID,\" + \"\tAD_Client_ID,\" + \"\tAD_Org_ID,\" + \"\tIsActive,\" + \"\tCreated,\" + \"\tCreatedBy,\" + \"\tUpdated,\" + \"\tUpdatedBy,\" + \"\tName,\" + \"\tIsBillTo,\" + \"\tIsShipTo,\" + \"\tIsPayFrom,\" + \"\tIsRemitTo,\" + \"\tPhone,\" + \"\tPhone2,\" + \"\tFax,\" + \"\tC_BPartner_ID,\" + \"\tC_Location_ID) \" + \"SELECT ?,AD_Client_ID,AD_Org_ID,'Y',current_timestamp,CreatedBy,current_timestamp,UpdatedBy,\" + \"CASE WHEN char_length(trim(coalesce(address1,''))) > 0 THEN address1 \" + \"     WHEN char_length(trim(coalesce(city,''))) > 0 THEN city \" + \"     WHEN char_length(trim(coalesce(regionname,''))) > 0 THEN regionname \" + \"     ELSE name \" + \"END,\" + \"'Y','Y','Y','Y',\" + \"Phone,Phone2,Fax, ?,? \" + \"FROM I_BPartner \" + \"WHERE I_BPartner_ID=?\");\n            PreparedStatement pstmt_insertBPContact = conn.prepareStatement(\"INSERT INTO AD_User (AD_User_ID,\" + \"AD_Client_ID,AD_Org_ID,IsActive,Created,CreatedBy,Updated,UpdatedBy,\" + \"C_BPartner_ID,C_BPartner_Location_ID,C_Greeting_ID,\" + \"Name,Title,Description,Comments,Phone,Phone2,Fax,EMail,Birthday) \" + \"SELECT ?,\" + \"AD_Client_ID,AD_Org_ID,'Y',current_timestamp,CreatedBy,current_timestamp,UpdatedBy,\" + \"?,?,C_Greeting_ID,\" + \"ContactName,Title,ContactDescription,Comments,Phone,Phone2,Fax,EMail,Birthday \" + \"FROM I_BPartner \" + \" WHERE I_BPartner_ID=?\");\n            PreparedStatement pstmt_updateBPContact = conn.prepareStatement(\"UPDATE AD_User \" + \"SET C_Greeting_ID=aux1.C_Greeting_ID\" + \",Name=aux1.Name\" + \",Title=aux1.Title\" + \",Description=aux1.Description\" + \",Comments=aux1.Commets\" + \",Phone=aux1.Phone\" + \",Phone2=aux1.Phone2\" + \",Fax=aux1.Fax\" + \",EMail=aux1.EMail\" + \",Birthday=aux1.Birthaday\" + \",Updated=current_timestamp\" + \",UpdatedBy=aux1.UpdatedBy\" + \" from (SELECT C_Greeting_ID,ContactName,Title,ContactDescription,Comments,Phone,Phone2,Fax,EMail,Birthday,UpdatedBy FROM I_BPartner WHERE I_BPartner_ID=?) as aux1\" + \" WHERE AD_User_ID=?\");\n            PreparedStatement pstmt_setImported = conn.prepareStatement(\"UPDATE I_BPartner SET I_IsImported='Y',\" + \" C_BPartner_ID=?, C_BPartner_Location_ID=?, AD_User_ID=?, \" + \" Updated=current_timestamp, Processed='Y' WHERE I_BPartner_ID=?\");\n            PreparedStatement pstmt = DB.prepareStatement(sql.toString());\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                int I_BPartner_ID = rs.getInt(1);\n                int C_BPartner_ID = rs.getInt(2);\n                boolean newBPartner = C_BPartner_ID == 0;\n                int C_BPartner_Location_ID = rs.getInt(3);\n                String newLocali = rs.getString(4);\n                boolean newLocation = rs.getString(4) != null;\n                int AD_User_ID = rs.getInt(5);\n                boolean newContact = rs.getString(6) != null;\n                log.fine(\"I_BPartner_ID=\" + I_BPartner_ID + \", C_BPartner_ID=\" + C_BPartner_ID + \", C_BPartner_Location_ID=\" + C_BPartner_Location_ID + \" create=\" + newLocation + \", AD_User_ID=\" + AD_User_ID + \" create=\" + newContact);\n                if (newBPartner) {\n                    X_I_BPartner iBP = new X_I_BPartner(getCtx(), I_BPartner_ID, null);\n                    MBPartner bp = new MBPartner(iBP);\n                    if (bp.save()) {\n                        C_BPartner_ID = bp.getC_BPartner_ID();\n                        log.finest(\"Insert BPartner\");\n                        noInsert++;\n                    } else {\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Insert BPartner failed: \" + CLogger.retrieveErrorAsString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                } else {\n                    pstmt_updateBPartner.setInt(1, I_BPartner_ID);\n                    pstmt_updateBPartner.setInt(2, C_BPartner_ID);\n                    try {\n                        no = pstmt_updateBPartner.executeUpdate();\n                        log.finest(\"Update BPartner = \" + no);\n                        noUpdate++;\n                    } catch (SQLException ex) {\n                        log.finest(\"Update BPartner -- \" + ex.toString());\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Update BPartner: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                }\n                if (C_BPartner_Location_ID != 0) {\n                } else if (newLocation) {\n                    int C_Location_ID = 0;\n                    try {\n                        C_Location_ID = DB.getNextID(m_AD_Client_ID, \"C_Location\", null);\n                        if (C_Location_ID <= 0) {\n                            throw new DBException(\"No NextID (\" + C_Location_ID + \")\");\n                        }\n                        pstmt_insertLocation.setInt(1, C_Location_ID);\n                        pstmt_insertLocation.setInt(2, I_BPartner_ID);\n                        no = pstmt_insertLocation.executeUpdate();\n                        log.finest(\"Insert Location = \" + no);\n                    } catch (SQLException ex) {\n                        log.finest(\"Insert Location - \" + ex.toString());\n                        conn.rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Insert Location: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                    try {\n                        C_BPartner_Location_ID = (DB.getNextID(m_AD_Client_ID, \"C_BPartner_Location\", null));\n                        log.finest(\"C_BPartner_Location_ID es : \" + C_BPartner_Location_ID);\n                        if (C_BPartner_Location_ID <= 0) {\n                            throw new DBException(\"No NextID (\" + C_BPartner_Location_ID + \")\");\n                        }\n                        pstmt_insertBPLocation.setInt(1, C_BPartner_Location_ID);\n                        pstmt_insertBPLocation.setInt(2, C_BPartner_ID);\n                        pstmt_insertBPLocation.setInt(3, C_Location_ID);\n                        pstmt_insertBPLocation.setInt(4, I_BPartner_ID);\n                        no = pstmt_insertBPLocation.executeUpdate();\n                        log.finest(\"Insert BP Location = \" + no);\n                    } catch (Exception ex) {\n                        log.finest(\"Insert BPLocation - \" + ex.toString());\n                        conn.rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Insert BPLocation: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                }\n                if (AD_User_ID != 0) {\n                    pstmt_updateBPContact.setInt(1, I_BPartner_ID);\n                    pstmt_updateBPContact.setInt(2, AD_User_ID);\n                    try {\n                        no = pstmt_updateBPContact.executeUpdate();\n                        log.finest(\"Update BP Contact = \" + no);\n                    } catch (SQLException ex) {\n                        log.finest(\"Update BP Contact - \" + ex.toString());\n                        conn.rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Update BP Contact: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                } else if (newContact) {\n                    try {\n                        AD_User_ID = DB.getNextID(m_AD_Client_ID, \"AD_User\", null);\n                        if (AD_User_ID <= 0) {\n                            throw new DBException(\"No NextID (\" + AD_User_ID + \")\");\n                        }\n                        pstmt_insertBPContact.setInt(1, AD_User_ID);\n                        pstmt_insertBPContact.setInt(2, C_BPartner_ID);\n                        if (C_BPartner_Location_ID == 0) {\n                            pstmt_insertBPContact.setNull(3, Types.NUMERIC);\n                        } else {\n                            pstmt_insertBPContact.setInt(3, C_BPartner_Location_ID);\n                        }\n                        pstmt_insertBPContact.setInt(4, I_BPartner_ID);\n                        no = pstmt_insertBPContact.executeUpdate();\n                        log.finest(\"Insert BP Contact = \" + no);\n                    } catch (Exception ex) {\n                        log.finest(\"Insert BPContact - \" + ex.toString());\n                        conn.rollback();\n                        noInsert--;\n                        sql = new StringBuffer(\"UPDATE I_BPartner i \" + \"SET I_IsImported='E', I_ErrorMsg=I_ErrorMsg||\").append(DB.TO_STRING(\"Insert BPContact: \" + ex.toString())).append(\" WHERE I_BPartner_ID=\").append(I_BPartner_ID);\n                        DB.executeUpdate(sql.toString());\n                        continue;\n                    }\n                }\n                pstmt_setImported.setInt(1, C_BPartner_ID);\n                if (C_BPartner_Location_ID == 0) {\n                    pstmt_setImported.setNull(2, Types.NUMERIC);\n                } else {\n                    pstmt_setImported.setInt(2, C_BPartner_Location_ID);\n                }\n                if (AD_User_ID == 0) {\n                    pstmt_setImported.setNull(3, Types.NUMERIC);\n                } else {\n                    pstmt_setImported.setInt(3, AD_User_ID);\n                }\n                pstmt_setImported.setInt(4, I_BPartner_ID);\n                no = pstmt_setImported.executeUpdate();\n                conn.commit();\n            }\n            rs.close();\n            pstmt.close();\n            pstmt_updateBPartner.close();\n            pstmt_insertLocation.close();\n            pstmt_insertBPLocation.close();\n            pstmt_insertBPContact.close();\n            pstmt_updateBPContact.close();\n            pstmt_setImported.close();\n            conn.close();\n            conn = null;\n        } catch (SQLException e) {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                conn = null;\n            } catch (SQLException ex) {\n            }\n            throw new Exception(\"ImportBPartner.doIt\", e);\n        } finally {\n            if (conn != null) {\n                conn.close();\n            }\n            conn = null;\n        }\n        sql = new StringBuffer(\"UPDATE I_BPartner \" + \"SET I_IsImported='N', Updated=current_timestamp \" + \"WHERE I_IsImported<>'Y'\").append(clientCheck);\n        no = DB.executeUpdate(sql.toString());\n        addLog(0, null, new BigDecimal(no), \"@Errors@\");\n        addLog(0, null, new BigDecimal(noInsert), \"@C_BPartner_ID@: @Inserted@\");\n        addLog(0, null, new BigDecimal(noUpdate), \"@C_BPartner_ID@: @Updated@\");\n        return \"\";\n    }\n", "label": 0, "substitutes": {"password": [" Password", "hash", "user", "token", "auth", "buffer", "sword", "username", "message", "wd", "PASS", "data", "phrase", "email", "address", "pad", "word", "name", " passwords", "pattern", "Pass", "text", "words", "key", "string", "path", "seed", "attribute", "secret", "database", "Password", "wallet", "padding", "pass"], "digestSeed": ["digestPreseal", "digESTPreseeds", "digestNee", "digESTPreseed", "digestSee", "digestNeal", "digestNeed", "digESTSeeds", "digesterNee", "digestPasseeds", "digestPasseal", "digestPresseed", "digestPeeds", "digESTSeal", "digesterSeeds", "digestSeeds", "digestPee", "digestPeal", "digESTSeed", "digesterSeal", "digesterNeal", "digESTSseed", "digestPreseeds", "digestNseed", "digesterNeeds", "digESTPreseal", "digesterSee", "digestPeed", "digestPassseed", "digesterNeed", "digesterSeed", "digestNeeds", "digestSseed", "digestSeal", "digESTPresseed", "digestPresee", "digestPreseed", "digestPasseed"], "digest": ["Diger", "digger", "digester", " digger", "exptest", "signester", "finEST", "DigEST", "Digger", "Digtest", "signusher", "finest", " Diger", "diger", "digtest", " digusher", "finester", "digusher", "digEST", " Digest", "Digester", "Digested", " Digger", " digEST", " digtest", "expest", "expester", " digester", "signer", "signest", "finested", "Digusher", "digested", " diger", " Digester", " digested", "Digest", "expEST"], "messageDigest": [" messageMarkest", "messagediger", "messagedigex", " messageModester", "messageModex", "messageDue", " messageDigEST", "messageDest", "messageModEST", "messageDigester", " messageModue", "messageDigEST", "messagePeder", "messagePedex", "messagedigEST", " messageDigests", "messagePedest", "messageMarkester", " messageDigex", " messageMarkEST", "messagedigests", "messageModests", "messageMarkest", "messageDigests", "messageDigue", "messageModer", " messageMarkests", "messageDEST", "messageDigex", "messageDester", " messageDigue", "messagedigester", "messagedigest", " messageMarkester", " messageDigester", " messageModEST", "messageModest", " messageModest", "messagePedester", "messagedigue", " messageDiger", "messageDiger", " messageModer", "messageModester", "messageMarkEST", " messageModex", "messageModue", "messageMarkests"], "hexString": ["hexArray", "hexCode", "hashCode", "hashStr", "shortArray", " hexCode", "strBuffer", "hexstring", "pureCode", "strStr", "shortBuffer", "hexBuffer", " hexstring", " hexStr", "hashstring", "hashBuffer", "pureArray", "hexStr", "exBuffer", "pureString", "strArray", "strString", "exString", " hexBuffer", "hashArray", "shortStr", "exstring", "pureStr", "hashString", "exArray", " hexArray", "shortString"], "i": ["h", "id", "d", "si", "multi", "abi", "qi", "k", "io", "l", "y", "b", "f", "di", "n", "bi", "mu", "I", "ti", "oi", "ai", "gi", "x", "ix", "ui", "u", "e", "ci", "o", "length", "t", "a", "m", "li", "v", "xi", "index", "ri", "count", "wei", "j", "c", "uri", "ii", "q", "pi", "fi", "s", "p"]}}
{"id1": "9728028", "id2": "305886", "code1": "    public static String getHashText(String plainText, String algorithm) throws NoSuchAlgorithmException {\n        MessageDigest mdAlgorithm = MessageDigest.getInstance(algorithm);\n        mdAlgorithm.update(plainText.getBytes());\n        byte[] digest = mdAlgorithm.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"plainText": ["rubyText", " plainTEXT", " plainScript", "regularTEXT", "longLetter", "flattext", "plainShort", "longTextColor", "plainTEXT", "plainScript", " plainKey", "regularKey", "binaryText", " plainString", "flatString", "plainClass", "plainKey", "rubyTEXT", "singleText", "binarytext", "plainLetter", "fullText", "flatCount", "hardShort", "rubyTextColor", "unitCount", "hardtext", "longText", "rubyLetter", "unitText", "flatTEXT", "flatShort", "singletext", "plaintext", " plainClass", "hardScript", " plainShort", "unitTEXT", " plainContent", "binaryString", "plainCount", " plainLetter", "singleTEXT", "plainString", "coretext", "fullContent", " plaintext", " plainTextColor", "coreText", "flatText", "hardText", "singleKey", "fullScript", "binaryTEXT", "coreTEXT", "coreClass", "fulltext", "hardContent", "regularText", "unittext", "plainContent", "regularClass", "regulartext", "plainTextColor", "longTEXT", "hardTEXT", " plainCount"], "algorithm": ["aligorith", "Algo", " algo", "aligorithm", "malgo", "palgebra", "Algebra", "aligebra", "malgorith", "malgebra", "palgo", "palgorith", "Algorith", "algebra", " algebra", "algo", "aligo", "Algorithm", "palgorithm", " algorith", "algorith", "malgorithm"], "mdAlgorithm": ["mdArchphabet", " mdEnphabet", "mdEngorithm", "mdArchgebra", " mdAlgebra", "mdAlger", "mdBlgorith", "mdAlphabet", "mdEnest", " mdDigphabet", "mdalgebra", " mdEnignment", "mdEnphabet", "mdBlphabet", " mdEnest", " mdAlignment", " mdEnger", "mdalphabet", "mdAlgorith", "mdArchgorithm", "mdBlgorithm", "mdDiggebra", "mdEnignment", "mdArchger", " mdEngorithm", "mdDigest", " mdAlgorith", "mdAlignment", "mdEnger", "mdBlger", "mdalgorithm", " mdDiggorithm", "mdDigignment", " mdAlest", "mdalest", " mdEngorith", " mdAlger", "mdArchgorith", "mdDiggorithm", "mdDigphabet", "mdAlgebra", " mdDiggebra", "mdEngorith", " mdAlphabet", "mdAlest", "mdalignment"], "digest": ["decest", "digitested", "digester", " digestest", "digests", "dumpested", "DigEST", "Digtest", "digitest", "dimest", "dEST", "diger", "dumpest", " digestests", "digtest", "defested", "generest", "decer", "digEST", "dester", "dest", "Digester", " digestester", "generested", "dimester", "Digested", " digesttest", " digEST", "decester", "dested", "decested", "digitEST", "defest", "dumpester", "generester", "defEST", "dumper", "generer", " digester", "dimests", "digitester", "defester", "digested", " digested", "Digests", "Digest", "dimtest"], "hexString": ["hexArray", "rawArray", "hashText", "purestring", "hardArray", "hardstring", "hexFunction", "tempstring", "hexText", "pureText", "hexstring", " hexText", "hardString", "hexFile", "hexBuffer", " hexFile", "pureBuffer", "rawFunction", "rawText", "tempBuffer", "tempText", "pureString", "tempString", "hardText", "rawString", "hashArray", "hardBuffer", "hashFile", "rawFile", "hashString", "hardFunction", " hexFunction", " hexArray"], "i": ["id", "si", "d", "multi", "qi", "k", "io", "l", "in", "b", "end", "f", "di", "n", "r", "zi", "I", "ti", "oi", "ai", "gi", "x", "it", "ui", "u", "ci", "e", "o", "length", "t", "a", "m", "li", "v", "key", "xi", "index", "count", "j", "c", "uri", "ii", "pi", "start", "z", "s", "ip", "p", "type"]}}
{"id1": "15223732", "id2": "17389235", "code1": "    @Test(dataProvider = Arquillian.ARQUILLIAN_DATA_PROVIDER)\n    public void shouldGreetUser(@ArquillianResource URL baseURL) throws IOException {\n        final String name = \"Earthlings\";\n        final URL url = new URL(baseURL, \"Foo.action\");\n        StringBuilder builder = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            builder.append(line);\n        }\n        reader.close();\n        LOGGER.info(\"Returned response: \" + builder.toString());\n        Assert.assertEquals(builder.toString(), FooService.GREETING + name);\n    }\n", "code2": "    public boolean PrintPage(String page, String url_addr, String charset) {\n        File parent_path = new File(new File(page).getParent());\n        if (!parent_path.exists()) {\n            parent_path.mkdirs();\n        }\n        String r_line = null;\n        BufferedReader bReader = null;\n        FileOutputStream out = null;\n        OutputStreamWriter writer = null;\n        PrintWriter fileOut = null;\n        File file = null;\n        try {\n            InputStream ins = new URL(url_addr).openStream();\n            file = new File(page);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            bReader = new BufferedReader(new InputStreamReader(ins, charset));\n            out = new FileOutputStream(page);\n            writer = new OutputStreamWriter(out, charset);\n            fileOut = new PrintWriter(writer);\n            while ((r_line = bReader.readLine()) != null) {\n                r_line = r_line.trim();\n                int str_len = r_line.length();\n                if (str_len > 0) {\n                    fileOut.println(r_line);\n                    fileOut.flush();\n                }\n            }\n            ins.close();\n            ins = null;\n            fileOut.close();\n            writer.close();\n            out.close();\n            bReader.close();\n            fileOut = null;\n            writer = null;\n            out = null;\n            bReader = null;\n            parent_path = null;\n            file = null;\n            r_line = null;\n            return true;\n        } catch (IOException ioe) {\n            log.error(ioe.getMessage());\n            ioe.printStackTrace();\n            return false;\n        } catch (Exception es) {\n            es.printStackTrace();\n            log.error(\"static----------\" + es.getMessage());\n            return false;\n        } finally {\n            try {\n                if (fileOut != null) {\n                    fileOut.close();\n                    fileOut = null;\n                }\n                if (writer != null) {\n                    writer.close();\n                    writer = null;\n                }\n                if (out != null) {\n                    out.close();\n                    out = null;\n                }\n                if (bReader != null) {\n                    bReader.close();\n                    bReader = null;\n                }\n            } catch (IOException ioe) {\n                log.error(ioe.getMessage());\n            } catch (Exception e) {\n                log.error(e.getMessage());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"baseURL": [" baseUrl", "BaseUrl", "baseUR", "apiCL", "resourceCL", "apiURI", "resourceURI", "baseURI", " baseURI", "BaseUR", "resourceUrl", " baseCL", "resourceUR", "BaseURL", " baseUR", "baseUrl", "apiURL", "resourceURL", "BaseURI", "baseCL", "apiUR"], "name": ["NAME", "parent", "ame", "id", "size", "Name", "user", "connection", "space", "username", "letter", "client", "this", "request", "description", "part", "base", "profile", "hello", "data", "version", "named", "resource", "email", "info", "word", "action", "e", "names", "job", "time", "key", "string", "path", "company", "label", "start", "self", "type"], "url": ["source", "user", "browser", "feed", "connection", "buffer", "build", "io", "l", "http", "client", "b", "base", "f", "channel", "stream", "resource", "handler", "server", "org", "address", "er", "ur", "bb", "log", "string", "path", "image", "uri", "file", "ssl", "URL", "Url", "web", "sl"], "builder": ["sb", "upper", "wrapper", "feed", "buffer", "build", "result", "iter", "keeper", "message", "outer", "letter", "driver", "b", "row", "base", "layer", "loader", "oder", "builders", "r", "handler", "writer", "inner", "der", "creator", "bean", "er", "null", "Builder", "json", "log", "atter", "parser", "runner", "length", "oster", "bar", "building", "string", "uri", "db", "built", "database", "door", "square", "board"], "reader": ["read", "upper", "input", "rar", "Reader", "feed", "buffer", "iter", "result", "keeper", "io", "http", "ler", "driver", "row", "f", "loader", "layer", "worker", "oder", "stream", "r", "resource", "handler", "editor", "server", "writer", "inner", "er", "rer", "rc", "reading", "per", "bird", "runner", "parser", "ri", "uri", "file", "i", "database", "cher", "ner"], "line": ["next", "source", "page", "link", "write", "feed", "connection", "buffer", "lines", "result", "message", "l", "letter", "one", "out", "object", "in", "char", "LINE", "cell", "end", "Line", "row", "base", "number", "part", "data", "column", "no", "style", "response", "strip", "e", "unit", "cl", "text", "comment", "content", "lc", "key", "string", "rule", "point", "pass", "file", "i", "code", "err", "character", "block", "lin", "str", "entry"]}}
{"id1": "6282214", "id2": "14588787", "code1": "    public static boolean Copy(String __from, String __to) {\n        try {\n            int bytesum = 0;\n            int byteread = -1;\n            java.io.File oldfile = new java.io.File(__from);\n            if (oldfile.exists()) {\n                InputStream inStream = new FileInputStream(__from);\n                FileOutputStream fs = new FileOutputStream(__to);\n                byte[] buffer = new byte[1024];\n                while ((byteread = inStream.read(buffer)) != -1) {\n                    bytesum += byteread;\n                    fs.write(buffer, 0, byteread);\n                }\n                inStream.close();\n                fs.close();\n            } else {\n                return false;\n            }\n        } catch (Exception e) {\n            System.out.println(\"processFile.copyFile()\ufffd\ufffd\ufffd\u01b5\ufffd\ufffd\ufffd\ufffd\u013c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \" + e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public void saveFile(final InputStream inputStream, final String fileName) {\n        final File file = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + fileName);\n        FileOutputStream fileOut = null;\n        try {\n            fileOut = new FileOutputStream(file);\n            IOUtils.copy(inputStream, fileOut);\n        } catch (FileNotFoundException e) {\n            LOGGER.error(\"saveFile() - File Not Found.\" + e);\n        } catch (IOException e) {\n            LOGGER.error(\"saveFile() - Error while saving file.\" + e);\n        } finally {\n            try {\n                inputStream.close();\n                if (fileOut != null) {\n                    fileOut.close();\n                }\n            } catch (IOException e) {\n                LOGGER.error(e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"__from": ["___from", "____start", "____to", "ngstart", " __start", "____From", "____from", "__start", "__From", "ngFrom", "ngto", "___to", "ngfrom", "___From", " __From"], "__to": [" __To", "____toc", "___from", "___toc", "____source", "____to", "__toc", "____TO", "____from", "___source", "___TO", "__source", " __TO", " __source", "___to", " __toc", "____To", "___To", "__To", "__TO"], "bytesum": [" bytessum", "esum", "bytessum", "esumm", "iesum", "Bytesum", "bytesumb", " bytesumb", "bytesumm", "Bytesumb", "bytesumo", "essum", "iesumb", "iesume", "Bytesumo", " bytesumo", "ipesumb", "bytesume", "iesumo", "Bytesume", "esumb", "ipesumm", "ipesum", " bytesumm", "ipessum", " bytesume"], "byteread": ["byfereads", "bytEREay", "byfearad", "bytaryrad", "byfererad", "bytERErad", "bytEREan", "bytearader", "byfearady", "byferean", "bynotearad", "byteseads", "byteretad", "byterestad", "byfEREad", "byteterad", "bytearand", "byfEREand", "byteretady", "bytEREand", "byteretads", "byfearader", "byterad", "byterenand", "bynoteready", "byterenady", "bytereads", "byteterads", "byteretader", "byterestady", "bytaryady", "bytaryad", "bynoteread", "bytesead", "byfeready", "byfereay", "byfEREay", "bytaryay", "byteready", "bytearads", "byferead", "bynotereads", "bytereand", "byterean", "byfEREan", "byterestads", "byfereand", "bytereader", "bytearan", "byterenad", "bynotearader", "bytearad", "bynotearads", "byterady", "bynotereader", "bytereay", "bytEREady", "byterestader", "bytearady", "byterrad", "byteterady", "byterenan", "byteterader", "byteray", "byfearads", "byfERErad", "byfereader", "bynotearady", "bytererad", "bytEREad", "byfEREady", "byteseady", "byteseader"], "oldfile": ["Oldfile", " oldfiles", "Oldf", "newfile", "Oldplain", "newf", " oldFile", "Oldfiles", "oldfiles", " oldf", "OLDfile", "oldf", "OLDFile", "newresource", "newFile", "newplain", "OldFile", "oldFile", "OLDplain", "OLDresource", "newfiles", "oldresource", "Oldresource", "oldplain"], "inStream": ["iniStreamer", "insstream", "iniFile", "inputSteam", "winstream", "outFile", " inFile", " inStreamer", "inFile", "inputstream", "InStreamer", "insSteam", "inputStreamer", "inSteam", "INSteam", "outstream", "inStreamer", "insStream", "INstream", "outSteam", "winSteam", "instream", "InFile", " inSteam", "INStream", "outStream", "INFile", "winStreamer", "InStream", "iniSteam", "iniStream", "winStream", "inputFile", "InSteam", "inputStream", "insStreamer"], "fs": ["aws", "ks", "fts", "ows", "bf", "feed", "ils", "cf", "ss", "ws", "io", "fc", "acs", "fp", "sf", "fd", "ms", "f", "ups", "fe", "fps", "fw", "os", "bs", "outs", "qs", "gets", "vs", "fn", "cs", "Fs", "abs", "FS", "df", "fits", "ls", "ios", "cache", "fb", "raf", "files", "fm", "ds", "obs", "bis", "ats", "res", "ves"], "buffer": ["page", "read", "reader", "url", "queue", "memory", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "message", "limit", "b", "base", "layer", "number", "data", "bytes", "available", "server", "address", "writer", "sequence", "uffer", "shape", "transfer", "padding", "null", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "string", "document", "border", "seed", "cache"]}}
{"id1": "12306298", "id2": "15171197", "code1": "    public static void renameFileMultiFallback(File sourceFile, File destFile) throws FileHandlingException {\n        if (destFile.exists()) {\n            throw new FileHandlingException(FileHandlingException.FILE_ALREADY_EXISTS);\n        }\n        if (!sourceFile.exists()) {\n            return;\n        }\n        boolean succ = sourceFile.renameTo(destFile);\n        if (succ) {\n            NLogger.warn(FileUtils.class, \"First renameTo operation worked!\");\n            return;\n        }\n        NLogger.warn(FileUtils.class, \"First renameTo operation failed.\");\n        System.gc();\n        Thread.yield();\n        succ = sourceFile.renameTo(destFile);\n        if (succ) {\n            return;\n        }\n        NLogger.warn(FileUtils.class, \"Second renameTo operation failed.\");\n        FileInputStream input = null;\n        FileOutputStream output = null;\n        try {\n            input = new FileInputStream(sourceFile);\n            output = new FileOutputStream(destFile);\n            long lengthLeft = sourceFile.length();\n            byte[] buffer = new byte[(int) Math.min(BUFFER_LENGTH, lengthLeft + 1)];\n            int read;\n            while (lengthLeft > 0) {\n                read = input.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                lengthLeft -= read;\n                output.write(buffer, 0, read);\n            }\n        } catch (IOException exp) {\n            NLogger.warn(FileUtils.class, \"Third renameTo operation failed.\");\n            throw new FileHandlingException(FileHandlingException.RENAME_FAILED, exp);\n        } finally {\n            IOUtil.closeQuietly(input);\n            IOUtil.closeQuietly(output);\n        }\n        destFile.setLastModified(sourceFile.lastModified());\n        FileUtils.deleteFileMultiFallback(sourceFile);\n    }\n", "code2": "    private static Pattern getBotPattern() {\n        StringBuilder sb = new StringBuilder();\n        try {\n            Enumeration<URL> urls = AbstractPustefixRequestHandler.class.getClassLoader().getResources(CONFIG);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                InputStream in = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in, \"utf8\"));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    line = line.trim();\n                    if (!line.startsWith(\"#\") && !line.equals(\"\")) {\n                        if (sb.length() > 0) sb.append(\"|\");\n                        sb.append(\"(\").append(line).append(\")\");\n                    }\n                }\n                in.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error reading bot user-agent configuration\", e);\n        }\n        return Pattern.compile(sb.toString());\n    }\n", "label": 0, "substitutes": {"sourceFile": ["sourceDir", " sourceFilename", "loadFILE", "srcfile", "thisFilename", "SourceFile", "targetPage", "sourceFILE", "ourcefile", " sourceFILE", "sourceSourceFile", "destfile", " sourceFiles", "ourceFile", "createFile", " sourcePath", "thisfile", "createFILE", "sourcefile", "loadfile", "targetPath", "SourceSourceFile", "ourceSourceFile", "SourcePath", "unitfile", "targetFiles", "ourcePage", "createDir", "loadFile", "targetfile", "sourceFilename", "sourceFiles", "destDir", "sourcePath", "unitFILE", " sourcePage", "loadDir", "srcFILE", "SourceDir", " sourceSourceFile", "targetFile", "Sourcefile", "srcFile", " sourcefile", "destFILE", "targetDir", " sourceDir", "ourcePath", "SourceFiles", "sourcePage", "createfile", "unitFile", "thisFile", "unitFilename", "thisFILE", "srcDir", "ourceDir", "srcPath"], "destFile": ["sourceDir", "srcFiles", "DestFiles", "srcfile", "destFiles", " destFiles", "srcLine", " destinationPath", "sourceLine", "destDirectory", "destfile", "destPath", "sourceSourceFile", " destfile", "defaultDir", "destSourceFile", "Destfile", "srcDirectory", "defaultFile", "sourcefile", "targetPath", "srcSourceFile", "routeDir", "routefile", "DestDirectory", "targetfile", " destinationFile", "sourceFilename", "sourceFiles", "destDir", "sourcePath", "defaultFiles", " destinationDir", " destDirectory", "srcDir", "routeFilename", "targetFile", "srcFilename", "routeFile", " destinationDirectory", "destLine", "srcFile", "targetDirectory", "targetDir", "defaultfile", " destLine", "DestDir", "targetLine", " destinationfile", " destinationLine", "destFilename", "DestFile", " destinationSourceFile"], "succ": ["rucf", "Suce", "suce", "Succ", "asuck", "Sucf", "rucc", "luucc", "SUcc", "sscc", " suucc", "Suec", "SuCC", "suec", "SUck", "ssacc", "lucc", "secc", "suucc", "seucc", "suCC", "ssce", "SUec", "ruck", "asucc", "luacc", " unsuCC", "luce", "ssck", "ruCC", " suacc", " suck", "Suacc", " unsucc", "Suck", "asucf", "suacc", "sucf", " suce", "suck", " unsuck", "asuCC", "seacc", "sece", "SUCC", " unsuec"], "input": ["source", "get", "select", "reader", "active", "url", "inc", "binary", "connection", "pull", "io", "audio", "conn", "http", "control", "out", "in", "request", "client", "driver", "state", "ou", "inf", "data", "include", "stream", "storage", "resource", "child", "address", "inner", "exec", "Input", "Output", "volume", "acl", "length", "api", "keep", "session", "media", "image", "connect", "cache", "socket", "context", "i", "error", "service", "form", "ip", "ie"], "output": ["source", "page", "parent", "operation", "queue", "write", "memory", "oper", "office", "connection", "reference", "core", "exit", "outer", "io", "audio", "letter", "control", "out", "object", "ou", "console", "environment", "application", "response", "resource", "external", "writer", "config", "module", "update", "Output", "o", "other", "target", "flow", "log", "oe", "job", "image", "OU", "entity", "socket", "file", "error", "ilo", "web", "op", "put", "unit"], "lengthLeft": ["LengthLeft", "durationRight", "LengthRight", "durationleft", "lengthL", "numberLimit", " lengthLo", "numberRight", " lengthFirst", "LengthLimit", "lenL", "lengthLo", "Lengthleft", " lengthL", "lenFirst", "lengthLimit", "sizeFirst", "lengthRight", "lengthleft", " lengthleft", "numberLeft", "positionLeft", "sizeLo", " lengthLimit", "lengthFirst", "lenLo", "sizeL", " lengthRight", "sizeLeft", "durationLeft", "positionRight", "lenLeft", "positionleft", "numberleft"], "buffer": ["source", "size", "reader", "url", "queue", "write", "memory", "binary", "feed", "reference", "buff", "result", "iter", "Buffer", "message", "request", "row", "layer", "number", "base", "data", "bytes", "available", "resource", "raw", "address", "writer", "pad", "uffer", "batch", "length", "wave", "FFER", "buf", "offset", "variable", "slice", "count", "cache", "block", "position", "value"], "read": ["READ", "end", "sleep", "r", "sync", " load", "reading", "ok", "count", "connect", "readable", "rw", " count", "line", "pass", "id", "feed", "Read", "build", "find", "child", "length", "se", "key", "load", "parse", "lex", "start", "add", "copy", "reads", "get", "size", "en", "write", "pe", "ind", "fill", "in", "skip", "work", "raw", "exec", "x", "send", "e", " use", "_", "text", "show", "run", "i", "g", "wait", " Read", " ride", "select", "play", " pass", " write", "reader", " get", "need", " skip", "k", "w", "data", " length", " r", "check", "seek", "block", " copy", "ed"]}}
{"id1": "789253", "id2": "8006559", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        int readBytes;\n        while ((readBytes = fis.read(b)) > 0) fos.write(b, 0, readBytes);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    private final void findSubclasses(URL location, String packageName, Class superClass, Set setOfClasses) {\n        synchronized (results) {\n            String fqcn = searchClass.getName();\n            List knownLocations = new ArrayList();\n            knownLocations.add(location);\n            for (int loc = 0; loc < knownLocations.size(); loc++) {\n                URL url = (URL) knownLocations.get(loc);\n                File directory = new File(url.getFile());\n                if (directory.exists()) {\n                    File[] files = directory.listFiles(CLASSES_ONLY);\n                    for (int i = 0; i < files.length; i++) {\n                        String filename = files[i].getName();\n                        String classname = filename.substring(0, filename.length() - 6);\n                        try {\n                            if (!fqcn.equals(packageName + \".\" + classname)) {\n                                Class c = callClassForName(packageName + \".\" + classname);\n                                manageClass(setOfClasses, superClass, c, url);\n                            }\n                        } catch (Throwable t) {\n                            errors.add(t);\n                        }\n                    }\n                } else {\n                    try {\n                        JarURLConnection conn = (JarURLConnection) url.openConnection();\n                        JarFile jarFile = conn.getJarFile();\n                        Enumeration e = jarFile.entries();\n                        while (e.hasMoreElements()) {\n                            JarEntry entry = (JarEntry) e.nextElement();\n                            String entryname = entry.getName();\n                            if (!entry.isDirectory() && entryname.endsWith(\".class\")) {\n                                String classname = entryname.substring(0, entryname.length() - 6);\n                                if (classname.startsWith(\"/\")) classname = classname.substring(1);\n                                classname = classname.replace('/', '.');\n                                try {\n                                    if (!fqcn.equals(classname)) {\n                                        Class c = callClassForName(classname);\n                                        manageClass(setOfClasses, superClass, c, url);\n                                    }\n                                } catch (Throwable t) {\n                                    errors.add(t);\n                                }\n                            }\n                        }\n                    } catch (IOException ioex) {\n                        errors.add(ioex);\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"src": ["source", "sel", "RC", "sb", "id", "url", "txt", "upload", "sit", "loc", "href", "ruby", "stream", "remote", "resource", "sc", "archive", "config", "sub", "cur", "sup", "filename", "name", "desc", "sync", "rc", "inst", "rs", "text", "ource", "gb", "sin", "string", "path", "image", "seed", "secure", "uri", "code", "ssl", "file", "files", "dist", "img", "project", "s", "rb"], "dest": ["source", "folder", "die", "tmp", "later", "default", "d", "txt", "build", "buff", "dev", "output", "flat", "wd", "home", "end", " destination", "const", "delete", "loc", "prop", "tern", "du", " Dest", "desc", "dir", "target", "feat", "text", "Dest", "temp", "orig", "file", "them", "comb", "replace", "wb", "opt", "dist", "img", "destroy", "bin", "test", "dat"], "ifp": ["Ifpr", "itf", "lfps", "dfb", "dfp", "ibcp", "Ifb", "Ifcp", "Ifop", "ifps", "iwpr", "lfcp", "Ifpe", "iwp", "dfcp", "ibp", "ifP", "itpr", "ibpe", "Ifp", "IfP", "Ifps", "ifb", "iwf", "ifpe", "ifcp", "ifpr", "dfpe", "ofcp", "ibb", "lfp", "ofps", "ifop", "Iff", "iwP", "itP", "lfop", "iff", "itp", "ofop"], "ofp": [" ofapi", "Ofpi", "OFc", "odP", "OFp", "Ofp", "otherps", "otherP", " ofc", "ofpi", "ippp", "othersp", "ippsp", "ofsp", "OFapi", "ippps", "odps", " ofpi", "odp", "ippP", "odsp", "Ofc", "OFpi", "ofc", "ofps", "otherp", "Ofapi", "ofP", "ofapi"], "fis": ["ifiss", "cfits", "ifois", "fois", " fops", "Fiss", "ifais", "fiss", "fais", "afais", "fops", "afos", "afis", "afops", " fois", "Fis", "cfos", " fits", "fits", "Fois", "cfops", "ifis", "ifos", " fais", "cfis", "ifops", " fiss", "ifits", "Fais"], "fos": ["Foes", "bas", " fros", "los", " foses", "ifas", " foes", "ifOS", " fOS", "bros", "fros", "Fos", "bos", "boses", "Fis", "loes", " fas", "fOS", "lis", "foses", "ifis", "ifos", "ifoes", "ifros", "Foses", "lOS", "bis", "foes", "fas", "boes"], "b": ["sb", "h", "binary", "mb", "d", "bf", "buffer", "buff", "br", "l", "w", "f", "base", "p", "bd", "bytes", "bi", "bs", "r", "n", "e", "bb", "ob", "a", "bound", "bar", "v", "gb", "ba", "xb", "B", "emb", "ab", "c", "db", "i", "wb", "fb", "nb", "bis", "boot", "lb", "bin", "rb", "ib", "bl"], "readBytes": ["writeBytes", " readbytes", "writeBs", "Readbytes", " readParts", "loadParts", "readParts", "loadBytes", "loadbytes", " readByte", "ReadBytes", "readbytes", "writeParts", "readBs", "readByte", "readingBytes", "ReadByte", "ReadParts", "loadBs", "readingByte", "readingBs", "loadByte", "writeByte", "writebytes", "readingbytes"]}}
{"id1": "22237326", "id2": "14878300", "code1": "    public QDataSet doRead(URL url, URLConnection connect) throws IOException, ParserConfigurationException, SAXException {\n        codebase = url;\n        InputStream in;\n        if (connect != null) {\n            in = connect.getInputStream();\n        } else {\n            in = url.openStream();\n        }\n        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        InputSource source = new InputSource(in);\n        Document document = builder.parse(source);\n        in.close();\n        QDataSet result = null;\n        NodeList kids = document.getChildNodes();\n        for (int i = 0; i < kids.getLength(); i++) {\n            Node n = kids.item(i);\n            if (n.getNodeName().equals(\"netcdf\")) {\n                result = netcdf(n);\n            }\n        }\n        return result;\n    }\n", "code2": "    public static byte[] MD5(String input) {\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n        md5.update(input.getBytes());\n        return md5.digest();\n    }\n", "label": 0, "substitutes": {"url": ["host", "id", "link", "connection", "feed", "xml", "buffer", "download", "build", "ll", "conn", "l", "http", "object", "b", "base", "loc", "href", "resource", "server", "contact", "address", "config", "name", "ob", "log", "api", "string", "path", "image", "file", "uri", "ssl", "URL", "service", "Url", "proxy", "web", "str", "sl"], "connect": ["select", "contract", "link", "connection", "open", "download", "build", "bind", "conn", "ct", "control", "con", "client", "request", "object", "union", "connected", "login", "serv", "config", "contact", "call", "condition", "exec", "access", "init", "log", "text", "Connect", "syn", "cli", "session", "close", "path", "graph", "don", "socket", "ssl", "struct", "construct", "process", "Conn", "port"], "codebase": ["coderef", "pagebase", "Codeline", "pageref", " codeBase", "codeline", " coderef", "Coderef", "pageBase", " codeline", "Codebase", "CodeBase", "pageline", "codeBase"], "in": ["get", "reader", "id", "input", "inc", "en", "token", "win", "connection", "nin", "conn", "src", "con", "out", "b", "login", "f", "as", "base", "data", "In", "pin", "stream", "again", "serv", "isin", "inner", "init", "it", "ins", "gin", "ini", "a", "m", "ex", "cli", "kin", "image", "cin", "lock", "socket", "file", "uri", "IN", "like", "ssl", "inn", "is", "lin", "bin"], "builder": ["reader", "sb", "wrapper", "connection", "buffer", "build", "keeper", "pb", "l", "definition", "driver", "b", "client", "object", "row", "base", "f", "loader", "builders", "config", "info", "writer", "creator", "Builder", "container", "parser", "instance", "api", "v", "building", "library", "db", "built", "context", "or", "manager", "hub", "construct", "s", "entry"], "source": ["reader", "input", "connection", "io", "src", "from", "out", "driver", "Source", "client", "this", "base", "data", "stream", "storage", "resource", "raw", "inner", "ins", "parser", "text", "ource", "string", "parse", "uri", "context", "file", "inn", "service", "start", "proxy", "s"], "document": ["page", "parent", "office", "connection", "Document", "xml", "build", "doc", "l", "root", "f", "base", "number", "data", "directory", "response", "tree", "resource", "config", "element", "container", "json", "parser", "text", "content", " documentation", "docs", "media", "node", "graph", "record", "context", "parse", "ocument", "person", "music", "concept", "database", "project", "copy", "collection", "null"], "result": ["page", "parent", "folder", "value", "successful", "compl", "default", "term", "success", "dict", "Result", "range", "division", "function", "product", "complete", "grade", "card", "out", "root", "data", "future", "include", "response", "r", "resource", "match", "ret", "feature", "info", "event", "results", "report", "runner", "instance", "found", "transform", "df", "cache", "obj", "replace", "error", "load", "err", "search", "uri", "array", "current", "valid", "rate", "test", "res", "use"], "kids": ["works", "los", "cells", "ks", "nice", "girls", "events", "things", "pieces", "dad", "lines", "parents", " kid", "stuff", "pins", "bars", "okers", "idd", "poly", "ilies", "lins", "Kid", "oi", "child", "fam", "children", "js", "devices", "rooms", "ods", "kind", "kas", "cs", "boys", "inos", "iq", "nos", "done", "roots", "cats", "les", "ops", "ours", "Kids", " Kids", "ku", "jobs", "pots", "ids", "ds", "holes", "kid", "bits"], "i": ["id", "si", "d", "abi", "multi", "qi", "iu", "hi", "phi", "io", "yi", "y", "b", "f", "di", "bi", "mu", "I", "oi", "ti", "ai", "gi", "info", "x", "ix", "ui", "ci", "u", "o", "e", "eni", "ini", "a", "li", "v", "xi", "ri", "index", "slice", "wei", "j", "c", "uri", "ori", "ii", "pi", "z", "mi", "me", "ip", "ie"], "n": ["Node", "none", "an", "ln", "d", "net", "nn", "not", "k", "l", "y", "cdn", "b", "ns", "f", "no", "rn", "r", "child", "dn", "adj", "cn", "nor", "name", "ne", "na", "u", "o", "e", "nt", "gn", "non", "fn", "t", "syn", "nu", "ann", "N", "node", "c", "nb", "ng", "sn", "z", "nc", "ner", "p"]}}
{"id1": "15106774", "id2": "21044594", "code1": "    private static String myCrypt(String password, String seed) throws RuntimeException {\n        String out = null;\n        int count = 8;\n        MessageDigest digester;\n        if (!seed.substring(0, 3).equals(\"$H$\")) {\n            byte[] randomBytes = new byte[6];\n            java.util.Random randomGenerator = new java.util.Random();\n            randomGenerator.nextBytes(randomBytes);\n            seed = genSalt(randomBytes);\n        }\n        String salt = seed.substring(4, 12);\n        if (salt.length() != 8) {\n            throw new RuntimeException(\"Error hashing password - Invalid seed.\");\n        }\n        byte[] sha1Hash = new byte[40];\n        try {\n            digester = MessageDigest.getInstance(\"SHA-1\");\n            digester.update((salt + password).getBytes(\"iso-8859-1\"), 0, (salt + password).length());\n            sha1Hash = digester.digest();\n            do {\n                byte[] CombinedBytes = new byte[sha1Hash.length + password.length()];\n                System.arraycopy(sha1Hash, 0, CombinedBytes, 0, sha1Hash.length);\n                System.arraycopy(password.getBytes(\"iso-8859-1\"), 0, CombinedBytes, sha1Hash.length, password.getBytes(\"iso-8859-1\").length);\n                digester.update(CombinedBytes, 0, CombinedBytes.length);\n                sha1Hash = digester.digest();\n            } while (--count > 0);\n            out = seed.substring(0, 12);\n            out += encode64(sha1Hash);\n        } catch (NoSuchAlgorithmException Ex) {\n            log.error(\"Error hashing password.\", Ex);\n        } catch (UnsupportedEncodingException Ex) {\n            log.error(\"Error hashing password.\", Ex);\n        }\n        if (out == null) {\n            throw new RuntimeException(\"Error hashing password - out = null\");\n        }\n        return out;\n    }\n", "code2": "        public void run() {\n            final String basename = FilenameUtils.removeExtension(file.getName());\n            final File compressed = new File(logDirectory, basename + \".gz\");\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = new FileInputStream(file);\n                out = new GZIPOutputStream(new FileOutputStream(compressed));\n                IOUtils.copy(in, out);\n                in.close();\n                out.close();\n            } catch (IOException e) {\n                reportError(\"Error compressing olg log file after file rotation\", e, ErrorManager.GENERIC_FAILURE);\n            } finally {\n                IOUtils.closeQuietly(in);\n                IOUtils.closeQuietly(out);\n            }\n            Collections.replaceAll(files, file, compressed);\n        }\n", "label": 0, "substitutes": {"password": ["input", "token", "auth", "python", "channel", "number", "hard", "directory", "zip", "enc", "email", "resource", "address", "pad", "name", "volume", "paste", "confirmed", "sudo", "crypt", "wallet", "project", "pass", "object", "application", "worker", "phrase", "handler", "ssh", "pattern", "ion", "key", "encrypted", "cache", "database", "value", "source", "parent", "user", "function", "description", "column", "server", "wp", "word", "text", "picture", "words", "string", "path", "secret", "Password", "account", "padding", "hash", "upload", "connection", "sword", "username", "message", "wd", "PASS", "root", "layer", "prefix", "config", "query", " passwords", "money", "session", "against", "code", "attribute", "device"], "seed": ["shift", "source", "size", "hash", "input", "sample", "sql", "si", "token", "feed", "theme", "prime", "username", "winner", "sed", "state", "root", "row", "sleep", "phrase", "zip", "slave", "email", "server", "shadow", "address", "sum", "handler", "finger", "pad", "random", "sequence", "config", "query", "chance", "length", "parser", "text", "json", "eed", "temp", "se", "key", "slice", "string", "sp", "grain", "secret", "sudo", "crypt", "order", "field", "wallet", "alpha", "padding", "ip", "sl", "pass"], "out": ["source", "parent", "plain", "tmp", "hash", "url", "user", "msg", "input", "token", "ban", "result", "output", "doc", "conn", "wx", "letter", "in", "cmd", "part", "login", "base", "data", "no", "OUT", "Out", "again", "sum", "prefix", "ret", "zip", "outs", "server", "raw", "work", "word", "name", "Output", "query", "full", "o", "exp", "flush", "comment", "bit", "ex", "copy", "v", "key", "up", "re", "string", "pool", "image", "cache", "obj", "ask", "error", "code", "err", "pass", "array", "secret", "crypt", "empty", "bin", "str", "null", "ext"], "count": ["div", "size", "id", "race", "fall", "len", "counter", "ind", "now", "limit", "state", "part", "base", "number", "n", "sum", "match", "low", "Count", "force", "depth", "nt", "patch", "found", "max", "ch", "more", "list", "c", "ount", "code", "error", "err", "i", "current", "process", "at", "start", "field", "test", "p", "type"], "digester": ["pushenser", "digler", "persest", " digitter", "Diger", "pushester", "signester", "logest", " diginer", " Digler", "poser", " Diger", "loginer", "diger", "diginer", "Digler", "digenser", "Digenser", "pusher", "persorter", "digorter", " Digest", "Digester", "loger", "perser", "signitter", "Digitter", "Diginer", " digler", "digitter", " digorter", " digenser", "digest", " digest", "persester", "poster", "digter", "signer", "signest", "Digorter", "Digter", " diger", " Digester", "logester", " digter", "posest", "Digest", "pushest", "posester"], "randomBytes": ["randPages", "randbytes", " randomPages", "Randombytes", " randombytes", "randomByte", "RandomPages", "RandomParts", " randomByte", "RandomBytes", "randBytes", "randomPages", "randomParts", "randByte", "randombytes", "RandomByte", "randParts", " randomParts"], "randomGenerator": ["randomGenation", "RandomGenator", "randomDesignATOR", "randomOperate", "randomDesignator", "randomGenate", "RandomGeneration", "randomGenerate", "randomGenner", "RandomGenate", "randomGenators", "randomIterator", "randomDesignators", "RandomGenATOR", "randomIteration", "RandomGenerATOR", "randomGeneration", "randomOperner", "randomGenATOR", "randomGenerators", "randomIterner", "RandomGenerator", "randomOperATOR", "randomGenator", "RandomGenators", "randomIterators", "RandomGenner", "randomIterATOR", "randomOperator", "randomDesignation", "RandomGenation", "randomIterate", "RandomGenerner", "randomGenerATOR", "RandomGenerate", "RandomGenerators", "randomGenerner"], "salt": ["sodium", "yalt", "sass", "Sodium", "sesorted", "sorted", "statesALT", "yodium", "singass", "shet", "Sass", "statesass", " sass", "sesALT", "salted", "singodium", "ssALT", "sesalt", "stateseal", "ssorted", " sALT", "Salt", "ssalt", "ssodium", "statesalt", "singalted", "sshet", "yass", " shet", "seal", "Salted", "singalt", "sesodium", " seal", "ssass", "yalted", "sALT"], "sha1Hash": ["sha3hash", "sha1Message", "base16hash", "base16Sum", "sha1Bytes", "SHA1Body", "sha256Hash", "shaOneHost", "shaOneSum", "sha01Salt", "sha1Copy", "sha64Hash", "sha512Hash", "SHAOneBytes", "sha4Key", "shaOneBytes", "sha256hash", "sha4Salt", "sha3Bytes", "SHA1Half", "sha16Sum", "sha01Hash", "sha3Salt", "shaOneSalt", "base16Hash", "sha4hash", "sha512Key", "sha4Copy", "sha3Hash", "base1hash", "SHA1Bytes", "SHAOneHash", "shaOneHash", "sha4Bytes", "sha3Sum", "SHA1hash", "SHA1Copy", "sha0Key", "sha1Body", "sha4Hash", "sha64hash", "SHA1Key", "sha16Message", "base1Sum", "sha1Key", "sha4Sum", "sha16Hash", "sha01Host", "SHA1Value", "sha1Value", "SHAOneHost", "shaOnehash", "sha01Sum", "SHAOneSalt", "shaOneKey", "sha64Bytes", "sha16hash", "sha1Half", "sha3Half", "sha512Body", "sha01Half", "sha256Sum", "sha1Host", "SHAOneSum", "sha0Body", "SHA1Host", "sha0Value", "base16Message", "sha1Sum", "sha1Salt", "SHA1Sum", "sha256Message", "base1Hash", "sha512Value", "sha1hash", "SHA1Hash", "shaOneCopy", "base1Message", "SHA1Salt", "sha0Hash", "sha64Salt"], "CombinedBytes": ["CombedMB", "CombedMembers", "CombinedShares", "CombinatedByte", "CombestedByte", "CombinedMembers", "combedByte", "CombineKeys", "Combestedbytes", "CombedKeys", "CombedByte", "combedKeys", " CombinedMembers", "Combinedbytes", "CombinedByte", " CombinatedByte", "combinedByte", "CombinedValues", "CombineBytes", "Combpledbytes", "CombinatedUrl", " CombinedByte", "CombedBytes", " CombinedUrl", " CombinatedBytes", "CombestedShares", "CombineParts", "CombedValues", "CombineMembers", "CombineByte", "combinedBytes", "Combinebytes", "combinedbytes", "CombpledParts", "combedValues", "combinedShares", "CombedUrl", "combinedMB", "CombodedBytes", "CombiningBytes", "combedMB", "combinedParts", " CombinatedUrl", "Combodedbytes", "combinedValues", "CombiningKeys", "CombpledMB", "CombestedParts", "CombinedUrl", "CombinedMB", "CombinatedBytes", "CombinedParts", "CombestedBytes", "CombinatedMembers", "CombodedParts", "combedShares", "CombpledBytes", "CombedShares", "CombineMB", "combedBytes", "combedbytes", "CombodedShares", "CombiningValues", "CombineValues", "CombiningByte", "combinedKeys", "combedParts", "CombinedKeys", "CombineUrl", " CombinatedMembers", "Combedbytes", "CombedParts"]}}
{"id1": "6778337", "id2": "22991420", "code1": "    private void copy(File from, File to) throws FileNotFoundException, IOException {\n        FileReader in;\n        in = new FileReader(from);\n        FileWriter out = new FileWriter(to);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void notifyIterationEnds(final IterationEndsEvent event) {\n        log.info(\"moving files...\");\n        File source = new File(\"deqsim.log\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"deqsim.log\"));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move deqsim.log to its iteration directory.\");\n            }\n        }\n        int parallelCnt = 0;\n        source = new File(\"deqsim.log.\" + parallelCnt);\n        while (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"deqsim.log.\" + parallelCnt));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move deqsim.log.\" + parallelCnt + \" to its iteration directory.\");\n            }\n            parallelCnt++;\n            source = new File(\"deqsim.log.\" + parallelCnt);\n        }\n        source = new File(\"loads_out.txt\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"loads_out.txt\"));\n            try {\n                IOUtils.copyFile(source, destination);\n            } catch (FileNotFoundException e) {\n                log.info(\"WARNING: Could not copy loads_out.txt to its iteration directory.\");\n            } catch (IOException e) {\n                log.info(\"WARNING: Could not copy loads_out.txt to its iteration directory.\");\n            }\n            destination = new File(\"loads_in.txt\");\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move loads_out.txt to loads_in.txt.\");\n            }\n        }\n        source = new File(\"linkprocs.txt\");\n        if (source.exists()) {\n            File destination = new File(Controler.getIterationFilename(\"linkprocs.txt\"));\n            if (!IOUtils.renameFile(source, destination)) {\n                log.info(\"WARNING: Could not move linkprocs.txt to its iteration directory.\");\n            }\n        }\n    }\n", "label": 1, "substitutes": {"from": ["source", "left", "url", "link", "about", "d", "user", "connection", "with", "range", "origin", "part", "base", "f", "From", "by", "resource", "address", "x", "name", "o", "e", "old", "a", "back", "path", "image", "file", "or", "vol", "front", "at", "form", "add"], "to": ["source", "size", "url", "about", "token", "office", "with", "tab", "top", "output", "TO", "tz", "client", "b", "toc", "To", "f", "base", "as", "by", "prefix", "eto", "address", "x", "until", "name", "o", "target", "t", "temp", "obj", "file", "at", "copy", "so", "p"], "in": ["source", "get", "read", "reader", "id", "input", "inc", "ln", "din", "win", "min", "nin", "conn", "l", "con", "login", "f", "as", "In", "pin", "again", "n", "r", "isin", "inner", "pc", "exec", "init", "ins", "e", "ax", "gin", "ini", "kin", "before", "image", "cin", "i", "IN", "inside", "inn", "rin", "is", "lin", "bin", "pass"], "out": ["plus", "parent", "plain", "inc", "write", "net", "outer", "io", "output", "conn", "w", "b", "client", "as", "data", "n", "Out", "OUT", "outs", "again", "writer", "off", "exec", "x", "sync", "o", "s", "ex", "temp", "v", "up", "obj", "cache", "file", "i", "err", "socket", "at", "outside", "bin", "copy", "line"], "c": ["dc", "cd", "d", "uc", "cy", "cu", "cm", "cf", "k", "fc", "l", "char", "bc", "f", "p", "oc", "ec", "cp", "n", "r", "xc", "enc", "sc", "pc", "ci", "rc", "u", "e", "esc", "o", "cl", "arc", "t", "ch", "m", "lc", "content", "v", "col", "cr", "pointer", "i", "code", "character", "ce", "cc", "ct", "nc", "ac", "C"]}}
{"id1": "15826301", "id2": "12631774", "code1": "    public static int getContentLength(String address) {\n        URLConnection conn = null;\n        int contentLength = 0;\n        try {\n            URL url = new URL(address);\n            conn = url.openConnection();\n            contentLength = conn.getContentLength();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return contentLength;\n    }\n", "code2": "    public static String getMd5Hash(String plaintext) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(plaintext.getBytes());\n            byte[] digest = md5.digest();\n            BigInteger bigInt = new BigInteger(1, digest);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            return hashtext;\n        } catch (final NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"address": ["host", "route", "connection", "reference", "network", "output", "message", "format", "object", "state", "base", "number", "data", "resource", "prefix", "server", "email", "config", "Address", "name", "length", "content", "localhost", "offset", "key", "string", "path", "point", "uri", "code", "attribute", "URL", "addr", "position", "port", "ip", "location", "type"], "conn": ["dc", "cb", "connection", "cm", "open", "cf", "co", "l", "ct", "con", "fp", "client", "pg", "Conn", "loc", "channel", "po", "cp", "n", "enc", "server", "config", "info", "ai", "pc", "cn", "conf", "exec", "oss", "ci", "rc", "nt", "act", "api", "Connect", "ch", "cli", "ann", "close", "path", "connect", "cert", "c", "rt", "code", "err", "Url", "Connection", "ca", "nc", "coll"], "contentLength": ["ContentType", "addressLength", "ContentLen", "ontentBuffer", "contentLen", " contentType", "paddingLife", "addressLen", "contentContent", "paddingLength", "ContentContent", "Contentlength", "addresslength", " contentlength", "ontentLength", "addressContent", "ontentLen", "contentInfo", "contentBuffer", "paddingInfo", " contentInfo", "ContentBuffer", "ContentLength", " contentLen", " contentContent", "contentlength", " contentBuffer", "ContentInfo", "contentType", "paddingLen", "ContentLife", "contentLife", "ontentType", " contentLife"], "url": ["host", "page", "cb", "connection", "open", "rel", "feed", "build", "l", "http", "object", "b", "channel", "f", "loc", "n", "r", "zip", "resource", "server", "config", "cur", "bb", "ob", "sl", "ch", "fl", "ls", "path", "orb", "image", "rl", "obj", "c", "file", "ssl", "connect", "URL", "Url", "blog", "web", "ll"]}}
{"id1": "22198322", "id2": "15292308", "code1": "    private void _loadInternalViews() {\n        _internalViews = new HashMap<String, InternalView>();\n        List<URL> list = new ArrayList<URL>();\n        ClassLoader loader = _getClassLoader();\n        try {\n            Enumeration<URL> en = loader.getResources(\"META-INF/org.apache.myfaces.trinidad.render.InternalView.properties\");\n            while (en.hasMoreElements()) {\n                list.add(en.nextElement());\n            }\n            en = loader.getResources(\"META-INF/org.apache.myfaces.trinidad.InternalView.properties\");\n            while (en.hasMoreElements()) {\n                list.add(en.nextElement());\n            }\n            Collections.reverse(list);\n        } catch (IOException ioe) {\n            _LOG.severe(ioe);\n        }\n        for (URL url : list) {\n            try {\n                Properties properties = new Properties();\n                _LOG.fine(\"Loading internal views from {0}\", url);\n                InputStream is = url.openStream();\n                try {\n                    properties.load(is);\n                } finally {\n                    is.close();\n                }\n                for (Map.Entry<Object, Object> entry : properties.entrySet()) {\n                    String name = (String) entry.getKey();\n                    String className = (String) entry.getValue();\n                    Class<?> clazz = loader.loadClass(className);\n                    InternalView view = (InternalView) clazz.newInstance();\n                    _internalViews.put(name, view);\n                }\n            } catch (IllegalAccessException iae) {\n                _LOG.severe(\"CANNOT_LOAD_URL\", url);\n                _LOG.severe(iae);\n            } catch (InstantiationException ie) {\n                _LOG.severe(\"CANNOT_LOAD_URL\", url);\n                _LOG.severe(ie);\n            } catch (ClassNotFoundException cnfe) {\n                _LOG.severe(\"CANNOT_LOAD_URL\", url);\n                _LOG.severe(cnfe);\n            } catch (IOException ioe) {\n                _LOG.severe(\"CANNOT_LOAD_URL\", url);\n                _LOG.severe(ioe);\n            }\n        }\n    }\n", "code2": "    private static File createFileFromURL(URL url) throws IOException {\n        File tempFile = File.createTempFile(\"oboFile\", \".obo\");\n        PrintStream ps = new PrintStream(tempFile);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            ps.println(line);\n        }\n        ps.close();\n        return tempFile;\n    }\n", "label": 0, "substitutes": {"_internalViews": ["_internalStreamS", "_externalViewes", "_internalViewports", "_internalviewls", "_internalViewS", "_internalVIEWls", "_externalVIEWes", "_internalviewss", "_internalviewsports", "_internalStreames", "_internalVIEWs", "_externalViewS", "_internalStreams", "_externalViewls", "_internalConfigS", "_internalViewes", "_internalConfigs", "_externalviewsports", "_externalVIEWs", "_externalViews", "_internalVIEWes", "_internalStreamls", "_internalviewses", "_internalVIEWS", "_externalviewses", "_externalviewss", "_internalviewports", "_externalviewsls", "_externalVIEWls", "_externalViewports", "_internalConfigls", "_internalConfiges", "_internalviewsls", "_internalVIEWports", "_internalViewls", "_externalVIEWS", "_internalviewes", "_internalviews"], "list": ["lp", "parent", "id", "queue", "default", "la", "LIST", "len", "the", "chain", "result", "l", "ist", "diff", "st", "part", "L", "base", "p", "table", "detail", "set", "tree", "resource", "server", "sequence", "where", "el", "stack", "full", "batch", "per", "log", "cl", "we", "keep", "lists", "lc", "li", "ls", "listed", "all", "path", "pool", "load", "live", "lock", "like", "and", "map", "array", "add", "test", "collection", "coll", "ll", "bl"], "loader": ["resources", "folder", "reader", "layout", "lang", "util", "buffer", "engine", "conn", "l", "lib", "driver", "lr", "layer", "worker", "loaded", "class", "system", "resource", "handler", "server", "config", "module", "er", "e", "container", "log", "cl", "parser", "sl", "lc", "Loader", "up", "path", "pool", "rl", "load", "cache", "impl", "file", "lock", "context", "library", "uri", "builder", "manager", "LOAD", "loading", "pl", "coll", "ll", "hl"], "en": ["ea", "ende", "hen", "pen", "an", "sen", "len", "eden", "open", "ken", "conn", "man", "\u00e9n", "enn", "ven", "end", "En", "isen", "gen", "enable", "n", "oa", "ben", "enc", "ens", "zen", "es", "he", "inner", "atten", "el", "ena", "ense", "er", "den", "EN", "e", "au", "de", "eni", "ani", "jen", "non", "ann", "ren", "re", "son", "ener", "ans", "un", "ern", "fen", "eng", "een", "et", "ien", "fin", "env", "on", "reen"], "url": ["source", "host", "page", "id", "connection", "rel", "download", "xml", "pull", "ll", "l", "http", "lib", "object", "lr", "fr", "base", "f", "loc", "data", "layer", "ref", "stream", "class", "href", "resource", "server", "address", "el", "element", "filename", "ur", "full", "e", "log", "fl", "location", "ls", "lc", "string", "path", "image", "rule", "rl", "uri", "file", "i", "ssl", "URL", "service", "Url", "www", "blog", "gl", "coll", "sl"], "properties": ["options", "resources", "classes", "lp", "reports", "xml", "ils", "settings", "lines", "pb", "l", "params", "types", "styles", "description", "prototype", "prop", "p", "data", "profile", "style", "storage", "objects", "config", "info", "address", "models", "posts", "ports", "plugins", "results", "prot", "json", "pps", "api", "rules", "fields", "status", "roots", "pro", "obj", "ips", "features", "maps", "vals", "utils", "property", "details", "pp", "files", "np", "gallery", "services", "metadata", "position", "ps", "perties"], "is": ["opens", "id", "ils", "isa", "src", "ais", "fs", "isl", "out", "object", "app", "in", "ms", "css", "as", "iss", "stream", "os", "es", "serv", "ris", "info", "gets", "js", "vs", "has", "it", "ui", "ins", "s", "iris", "IS", "api", "abs", "il", "lis", "ios", "its", "uri", "i", "or", "us", "bis", "Is", "cms", "iso", "res", "ip", "p", "does"], "entry": ["ner", "reader", "si", "la", "ent", "connection", "counter", "ry", "letter", "owner", "cell", "part", "row", "ries", "data", "class", "auto", "match", "child", "second", "info", "inner", "way", "section", "element", "angler", "inter", "ge", "event", "member", "e", "see", "enter", "post", "key", "index", "image", "entity", "record", "error", "parse", "or", "Entry", "array", "value", "line", "ie"], "name": ["NAME", "ame", "id", "Name", "connection", "username", "object", "part", "base", "data", "no", "named", "version", "class", "n", "resource", "info", "alias", "filename", "member", "old", "instance", "names", "key", "up", "string", "path", "image", "pass", "file", "title", "search", "property", "field", "value", "type"], "className": ["functionname", "CLASSName", "CLASSDesc", "classDesc", "classPath", "connectionNAME", "ClassPath", "connectionPath", " classname", "connectionDesc", "connectionName", "CLASSNAME", "ClassName", " classNAME", "classname", "CLASSPath", "Classname", "classNAME", "functionName", " classPath", "functionPath", " classDesc"], "clazz": ["Claz", " claz", "clclass", " cllass", "phazz", "slasse", " clos", "classe", "clos", "clias", "slos", "phias", "Clazz", " classe", "slazz", "claz", "CLlass", "phasse", "Cllass", " clclass", "CLclass", "CLaz", "phos", " clias", "Clclass", "CLazz", "slias", "cllass"], "view": ["page", "sel", "route", "id", "layout", "plugin", "widget", "l", "object", "client", "model", "row", "f", "base", "data", "version", "class", "resource", "View", "server", "child", "config", "info", "feature", "component", "event", "VIEW", "container", "instance", "iew", "v", "se", "up", "point", "image", "obj", "builder", "service", "look", "views", "value", "type"]}}
{"id1": "9830267", "id2": "8496070", "code1": "            public void run() {\n                final SimpleMessageListener listener = new SimpleMessageListener() {\n\n                    public final boolean accept(final String from, final String recipient) {\n                        return true;\n                    }\n\n                    public final void deliver(final String from, final String recipient, final InputStream data) throws TooMuchDataException, IOException {\n                        System.out.println(\"FROM: \" + from);\n                        System.out.println(\"TO: \" + recipient);\n                        final File tmpDir = new File(System.getProperty(\"java.io.tmpdir\"));\n                        final File file = new File(tmpDir, recipient);\n                        final FileWriter fw = new FileWriter(file);\n                        try {\n                            IOUtils.copy(data, fw);\n                        } finally {\n                            fw.close();\n                        }\n                    }\n                };\n                final SMTPServer smtpServer = new SMTPServer(new SimpleMessageListenerAdapter(listener));\n                smtpServer.start();\n                System.out.println(\"Started SMTP Server\");\n            }\n", "code2": "    private void removeSessionId(InputStream inputStream, Output output) throws IOException {\n        String jsessionid = RewriteUtils.getSessionId(target);\n        boolean textContentType = ResourceUtils.isTextContentType(httpClientResponse.getHeader(\"Content-Type\"));\n        if (jsessionid == null || !textContentType) {\n            IOUtils.copy(inputStream, output.getOutputStream());\n        } else {\n            String charset = httpClientResponse.getContentCharset();\n            if (charset == null) {\n                charset = \"ISO-8859-1\";\n            }\n            String content = IOUtils.toString(inputStream, charset);\n            content = removeSessionId(jsessionid, content);\n            if (output.getHeader(\"Content-length\") != null) {\n                output.setHeader(\"Content-length\", Integer.toString(content.length()));\n            }\n            OutputStream outputStream = output.getOutputStream();\n            IOUtils.write(content, outputStream, charset);\n        }\n        inputStream.close();\n    }\n", "label": 1, "substitutes": {"listener": ["listencer", "contener", "addter", "lockender", "contter", "addender", "conteners", "listner", "listender", "filencer", "addner", "lockener", "addener", "adderver", "addeners", "fileners", "listter", "contencer", "filener", "istener", "istner", "isterver", "listeners", "lockner", "addencer", "listerver", "istender", "filter", "lockerver"], "from": ["source", "route", "size", "url", "en", "about", "user", "connection", "range", "with", "origin", "message", "client", "end", "char", "without", "part", "base", "normal", "From", "by", "to", "channel", "resource", "email", "contact", "address", "send", "name", "component", "ender", "text", "mail", "pro", "uri", "error", "or", "ce", "addr", "subject", "start", "who", "form", "author", "entry"], "recipient": ["reciever", " recceiver", "regipt", "encipt", "encipient", "Reciever", "previent", "RECider", "recient", "recenter", "regider", " recaddress", " recip", "Recient", "recipt", "RECipt", "recward", "RECenter", "Recaddress", "recider", "RECipient", " recender", "encider", "recip", "regient", "prevender", "reliever", "Recceiver", "relward", "RECient", "RECender", "preventer", "recaddress", " recenter", "regipient", "encip", "Recward", "Recipient", "recender", " recward", "encceiver", "recceiver", "reladdress", "previpient", "Recip", " recient", "relipient", "encient", " reciever"], "data": ["source", "reader", "input", "queue", "feed", "buffer", "result", "message", "output", "audio", "dump", "this", "request", "client", "loader", "ata", "stream", "bytes", "response", "resource", "work", "handler", "raw", "address", "writer", "info", "send", "body", "DATA", "results", "json", "api", "content", "temp", "session", "media", "cache", "video", "start", "empty"], "tmpDir": ["tempPath", "tmpFolder", "mpPath", " tmpdir", " tmpPath", "tmpdir", "tmpDirectory", "mpFolder", "mpDirectory", "tempDirectory", "mpdir", "tempDir", " tmpFolder", "tempdir", "mpDir", " tmpDirectory", "tmpPath", "tempFolder"], "file": ["source", "folder", "parent", "reader", "connection", "buffer", "cf", "function", "File", "io", "w", "out", "fp", "sf", "fd", "part", "model", "f", "base", "fe", "stream", "work", "handler", "child", "writer", "wrap", "force", "filename", "dir", "framework", "flow", "up", "path", "cache", "lock", "db", "files", "self", "fi", "store", "unit"], "fw": ["die", "rf", "hw", "nw", "cf", "ht", "io", "fo", "fc", "wx", "w", "wd", " FW", "fp", "ew", "sf", "fd", "lv", "fr", "f", "tf", "fe", "work", "writer", "wrap", "wp", "force", "wt", "aw", "fly", "flow", "wl", "ow", "FH", "rw", "flo", "wb", "fb", "war", "FW", "raf", "ww", "fi", "ff", "iw", "wr", "cow", "fx"], "smtpServer": ["smphSer", "smpService", "smTPserver", "SMtpService", "smpSer", "smtapServer", "smtapService", "mmtpSer", "smtpSer", "mmpProxy", "smpserver", "smwtServer", "mmtpserver", "SMpService", "SMpserver", "smpProxy", "smtpService", "smTPClient", "smtapserver", "mmtpServer", "smtpClient", "mmpServer", "smwtserver", "SMpServer", "mmtpProxy", "smtapClient", "SMtpServer", "smpClient", "smwtProxy", "SMtpClient", "smtpserver", "smwtSer", "smpServer", "smphServer", "smphserver", "smTPService", "mmpSer", "smTPServer", "SMtpserver", "SMpClient", "smtpProxy", "mmpserver", "smphProxy"]}}
{"id1": "11608926", "id2": "8708602", "code1": "    void ProcessRequests(DataInputStream in, PrintStream out) {\n        String sQuery;\n        while (true) {\n            try {\n                sQuery = in.readLine();\n                if (sQuery == null) return;\n                if (sQuery.startsWith(\"select\")) {\n                    ProcessQuery(sQuery, out);\n                } else if (sQuery.startsWith(\"insert\")) {\n                    Statement stmt = con.createStatement();\n                    stmt.executeUpdate(sQuery);\n                } else if (sQuery.startsWith(\"update\")) {\n                    Statement stmt = con.createStatement();\n                    stmt.executeUpdate(sQuery);\n                } else if (sQuery.startsWith(\"commit\")) {\n                    con.commit();\n                } else if (sQuery.startsWith(\"autocommit true\")) {\n                    con.setAutoCommit(true);\n                } else if (sQuery.startsWith(\"autocommit false\")) {\n                    con.setAutoCommit(false);\n                } else if (sQuery.startsWith(\"delete\")) {\n                    Statement stmt = con.createStatement();\n                    stmt.executeUpdate(sQuery);\n                } else if (sQuery.startsWith(\"rollback\")) {\n                    con.rollback();\n                } else {\n                    out.println(\"What ?\");\n                }\n                out.println(\">\");\n            } catch (SQLException ex) {\n                out.println(\"\\n*** SQLException caught ***\\n\");\n                while (ex != null) {\n                    out.println(\"SQLState: \" + ex.getSQLState());\n                    out.println(\"Message:  \" + ex.getMessage());\n                    out.println(\"Vendor:   \" + ex.getErrorCode());\n                    ex = ex.getNextException();\n                    out.println(\"\");\n                }\n            } catch (java.lang.Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n", "code2": "            public void execute(File temporaryFile) throws Exception {\n                ZipArchive archive = new ZipArchive(temporaryFile.getPath());\n                InputStream input = archive.getInputFrom(ARCHIVE_FILE_1);\n                if (input != null) {\n                    ByteArrayOutputStream output = new ByteArrayOutputStream();\n                    IOUtils.copyAndClose(input, output);\n                    assertEquals(ARCHIVE_FILE_1 + \" contents not correct\", ARCHIVE_FILE_1_CONTENT, output.toString());\n                } else {\n                    fail(\"cannot open \" + ARCHIVE_FILE_1);\n                }\n            }\n", "label": 0, "substitutes": {"in": ["reader", "url", "input", "inc", "win", "connection", "min", "conn", "con", "b", "this", "login", "as", "data", "In", "pin", "stream", "again", "r", "re", "raw", "inner", "exec", "conf", "ins", "ini", "up", "cin", "cache", "c", "lock", "i", "IN", "err", "inn", "rin", "is", "lin", "bin", "s"], "out": ["page", "parent", "str", "user", "write", "buffer", "down", "extra", "co", "io", "output", "outer", "conn", "view", "w", "con", "dump", "object", "this", "ou", "client", "part", "gen", "as", "base", "In", "OUT", "Out", "print", "outs", "again", "clean", "sum", "raw", "writer", "inner", "pre", "off", "exec", "name", "query", "full", "o", "report", "exp", "log", "cli", "bar", "post", "up", "key", "session", "string", "re", "pool", "list", "obj", "cache", "c", "error", "lock", "err", "IN", "group", "bin", "res", "line"], "sQuery": ["SFlow", "osSQL", "sOnce", "cquery", "sQueue", "sslUpdate", " sDb", " sQu", "cStatement", " sString", " sScan", "cScan", "sForm", "sesQuery", " sSource", "pQ", "sqlDb", " sCondition", "sesSQL", "setsQuestion", "SSQL", "wsExp", "dsQuery", "stringInstall", "SQuestion", "Squery", "dsQuestion", " sQ", "osQuery", "sQ", "sslQuery", " sCommand", "sesInstall", "sqlStatement", "wsOnce", "sScan", "suStatement", "sInstall", "sesStatement", "wsUpdate", "YourSQL", "sDb", "dsInstall", "osLimit", "YourQuery", "nsUser", "symQuery", "sslQuestion", "sslquery", "dsStatement", "osQuestion", "suQuery", "sesQu", "cQuery", "southStatement", " sStatement", "sportsQuery", "southQuery", "sCondition", "sUpdate", "sStatement", "SQu", "SCondition", "sslCondition", "sExp", "wsQuery", "nsQuery", " sOnce", "suquery", "symInstall", " squery", "sUser", "sCommand", "nsSQL", "nsForm", "YourFlow", "sqlQuery", "pQuery", "sString", "wsStatement", "dsSQL", "nsSource", "stringThrow", "southThrow", "sesQueue", "setsQu", "siteQuery", "symStatement", "pquery", "YourCondition", "sslExp", "wsDb", "sportsSQL", "sportsLimit", "SQ", "sSQL", " sUser", "sqlOnce", "pQu", "siteQuestion", "dsQu", "sSource", "sThrow", "setsSQL", " sQueue", "SString", " sSQL", "setsStatement", "setsQuery", " sQuestion", "sFlow", "siteStatement", "SQuery", "sQu", " sForm", "stringQuery", "nsStatement", "sportsQuestion", "suScan", "sLimit", "nsCommand", "sQuestion", "stringStatement", "squery", "southInstall"], "stmt": ["tmut", " stmr", "Stmr", "Stmo", "strmd", "Stmm", "stmn", "tmt", "strnt", "stMT", "stmm", "StMT", "Stmi", "Stmb", "stnt", " stmd", "structmut", "strmb", " statt", "strMT", "stmd", "strmr", "stmo", " stMT", "playatt", "Stnt", " stmo", "playmi", "stmr", " stmi", "statt", "strdo", "stmb", "Stmn", " stmm", "strmm", " stnt", "tnt", " stmn", "strmt", "playmt", " stdo", "playmn", " stmut", "tmn", "stmut", "stdo", "structnt", "structmn", "structmt", " stmb", "Stdo", "stmi", "strmo", "Stmt", "Stmd", "Statt"], "ex": ["expl", "su", "ru", "en", "nex", "none", "rx", "uc", "ception", "rex", " exception", "extra", "Ex", " exc", "ry", "example", "io", "con", "app", "tex", "Exc", "aux", "diff", "used", "def", "exc", "pex", "hex", "fe", "again", "re", "ticket", "tx", "sex", "el", "x", "crit", "six", "ix", "event", "e", "de", "ax", "exp", "act", "cl", "log", "temp", "status", "up", "com", "se", "EX", "obj", "pass", "error", "fail", "err", "lex", "Exception", "ignore", "test", "exit", "null", "except", "ext"]}}
{"id1": "12435022", "id2": "5048220", "code1": "    protected void generateDiffResults(File outFile) throws IOException {\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream, outputCharset));\n        intlWrite(out, HTML_STRICT_DOCTYPE + \"<html><head><title>${Report.Title}</title>\\n\" + \"<meta http-equiv=\\\"Content-Type\\\"\" + \" content=\\\"text/html; charset=\" + outputCharset + \"\\\">\\n\" + \"<style type=\\\"text/css\\\">\\n\");\n        out.write(LOCDiff.getCssText());\n        writeCustomStyleInfo(out);\n        out.write(\"</style></head>\\n\" + \"<body>\\n\" + \"<div>\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border>\");\n            intlWrite(out, getAddedTableHeader());\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border>\");\n            intlWrite(out, getModifiedTableHeader());\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border>\");\n            intlWrite(out, getDeletedTableHeader());\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (unchangedTable.length() > 0) {\n            out.write(\"<table border>\");\n            intlWrite(out, getUnchangedTableHeader());\n            out.write(unchangedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        writeSummaryTable(out);\n        out.write(\"</div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n    }\n", "code2": "    private int connect() {\n        if (ftp.isConnected()) {\n            log.debug(\"Already connected to: \" + getConnectionString());\n            return RET_OK;\n        }\n        try {\n            ftp.connect(server, port);\n            ftp.login(username, password);\n            ftp.setFileType(FTP.BINARY_FILE_TYPE);\n        } catch (SocketException e) {\n            log.error(e.toString());\n            return RET_ERR_SOCKET;\n        } catch (UnknownHostException e) {\n            log.error(e.toString());\n            return RET_ERR_UNKNOWN_HOST;\n        } catch (FTPConnectionClosedException e) {\n            log.error(e.toString());\n            return RET_ERR_FTP_CONN_CLOSED;\n        } catch (IOException e) {\n            log.error(e.toString());\n            return RET_ERR_IO;\n        }\n        if (ftp.isConnected()) {\n            log.debug(\"Connected to \" + getConnectionString());\n            return RET_OK;\n        }\n        log.debug(\"Could not connect to \" + getConnectionString());\n        return RET_ERR_NOT_CONNECTED;\n    }\n", "label": 0, "substitutes": {"outFile": ["outputStream", "plainFile", "outputLog", "outputFILE", "inFile", "outDir", "outLog", "outputFile", "outFILE", "inLog", "plainFILE", " outDir", " outPath", " outLog", "outPath", "inStream", "outputDir", " outFILE", "inPath", "outputPath", "plainStream", "plainDir"], "outStream": ["outputStream", "outputLog", "fullFile", "fullStream", " outWriter", "outStreamer", "inFile", "OutFile", "outLog", "outputFile", "inWriter", "inLog", "fullWriter", " outLog", "inStreamer", "OutStreamer", "inStream", "fullStreamer", "OutStream", "outWriter", "OutWriter", "outputWriter"], "out": ["net", "result", "down", "extra", "doc", "Out", "resource", "call", "writer", "sync", "name", "log", "flush", "temp", "image", "obj", "file", "err", "group", "project", "line", "io", "outer", "conn", "lib", "one", "pre", "object", "app", "part", "gen", "by", "to", "table", "OUT", "remote", "editor", "off", "update", "t", "a", "ex", "job", "key", "all", "pool", "cache", "or", "at", "copy", "ext", "page", "parent", "user", "write", "http", "in", "client", "cmd", "this", "base", "version", "no", "n", "work", "server", "external", "exec", "word", "full", "o", "comment", "v", "global", "path", "error", "process", "req", "connection", "output", "view", "w", "again", "outs", "prefix", "config", "inner", "password", "session", "up", "window", "lock", "check", "code", "block"], "redlines": ["REDls", "redls", "badblocks", "badline", "badls", "redblocks", " redls", "badlines", " redblocks", "REDblocks", " redline", "REDline", "REDlines", "redline"]}}
{"id1": "5125847", "id2": "3613198", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineCss(URL base, List<Node> linkCss, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"css\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"style.css\");\n                Writer writer = new FileWriter(combineFile);\n                boolean first = true;\n                for (Node link : linkCss) {\n                    String path = ((Element) link).getAttribute(\"href\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File cssFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(cssFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        writer.write('\\n');\n                    } else {\n                        first = false;\n                    }\n                    Reader reader = new FileReader(cssFile);\n                    if (Configuration.cssMinification()) {\n                        CssCompressor cssCompressor = new CssCompressor(reader);\n                        cssCompressor.compress(writer, 0);\n                    } else {\n                        IOUtils.copy(reader, writer);\n                    }\n                    reader.close();\n                    String fileName = cssFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                writer.close();\n                FileReader reader = new FileReader(combineFile);\n                name.append(hashCode(IOUtils.toString(reader))).append(\".css\");\n                reader.close();\n                File targetFile = new File(Configuration.getCssLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    FileUtils.copyFile(combineFile, targetFile);\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several css files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkCss.get(0);\n            element.setAttribute(\"href\", Configuration.getCssUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"base": ["source", "absolute", "bas", "page", "id", "site", "build", "l", "http", "out", "home", "based", "root", "part", "data", "ref", "style", "resource", "prefix", "server", "config", "relative", "log", "api", "area", "string", "image", "cache", "uri", "file", "db", "builder", "Base", "bot", "proxy", "store"], "linkCss": ["lineCustomcss", "linkcps", "linkStss", "stylePSS", "linkccss", "linkCustomcss", "linkCcss", "linkScss", "linkScSS", "lineCcss", "linkCps", "linkcss", "linkPss", "styleCss", "linkPcss", "styleCcss", "linkCfs", "lineCfs", "linkStls", "styleCls", "linkCustomfs", "linkCls", "linkSccss", "linkStcss", "linkScls", "lineCustomfs", "stylePss", "linkCSS", "stylePcss", "linkPSS", "lineCss", "lineCustomss", "stylePls", "linkCustomps", "linkcfs", "linkSfs", "linkCustomss", "linkStSS", "linkSps", "lineCustomps", "lineCps", "linkPls", "styleCSS", "linkSss"], "newFiles": [" newfiles", " newResources", "newfiles", "newSources", "newResources", "oldFiles", "oldSources", "oldfiles", "oldResources", "existingSources", "existingfiles", "existingResources", " newSources", "existingFiles"], "dir": ["folder", "div", "parent", "id", " db", " directory", "draft", "d", "rel", "plugin", "build", " repo", "DIR", "lib", "wd", "http", "out", "in", "home", "diff", "root", "f", " cur", "loc", "directory", " folder", "zip", "work", "editor", " d", "dest", "ir", "module", "desc", " manager", "direction", "container", "log", " parent", "keep", "area", "session", "done", "cache", "lock", "file", "db", "uri", " director", "manager", "local", "dist", " Dir", "md", "domain", "store", " module", "coll", "Dir"], "name": ["source", "NAME", "attr", "parent", "size", "id", "memory", "Name", "default", "connection", "build", "space", "now", "output", "out", "object", "home", "part", "number", "data", "directory", "named", "style", "n", "resource", "prefix", "address", "template", "info", "word", "alias", "filename", "comment", "names", "temp", "key", "time", "string", "image", "cache", "file", "uri", "search", "builder", "files", "array", "block", "create", "mini", "type"], "minDir": ["miniEntry", "localUrl", "MinFile", "mainDb", "minDb", "miniStore", " minFile", "minEntry", "localFolder", "miniDir", "miniFile", "smallFile", "miniFolder", " minDb", "minFolder", "mainDir", "minStore", "smallFolder", "minUrl", "miniDb", "smallDir", " minEntry", " minUrl", "MinDir", "MinFolder", "MinUrl", "mainFile", "localFile", "smallStore", "localDir", " minStore", " minFolder", "mainEntry", "minFile"], "combineFile": ["comineDir", "combinatePath", "combiseFile", "comineDirectory", "combINEFile", "compiningDirectory", "combINEPath", "combiningDirectory", "compiningFiles", "combiningPath", "combinateDirectory", "cominatefile", "domineDir", "combiningFiles", "domineFile", "combinateFiles", "combinFile", "combineDirectory", "cominateDir", "domineFiles", "cominateFile", "dominationFiles", "combinedPath", "combineDir", "combINEFiles", "combineFiles", "combinationFiles", "compiningFile", "combinfile", "combinefile", "combiningFile", "combinateFile", "cominateDirectory", "comineFile", "combINEDirectory", "combiseDir", "compineFile", "combinationDir", "combisefile", "combinedDir", "combinateDir", "compineFiles", "combinePath", "combinationFile", "combinationPath", "combinDir", "dominationPath", "compinePath", "compineDirectory", "dominePath", "combinedFile", "combinedDirectory", "cominefile", "combinatefile", "combinDirectory", "dominationDir", "combiseDirectory", "compiningPath", "dominationFile", "combinedFiles"], "writer": ["source", "page", "parent", "read", "later", "input", "wrapper", "write", "buffer", "director", "player", "engine", "ws", "output", "outer", "io", "format", "w", "out", "driver", "ler", "this", "root", "layer", "loader", "worker", "data", "writers", "stream", "style", "r", "master", "riter", "handler", "editor", "work", "inner", "server", "resource", "er", "word", "null", "o", "wl", "Writer", "temp", "key", "window", "string", "document", "rw", "file", "builder", "war", "self", "writing", "value", "RW", "wr", "entry"], "link": ["page", " links", " page", " comment", "links", " style", " source", "connection", "feed", "user", " anchor", "l", "bug", " object", "loc", "cp", "style", " linked", "match", "info", " Link", " inline", " match", "ink", "linked", "comment", "li", "node", "image", " type", "load", " entry", "parse", " tag", "Link", " node", "follow", " label", "line", "sl", "type"], "path": ["source", "route", "id", "xml", "PATH", "Path", "part", "href", "data", "ref", "style", "info", "ath", "method", "full", "pattern", "step", "text", "content", "key", "ri", "string", "node", "pointer", "pass", "file", "uri", "code", "attribute", "value", "location", "type"], "url": ["source", "page", "route", "browser", "feed", "rel", "download", "open", "connection", "l", "ul", "http", "b", "f", "loc", "data", "href", "ref", "stream", "style", "r", "channel", "resource", "server", "config", "address", "ur", "gl", "sl", "ri", "string", "image", "html", "file", "uri", "ssl", "URL", "Url", "blog", "web", "str", "location"], "inputStream": [" inputContent", "outputSteam", "inputSteam", "loadStreamer", "inputContent", "imageFile", "imageStream", "InputBuffer", "outputBuffer", "outputFile", "InputStream", "imageSteam", " inputFile", "outputContent", "inputStreamer", " inputWriter", "loadFile", "InputFile", " inputBuffer", "inputWriter", "InputWriter", "loadStream", "inputBuffer", "imageStreamer", "outputWriter", "inputFile", "loadSteam", "InputContent", "outputStreamer"], "cssFile": ["nsfile", "ssName", "nsFile", "styleStream", "styleFile", "styleFiles", "stylefile", "cssUrl", "rssName", "ssfile", "ssUnit", "rssUnit", "cssfile", "ssStream", "cssUnit", "cleanfile", "nsFiles", "ssWriter", "rssUrl", "ssUrl", "lsfile", "cssFILE", "ssFILE", "cleanName", "rssFILE", "styleWriter", "cacheFile", "ssFiles", "cssName", "nsWriter", "ssFile", "cleanFile", "cachefile", "cacheUnit", "cssFiles", "lsFile", "cssWriter", "lsStream", "cacheUrl", "rssFile", "lsWriter", "cleanFILE", "cssStream", "rssfile"], "fileName": ["FileInfo", "filePart", " fileTime", " fileCode", "profileDie", "fName", "FilePath", "FILELocation", "profilePath", " fileValue", "fPath", "pageValue", "FileLocation", "typePath", "singlename", "typeInfo", "FileValue", " fileString", "Filename", "typename", "pagePart", "FILEString", "fileDie", " filePath", "fileLine", "filename", "FileDie", "FilePart", "FileCode", " filename", "fname", "fileString", "FileTime", "fileInfo", "singleName", " fileInfo", " fileLocation", "typeName", "fileCode", "filePath", "profileInfo", "FileName", "FileString", "singleLine", "fTime", "FILEPath", "singleCode", " filePart", "pageName", "fileLocation", "FILEName", "pagename", "profileName", " fileDie", "fileValue", "fileTime", " fileLine", "FileLine"], "outputStream": ["outputSteam", "inputSteam", "OutputSteam", "externalWriter", "responseSteam", "resourceStream", "OutputReader", "resourceSteam", "responseStream", "resourceFile", "inputstream", "outputFile", "OutputStream", "resourcestream", "externalSteam", "OutputWriter", " outputFile", "inputReader", "outputstream", "outputReader", "externalStream", " outputSteam", "responseFile", "externalFile", "inputWriter", "responsestream", "OutputFile", " outputReader", "outputWriter", "inputFile"], "first": ["First", "next", "left", "parent", "split", "default", "user", "last", "success", "share", "result", "right", "now", "must", "top", "one", "seen", "st", "root", "again", "always", "auto", "second", "yet", "full", "third", "other", "then", "once", "initial", "all", "same", "before", "leaf", "replace", "error", "prev", "only", "current", "start", "self", "empty", "alpha", "use"], "reader": ["read", "draft", "input", "rar", "wrapper", "rx", "Reader", "feed", "buffer", "iter", "player", "io", "ry", "l", "http", "out", "driver", "ler", "riter", "client", "lr", "row", "layer", "loader", "data", "worker", "auto", "stream", "serial", "r", "system", "zip", "handler", "her", "editor", "config", "inner", "server", "author", "resource", "info", "er", "rer", "rc", "per", "reading", "report", "parser", "runner", "ri", "image", "seed", "readable", "file", "uri", "i", "or", "builder", "manager", "service", "ner", "entry"], "cssCompressor": ["cssCompress", "cssPrepulator", "stylesCompression", "stylesRepoder", "cssComproller", "ssCompressor", "ssComproller", "cssRepressor", "cssContressor", "stylesCompressor", "cssCombress", "cssCombression", "cssContression", "cssController", "cssComboder", "cssCompression", "stylesCompoder", "stylesRepressor", "ssCompulator", "cssCompulator", "stylesCompress", "cssCombressor", "cssRepression", "cssContulator", "ssCompression", "cssPrepressor", "cssPreproller", "cssRepoder", "stylesRepress", "cssCompoder", "stylesRepression", "cssRepress", "cssPrepression"], "pos": ["POS", "su", "num", "rel", "len", "ind", "min", "pl", "limit", "end", "val", "wa", "part", "loc", "prop", "po", "neg", "no", "ref", "oa", "os", "r", "ni", "x", " position", "seq", "pr", "abs", "post", "nos", "offset", "index", "pt", "sort", "col", "pass", "sp", "pro", "obj", "pointer", "i", "Pos", "start", "position", "ps", "s", "eff", "line", "p", "type"], "targetFile": ["cssDir", " destinationStream", "targetfile", "targetDir", " destinationFile", "targetStream", " targetDir", "cssfile", " targetfile", " targetStream", " destinationDir", " destinationfile", "cssStream"]}}
{"id1": "17874922", "id2": "19687455", "code1": "    public static boolean buildPerMovieDiffBinary(String masterFile) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            System.out.println(inC.size());\n            short movie1, movie2;\n            int count;\n            float diffRating, sumXY, sumX, sumY, sumX2, sumY2, pearsonCorr, adjustedCosineCorr, cosineCorr;\n            long position;\n            for (long i = 1; i < 17770; i++) {\n                File outFile = new File(\"C:\\\\NetflixData\\\\download\\\\SmartGrape\\\\CFItemToItemStats\\\\Movie--\" + i + \"-MatrixData.txt\");\n                FileChannel outC = new FileOutputStream(outFile, true).getChannel();\n                ByteBuffer buf = ByteBuffer.allocate(17770 * 44);\n                for (long j = 1; j < i; j++) {\n                    ByteBuffer bbuf = ByteBuffer.allocate(44);\n                    position = 0;\n                    position += new Long(17769).longValue() * new Long(17770).longValue() * new Long(22).longValue();\n                    position -= new Long((17769 - (j - 1))).longValue() * new Long((17770 - (j - 1))).longValue() * new Long(22).longValue();\n                    position += new Long((i - j - 1) * 44).longValue();\n                    inC.position(position);\n                    inC.read(bbuf);\n                    bbuf.flip();\n                    buf.putShort(bbuf.getShort());\n                    bbuf.getShort();\n                    buf.putInt(bbuf.getInt());\n                    buf.putFloat(-bbuf.getInt());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                    buf.putFloat(bbuf.getFloat());\n                }\n                buf.putShort(new Long(i).shortValue());\n                buf.putInt(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                buf.putFloat(0);\n                position = 0;\n                position += new Long(17769).longValue() * new Long(17770).longValue() * new Long(22).longValue();\n                position -= new Long((17769 - (i - 1))).longValue() * new Long((17770 - (i - 1))).longValue() * new Long(22).longValue();\n                ByteBuffer remainingBuf = inC.map(FileChannel.MapMode.READ_ONLY, position, (17770 - i) * 44);\n                while (remainingBuf.hasRemaining()) {\n                    remainingBuf.getShort();\n                    buf.putShort(remainingBuf.getShort());\n                    buf.putInt(remainingBuf.getInt());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                    buf.putFloat(remainingBuf.getFloat());\n                }\n                buf.flip();\n                outC.write(buf);\n                buf.clear();\n                outC.close();\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public void testReadPerMemberAllFour() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(allfour_gz));\n        gzin.setEofEachMember(true);\n        int count0 = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong 1k member count\", 1024, count0);\n        assertEquals(\"wrong member number\", 0, gzin.getMemberNumber());\n        assertEquals(\"wrong member0 start\", 0, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member0 end\", noise1k_gz.length, gzin.getCurrentMemberEnd());\n        gzin.nextMember();\n        int count1 = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong 32k member count\", (32 * 1024), count1);\n        assertEquals(\"wrong member number\", 1, gzin.getMemberNumber());\n        assertEquals(\"wrong member1 start\", noise1k_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member1 end\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberEnd());\n        gzin.nextMember();\n        int count2 = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong 1-byte member count\", 1, count2);\n        assertEquals(\"wrong member number\", 2, gzin.getMemberNumber());\n        assertEquals(\"wrong member2 start\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member2 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberEnd());\n        gzin.nextMember();\n        int count3 = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong 5-byte member count\", 5, count3);\n        assertEquals(\"wrong member number\", 3, gzin.getMemberNumber());\n        assertEquals(\"wrong member3 start\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberStart());\n        assertEquals(\"wrong member3 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length + hello_gz.length, gzin.getCurrentMemberEnd());\n        gzin.nextMember();\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"masterFile": ["distPath", "configFilename", "parentFile", "masterPath", "masterFilename", "mastersFile", "MasterFilename", "Masterfile", "distfile", "masterStream", "configfile", "MasterStream", "parentPath", "mastersfile", "MasterPath", "configStream", "configFile", "parentfile", "MasterFile", "mastersStream", "parentFilename", "masterfile", "distFilename", "mastersFilename", "distFile"], "inFile": ["outF", "InC", "InFILE", "linC", "outFILE", " inF", "inF", "linFile", "inFILE", "outfile", "incF", "linfile", "infile", "InFile", "incfile", "outFiles", "incFile", "inFiles", " inFiles", "incFiles", "linFILE", " infile", "Infile"], "inC": ["InCL", "outF", "tryF", "inT", "inc", "InCA", "inCL", " inCL", "outCL", "inB", "InC", "tryB", " inF", "winB", "InT", "inF", "inCA", "outB", "outT", "tryC", "winCL", "InB", "InFile", "tryc", "outc", " inCA", "winC", "winCA", " inc", " inB", " inT"], "movie1": ["movieOne", "imageA", "playerone", "playerOne", "movieA", "image1", "imageone", "MovieA", "Movie1", "MovieOne", "imageOne", "player1", "playerA", "movieone", "Movieone"], "movie2": ["videoSecond", "video0", "movie0", "video4", " movieSecond", "series4", "series2", " movie4", "series0", "video2", "movie4", "seriesSecond", " movie0", "movieSecond"], "count": ["id", "last", "len", "counter", "ind", "weight", "score", "base", "sum", "child", "Count", "depth", "batch", "length", "found", "screen", "content", "col", "index", "list", "cache", "code", "err", "process", "mean", "start", "coll", "type"], "diffRating": ["diffRank", "DiffRank", "DiffRating", "meanRat", "DiffScore", "meanRating", " diffRank", " diffScore", "meanScore", "meanRank", "diffRat", "DiffRat", " diffRat", "diffScore"], "sumXY": ["numY", "scaleXY", "scaleY", "sumYY", "numYY", "numZ", "scaleZ", "sumZ", " sumZ", " sumYY", "numXY", "scaleYY"], "sumX": ["summaryZ", "summaryX", "SumX", "SumY", "SumXY", "summaryY", "summaryXY", "sumZ", " sumZ", "SumZ"], "sumY": ["sumy", "simY", "sumYY", "SumYY", "SumY", "simy", "SumXY", " sumy", "simYY", " sumYY", "simXY", "Sumy"], "sumX2": ["sumYTwo", " sumXYTwo", " sumXY1", "sumXX1", " sumXY2", " sumXTwo", "sumX1", "sumXY1", "sumXX2", "sumXY2", "sumY1", "sumXXTwo", "sumXYTwo", " sumX1", "sumXTwo"], "sumY2": ["sumYTwo", " sumXYTwo", " sumXY1", " sumYTwo", " sumXY2", "sumX1", "sumXY1", "sumXY2", "sumY1", " sumY1", "sumYY2", "sumXYTwo", "sumYYTwo", "sumYY1", "sumXTwo"], "pearsonCorr": ["pelevisionCorr", "pearsoncorrs", "pelevisionCorp", "pearsonArrs", "pearsonCorp", "pearsonErrs", "pearsonCorrs", "pearsonArp", "pearsonArc", "pearsonErr", "pelevisioncorp", "pelevisioncorrs", "pearsonErc", "pearsonArr", "pelevisionCorc", "pearsonErp", "pearsoncorc", "pearsoncorr", "pelevisioncorc", "pelevisionCorrs", "pelevisioncorr", "pearsoncorp", "pearsonCorc"], "adjustedCosineCorr": ["adjustedCosineErr", "adjustedCosineCorb", "adjustedCosieCorp", "adjustedCosineErR", "adjustedCosieCorr", "adjustedCosineCorp", "adjustedCosineErp", "adjustedCosineErb", "adjustedCosineCorR", "adjustedCosieCorb", "adjustedCosieCorR"], "cosineCorr": ["cosinesCorp", "cosinescorrd", "cosinescorrs", "cosineErrs", "cosineMirrs", "cosineErr", "cosinecorrd", "cosineMirp", "cosinesCorrs", "cosinescorp", "cosinesCorr", "cosinesCorrd", "cosineErrd", "cosineCorrs", "cosinecorrs", "cosinecorp", "cosineCorrd", "cosineMirrd", "cosineErp", "cosineCorp", "cosineMirr", "cosinescorr", "cosinecorr"], "position": ["select", "adjust", "shift", "read", "pixel", "display", "layout", "connection", "axis", "player", "pose", "weight", "params", "object", "portion", "state", "move", "part", "loc", "number", "data", "version", "cover", "style", "response", "condition", "address", "angle", "sequence", "shape", "Position", "update", "use", "action", "direction", "selection", "patch", "length", "ion", "job", "offset", "release", "index", "media", "sort", "image", "point", "pointer", "time", "run", "record", "slice", "expression", "motion", "coord", "property", "seek", "pos", "character", "block", "speed", "type", "mount", "osition", "order", "option", "value", "port", "location", "duration", "unit"], "i": ["id", "ik", "si", "qi", "d", "iu", "phi", "io", "k", "hi", "yi", "l", "y", "b", "part", "f", "number", "ij", "di", "bi", "zi", "n", "I", "ni", "ti", "ai", "gi", "info", "ji", "x", "sup", "ix", "init", "ui", "ci", "e", "u", "o", "api", "ini", "m", "li", "xi", "v", "ri", "index", "slice", "c", "ori", "uri", "ii", "im", "pi", "is", "start", "fi", "z", "mi", "mini", "ip", "p", "ie"], "outFile": [" outTable", "outF", "OutFolder", "outTable", "outputF", " outF", "OutFile", " outfile", "outDir", "outputFile", "outputC", " outFolder", " outDir", "outfile", "OutTable", "OutF", "incTable", "Outfile", "outFolder", "OutDir", "outputDir", "incfile", "incFolder", "incFile", "OutC"], "outC": ["outF", "OutF", "inL", " outF", " outL", "inF", "OutFile", "OutC", "outL", "OutL"], "buf": ["af", "cb", "queue", "bf", "bh", "uc", "buffer", "buff", "cf", "cmp", "ux", "Buffer", "bg", "cas", "fp", "b", "home", "bc", "fd", "aux", "console", "cmd", "f", "cv", "loc", "data", "bd", "ctx", "box", "config", "Buff", "func", "rc", "CB", "tc", "uf", "cap", "bag", "v", "ba", "book", "port", "window", "pool", "border", "utils", "socket", "db", "context", "vec", "wb", "fb", "BU", "header", "block", "conv", "fx", "img", "ff", "bu", "rb", "coll", "pkg", "BA"], "j": ["h", "jj", "d", "kj", "si", "jet", "J", "br", "jp", "k", "l", "y", "jo", "b", "fr", "ja", "f", "aj", "ij", "bi", "n", "ji", "el", "x", "js", "bj", "u", "o", "e", "ci", "uj", "dj", "pr", "ch", "m", "job", "jc", "v", "li", "obj", "c", "ii", "jl", "g", "q", "oj", "z", "p", "ie"], "bbuf": ["obuff", "obbdef", "ppuf", "bdef", "mbbuff", "bootuff", "mbbuf", "kkff", "obbbuff", "dbuff", "BBdef", "dbuf", "buffer", "obblf", "buff", "bbuffer", "ebbuf", "mbuff", "buffbuff", "bbuff", "obbuff", "BBff", "buffbuf", "bbbuf", "buffdef", "kkuff", "bufflf", "dbbuf", "mbuf", "kkuf", "bbdef", "buffuff", "ebbuff", "obff", "obbuf", "kkbuf", "dbuffer", "ebuff", "ppuff", "bootbuff", "buffff", "BBuff", "bbbuff", "buffuf", "obuf", "BBbuf", "ppbuff", "blf", "BBbuff", "bff", "bbff", "BBuf", "obbuffer", "bootuf", "bootbuf", "bblf", "oblf", "obbbuf", "obdef", "dbbuff", "ppbuf", "ebuf"]}}
{"id1": "18435231", "id2": "3257108", "code1": "    public String getSHA1Hex(String original) {\n        MessageDigest digest;\n        String result = \"\";\n        try {\n            digest = MessageDigest.getInstance(\"sha1\");\n            digest.reset();\n            digest.update(original.getBytes());\n            byte[] dig = digest.digest();\n            String hexStr = \"\";\n            for (int i = 0; i < dig.length; i++) {\n                hexStr += Integer.toString((dig[i] & 0xff) + 0x100, 16).substring(1);\n            }\n            result = hexStr;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "code2": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            s = new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return s;\n    }\n", "label": 1, "substitutes": {"original": ["source", "wrapper", "edited", "actual", "winner", "Orig", "data", "hex", "boxing", "Original", "author", "raw", "creator", "x", "old", "text", "initial", "instance", "temp", "string", "orig", "image", "before", "cache", "encrypted", "code", "or", "modified", "array", "current", "created", "initialized", "create", "empty", "existing", "copy", "null", "p"], "digest": ["Diger", "digger", "compests", "fdest", "digester", " digger", "digests", "signester", "Dige", "DigEST", "genest", "Digger", "gener", " digests", " digit", "gene", " digse", "digit", "diger", "Digit", "compit", "digse", "signse", "digEST", "genester", "genested", "Digester", "Digested", "compester", " digEST", "fdEST", "dige", "Diggest", "fdgest", "compest", "diggest", "genger", " digester", " dige", "Digse", "signer", "signest", " diggest", "digested", " diger", " digested", "Digests", "Digest", "fdester"], "dig": ["div", "dec", "dc", "cd", "d", "ded", "dd", "ind", "ld", "ord", "sign", "rub", "digit", "gen", "def", "loc", "poly", "std", "integ", "rob", "rib", "Dig", "bad", "cod", "del", "fun", "du", "tag", "init", "big", "mod", "exp", "spec", "gin", "deg", "dim", "cr", "db", "comb", "rd", "oct", "lab", "grad", "nd", "ig", "dom", "test", "str", "dat", "mix"], "i": ["id", "h", "si", "d", "multi", "qi", "hi", "k", "io", "phi", "l", "yi", "in", "b", "end", "f", "data", "di", "n", "r", "bi", "I", "zi", "ti", "oi", "ai", "mu", "gi", "ni", "ji", "x", "ix", "it", "ui", "u", "e", "ci", "o", "t", "ini", "li", "v", "key", "xi", "ri", "index", "j", "c", "uri", "ii", "pi", "start", "fi", "z", "s", "p"], "hexStr": ["octStr", " hexstr", "digstr", "octEnc", "exstr", "shortSt", " hexEnc", "hexString", "exStr", " hexString", "digStr", "octstr", "octString", " hexSt", "hexEnc", "shortstr", "hexstr", "exString", "hexSt", "exSt", "shortStr", "digEnc", "digString", "octSt", "shortString"], "result": ["value", "upper", "default", "url", "success", "Result", "prime", "function", "message", "card", "format", "val", "description", "root", "color", "data", "hex", "style", "response", "sum", "match", "ret", "work", "res", "results", "report", "json", "password", "text", "comment", "transform", "found", "content", "string", "orig", "answer", "uri", "replace", "array", "current", "valid", "secret", "reason", "test", "str", "pass"]}}
{"id1": "11846837", "id2": "4955403", "code1": "    public static void copyFile(File source, File destination, boolean lazy) {\n        if (!source.exists()) {\n            return;\n        }\n        if (lazy) {\n            String oldContent = null;\n            try {\n                oldContent = read(source);\n            } catch (Exception e) {\n                return;\n            }\n            String newContent = null;\n            try {\n                newContent = read(destination);\n            } catch (Exception e) {\n            }\n            if (oldContent == null || !oldContent.equals(newContent)) {\n                copyFile(source, destination, false);\n            }\n        } else {\n            if ((destination.getParentFile() != null) && (!destination.getParentFile().exists())) {\n                destination.getParentFile().mkdirs();\n            }\n            try {\n                FileChannel srcChannel = new FileInputStream(source).getChannel();\n                FileChannel dstChannel = new FileOutputStream(destination).getChannel();\n                dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public FetchTextFromWebPage(String path) {\n        HTMLEditorKit.Parser parser;\n        HTMLFile = new File(path);\n        byte[] html = new byte[new Long(HTMLFile.length()).intValue()];\n        try {\n            FileInputStream fis = new FileInputStream(HTMLFile);\n            try {\n                fis.read(html);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            ByteArrayInputStream ba_read = new ByteArrayInputStream(html);\n            r = new InputStreamReader(ba_read);\n        } catch (FileNotFoundException e) {\n            URL url = null;\n            try {\n                url = new URL(path);\n                URLConnection connection = null;\n                try {\n                    connection = url.openConnection();\n                    connection.setDoInput(true);\n                    InputStream inStream = null;\n                    try {\n                        inStream = connection.getInputStream();\n                        BufferedReader input = new BufferedReader(new InputStreamReader(inStream));\n                        StringBuffer sbr = new StringBuffer();\n                        String line = null;\n                        try {\n                            while ((line = input.readLine()) != null) {\n                                System.out.println(line);\n                                sbr.append(line + \"\\n\");\n                            }\n                        } catch (IOException e1) {\n                            e1.printStackTrace();\n                        }\n                        File temp = new File(\"//home//wiki14//temp.txt\");\n                        if (!temp.exists()) {\n                            if (!temp.createNewFile()) System.out.println(\"File caanot be created\");\n                        } else {\n                            temp.delete();\n                            if (!temp.createNewFile()) System.out.println(\"File caanot be created\");\n                        }\n                        java.io.FileWriter fw = new java.io.FileWriter(temp);\n                        fw.write(sbr.toString());\n                        fw.close();\n                        byte[] newbyte = new byte[new Long(sbr.length()).intValue()];\n                        ByteArrayInputStream ba_read = new ByteArrayInputStream(newbyte);\n                        r = new InputStreamReader(ba_read);\n                    } catch (IOException e1) {\n                        e1.printStackTrace();\n                    }\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n            } catch (MalformedURLException e1) {\n                e1.printStackTrace();\n            }\n        }\n        parser = new ParserDelegator();\n        htmltextparser = new HtmlTextParser();\n        htmltextparser.initData();\n        try {\n            parser.parse(r, htmltextparser, true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            r.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"source": ["parent", "route", "reader", "site", "url", "input", "connection", "reference", "core", "src", "from", "view", "object", "client", "Source", "root", "base", "directory", "stream", "remote", "resource", "slave", "server", "archive", "ie", "inner", "name", "project", "target", "ource", "sin", "SOURCE", "slice", "internal", "string", "image", "path", "seed", "file", "uri", "service", "current", "scene", "ce", "start", "proxy", "copy", "null", "sample", "use", "unit"], "destination": [" destinated", " destinator", "descinated", "restruction", "combinations", "configinated", "restination", "combinated", " destinations", "Destinated", "distinated", "distruction", "distination", "Destification", "destinary", "datinator", "descification", "temine", "destinated", "dominator", " destine", "restinator", "teminator", "destification", "dinary", "configinator", "combination", "diination", "diinations", "datinated", "Destinator", "postination", "Destruction", "datination", "diinated", "domination", "destine", "dinated", "destinations", "Destinations", "Destine", "temination", "teminated", "postinated", "descinary", "dination", "configination", "diinator", "destinator", "domruction", "dification", "postinary", " destification", "restinated", "descination", "combinator", "distinator", "datinations", "postification", "destruction", "dominated", "Destination", "configification"], "lazy": ["lucky", "plaz", "lached", "lait", "flickle", "gazy", "flazy", "plached", "gickle", "elaz", "cucky", " lickle", "cazy", "elached", "lickle", "flicit", "plazy", "elazy", "laz", "elucky", "licit", "flait", " licit", "plucky", " lait", "gait", "caz", "cached", "gicit"], "oldContent": ["expectedcontent", " oldCurrent", "newPage", "OldMessage", "olderContent", "oldercontent", "expectedContent", "oldValue", "oldRead", "expectedCode", "OldVersion", "OldContents", " oldMessage", " oldValue", "expectedRead", "oldCode", "oldCurrent", "diffContent", "oldString", "olderMessage", " oldContents", "newValue", "newVersion", "diffPage", "olderCurrent", "newContents", " oldcontent", " oldPage", " oldCode", "diffcontent", "OldContent", "OldValue", "olderString", "oldVersion", "OldString", " oldVersion", "olderCode", "oldContents", "olderRead", "diffString", "newcontent", "oldMessage", "oldcontent", "oldPage", " oldString", "newString", "OldCurrent", " oldRead"], "newContent": ["newCode", "differentcontent", " newContents", " newCode", "differentCode", "newText", "oldValue", "NewCode", "differentContent", "oldText", "wordcontent", "NewContent", "nowContent", "oldCode", "NewValue", "newValue", "newContents", "nowText", "Newcontent", "wordContents", "nowValue", "nowContents", " newcontent", " newText", "wordCode", "oldContents", "newcontent", "oldcontent", "wordContent", " newValue", "differentValue"], "srcChannel": ["sourceConnection", "srcchannel", "rcContext", "sourceChan", "rcChan", " srcChan", "destChan", "sourceContext", "destContext", "rcStream", "inputConnection", " srcStream", " srcConnection", "rcchannel", "srcChan", "rcChannel", "srcContext", "inputChannel", "inputchannel", "inputChan", "destConnection", "rcConnection", "srcStream", "destChannel", " srcContext", " srcchannel", "sourcechannel", "sourceChannel", "srcConnection", "inputStream", "sourceStream"], "dstChannel": ["ddestChan", "dcrStream", "dspChannel", "dstStream", " dstStream", "Destchannel", "dostChannel", "ddestchannel", "udstChan", "ddestChannel", "uddestChan", "uddestButton", "DstStream", "ddestContext", "destChan", "DestStream", "udstChannel", "dstContext", "dsrcchannel", "dostchannel", "DstChannel", " dstContext", "destContext", "dstButton", "destchannel", "dcrChan", " dstChan", "dstChan", " destChannel", " destChan", "destStream", "DestChannel", "ddestButton", "dcrChannel", "dsrcChannel", "dspchannel", "destButton", "ddestStream", "udstchannel", "dcrContext", "dsrcButton", "destChannel", "Dstchannel", "uddestchannel", " destStream", "dstchannel", " destContext", "dspStream", "dsrcChan", "udstButton", "uddestChannel", "dostStream"]}}
{"id1": "19746605", "id2": "4232438", "code1": "    private synchronized Frame insertFrame(int index, File source, INSERT_TYPE type) throws IOException {\n        if (source == null) throw new NullPointerException(\"Parameter 'source' is null\");\n        if (!source.exists()) throw new IOException(\"File does not exist: \" + source.getAbsolutePath());\n        if (source.length() <= 0) throw new IOException(\"File is empty: \" + source.getAbsolutePath());\n        if (index < 0) throw new IndexOutOfBoundsException(\"index < 0\");\n        if (index >= frames_.size()) throw new IndexOutOfBoundsException(\"index >= frames_.size()\");\n        File tmp = new File(Settings.getPropertyString(ConstantKeys.project_dir), \"tmp.jpg\");\n        switch(type) {\n            case MOVE:\n                if (source.getParentFile().compareTo(new File(Settings.getPropertyString(ConstantKeys.project_dir))) == 0 && source.getName().matches(\"img_[0-9]{5}\\\\.jpg\")) {\n                    for (int i = 0; i < frames_.size(); i++) {\n                        Frame f = frames_.get(i);\n                        if (f.getFile().compareTo(source) == 0) {\n                            frames_.remove(i);\n                            break;\n                        }\n                    }\n                }\n                source.renameTo(tmp);\n                break;\n            case COPY:\n                FileChannel inChannel = new FileInputStream(source).getChannel();\n                FileChannel outChannel = new FileOutputStream(tmp).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n                break;\n        }\n        for (int i = frames_.size() - 1; i >= index; i--) {\n            Frame newFrame = new Frame(new File(Settings.getPropertyString(ConstantKeys.project_dir), formatFileName(i)));\n            frames_.get(i).moveTo(newFrame);\n            frames_.set(i, newFrame);\n        }\n        File newLocation = new File(Settings.getPropertyString(ConstantKeys.project_dir), formatFileName(index));\n        tmp.renameTo(newLocation);\n        Frame f = new Frame(newLocation);\n        f.createThumbNail();\n        frames_.set(index, f);\n        return f;\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        log.debug(\"Copy from {} to {}\", source.getAbsoluteFile(), dest.getAbsoluteFile());\n        FileInputStream fi = new FileInputStream(source);\n        FileChannel fic = fi.getChannel();\n        MappedByteBuffer mbuf = fic.map(FileChannel.MapMode.READ_ONLY, 0, source.length());\n        fic.close();\n        fi.close();\n        fi = null;\n        if (!dest.exists()) {\n            String destPath = dest.getPath();\n            log.debug(\"Destination path: {}\", destPath);\n            String destDir = destPath.substring(0, destPath.lastIndexOf(File.separatorChar));\n            log.debug(\"Destination dir: {}\", destDir);\n            File dir = new File(destDir);\n            if (!dir.exists()) {\n                if (dir.mkdirs()) {\n                    log.debug(\"Directory created\");\n                } else {\n                    log.warn(\"Directory not created\");\n                }\n            }\n            dir = null;\n        }\n        FileOutputStream fo = new FileOutputStream(dest);\n        FileChannel foc = fo.getChannel();\n        foc.write(mbuf);\n        foc.close();\n        fo.close();\n        fo = null;\n        mbuf.clear();\n        mbuf = null;\n    }\n", "label": 1, "substitutes": {"index": ["page", "active", "id", "url", "num", "input", "inc", "axis", "connection", "len", "ind", "weight", "example", "view", "alpha", "object", "fix", "end", "in", "part", "loc", "number", "include", "version", "sort", "style", "zip", "match", "ticket", "condition", "address", "element", "module", "update", "depth", "action", "x", "body", "shape", "all", "other", "length", "instance", "dim", "show", "offset", "slice", "frame", "image", "point", "pointer", "string", "path", "file", "change", "search", "width", "Index", "pos", "current", "date", "start", "order", "position", "value", "key"], "source": ["input", "result", "src", "channel", "directory", "storage", "style", "zip", "resource", "name", "volume", "rc", "scope", "ource", "temp", "slice", "image", "secure", "file", "project", "store", "site", "reference", "buffer", "settings", "origin", "object", "class", "remote", "slave", "force", "instance", "sin", "scene", "start", "self", "figure", "stack", "parent", "size", "url", "this", "stream", "server", "template", "e", "text", "string", "path", "service", "subject", "null", "use", "connection", "game", "from", "view", "original", "Source", "data", "config", "inner", "target", "session", "SOURCE", "frame", "seed", "uri", "current", "proxy", "sl", "unit"], "type": [" TYPE", "id", "link", "pe", "rel", " Type", "TYPE", "format", "object", "in", "types", "Type", "state", "mode", "model", "class", "style", "role", "info", "shape", "name", "method", "action", "kind", "direction", "event", "t", "transform", "key", "time", "string", "path", "ping", "sort", "file", "code", "pos", "block", "position", "port", "null"], "tmp": ["mobi", "folder", "parent", "sb", "proc", "buffer", "now", "output", "src", "audio", "out", "fp", "app", "fake", "home", "root", "part", "base", "cpp", "table", "cp", "storage", "zip", "ctx", "handler", "archive", "template", "Temp", "dest", "pad", "machine", "tp", "mp", "project", "target", "api", "temp", "slice", "media", "image", "sp", "cache", "obj", "vm", "manager", "front", "video", "img", "metadata", "proxy", "copy", "cmp"], "i": ["id", "h", "my", "si", "qi", "multi", "d", "ind", "iu", "phi", "io", "hi", "yi", "l", "y", "b", "part", "di", "bi", "zi", "mu", "I", "n", "ni", "ti", "gi", "info", "ai", "x", "sup", "name", "ix", "it", "ui", "ci", "e", "o", "u", "ini", "m", "lc", "li", "v", "xi", "key", "ri", "slice", "image", "j", "ori", "uri", "ii", "g", "q", "pi", "is", "field", "fi", "chi", "z", "mi", "me", "ip", "p", "ie"], "f": ["bf", "d", "feed", "cf", "k", "l", "fs", "fc", "fp", "b", "elf", "fd", "inf", "fr", "tf", "def", "fe", "n", "r", "info", "x", "conf", "func", "full", "fn", "t", "F", "ef", "m", "fl", "df", "v", "frame", "j", "c", "file", "fb", "g", "q", "form", "fab", "p", "fx"], "inChannel": ["inButton", "outChan", "innerStream", " inChan", "INChannel", " inStream", "inChan", "INchannel", "outchannel", "INChan", "InChan", "inputChannel", "inputchannel", "inchannel", "inStream", "inputChan", "Inchannel", "innerchannel", "INStream", "outStream", "outButton", "InStream", "innerChannel", " inButton", "InButton", "InChannel", "innerChan", "inputStream", " inchannel"], "outChannel": ["inButton", "outChan", "inBuffer", " outChan", " outQueue", "OutButton", " outchannel", "Outchannel", "inChan", "outchannel", " outBuffer", "OutChan", "OutChannel", "outBuffer", "inchannel", "inStream", "outQueue", "outStream", "outButton", "OutStream", " outButton", "OutQueue", " outStream", "OutBuffer", "inQueue"], "newFrame": [" newframe", "anotherframe", "nextframe", "newScene", "nextScene", "thisFrame", "NEWFrame", "NEWSection", "thisSection", " newFrames", "anotherFrame", " newSection", " newScene", "newframe", "newFram", "NEWFram", " newFram", "anotherFrames", "thisFram", "nextFrame", "newSection", "anotherScene", "newFrames", "nextFrames"]}}
{"id1": "20413859", "id2": "238176", "code1": "    @Override\n    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            final HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n            final HttpServletResponse httpServletResponse = (HttpServletResponse) response;\n            final String contextPath = httpServletRequest.getContextPath() + \"/\";\n            final String requestURI = httpServletRequest.getRequestURI();\n            if (requestURI.startsWith(contextPath)) {\n                final String filterURI = requestURI.substring(contextPath.length());\n                final String filterPath = getFilterPath();\n                if (filterURI.startsWith(filterPath)) {\n                    final String targetURI = filterURI.substring(filterPath.length());\n                    for (final Entry<String, String> entry : mapping.entrySet()) {\n                        final String key = entry.getKey();\n                        final String value = entry.getValue();\n                        if (targetURI.startsWith(key) && (targetURI.length() > key.length())) {\n                            final String resourceName = value + targetURI.substring(key.length());\n                            InputStream is = null;\n                            try {\n                                is = getClass().getResourceAsStream(\"/\" + resourceName);\n                                if (is != null) {\n                                    IOUtils.copy(is, httpServletResponse.getOutputStream());\n                                    httpServletResponse.flushBuffer();\n                                    break;\n                                } else {\n                                    httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n                                    break;\n                                }\n                            } catch (final IOException ioex) {\n                                throw new ServletException(\"Error serving resource [\" + resourceName + \"].\", ioex);\n                            } finally {\n                                IOUtils.closeQuietly(is);\n                            }\n                        }\n                    }\n                } else {\n                    chain.doFilter(request, response);\n                }\n            } else {\n                chain.doFilter(request, response);\n            }\n        } else {\n            chain.doFilter(request, response);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"request": ["host", "head", "get", "route", "reader", "url", "input", "queue", "user", "req", "require", "connection", "buffer", "xml", "complete", "result", "right", "message", "view", "http", "client", "state", "model", "application", "hello", "data", "worker", "version", "remote", "resource", "server", "call", "condition", "Request", "address", "method", "event", "query", "requ", "report", "instance", "cause", "post", "session", "index", "frame", "path", "image", "uri", "error", "current", "invoke", "q", "header", "create", "subject", "order", "received", "proxy", "ware", "QUEST"], "response": ["next", "host", "page", "respond", "site", "connection", "reference", "success", "reply", "ception", "result", "output", "message", "view", "one", "http", "out", "object", "model", "application", "onse", "data", "version", "resolution", "re", "r", "resource", "server", "serv", "body", "report", " Response", "json", "status", "session", "Response", "index", "string", "respons", "image", "cache", "answer", "error", "err", "resp", "service", "received", "reason", "res", "collection"], "chain": ["chains", "processor", "default", "wrapper", "network", "cycle", "Chain", "range", "build", "function", "result", " chained", "view", "thread", "client", "end", "loop", "row", "channel", "stream", "class", "clean", "call", "config", "module", "query", "batch", "cross", "container", "middle", "hole", "run", "rule", "pool", "list", "cache", "lock", "c", "check", "or", "builder", "block", "process", "self", "group", "stack", "collection", "filter"], "httpServletRequest": ["httpSingleResponse", "httpSingleQuery", "httpServlingMessage", "httpServletsMessage", "httpServetQuery", "httpWebleMessage", "httpWebleSession", "httpServlingRequest", "httpServLETMessage", "httpServletsRequest", "httpServleServer", "httpServLETResponse", "httpServLETResource", "httpServlingSession", "httpServleSession", "httpSingleServer", "httpSingletResponse", "httpServetRequest", "httpWebleResource", "httpWebletResponse", "httpServLETRequest", "httpServleQuery", "httpServletSession", "httpServledMessage", "httpServledSession", "httpServleResponse", "httpServletServer", "httpWebletRequest", "httpWebletResource", "httpServleRequest", "httpServleResource", "httpSingletRequest", "httpWebleRequest", "httpServetResponse", "httpServletResource", "httpWebletSession", "httpSingletQuery", "httpServlingResponse", "httpServetServer", "httpServcelQuery", "httpServledRequest", "httpServleMessage", "httpWebletMessage", "httpServletsResponse", "httpWebleResponse", "httpSingleRequest", "httpServletMessage", "httpServcelRequest", "httpServcelResponse", "httpServcelServer", "httpServletQuery", "httpSingletServer", "httpServledResponse", "httpServletsResource"], "httpServletResponse": ["httpBootlettresponse", "httpServLETResult", "httpServleServer", "httpBootlettResponse", "httpServletsView", "httpServletService", "httpWebletResult", "httpWebletRequest", "httpServlingView", "httpServleteResponse", "httpServledWriter", "httpServleRequest", "httpServleteView", "httpServletePage", "httpServlettresponse", "httpServledResponse", "httpServietResponse", "httpBootlettRequest", "httpServietSession", "httpServLETResponse", "httpServletResult", "httpServietResult", "httpServleresponse", "httpBootlettService", "httpServleResponse", "httpPortletSession", "httpBootletResponse", "httpServletWriter", "httpServetResponse", "httpServietWriter", "httpServletsresponse", "httpServlingWriter", "httpServletsPage", "httpServLETServer", "httpPortietSession", "httpServleResult", "httpPortletWriter", "httpServletsService", "httpServlingSession", "httpPortletResult", "httpWebleServer", "httpServLETRequest", "httpServleteResult", "httpServletView", "httpServledSession", "httpPortietResponse", "httpServletPage", "httpServlettService", "httpPortletResponse", "httpPortietResult", "httpBootletService", "httpPortietWriter", "httpBootletRequest", "httpServlingResponse", "httpServlingResult", "httpWebletServer", "httpServletsResult", "httpServleService", "httpServledResult", "httpServletsRequest", "httpServlingPage", "httpServetRequest", "httpWebletResponse", "httpServletSession", "httpServlettResponse", "httpWebleResult", "httpServletServer", "httpWebleRequest", "httpServetResult", "httpServetServer", "httpServletsResponse", "httpServlettRequest", "httpWebleResponse", "httpServletresponse", "httpBootletresponse"], "contextPath": ["contextPoint", "ContextPath", "requestPATH", " contextPoint", "contextPATH", "backgroundPATH", " contextFile", "backgroundpath", "cachePath", "filterpath", "cachepath", "filterPATH", "contextath", "ContextPoint", "ContextFile", "ContextURI", "backgroundPath", "requestath", "requestpath", "requestFile", "requestPath", "contextpath", "contextFile", "cacheath", " contextpath", "requestPoint", "backgroundURI", "cachePATH", " contextURI", " contextPATH", "contextURI", " contextath"], "requestURI": ["contextURL", "contextLocation", "responseURL", "responseLocation", "responsePath", "requestUrl", "contexturi", " requestFolder", "RequestFolder", "requestFolder", "resourceURI", "RequestURI", "requesturi", "responseUrl", "RequestUrl", "requestLocation", "resourceLocation", "RequestURL", "contextUrl", "resourceuri", "requestPath", "responseURI", " requesturi", "resourcePath", " requestURL", "responseuri", "contextURI", "requestURL", " requestUrl", "contextFolder"], "filterURI": ["contextURL", "sourceUrl", "controlPath", "contexturi", "filterFile", "resourceURI", "filterURL", "requesturi", "targetPath", "sourceFile", "targeturi", "controlURI", "filterUrl", " filterFile", "controlUrl", "filteruri", "targetURL", "resourceUrl", "sourcePath", "requestPath", "controlURL", "targetUrl", "targetFile", "sourceURI", "resourcePath", "resourceURL", "contextURI", "requestURL", " filterUrl"], "filterPath": ["targetPattern", "targetKey", "targetpath", "FilterPath", "filterPart", "FilterCase", "FilterPart", "filterpath", "FilterName", "targetPath", "targetName", "FilterPattern", "Filterpath", "FilterURI", " filterPart", "filterPattern", " filterPattern", "targetCase", " filterCase", "FilterKey", " filterpath", "filterName", "targetPart", " filterName", "filterCase", " filterKey", "filterKey"], "targetURI": ["sourceUrl", "filterString", "requestUrl", " targetString", "filterURL", "requesturi", "targetPath", "TargetURI", "targeturi", " targetURL", "filterUrl", "filteruri", "targetURL", "TargetPath", " targetPath", " targetUrl", "targetUrl", "sourceURI", "Targeturi", "sourceuri", "targetString", "TargetString", " targeturi", "sourceURL", "requestURL"], "entry": ["next", "via", "page", "route", "mission", "id", "reader", "term", "connection", "feed", "result", "ry", "letter", "part", "row", "ries", "data", "no", "directory", "auto", "r", "pair", "her", "archive", "address", "way", "info", "section", "element", "word", "alias", "ge", "e", "escape", "se", "index", "string", "image", "entity", "record", "uri", "file", "parse", "or", "service", "array", "Entry", "rant", "ie"], "key": ["source", "parent", "route", "size", "id", "link", "pe", "connection", "core", "k", "ry", "view", "owner", "root", "part", "base", "ver", "data", "Key", "style", "prefix", "feature", "child", "address", "role", "KEY", "ie", "section", "element", "word", "name", "query", "ge", "target", "length", "text", "index", "string", "path", "point", "rule", "uri", "code", "search", "service", "item", "type", "field", "ip", "use"], "value": ["source", "host", "id", "url", "write", "reference", "username", "output", "message", "val", "base", "data", "version", "VALUE", "resource", "prefix", "server", "address", "element", "section", "name", "volume", "target", "text", "content", "v", "variable", "index", "string", "path", "media", "uri", "attribute", "Value", "property", "service", "type"], "resourceName": ["referencename", "rangePath", "remoteKey", " resourceFamily", "collectionKey", "ResourceName", " resourceType", "resourcename", "collectionName", "resourceFamily", "resourceNames", "remoteType", "remotename", " resourcePath", "collectionFamily", "referenceKey", "rangeNames", "Resourcename", "collectionname", "resourceType", "ResourcePath", "ResourceType", " resourcename", "referenceName", "resourcePath", "ResourceKey", "rangeType", "resourceKey", "remoteName", " resourceNames", "rangeName", " resourceKey", "ResourceNames", "referenceFamily"], "is": ["get", "id", "nis", "si", "ils", "isa", "fs", "ais", "isl", "out", "in", "alis", "ists", "as", "isp", "was", "are", "iss", "stream", "os", "ens", "ris", "serv", "es", "info", "gets", "js", "x", "iv", "has", "isi", "it", "ui", "s", "IS", "api", "rs", "abs", "ri", "il", "lis", "ios", "image", "ops", "isc", "its", "uri", "ori", "i", "or", "ois", "us", "ar", "Is", "bis", "iso", "res", "p", "does"]}}
{"id1": "2972950", "id2": "5926761", "code1": "    private void proxyMediaServlet(String url, HttpServletRequest req, HttpServletResponse resp) {\n        try {\n            URL u = new URL(\"http://mediaserver:8080/sagex\" + url);\n            log.debug(\"Proxy Media: \" + u.toString());\n            URLConnection c = u.openConnection();\n            c.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.1) Gecko/2008072820 Firefox/3.0.1\");\n            OutputStream os = resp.getOutputStream();\n            IOUtils.copy(c.getInputStream(), os);\n            os.flush();\n            resp.flushBuffer();\n        } catch (Throwable t) {\n            log.error(\"Failed to get url: \" + url, t);\n            try {\n                resp.sendError(500, t.getMessage());\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (feedbackView.getText().length() <= 0) return;\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                }\n\n                public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                }\n            } };\n            try {\n                SSLContext sc = SSLContext.getInstance(\"SSL\");\n                sc.init(null, trustAllCerts, new java.security.SecureRandom());\n                HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n            } catch (Exception e3) {\n                e3.printStackTrace();\n            }\n            feedback = \"\";\n            addLine(\"Type            : \" + feedbackView.getType());\n            addLine(\"User            : \" + HIRuntime.getManager().getCurrentUser().getLastName() + \", \" + HIRuntime.getManager().getCurrentUser().getFirstName() + \" (\" + HIRuntime.getManager().getCurrentUser().getUserName() + \") \" + HIRuntime.getManager().getCurrentUser().getEmail());\n            addLine(\"Project         : P\" + HIRuntime.getManager().getProject().getId() + \" - \" + MetadataHelper.findValue(HIRuntime.getManager().getProject(), HIRuntime.getManager().getProject().getDefaultLanguage().getLanguageId()));\n            addLine(\"Client Version  : \" + HIRuntime.getClientVersion());\n            addLine(\"Service URL     : \" + HIRuntime.getManager().getServerURL());\n            try {\n                addLine(\"Service Version : \" + HIRuntime.getManager().getVersionID());\n            } catch (HIWebServiceException e1) {\n            }\n            addLine(\"Client OS       : \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\") + \" (\" + System.getProperty(\"os.arch\") + \")\");\n            addLine(\"Java Version    : \" + System.getProperty(\"java.version\") + \" (\" + System.getProperty(\"java.vendor\") + \")\");\n            if (HIRuntime.getGui().getLastWSError() == null) addLine(\"Last WS Error   : -none-\"); else {\n                HIWebServiceException lastWSError = HIRuntime.getGui().getLastWSError();\n                addLine(\"Last WS Error   : \" + lastWSError.getCause().getMessage() + \" (\" + lastWSError.getErrorType() + \")\");\n                addLine(\"\");\n                addLine(\"Stack Trace\");\n                addLine(\"-----------\");\n                ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n                PrintWriter writer = new PrintWriter(byteStream);\n                lastWSError.getCause().printStackTrace(writer);\n                writer.close();\n                addLine(new String(byteStream.toByteArray()));\n            }\n            addLine(\"\");\n            addLine(\"Message\");\n            addLine(\"-------\");\n            feedback = feedback + feedbackView.getText();\n            feedback = feedback + \"\\n\\n\";\n            feedback = URLEncoder.encode(feedback, \"UTF-8\");\n            URL url = new URL(\"https://hyperimage.cms.hu-berlin.de/2.0/wstart/provideFeedback.php\");\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setDoOutput(true);\n            PrintWriter writer = new PrintWriter(connection.getOutputStream());\n            writer.write(\"raw_fb=\" + feedback);\n            writer.close();\n            connection.connect();\n            String response = connection.getResponseMessage();\n            if (response.compareTo(\"OK\") == 0) {\n                HIRuntime.getGui().clearLastWSError();\n                HIRuntime.getGui().displayInfoDialog(\"Feedback gesendet\", \"Vielen Dank f\u00fcr Ihr Feedback!\\n\\nIhre Nachricht wurde an die HyperImage Entwickler gesendet.\");\n            } else HIRuntime.getGui().displayInfoDialog(\"Feedback Fehlgeschlagen\", \"Leider konnte Ihr Feedback aufgrund eines Systemfehlers nicht gesendet werden.\\n\" + \"Bitte versuchen Sie es sp\u00e4ter erneut.\\n\\n\" + \"Sollte das Problem bestehen bleiben wenden Sie sich bitte per mail an die Entwickler.\\n\\nVielen Dank!\");\n            connection.disconnect();\n        } catch (MalformedURLException e1) {\n            e1.printStackTrace();\n            HIRuntime.getGui().displayInfoDialog(\"Feedback Fehlgeschlagen\", \"Leider konnte Ihr Feedback aufgrund eines Systemfehlers nicht gesendet werden.\\n\" + \"Bitte versuchen Sie es sp\u00e4ter erneut.\\n\\n\" + \"Sollte das Problem bestehen bleiben wenden Sie sich bitte per mail an die Entwickler.\\n\\nVielen Dank!\");\n        } catch (IOException e2) {\n            e2.printStackTrace();\n            HIRuntime.getGui().displayInfoDialog(\"Feedback Fehlgeschlagen\", \"Leider konnte Ihr Feedback aufgrund eines Systemfehlers nicht gesendet werden.\\n\" + \"Bitte versuchen Sie es sp\u00e4ter erneut.\\n\\n\" + \"Sollte das Problem bestehen bleiben wenden Sie sich bitte per mail an die Entwickler.\\n\\nVielen Dank!\");\n        }\n        HIRuntime.getGui().deregisterComponent(this, false);\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "route", "id", "connection", "rel", "ll", "src", "l", "http", "request", "fr", "loc", "base", "f", "href", "ref", "remote", "zip", "resource", "org", "server", "address", "el", "name", "ur", "gl", "location", "ls", "string", "media", "path", "image", "rl", "rule", "html", "uri", "ssl", "file", "URL", "service", "Url", "proxy", "web", "sl"], "req": ["cb", "proc", "rx", "ro", "cgi", "conn", "src", "w", "request", "b", "fr", "ref", "re", "r", "ctx", "Request", "conf", "query", "requ", "Requ", "rec", "quest", "obj", "err", "rr", "q", "res", "rb"], "resp": ["page", "respond", "rel", "rep", "reply", "result", "conn", "http", "out", "request", "client", "ref", "re", "response", "r", "ctx", "zip", "server", "ret", "serv", "esi", "body", "e", "report", "cl", "api", "df", "esp", "rec", "Response", "v", "respons", "pool", "sp", "obj", "rev", "cache", "html", "err", "wb", "Resp", "prev", "pp", "rr", "inv", "res", "cmp", "p"], "u": ["su", "ru", "uc", "util", "cu", "iu", "l", "ul", "uu", "http", "this", "fp", "b", "ue", "ou", "client", "f", "n", "mu", "tu", "U", "yu", "hu", "ur", "ui", "o", "t", "m", "nu", "up", "chu", "lu", "ut", "uri", "uv", "i", "us", "eu", "bu", "p"], "c": ["h", "dc", "d", "uc", "cm", "cu", "cy", "cf", "co", "conn", "l", "ct", "fc", "con", "w", "client", "b", "bc", "f", "p", "ec", "cp", "enc", "xc", "mc", "pc", "exec", "cn", "ci", "e", "o", "cl", "t", "cs", "ch", "cli", "lc", "v", "cr", "i", "cc", "z", "cmp", "ac", "C"], "os": ["los", "ys", "ks", "des", "ies", "ss", "io", "conn", "fs", "http", "out", "OS", "bos", "as", "oc", "oa", "bs", "outs", "ens", "es", "dos", "ors", "vs", "oss", "oos", "o", "e", "aos", "s", "cs", "rs", "ls", "Os", "nos", "ios", "ops", "i", "us", "ds", "cos", "is", "osi", "ps", "res"]}}
{"id1": "9088422", "id2": "15416857", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private boolean extract(File archive, File dir, IProgressMonitor monitor) {\n        monitor.subTask(\"Extract : \" + archive.getName());\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else {\n            File[] files = dir.listFiles();\n            for (int j = 0; j < files.length; j++) {\n                files[j].delete();\n            }\n        }\n        ZipInputStream zis = null;\n        try {\n            zis = new ZipInputStream(new FileInputStream(archive));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                File indexFile = new File(dir, entry.getName());\n                FileOutputStream fos = null;\n                try {\n                    fos = new FileOutputStream(indexFile);\n                    IOUtils.copy(zis, fos);\n                } finally {\n                    IOUtils.closeQuietly(fos);\n                }\n            }\n            return true;\n        } catch (Exception ex) {\n            M4EclipsePlugin.log(new Status(IStatus.ERROR, M4EclipsePlugin.PLUGIN_ID, -1, \"For index '\" + dir.getName() + \"' Unable to initialize indexes\", ex));\n        } finally {\n            IOUtils.closeQuietly(zis);\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"infile": ["inputfile", "infilename", "outFile", "infiles", "inFile", "inputfiles", "inputfilename", "outfiles", " infilename", "infp", " infp", "inputfp", "outfilename", "Infiles", " infiles", "InFile", "outfp", "Infilename", "inputFile", "Infile"], "outfile": ["outputfp", "outFile", "infilename", "Outname", "newfile", "OutFile", "outputfilename", " outFile", "newname", "infp", "newfolder", "outfilename", "Outfile", " outfolder", "newFile", " outname", "outfolder", " outfp", "outputfolder", "outfp", "Outfolder", "infolder", "outname", " outfilename", "outputfile"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "min", "nin", "conn", "con", "b", "login", "as", "base", "data", "In", "pin", "into", "re", "r", "inas", "thin", "again", "ac", "isin", "inner", "init", "ins", "vin", "gin", "ini", "a", "m", "sin", "cin", "image", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "bin", "s", "ic", "pass"], "out": ["source", "parent", "inc", "write", "net", "co", "io", "output", "outer", "conn", "lib", "one", "client", "home", "ou", "base", "on", "to", "no", "In", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "ex", "post", "timeout", "session", "up", "job", "point", "image", "cache", "socket", "file", "obj", "error", "err", "or", "bin", "copy", "exit", "line"], "buffer": ["source", "size", "reader", "split", "url", "queue", "input", "write", "binary", "feed", "len", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "base", "layer", "data", "bytes", "server", "raw", "address", "uffer", "transfer", "null", "padding", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "count", "border", "seed", "cache", "fb", "value", "type"], "read": ["play", "select", "next", " write", "size", "reader", "ad", "input", "get", "write", "inc", "id", "feed", "len", "Read", "ind", "iter", " skip", "fill", "READ", "ride", "io", "limit", "end", "tell", "f", "sleep", "find", "n", "work", "raw", "exec", "x", "sync", "send", "reading", "_", "length", "allow", "run", "close", "se", "slice", "count", "pass", "load", "connect", "parse", "i", "seek", "check", "wait", "lex", "current", " copy", "start", " count", "ip", "add", "copy", " Read", "use", "reads"], "success": ["successful", "continue", "roll", "default", "warning", "first", "better", "successfully", "open", " succeed", "complete", "growth", "result", "right", "message", "Success", "true", "flash", "winner", " succ", "model", " successful", "cess", "data", "fast", "again", "response", "primary", "xx", "rolled", " Success", "method", "func", "results", "failed", "initial", "comment", "danger", "content", "status", "done", "path", "respons", "error", "fail", "modified", "valid", "construct", "ccess", "rolling", "follow", "ceed", "good", "value", "null", "pass"]}}
{"id1": "10067028", "id2": "19267604", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            long size = in.size();\n            MappedByteBuffer buffer = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buffer);\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    protected void convertInternal(InputStream inputStream, DocumentFormat inputFormat, OutputStream outputStream, DocumentFormat outputFormat) {\n        File inputFile = null;\n        File outputFile = null;\n        try {\n            inputFile = File.createTempFile(\"document\", \".\" + inputFormat.getFileExtension());\n            OutputStream inputFileStream = null;\n            try {\n                inputFileStream = new FileOutputStream(inputFile);\n                IOUtils.copy(inputStream, inputFileStream);\n            } finally {\n                IOUtils.closeQuietly(inputFileStream);\n            }\n            outputFile = File.createTempFile(\"document\", \".\" + outputFormat.getFileExtension());\n            convert(inputFile, inputFormat, outputFile, outputFormat);\n            InputStream outputFileStream = null;\n            try {\n                outputFileStream = new FileInputStream(outputFile);\n                IOUtils.copy(outputFileStream, outputStream);\n            } finally {\n                IOUtils.closeQuietly(outputFileStream);\n            }\n        } catch (IOException ioException) {\n            throw new OpenOfficeException(\"conversion failed\", ioException);\n        } finally {\n            if (inputFile != null) {\n                inputFile.delete();\n            }\n            if (outputFile != null) {\n                outputFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "src", "from", "object", "Source", "client", "base", "table", "stream", "remote", "resource", "server", "inner", "ources", "sync", "filename", "name", "ins", "target", "ource", "sin", "SOURCE", "internal", "slice", "path", "image", "string", "cache", "file", "service", "proxy", "use"], "destination": [" Destination", " Destinations", "destitution", "declinator", "declination", "Destinated", "distinated", "distination", "distitution", "declinations", "destinated", "declinated", "Destinator", "constinator", "constitution", "destinations", "Destinations", " Destinator", "constination", "destinator", "constinated", "distinator", " Destinated", "Destination", "Destitution"], "in": ["get", "reader", "id", "url", "input", "inc", "din", "token", "win", "pull", "min", "nin", "conn", "src", "con", "b", "this", "diff", "login", "base", "as", "data", "In", "pin", "again", "n", "r", "include", "thin", "stream", "server", "work", "isin", "inner", "info", "pc", "name", "init", "ins", "gin", "ini", "m", "issue", "up", "slice", "index", "cin", "image", "socket", "c", "file", "i", "IN", "err", "inside", "inn", "is", "bin", "pass"], "out": ["parent", "id", "plain", "write", "line", "net", "connection", "extra", "io", "output", "outer", "conn", "one", "w", "client", "ou", "part", "channel", "to", "no", "version", "OUT", "Out", "again", "n", "prefix", "outs", "server", "external", "writer", "inner", "off", "exec", "dest", "sync", "init", "o", "other", "target", "flush", "ex", "timeout", "up", "image", "pool", "vert", "cache", "obj", "file", "socket", "err", "at", "outside", "bin", "copy", "null", "ext"], "size": ["page", "export", "en", "write", "si", "len", "range", "scale", "weight", "limit", "sized", "end", "mode", "Size", "number", "loc", "SIZE", "bytes", "n", "sum", "address", "shape", "send", "depth", "name", "transfer", "sync", "e", "ize", "length", "flush", "capacity", "max", "content", "offset", "time", "count", "code", "seek", "width", "speed", "type", "order", "empty", "small", "clear", "unit"], "buffer": ["reader", "value", "url", "input", "queue", "feed", "buff", "iter", "Buffer", "output", "BB", "channel", "base", "layer", "data", "resource", "address", "info", "writer", "uffer", "null", "batch", "bb", "flow", "length", "wave", "FFER", "buf", "offset", "document", "cache", "map", "header", "texture", "bin", "copy"]}}
{"id1": "8793826", "id2": "8481623", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        from_file = checkFile(from_file);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"infile": ["inputfile", "infilename", " inFile", "infiles", "inFile", "inbase", "inputfiles", "inputfilename", " instream", "outfiles", " infilename", "Instream", "infp", " infp", "inputfp", "Inbase", "outfilename", " infiles", "InFile", "instream", "minbase", " inbase", "minstream", "outfp", "minfile", "Infile", "minFile"], "outfile": ["inputfile", "outFile", "infilename", " outdatabase", "outputpath", "inFile", "outputfilename", "outdatabase", "outputFile", " outFile", "outpath", "outfilename", "outputdatabase", " outfolder", "inputdatabase", "outfolder", "outputfolder", "infolder", "inputpath", "inputFile", " outpath", " outfilename", "outputfile"], "in": ["source", "reader", "id", "input", "inc", "din", "win", "min", "nin", "conn", "con", "b", "login", "as", "data", "In", "pin", "into", "re", "r", "inas", "thin", "again", "ac", "isin", "inner", "init", "ins", "gin", "ini", "a", "m", "sin", "cin", "socket", "i", "IN", "err", "inside", "inn", "rin", "is", "lin", "bin", "s", "ic", "pass"], "out": ["parent", "inc", "write", "net", "co", "io", "output", "outer", "conn", "one", "lib", "client", "home", "ou", "base", "channel", "to", "no", "In", "OUT", "Out", "again", "outs", "work", "writer", "inner", "off", "exec", "sync", "name", "o", "log", "ex", "post", "job", "session", "up", "timeout", "point", "image", "cache", "socket", "file", "obj", "error", "err", "or", "bin", "copy", "exit", "line", "pass"], "buffer": ["source", "size", "reader", "split", "url", "queue", "input", "write", "binary", "feed", "reference", "buff", "iter", "result", "Buffer", "limit", "b", "base", "channel", "layer", "data", "bytes", "server", "raw", "address", "uffer", "transfer", "null", "padding", "batch", "bb", "length", "flush", "wave", "buf", "offset", "slice", "count", "border", "seed", "cache", "bin", "value", "type"], "read": ["play", "select", "next", " write", "size", "reader", "ad", "get", "inc", "write", "id", "feed", "len", "Read", "ind", "iter", " skip", "fill", "READ", "ride", "io", "limit", "end", "tell", "f", "sleep", "find", "n", "r", "work", "raw", "exec", "x", "sync", "send", "reading", "_", "length", "allow", "run", "se", "slice", "count", "pass", "load", "parse", "connect", "i", "seek", "check", "wait", "lex", "current", " copy", "start", " count", "ip", "add", "copy", " Read", "use", "reads"], "success": ["successful", "continue", "roll", "default", "warning", "first", "better", "successfully", "open", " succeed", "complete", "growth", "result", "right", "message", "Success", "true", "positive", "flash", "winner", " succ", "model", " successful", "cess", "data", "fast", "again", "response", "primary", "xx", "rolled", " Success", "method", "func", "results", "failed", "initial", "comment", "danger", "content", "status", "done", "path", "error", "fail", "valid", "construct", "ccess", "rolling", "follow", "ceed", "good", "value", "null", "pass"]}}
{"id1": "22726124", "id2": "15570948", "code1": "    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"http://localhost:9090/node/Insert/\" + args[0] + \"?address=blah\");\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStream os = conn.getOutputStream();\n        Conduit.pump(System.in, os);\n        Conduit.pump(conn.getInputStream(), System.out);\n        System.out.println(\"done\");\n    }\n", "code2": "    private String generate(String value) throws Exception {\n        String resStr = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(value.getBytes(\"utf-8\"), 0, value.length());\n            byte[] result = md.digest();\n            resStr = FTGenerate.convertToHex(result);\n            md.reset();\n        } catch (NoSuchAlgorithmException nae) {\n            this.getLog().severe(\"Hash no funcionando\");\n            nae.printStackTrace();\n            throw new Exception(\"Hash no funcionando\");\n        } catch (UnsupportedEncodingException ee) {\n            this.getLog().severe(\"Encoding no funcionando\");\n            ee.printStackTrace();\n            throw new Exception(\"Encoding no funcionando\");\n        }\n        return resStr;\n    }\n", "label": 0, "substitutes": {"url": ["host", "page", "connection", "open", "build", "ll", "l", "http", "con", "out", "client", "b", "f", "base", "channel", "loc", "r", "resource", "org", "server", "address", "config", "bb", "log", "api", "bel", "ls", "string", "path", "obj", "file", "ssl", "uri", "err", "URL", "service", "Url", "www", "blog", "web", "sl"], "conn": ["h", "dc", "cb", "en", "connection", "cm", "open", "cf", "io", "ct", "http", "con", "out", "b", "client", "pg", "connected", "f", "ec", "cp", "n", "enc", "ctx", "comm", "cn", "exec", "cur", "sync", "ci", "s", "nt", "act", "api", "ch", "cli", "ann", "close", "col", "connect", "obj", "c", "socket", "ssl", "conv", "Connection", "Conn", "nc", "coll", "p"], "os": ["ks", "si", "so", "io", "fs", "object", "ns", "ms", "OS", "ou", "bos", "oa", "outs", "ens", "es", "sys", "oss", "o", "aos", "ok", "log", "cs", "ls", "Os", "ios", "ops", "ips", "i", "ol", "pos", "obs", "osi", "ps", "s", "ot", "p"]}}
{"id1": "12798566", "id2": "12116028", "code1": "    private static void process(String urlstring) {\n        try {\n            URL url = new URL(urlstring);\n            System.out.println(\"Connecting to \" + url);\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            for (String line; (line = in.readLine()) != null; ) if (line.startsWith(MARKER)) {\n                System.out.println(TAG.matcher(line).replaceAll(\"\"));\n            }\n            in.close();\n        } catch (IOException ioe) {\n            System.err.println(\"\" + ioe);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        File inputFile = new File(args[0]);\n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));\n        StringBuffer stringBuffer = new StringBuffer();\n        String readed;\n        while ((readed = reader.readLine()) != null) stringBuffer.append(readed + \"\\r\\n\");\n        readed = stringBuffer.toString();\n        reader.close();\n        File outputFile = new File(args[0] + \".output\");\n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));\n        readed = readed.replaceAll(\"\\\\t+\", \"#\");\n        readed = readed.replaceAll(\"\\\\s*#\\\\s*\", \"#\");\n        readed = readed.replaceAll(\"Latitude,.*\", \"\");\n        readed = readed.replaceAll(\"Flag of\", \"\");\n        readed = readed.replaceAll(\"^\\\\s+$\", \"\");\n        writer.write(readed);\n        writer.close();\n    }\n", "label": 0, "substitutes": {"urlstring": ["feedString", "httpsource", "urlspace", "urlsource", "longstream", " urlString", "feedstr", " urlspace", " urlstr", "httpspace", "httpstream", "httpstr", " urlstream", " urlsource", "urlstr", "longstring", "feedstring", "urlstream", "feedsource", "urlString", "longstr", "longspace", "httpString", "httpstring"], "url": ["source", "host", "page", "route", "id", "link", "user", "open", "buffer", "conn", "l", "http", "client", "b", "object", "bug", "base", "f", "layer", "resource", "email", "server", "address", "config", "use", "name", "bb", "log", "cli", "ls", "session", "string", "path", "rule", "image", "connect", "socket", "uri", "file", "ssl", "c", "db", "URL", "service", "Url", "www", "proxy", "web", "location"], "connection": ["reader", "open", "director", "function", "io", "conn", "l", "communication", "http", "con", "out", "b", "client", "union", "connected", "login", "channel", "application", "f", "directory", "handler", "server", "config", "condition", "section", "password", "ion", "relation", "timeout", "cli", "session", "pool", "connect", "socket", "c", "db", "context", "uri", "service", "database", "which", "position", "cond", "Connection", "proxy"], "in": ["reader", "input", "inc", "din", "io", "nin", "conn", "con", "out", "b", "client", "login", "f", "loader", "In", "pin", "stream", "re", "r", "again", "into", "inner", "body", "init", "ins", "gin", "ini", "kin", "connect", "c", "socket", "i", "IN", "inside", "inn", "is", "lin", "bin"], "line": ["source", "page", "reader", "link", "write", "buffer", "lf", "lines", "message", "l", "letter", "definition", "out", "end", "LINE", "cell", "column", "Line", "row", "f", "part", "data", "inline", "style", "response", "match", "strip", "section", "word", "tag", "name", "e", "log", "text", "comment", "content", "lc", "le", "up", "string", "rule", "file", "parse", "code", "err", "label", "header", "item", "block", "character", "lin", "str", "unit"]}}
{"id1": "228212", "id2": "18354823", "code1": "    public void CopyFile(File source, File destination) throws Exception {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(source);\n            fos = new FileOutputStream(destination);\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                fos.write(buffer, 0, read);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private String storeEditionFile(InputStream in) throws IOException {\n        String datadir = getCqPropertiesBeanSpring().getDatadir() + File.separator + \"attachments\" + File.separator;\n        File attachmentsDir = new File(datadir);\n        attachmentsDir.mkdirs();\n        File storedEditionFile = File.createTempFile(\"edition_import_\", \".tmp\", attachmentsDir);\n        FileOutputStream out = new FileOutputStream(storedEditionFile);\n        IOUtils.copyLarge(in, out);\n        IOUtils.closeQuietly(out);\n        IOUtils.closeQuietly(in);\n        return storedEditionFile.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"source": ["reader", "site", "input", "connection", "reference", "iter", "origin", "io", "src", "from", "in", "this", "Source", "base", "table", "directory", "stream", "remote", "resource", "ie", "server", "address", "info", "ources", "filename", "name", "e", "target", "ource", "sin", "SOURCE", "slice", "string", "image", "file", "uri", "i", "service", "scene", "proxy", "use", "unit"], "destination": ["deadinated", "deadination", "Desturation", "destiner", "combinated", "deaduration", "Destinated", "desturation", "Destiner", "destinated", "dinations", "combination", "diination", "diinations", "Destinator", "deadiner", "diinated", "dinated", "destinations", "dinator", "Destinations", "dination", "combiner", "diinator", "comburation", "destinator", "Destination"], "fis": ["los", "fris", "infris", "fois", "Fos", "Fiss", "las", "fiss", "bos", "infos", "lois", "fios", "Fas", " fois", "biss", " fios", "bris", "Fris", "hos", "Fis", "his", "hiss", " fas", "infis", " fris", "hris", "Fois", "lis", "infios", "Fios", "lris", "bis", " fiss", "fas"], "fos": ["Foes", "los", " fros", " foses", "fose", "fus", " foes", " fou", "ufou", "ufos", "baos", "ufros", "pose", "bros", "fros", "Fos", "bos", "infos", "fios", "infus", " fios", " faos", " fus", "Faos", "poes", "lios", "bou", "Fis", "infis", "Fose", "loses", "faos", "lis", "ufis", "infios", "foses", "bus", "Fios", "bios", "pos", "Foses", "poses", "bis", "fou", "foes", " fose"], "buffer": ["reader", "url", "queue", "memory", "binary", "input", "write", "feed", "reference", "buff", "repeat", "iter", "result", "Buffer", "limit", "request", "b", "channel", "number", "layer", "data", "available", "resource", "address", "uffer", "shape", "transfer", "null", "batch", "flush", "length", "wave", "buf", "slice", "count", "document", "border", "seed", "cache", "header", "block", "total", "position", "bin"], "read": ["play", "get", "next", "reader", "en", "size", "id", "write", "d", "input", "feed", "len", "Read", "ind", "open", "iter", "READ", "io", "in", "b", "end", "f", "data", "rate", "find", "n", "work", "raw", "exec", "x", "send", "e", "reading", "_", "length", "allow", "text", "max", "se", "key", "run", "index", "close", "count", "pass", "load", "connect", "parse", "readable", "i", "check", "seek", "current", "type", "wait", "start", " count", "add", "ed", " Read", "use", " ride", "reads"]}}
{"id1": "10450245", "id2": "13806107", "code1": "    public Map<String, String> getMetadata(WebFileObject fo) throws IOException {\n        if (!fo.wfs.getRootURL().getProtocol().equals(\"ftp\")) {\n            String realName = fo.pathname;\n            boolean exists;\n            URL ur = new URL(fo.wfs.getRootURL(), realName);\n            HttpURLConnection connect = (HttpURLConnection) ur.openConnection();\n            connect.setRequestMethod(\"HEAD\");\n            HttpURLConnection.setFollowRedirects(false);\n            connect.connect();\n            HttpURLConnection.setFollowRedirects(true);\n            if (connect.getResponseCode() == 303) {\n                String surl = connect.getHeaderField(\"Location\");\n                if (surl.startsWith(fo.wfs.root.toString())) {\n                    realName = surl.substring(fo.wfs.root.toString().length());\n                }\n                connect.disconnect();\n                ur = new URL(fo.wfs.getRootURL(), realName);\n                connect = (HttpURLConnection) ur.openConnection();\n                connect.setRequestMethod(\"HEAD\");\n                connect.connect();\n            }\n            exists = connect.getResponseCode() != 404;\n            Map<String, String> result = new HashMap<String, String>();\n            Map<String, List<String>> fields = connect.getHeaderFields();\n            for (Entry<String, List<String>> e : fields.entrySet()) {\n                String key = e.getKey();\n                List<String> value = e.getValue();\n                result.put(key, value.get(0));\n            }\n            result.put(META_EXIST, String.valueOf(exists));\n            connect.disconnect();\n            return result;\n        } else {\n            Map<String, String> result = new HashMap<String, String>();\n            URL url = new URL(fo.wfs.getRootURL(), fo.pathname);\n            URLConnection urlc = url.openConnection();\n            try {\n                urlc.connect();\n                urlc.getInputStream().close();\n                result.put(META_EXIST, \"true\");\n            } catch (IOException ex) {\n                result.put(META_EXIST, \"false\");\n            }\n            return result;\n        }\n    }\n", "code2": "    private void makeQuery(String query) {\n        System.out.println(\" Querying for \" + query);\n        try {\n            query = URLEncoder.encode(query, \"UTF-8\");\n            for (int k = 0; k < 100; k++) {\n                System.out.println(query);\n                URL url = new URL(\"http://ajax.googleapis.com/ajax/services/search/web?start=\" + k * 8 + \"&rsz=large&v=1.0&q=\" + query);\n                URLConnection connection = url.openConnection();\n                connection.addRequestProperty(\"Referer\", HTTP_REFERER);\n                String line;\n                StringBuilder builder = new StringBuilder();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n                String response = builder.toString();\n                JSONObject json = new JSONObject(response);\n                if (k == 0) {\n                    result = \"Total results = \" + json.getJSONObject(\"responseData\").getJSONObject(\"cursor\").getString(\"estimatedResultCount\") + \"\\n\";\n                }\n                JSONArray ja = json.getJSONObject(\"responseData\").getJSONArray(\"results\");\n                jsonres = ja;\n                for (int i = 0; i < ja.length(); i++) {\n                    System.out.print((i + 1) + \". \");\n                    JSONObject j = ja.getJSONObject(i);\n                    result = result + j.getString(\"titleNoFormatting\") + \" \";\n                    result = result + j.getString(\"url\") + \"\\n\";\n                    result = result + j.getString(\"content\") + \"\\n\\n\";\n                }\n            }\n        } catch (Exception e) {\n            System.err.println(\"Something went wrong...\");\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"fo": ["af", "su", "rf", "ao", "txt", "la", "xml", "prof", "za", "cf", "so", "tto", "ws", "io", "ma", "aco", "olo", "fs", "tw", "ico", " info", "fp", "inf", "sf", "jo", "FO", "ho", "umo", "tra", "f", "tf", "po", "data", "mo", "fe", "fw", "wh", "os", "hello", "auto", "oo", "bo", "abo", "tu", "info", "hea", "vo", "off", "yahoo", " Fo", "lo", "zo", "tp", " FO", "o", "ph", "fn", "shi", "F", "ko", "uf", "no", "ft", "co", "obj", "flo", "ato", "fi", "fa", "wo", "wt"], "realName": ["shortName", "specialNames", "shortResource", "fullFile", "complexName", "complexURL", " realNAME", "RealFile", "realResource", "realNames", "Realname", " realname", "realMessage", "releasename", "RealResource", "realAddress", " realMessage", "reMessage", "realURL", " realNames", "releaseMessage", " realFile", "RealAddress", "specialURL", "rename", "complexNames", "releaseName", "specialname", "realname", "fullAddress", "shortname", "reName", "fullName", "releaseNAME", " realResource", "specialName", "RealName", "realNAME", "complexname", " realURL", "realFile", "fullname", "reNAME", " realAddress"], "exists": ["Existant", "existant", "nexistant", "xists", "expist", " existence", "Expects", "nexists", "exits", "nexits", "Exits", "exist", " exist", "Exists", "existence", "suist", "exests", "Exests", "expects", "expils", "Exist", " expects", "xist", "expits", "nexests", "Existence", "xpects", "Exils", " expistant", "exils", " expests", " expits", "xistence", "suits", "expists", "suils", " expists", "suists"], "ur": ["ure", "attr", "su", "ru", "gr", "util", "UR", "br", "urt", "conn", "ul", "uu", "urs", "ou", "fr", "loc", " cur", "eur", "tur", "sur", "ud", "r", "aur", "org", "air", "ocr", "ub", "ir", "cur", "bor", "ui", "u", "rc", "au", "uj", "enter", "ch", "dr", "Ur", "adr", "tr", "up", "il", "rl", "ut", "utils", "uri", "rt", "uv", "ract", "ol", "raf", "rr", "ar", " su"], "connect": ["contract", "input", "sign", "control", "con", "connected", " disconnect", "r", "contact", "call", "info", "stop", "sync", "cont", "log", "Connect", "syn", "timeout", "release", "quit", "ssl", "support", "construct", "create", "exit", "read", "feed", "build", "destruct", "conn", "join", "object", "find", "remote", "update", "ssh", "event", "patch", "act", "collect", "index", "load", "c", "fail", "nat", "start", "add", "get", "respond", "en", "open", "util", "complete", "core", "http", "request", "client", "login", "sc", "exec", "send", "access", "shut", "text", "ch", "close", "run", "don", "j", "reg", "struct", "reset", "process", "ct", "use", "select", "connection", "uc", "pull", "download", "success", "bind", "output", "out", "config", "condition", "init", "graph", "socket", "un", "follow", "accept", "on", "put"], "surl": ["nsurl", "suri", "sesstring", "nsuri", "nstring", " sstring", "sesuri", "setsuri", "nuri", "setsurl", "srule", "buri", "lstring", "nslocation", "slocation", " sloc", " slocation", "setsrule", "sloc", " srule", "setsstring", "lloc", "sesrule", "sesurl", "bstring", "burl", "nurl", "lurl", "bloc", " suri", "luri", "nloc", "sstring", "nsloc"], "result": ["source", "resources", "page", "attr", "continue", "compl", "test", "default", "user", "success", "buffer", "Result", "dict", "complete", "function", "product", "message", "output", "params", "fr", "part", "table", "summary", "data", "include", "response", "master", "sum", "ret", "match", "repl", "changes", "resource", "section", "results", "report", "json", "instance", "found", "comment", "df", "list", "cache", "record", "err", "search", "map", "details", "manager", "date", "array", "current", "total", "order", "follow", "group", "detail", "res", "filter", "coll", "use"], "fields": ["comments", "ums", "relations", "cells", "strings", "events", "errors", "lines", "keys", "fs", "properties", "items", "types", "f", "data", "objects", "posts", "forms", "groups", "plugins", "results", "pages", "members", "lists", "values", "names", "rules", "rows", "headers", "features", "details", "files", "ids", "tags", "services", "field", "dates", "s"], "e": ["ea", "h", "en", "pe", "d", "be", "edge", "ee", "l", "ev", "end", "ue", "E", "fe", "ec", "r", "es", "esi", "element", "er", "ge", "ne", "de", "ae", "ve", "oe", "enter", "je", "se", "le", "ze", "g", "ele", "eu", "ce", "me", "te", "entry", "p", "ie"], "key": ["source", "id", "link", "keys", "k", "ry", "object", "val", "op", "by", "data", "Key", "version", "match", "prefix", "pair", "ie", "feature", "server", "KEY", "element", "section", "name", "query", "ge", "text", "v", "index", "string", "change", "list", "code", "search", "property", "service", "secret", "item", "type", "field", "option", "ip", "entry"], "value": ["default", "alt", "range", "function", "message", "one", "object", "val", "description", "ue", "part", "data", "VALUE", "response", "pair", "feature", "info", "element", "section", "name", "ge", "member", "flow", "ve", "values", "sv", "area", "v", "all", "string", "media", "image", "list", "Value", "vi", "video", "field", "collection", "entry", "va", "type"], "url": ["host", "feed", "connection", "download", "pull", "ll", "conn", "l", "http", "control", "client", "b", "f", "base", "loc", "stream", "r", "resource", "server", "config", "tool", "cur", "gl", "cl", "t", "bel", "sl", "ch", "fl", "ls", "orb", "c", "ssl", "uri", "g", "URL", "service", "Url", "www", "web", "p"], "urlc": [" urlfc", "URLcon", "urln", "libcon", "urlcon", " urldc", "urldc", "URLf", "Urlh", "URLp", " urlh", "belfc", "llf", "llp", "urlenc", " urlenc", "belc", "URLdc", " urlcache", "slc", "sln", "URLc", " urln", "urlp", "urlfc", "slenc", "urlh", "libc", "urlcache", "llcon", "URLh", "slfc", "Urlc", "URLcache", "beln", "libp", "belenc", "Urlcache", "urlf", "libf", "Urldc", "llc"]}}
{"id1": "852143", "id2": "13637424", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "        public void actionPerformed(ActionEvent e) {\n            String aboutText = \"Slug application.\";\n            String aboutURL = System.getProperty(GateConstants.ABOUT_URL_JAVA_PROPERTY_NAME);\n            boolean canShowInPane = false;\n            if (aboutURL != null) {\n                try {\n                    URL url = new URL(aboutURL);\n                    AboutPaneDialog dlg = new AboutPaneDialog(ShellSlacFrame.this, \"Slug application about\", true);\n                    canShowInPane = dlg.setURL(url);\n                    if (canShowInPane) {\n                        dlg.setSize(300, 200);\n                        dlg.setLocationRelativeTo(ShellSlacFrame.this);\n                        dlg.setVisible(true);\n                    } else {\n                        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                        String line = \"\";\n                        StringBuffer content = new StringBuffer();\n                        do {\n                            content.append(line);\n                            line = reader.readLine();\n                        } while (line != null);\n                        if (content.length() != 0) {\n                            aboutText = content.toString();\n                        }\n                    }\n                } catch (Exception ex) {\n                    if (DEBUG) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n            if (!canShowInPane) JOptionPane.showMessageDialog(ShellSlacFrame.this, aboutText, \"Slug application about\", JOptionPane.INFORMATION_MESSAGE);\n        }\n", "label": 1, "substitutes": {"view": ["page", "div", "sel", "reader", "input", "display", "link", "layout", "buffer", "pull", "review", "widget", "http", "object", "out", "this", "app", "cell", "request", "model", "row", "client", "style", "View", "box", "server", "config", "can", "el", "update", "gui", "body", "event", "ui", "full", "e", "edit", "VIEW", "see", "query", "comment", "screen", "show", "session", "window", "image", "change", "gu", "cache", "lock", "vis", "html", "check", "fail", "im", "GUI", "block", "q", "self", "form", "views", "port", "use"], "url": ["source", "host", "page", "input", "user", "browser", "connection", "open", "buffer", "build", "l", "http", "client", "base", "loader", "f", "channel", "stream", "zip", "resource", "server", "address", "bb", "ob", "log", "bel", "string", "path", "image", "socket", "file", "uri", "ssl", "URL", "service", "hub", "Url", "blog", "web", "sl"], "in": ["source", "reader", "input", "inc", "din", "binary", "win", "buffer", "nin", "con", "out", "b", "login", "as", "data", "In", "stream", "n", "again", "resource", "isin", "inner", "init", "ins", "gin", "ini", "sin", "cin", "socket", "file", "i", "IN", "inn", "rin", "is", "bis", "lin", "s", "ac"], "bin": ["reader", "input", "binary", "din", "browser", "win", "abi", "connection", "buffer", "lib", "http", "con", "out", "b", "part", "loader", "data", "pin", "ruby", "inline", "bi", "inner", "oin", "body", "init", "bb", "log", "spin", "gin", "ini", "sin", "run", "cin", "border", "lock", "socket", "file", "record", "IN", "inn", "lin", "bn", "bot", "fin"], "line": ["source", "page", "entry", "site", "split", "nl", "link", "pe", "lf", "plugin", "band", "lines", "message", "l", "letter", "out", "b", "end", "LINE", "cell", "home", "Line", "row", "base", "part", "layer", "data", "ine", "no", "inline", "style", "server", "el", "section", "word", "name", "ge", "e", "unit", "log", "cl", "text", "comment", "sl", "lc", "job", "status", "key", "le", "day", "string", "up", "rule", "pass", "load", "file", "parse", "code", "i", "block", "lin", "look", "str", "ip", "shell"], "develBuild": ["DEvelbuild", "deestInstall", "deventbuild", "develBuilder", "DEVELProject", "deestBuild", "devenBuilt", "evelInstall", "evenBuild", "deventBuilt", "Develbuild", " develbuild", "evelBuilder", "devenInstall", "deestBuilder", "evelBuild", "devenMake", "develBuilt", " develBuilt", "deVELBuild", "evenMake", "deeedMake", "Deploybuild", "DEVELbuild", "deVELBuilt", " deventBuilt", "deveBuilt", "devenbuild", "deVELProject", "develbuild", "deveBuild", "DevelBuild", " deventBuild", "deployProject", "deployBuilt", "DevelBuilt", "DEVELBuild", "DEvelBuild", "deventBuild", "evelMake", "deploybuild", "deestMake", "deVELbuild", " deventbuild", "DeployBuilt", "DEvelBuilt", "develInstall", "devenProject", "deployInstall", "evenBuilder", "DEVELBuilt", "deventInstall", "develProject", "deeedInstall", "DeployBuild", "evenInstall", "develMake", "deeedBuild", " deventInstall", "DEvelProject", "deployBuild", "devenBuild", "devebuild", "devenBuilder", "deeedBuilder", " develInstall"], "stableBuild": ["latestBuild", "expectedBuild", "stablebuild", "devbuild", " stableRound", " stableBuilding", "stableBuilder", "latestBuilder", "solidBuild", "solidBuilding", " stableBuilder", "expectedbuild", "secureBuild", "latestbuild", "securebuild", "validbuild", "stableRoll", "severeRound", "devBuild", "devBuilder", "weakBuild", "secureRound", "stableRound", "expectedRoll", "severebuild", "weakRoll", "weakVersion", "stableBuilding", "validBuild", " stablebuild", "stableVersion", "solidbuild", " stableVersion", " stableRoll", "validBuilder", "severeBuild", "weakbuild", "latestBuilding", "expectedVersion", "solidBuilder"]}}
{"id1": "2021569", "id2": "7114853", "code1": "    public boolean getFile(String local, String remote) throws IOException {\n        boolean result = false;\n        GridFTP ftp = new GridFTP();\n        ftp.setDefaultPort(port);\n        System.out.println(this + \".getFile \" + remote);\n        try {\n            ftp.connect(host);\n            ftp.login(username, password);\n            int reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                System.err.println(\"FTP server refused connection.\");\n                return false;\n            }\n            ftp.get(local, remote);\n            ftp.logout();\n            result = true;\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        System.out.println(this + \".getFile return \" + result);\n        return result;\n    }\n", "code2": "    private MailBox authenticate() throws Exception {\n        String line = \"POP3 Server Ready\" + ((mChallenge == null) ? \"\" : (\" \" + mChallenge));\n        MailBox mailbox = null;\n        mStream.writeOk(line);\n        while (mailbox == null) {\n            line = mStream.readLine();\n            if (isQuit(line)) break;\n            String body;\n            if ((body = isCommand(line, \"USER\")) != null) {\n                String user = body;\n                MailBox mb = mRepository.getMailBox(user);\n                if (mb == null) mStream.writeErr(\"No mailbox for: \" + line); else {\n                    mStream.writeOk();\n                    String pswd, line2 = mStream.readLine();\n                    if (isQuit(line2)) break;\n                    if ((pswd = isCommand(line2, \"PASS\")) == null) mStream.writeErr(\"Expected PASS but got {\" + line2 + \"}\"); else {\n                        String realPswd = mb.getPassword();\n                        if ((realPswd != null) ? pswd.equals(realPswd) : mb.checkPassword(pswd)) {\n                            mailbox = mb;\n                            mStream.writeOk();\n                        } else mStream.writeErr(\"Bad password for \" + user);\n                    }\n                }\n            } else if ((body = isCommand(line, \"APOP\")) != null) {\n                if (mChallenge == null) mStream.writeErr(\"APOP Not Supported\"); else {\n                    int space = body.indexOf(' ');\n                    if (space < 0) mStream.writeErr(\"Bad APOP command {\" + line + \"}\"); else {\n                        String user = body.substring(0, space);\n                        String hash = body.substring(space + 1);\n                        MailBox mb = mRepository.getMailBox(user);\n                        if (mb == null) mStream.writeErr(\"No mailbox for: \" + line); else if (mb.getPassword() == null) mStream.writeErr(\"User(\" + user + \") cannot login using APOP\"); else {\n                            String secret = mChallenge + mb.getPassword();\n                            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n                            md5.update(secret.getBytes(\"UTF-8\"));\n                            byte[] digest = md5.digest();\n                            String digestStr = new String(Hex.encodeHex(digest));\n                            if (hash.equalsIgnoreCase(digestStr)) {\n                                mailbox = mb;\n                                mStream.writeOk();\n                            } else mStream.writeErr(\"Bad password for \" + user);\n                        }\n                    }\n                }\n            } else mStream.writeErr(\"Authentication required (got '\" + line + \"')\");\n        }\n        return mailbox;\n    }\n", "label": 0, "substitutes": {"local": ["source", "host", "id", "url", "input", "user", "Local", "username", "from", "Remote", "one", "http", "home", "request", "state", "part", "loc", "base", "resource", "prefix", "server", "address", "name", "filename", "old", "password", "localhost", "internal", "global", "path", "same", "file", "uri", "current", "self", "port", "location"], "remote": ["source", "host", "route", "url", "user", "foreign", "reference", "wire", "range", "extra", "real", "secondary", "Remote", "http", "out", "client", "request", "loc", "region", "resolution", "response", "resource", " remotely", "server", "prefix", "external", "address", "different", "random", "name", "method", "query", "target", "password", "localhost", "global", "path", "point", "string", "file", "uri", "command", "res", "port", "location"], "ftp": ["ctps", "aftpc", "landip", "rtpc", " fttp", " ftpoint", "aftq", " ftpc", " ftcp", " ftn", "bbps", "afn", "ktp", "dftp", "dfap", "fxe", "fap", " ftps", "afte", "ftpoint", "landsp", "lfp", "ffpoint", "ctp", "bbtp", "aftf", "fto", " ftf", "ffp", " fth", "fxpoint", "bbp", "ffh", "ftm", "ktcp", "ktpc", "udtp", "dfper", "fxtp", "ftper", "udpc", "fper", "udp", "fxm", "fttp", " ftap", "ftf", "gto", "ftip", " ftper", "aftb", "ctb", "fxper", "ftap", "rtf", "ctr", "bbm", "aftp", " fte", "ottpart", "udb", "rtp", "aftsp", "fp", "fftp", "ftr", "fxr", "afp", "ftpart", "fte", " ftr", "lftp", "afpc", "ftq", "ftps", "gttp", "lfb", "ftpc", "fxps", "aftpart", "ftsp", "fxp", " ftb", "ottsp", " fto", "lfpc", "dfp", "ftn", "ftcp", "aftr", "ftb", "fxo", " ftm", "ottp", "ottip", "aftper", "aftip", "gtp", "afcp", "fth", "ktn", "aftps", "gtper", "landpart", " ftq", "fxh", "landp", "rtq"], "reply": ["next", "respond", "continue", "connection", "feed", "buffer", "fee", "message", " replied", "request", "state", "ply", "part", "base", "response", " answer", "prefix", "ret", "call", "address", "info", "repl", "server", "update", "sync", "Reply", " response", "send", "query", "report", "comment", "post", "related", "status", "ping", "dy", "answer", "error", "code", "err", "resp", "follow", "bot", "reason"], "result": ["successful", "folder", "page", "value", "continue", "compl", "gr", "user", "default", "our", "success", "counter", "Result", "complete", "function", "expected", "dict", "message", "card", "diff", "root", "row", "ver", "data", "future", "response", "r", "match", "work", "ret", "func", "full", "results", "rc", "report", "length", "runner", "instance", "comment", "found", "ault", "df", "status", "up", "count", "load", "error", "err", "or", "current", "valid", "cup", "test", "res", "entry", "pass"]}}
{"id1": "17208661", "id2": "21044594", "code1": "    protected void copyFile(File from, File to) throws IOException {\n        new File(intSfPath).delete();\n        if (to.exists() && (from.length() == to.length()) && (from.lastModified() == to.lastModified())) return;\n        if (to.exists()) to.delete();\n        to.createNewFile();\n        FileChannel inFC = null;\n        FileChannel outFC = null;\n        try {\n            inFC = new FileInputStream(from).getChannel();\n            outFC = new FileOutputStream(to).getChannel();\n            long cnt = outFC.transferFrom(inFC, 0, inFC.size());\n            if (cnt < inFC.size()) throw new IOException(\"File copy failed\");\n        } finally {\n            if (inFC != null) {\n                try {\n                    inFC.close();\n                } catch (IOException ex) {\n                }\n            }\n            if (outFC != null) {\n                try {\n                    outFC.close();\n                } catch (IOException ex) {\n                }\n            }\n            to.setLastModified(from.lastModified());\n        }\n    }\n", "code2": "        public void run() {\n            final String basename = FilenameUtils.removeExtension(file.getName());\n            final File compressed = new File(logDirectory, basename + \".gz\");\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = new FileInputStream(file);\n                out = new GZIPOutputStream(new FileOutputStream(compressed));\n                IOUtils.copy(in, out);\n                in.close();\n                out.close();\n            } catch (IOException e) {\n                reportError(\"Error compressing olg log file after file rotation\", e, ErrorManager.GENERIC_FAILURE);\n            } finally {\n                IOUtils.closeQuietly(in);\n                IOUtils.closeQuietly(out);\n            }\n            Collections.replaceAll(files, file, compressed);\n        }\n", "label": 1, "substitutes": {"from": ["source", "left", "size", "parent", "url", "user", "connection", "open", "with", "range", "io", "origin", "original", "one", "out", "in", "this", "client", "of", "root", "part", "base", "f", "po", "From", "by", "data", "storage", "resource", "server", "address", "config", "name", "component", "o", "old", "missing", "se", "path", "c", "file", "or", "vol", "current", "ce", "start", "self", "form", "empty", "add", "so", "entry"], "to": ["options", "source", "page", "parent", "size", "site", "user", "about", "token", "connection", "office", "not", "with", "after", "top", "peer", "io", "output", "tto", "TO", "one", "out", "client", "b", "this", "toc", "To", "base", "as", "po", "by", "into", "no", "storage", "data", "remote", "resource", "again", "server", "auto", "eto", "onto", "x", "until", "name", "transfer", "o", "two", "target", "t", "too", "temp", "same", "before", "socket", "file", "flo", "or", "at", "proxy", "copy", "so", "p"], "inFC": ["InFC", "InPC", " infc", "onMc", "diffPC", "linCF", "incfc", "outCL", "inCL", " inCL", "INMc", "outEC", "inWC", "outWC", "INPC", "infc", "INCL", "rinfc", "outLC", " inLC", " inEC", "INFC", " inUC", "outPC", "incFS", "incFC", "INUC", "inLC", "onWC", "inEC", "outFS", " inWC", "rinFC", "diffEC", "INEC", "onPC", "inUC", "linPC", "linFC", "INfc", "onFC", "diffFC", "linfc", " inFS", "inMc", "difffc", "InMc", " inPC", "inFS", "InWC", "incPC", "inCF", "INCF", "rinCF", "inPC", "outUC", "rinPC", "INLC", "INWC", "outfc"], "outFC": ["otherFC", "outCC", " outCC", "outputfc", "binFC", "forPC", "outsfc", "exLC", "forfc", "binRC", "outEC", "exFC", "outWC", "inWC", " outfc", "infc", "outputRC", "outputEC", " outPC", "forEC", "outputLC", "outsPC", "outLC", "outsLC", "otherUC", "outsFC", "outPC", "inLC", " outWC", "outputPC", "forFC", " outEC", "otherLC", "inUC", "otherfc", "binfc", "OutWC", "exUC", "outRC", " outRC", "OutPC", "exfc", "OutLC", " outLC", "inPC", "OutFC", "outUC", "outputCC", "binCC", "outfc", "outputFC"], "cnt": ["Cct", " cct", "cnot", "lcNT", "icnt", "cNT", "ccNT", "lcnt", "cunt", "ccnot", "cuint", "icct", "Cint", "cno", "cunot", "lcint", "cint", "icint", "Cno", " cno", "lcnot", "icno", " cint", "ccnt", "cct", "cuNT", "ccint", "Cnt"]}}
{"id1": "18490448", "id2": "411630", "code1": "    @Deprecated\n    public void encodeBegin(FacesContext context, UIComponent component) throws IOException {\n        XUIResponseWriter w = getResponseWriter();\n        XUIViewRoot viewRoot = (XUIViewRoot) component;\n        XUIResponseWriter headerW = getResponseWriter().getHeaderWriter();\n        headerW.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<!DOCTYPE foo [\\n\");\n        InputStream is1 = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"xhtml-lat1.ent\");\n        headerW.write(new String(IOUtils.copyByte(is1)));\n        headerW.write(\"\\n\");\n        is1.close();\n        InputStream is2 = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"xhtml-special.ent\");\n        headerW.write(new String(IOUtils.copyByte(is2)));\n        headerW.write(\"\\n\");\n        is2.close();\n        InputStream is3 = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"xhtml-symbol.ent\");\n        headerW.write(new String(IOUtils.copyByte(is3)));\n        headerW.write(\"\\n]>\\n\");\n        is3.close();\n        headerW.startElement(\"html\", component);\n        XUITheme t = getTheme();\n        if (t != null) {\n            headerW.writeAttribute(\"style\", getTheme().getHtmlStyle(), \"style\");\n        }\n        headerW.startElement(\"head\", component);\n        headerW.startElement(\"base\", component);\n        HttpServletRequest req = (HttpServletRequest) getRequestContext().getRequest();\n        String link = (req.isSecure() ? \"https\" : \"http\") + \"://\" + req.getServerName() + (req.getServerPort() == 80 ? \"\" : \":\" + req.getServerPort()) + getRequestContext().getResourceUrl(\"\");\n        headerW.writeAttribute(\"href\", link, \"href\");\n        headerW.endElement(\"base\");\n        w.startElement(\"body\", component);\n        if (t != null && t.getBodyStyle() != null) {\n            w.writeAttribute(\"style\", getTheme().getBodyStyle() + \";height:100%;width:100%\", \"style\");\n        }\n        headerW.writeText('\\n');\n        w.startElement(\"div\", component);\n        w.writeAttribute(\"id\", ((XUIViewRoot) component).getClientId(), \"id\");\n        if (viewRoot.findComponent(Window.class) != null) {\n            w.writeAttribute(HTMLAttr.CLASS, \"x-panel\", \"\");\n        }\n        w.writeAttribute(\"style\", \"width:100%;height:100%\", null);\n        if (t != null) {\n            t.addScripts(w.getScriptContext());\n            t.addStyle(w.getStyleContext());\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"context": ["xml", "view", "cas", "app", "request", "object", "application", "loader", "kit", "face", "ctx", "comp", "tx", "config", " Context", "instance", "text", "com", "frame", "path", "document", "c", "font", "Context", "ce", "cms", "ca"], "component": ["host", "parent", "input", "connection", "cm", "result", "function", "output", "view", "thread", "controller", "request", "app", "object", "cell", "root", "part", "application", "system", "ctx", "comp", "resource", "compatible", "config", "template", "Component", "server", "element", "section", "module", "e", "target", "report", "container", " components", "instance", "chart", "ch", "content", "document", "entity", "html", "c", "callback", "or", "current", "header", "ce", "cms", "omp", "project", "web", "port"], "w": ["h", "d", "xml", "ws", "ew", "wx", "http", "sw", "f", "fw", "response", "r", "writer", " W", "wp", "W", "x", "u", "e", "we", "v", "rw", "c", "wb", "web", "iw", "wt"], "viewRoot": [" imageRO", " navHome", " imageRoot", " viewRO", " imageProxy", "iewHome", " viewProxy", "iewProxy", " navRO", "iewRoot", " navProxy", " viewHome", "iewRO", " navRoot", " imageHome"], "headerW": ["HeaderCW", "pagew", "headerw", " headerGW", "headNW", "layoutW", "jsonw", "detailw", "writerWeb", "HeaderNW", "responseW", " headerWB", "headerWeb", "authorW", "responseWriter", "responseL", "chartW", "reportWB", "authorGW", "jsonCW", "headerWB", "chartWe", " headerQ", "detailA", "triggerGW", "reportSW", "layoutWriter", "layoutWC", "summaryGW", " headerWeb", " headerNW", "summaryP", "HeaderM", "summaryTW", "jsonW", "headerCW", "jsonWS", "chartWC", "headWC", " headerCW", "detailWe", "headW", "HeaderWS", "triggerWB", "summaryWe", "writerM", "summarySW", "writerWB", "centerWeb", "headWP", "chartWriter", "HeaderQ", "HeaderL", " headerA", "summaryW", "headerWC", "HeaderWriter", "headerA", "pageWe", " headerWS", " headerWriter", "layoutw", "headerSW", "metadataGW", "headerGW", "reportTW", "Headerw", "centerWriter", " headerL", "HeaderW", "headerL", "headerQ", "headerM", " headerw", " headerWC", "writerW", "headerWP", "writerWriter", "metadataTW", "triggerTW", "metadataW", "reportW", " headerWP", "writerNW", " headerWe", "reportGW", "authorTW", " headerSW", "detailW", "headerWe", "metadataWB", "reportWe", " headerM", "headerWriter", "headWS", " headerRW", "HeaderWP", "pageA", "headerP", "headWe", "pageW", " headerP", "headerNW", "triggerW", "authorP", " headerTW", "headWriter", "headQ", "HeaderRW", "headw", "responseRW", "centerWB", "headerRW", "headerTW", "headerWS", "centerW"], "is1": ["ISone", "islone", "isOne", "issone", "bis2", "is0", "isone", "lis1", "IsOne", "issN", "isl0", "ione", " is0", "iOne", " isN", "issOne", "Is1", " isone", "lis2", "is01", "isN", " is01", "ISOne", "bis01", "bis0", "IS1", "Is0", " isOne", "Isone", "lis0", "ISN", "iss1", "bis1", "lis01", "isl1", "islOne", "i1", "i0"], "is2": ["has2", "has1", "IS2", "isiSecond", " is4", " isSecond", "isiTwo", "is4", " isTwo", "isTwo", "IsTwo", "IsSecond", "Is4", "isa1", "iss7", "ISTwo", "hasSecond", "issSecond", " is7", "isSecond", "Is2", "isi1", "isaTwo", "isaSecond", "isa2", "ISSecond", "isi2", "IS4", "hasTwo", "is7", "IS7", "IS1", "iss1", "iss2"], "is3": ["inthree", "isa03", "iss3", "asThree", "is23", " isThree", "isiThree", "isa15", "is43", "iss43", "IS23", " is23", " is15", "inThree", "is03", "IS03", "isThree", "in3", "as43", "issThree", "iss15", "asthree", "isi1", " is03", "issthree", "isthree", "IS3", "isi15", "IS15", "is15", "iss1", "isa3", "isa23", "in43", "isi3", "as3"], "t": ["parent", "h", "ant", "d", "tor", "theme", "l", "ct", "y", "b", "f", "n", "r", "ot", "ti", "tp", "u", "e", "o", "T", "tt", "z", "m", " T", "tr", "v", "ut", "j", "c", "i", "att", "g", "at", "Theme", "qt", "ts", "s", "te", "p", "tg"], "req": ["dq", "cb", "gr", "proc", "sem", "rx", "pkg", "require", "wx", " requ", "http", "request", "b", "cmd", "fr", "f", "base", "https", "def", "progress", "worker", "ver", "remote", "r", "ctx", "qq", "org", "config", "Request", "comm", "exec", "conf", "cur", "tar", "desc", "crit", "query", "requ", "exp", "Requ", "pr", "hr", "rec", "sec", "quest", "rw", "c", "reg", "cache", "mr", "err", "resp", "g", "required", "sq", "q", "rr", "grad", "qt", "res", "p", "ext"], "link": ["next", " links", "url", " anchor", " site", " fragment", "loc", "href", "style", "r", "address", "info", "template", "external", " redirect", " Link", "name", "e", "path", "html", "uri", "replace", "i", "Link", "header", "www", "s", "location"]}}
{"id1": "20841292", "id2": "17114096", "code1": "    public void fileCopy(File src, File dest) throws IOException {\n        if (!dest.exists()) {\n            final File parent = new File(dest.getParent());\n            if (!parent.exists() && !parent.mkdirs()) {\n                throw new IOException();\n            }\n            if (!dest.createNewFile()) {\n            }\n        }\n        FileInputStream is = null;\n        FileOutputStream os = null;\n        try {\n            is = new FileInputStream(src);\n            os = new FileOutputStream(dest);\n            final FileChannel srcChannel = is.getChannel();\n            final FileChannel dstChannel = os.getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } finally {\n            try {\n                if (is != null) {\n                    is.close();\n                }\n            } finally {\n                if (os != null) {\n                    os.close();\n                }\n            }\n        }\n    }\n", "code2": "    public HttpResponse executeHttpGetRequest(String uri, Map<String, Object> parameters) throws HttpTestClientException {\n        HttpGet httpGet = new HttpGet(uri);\n        if (parameters != null) {\n            httpGet.setParams(createBasicParameters(parameters));\n        }\n        return executeHttp(httpGet);\n    }\n", "label": 0, "substitutes": {"src": ["source", "sel", "tmp", "url", "upload", "sit", "conn", "this", "b", "in", "st", "root", "loc", "data", "stream", "class", "resource", "sc", "server", "config", "sub", "filename", "desc", "rc", "inst", "s", "fn", "Dest", "buf", "sin", "slice", "path", "obj", "file", "ssl", "dist", "img", "copy", "rb", "rest", "sl"], "dest": ["source", "folder", "route", "tmp", "later", "dc", "trans", "default", "d", "txt", "cat", "output", "cdn", "out", "home", "this", "st", "root", "delete", "to", "data", "cp", "class", "zip", "slave", " Dest", "sup", "name", "desc", "usr", "dir", "target", "de", "nt", "cont", "transform", "Dest", "temp", "done", "sort", "slice", "orig", "path", "obj", "file", "comb", "wb", "opt", "dist", "destroy", "project", "null", "rest"], "parent": ["source", "Parent", "folder", "plain", "id", "user", "cat", "home", "object", "this", "client", "root", "part", "loc", "layer", "data", "directory", "class", "remote", "master", "resource", "ctx", "child", "ac", "fat", "cot", "desc", "dir", "pa", "target", "unit", "container", "instance", "temp", "image", "pool", "pointer", "cache", "point", "file", "c", "current", "valid", "op", "null", "cmp", "p"], "is": ["get", "nis", "id", "si", "be", "isa", "ss", "fs", "ais", "isl", "out", "in", "ist", "app", "ms", "css", "hide", "as", "was", "iss", "are", "bs", "ris", "serv", "ai", "info", "isin", "ir", "x", "ics", "iv", "has", "isi", "init", "it", "ins", "ci", "iris", "IS", "cs", "api", "mis", "abs", "ls", "sin", "isc", "ri", "lis", "ios", "ops", "ori", "its", "i", "or", "ois", "us", "ar", "Is", "obs", "osi", "bis", "iso", "ps", "s", "ip", "ib", "does", "ie"], "os": ["los", "oses", "io", "acs", "oser", "object", "ns", "ros", "OS", "ou", "bos", "op", "oes", "as", "oa", "bs", "ot", "ens", "es", "js", "vs", "oss", "oos", "oS", "ui", "o", "aos", "Os", "nos", "ose", "ios", "ops", "ori", "i", "ol", "ols", "or", "pos", "us", "cos", "ds", "obs", "boot", "osi", "iso", "ps", "s", "so"], "srcChannel": ["sourceConnection", "srcchannel", " srcQueue", "sourceChan", "rcChan", " srcChan", "destChan", "configChannel", "configchannel", "configChan", "rcStream", " srcStream", " srcConnection", " srcCh", "rcchannel", "destchannel", "srcChan", "rcChannel", "srcQueue", "configStream", "rcCh", "srcCh", "destQueue", "sourceQueue", "rcConnection", "srcStream", "destChannel", " srcchannel", "sourceCh", "sourcechannel", "sourceChannel", "srcConnection"], "dstChannel": ["dntchannel", "destClient", "dntChan", "dstStream", "dstsChan", " dstStream", "ddestchannel", "DestHandler", "Destchannel", "DstClient", "ddestChannel", "ddsMember", "drcChannel", "ddsChan", "destChan", "dndchannel", "drcChan", "DstChannel", "ddsChannel", "drcMember", "dntChannel", "destchannel", "dntStream", "dstHandler", " dstChan", "dstChan", " drcChannel", "dstsStream", " destChannel", "ddestHandler", "destHandler", " destChan", "destStream", "DestChannel", "dstschannel", "drcchannel", "dndChan", "dstClient", "dstMember", "dndChannel", "drcHandler", " drcMember", "destChannel", "Dstchannel", " destchannel", "drcClient", "DestClient", "ddestClient", "DstHandler", "dstchannel", " destStream", " dstchannel", "dndMember", " drcchannel", " drcChan", " dstMember", "dstsChannel", "ddschannel"]}}
{"id1": "2226035", "id2": "2009328", "code1": "    @Override\n    public boolean performOk() {\n        this.setPropertyValue(\"bea.home\", this.beaHome.getText());\n        this.setPropertyValue(\"bea.domain\", this.domainDirectory.getText());\n        Display.getDefault().syncExec(new Runnable() {\n\n            public void run() {\n                saveWLHome();\n                for (final TabControl control : tabControls) {\n                    control.performOk(WLPropertyPage.this.getProject(), WLPropertyPage.this);\n                }\n                if (isEnabledJCLCopy()) {\n                    final File url = new File(WLPropertyPage.this.domainDirectory.getText());\n                    File lib = new File(url, \"lib\");\n                    File log4jLibrary = new File(lib, \"log4j-1.2.13.jar\");\n                    if (!log4jLibrary.exists()) {\n                        InputStream srcFile = null;\n                        FileOutputStream fos = null;\n                        try {\n                            srcFile = toInputStream(new Path(\"jcl/log4j-1.2.13.jar\"));\n                            fos = new FileOutputStream(log4jLibrary);\n                            IOUtils.copy(srcFile, fos);\n                            srcFile.close();\n                            fos.flush();\n                            fos.close();\n                            srcFile = toInputStream(new Path(\"/jcl/commons-logging-1.0.4.jar\"));\n                            File jcl = new File(lib, \"commons-logging-1.0.4.jar\");\n                            fos = new FileOutputStream(jcl);\n                            IOUtils.copy(srcFile, fos);\n                        } catch (IOException e) {\n                            Logger.log(Logger.ERROR, \"Could not copy JCL jars file to Bea WL\", e);\n                        } finally {\n                            try {\n                                if (srcFile != null) {\n                                    srcFile.close();\n                                    srcFile = null;\n                                }\n                                if (fos != null) {\n                                    fos.flush();\n                                    fos.close();\n                                    fos = null;\n                                }\n                            } catch (IOException e) {\n                            }\n                        }\n                    }\n                }\n                if (isEnabledJSTLCopy()) {\n                    File url = new File(WLPropertyPage.this.domainDirectory.getText());\n                    File lib = new File(url, \"lib\");\n                    File jstlLibrary = new File(lib, \"jstl.jar\");\n                    if (!jstlLibrary.exists()) {\n                        InputStream srcFile = null;\n                        FileOutputStream fos = null;\n                        try {\n                            srcFile = toInputStream(new Path(\"jstl/jstl.jar\"));\n                            fos = new FileOutputStream(jstlLibrary);\n                            IOUtils.copy(srcFile, fos);\n                        } catch (IOException e) {\n                            Logger.log(Logger.ERROR, \"Could not copy the JSTL 1.1 jar file to Bea WL\", e);\n                        } finally {\n                            try {\n                                if (srcFile != null) {\n                                    srcFile.close();\n                                    srcFile = null;\n                                }\n                                if (fos != null) {\n                                    fos.flush();\n                                    fos.close();\n                                    fos = null;\n                                }\n                            } catch (final IOException e) {\n                                Logger.getLog().debug(\"I/O exception closing resources\", e);\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return super.performOk();\n    }\n", "code2": "    private String storeProxy(String proxyPath, String userName) throws IOException {\n        File inputFile = new File(proxyPath);\n        String outfile = slcsFactory.getStoreDirectory() + File.separator + userName + File.separator + PROXYFILENAME;\n        File outputFile = new File(outfile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n        Process p = Runtime.getRuntime().exec(\"/bin/chmod 600 \" + outfile);\n        try {\n            p.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return outfile;\n    }\n", "label": 1, "substitutes": {"control": ["page", "contract", "button", "input", "roll", "layout", "tab", "panel", " form", "output", "fc", "view", "hide", "controller", "this", "object", "cell", "f", "ctrl", " section", "child", "config", "contact", "section", "sub", " layout", "holder", "controlled", "edit", "flow", "container", "radio", "content", "toggle", "list", "board", "or", "label", "manager", "follow", "form", "group", " label", "filter", "Control"], "url": ["source", "host", "id", "la", "browser", "feed", "download", "ld", "ll", "src", "http", " blob", "lr", "loc", "base", "ref", "resource", "org", "server", "config", " URL", "name", "dir", "LIB", "log", "fl", "ls", "lc", "li", "location", "ib", "library", "rl", "obj", "uri", "ssl", "file", "URL", "service", "hub", "Url", "www", "lb", "blog", "web", "jar", "sl", "bl"], "lib": ["dl", "binary", "Lib", "la", "browser", "lang", "lit", "lf", "pkg", "plugin", "ld", "ll", "io", "src", "l", " library", " blob", "b", "base", "loc", "loader", "include", "storage", "server", "config", "module", "conf", "script", "Library", "dir", "plugins", "framework", "ob", "LIB", "log", "fn", "api", " glob", "lc", "li", "ls", " fn", "ib", "library", "lock", "install", "file", "db", "local", "lab", "hub", " Lib", " libraries", "bin", "lb", "pl", "sl"], "log4jLibrary": ["log4jlib", "log4JLibrary", "log4jaDirectory", "log4Jlibrary", "log4jBook", "log2Jlibrary", "log4jFile", "log4jaBook", "log4djlibrary", "log2Jlib", "log4JFile", "log2JLibrary", "log4jslib", "log2jlib", "log4jLib", "log4djLib", "log2JLib", "log4jsLib", "log4JBook", "log4jcBook", "log4jslibrary", "log4jalib", "log2jDirectory", "log4JDirectory", "log2jLib", "log2jLibrary", "log4jcLibrary", "log4djLibrary", "log2JBook", "log4jaLib", "log2JDirectory", "log4jaLibrary", "log2jlibrary", "log4Jlib", "log4JLib", "log2jBook", "log2JFile", "log4jcFile", "log4djDirectory", "log4jsLibrary", "log4jDirectory", "log4jaFile", "log4jalibrary", "log2jFile", "log4jlibrary", "log4jcLib"], "srcFile": ["sourceDir", "libBook", "soundStream", "rcfile", "srcFiles", "locFile", "srcfile", "rcDir", "destFiles", "libFile", "srcBook", "soundContent", "locDir", " srcContent", "ourcefile", "ourceDir", "rcFiles", "sbDir", "locStream", "destfile", " srcUnit", "srcContent", "ourceFile", "libFiles", " srcfile", "rcStream", " srcStream", "sourcefile", "libfile", "soundFile", "sourceFile", "rcBook", " srcFiles", "curFile", "soundUnit", "srcFull", "sourceFilename", "sbFilename", "sourceFiles", "ourceFull", "locfile", "destDir", " srcFilename", "curFiles", "rcFull", " srcDir", "srcFilename", "rcContent", " srcBook", "sbfile", "srcStream", "rcFile", "sourceUnit", "destFile", "sbFile", "curStream", "curfile", "srcUnit", " srcFull", "srcDir", "rcUnit"], "fos": [" fros", "flops", " fo", "ifaos", "Fos", "paos", "bos", "infos", "pOS", " fis", " faos", "infros", "fdodes", "faos", "fdo", "fodes", "eros", "sfos", "bops", "Fops", " foses", " foes", " fOS", "fdos", "fops", "po", "fios", "bo", "lo", "Faos", " fodes", "Fots", "Foses", "ifoser", "ifops", "foes", "Foes", "los", "Fors", "fdops", "flots", "flos", " foser", "fo", "fros", "Fodes", "sfOS", "sfo", "FOS", "lis", "eops", "ifos", "ifoes", "foses", "fots", "Fios", "fis", "infaos", "lOS", " fors", "eos", "flaos", "infoses", "ifios", " fops", " fots", "Fros", "fors", "Fo", "ifo", " fios", "infors", "Fis", "foser", "fOS", "boser", "eoes", "sfops", "pos", "infops"], "jcl": [" jCl", " jCL", "jsl", "gacl", "Jacl", "jsacl", "ajsl", "jacl", "jsCL", "jpCl", "jpsl", "jsCl", "ajCl", "gcl", "jpacl", "JCL", "JCl", "jCl", "jscl", "jpcl", "ajacl", " jacl", "jCL", "Jcl", "gsl", "gCl", "ajcl"]}}
{"id1": "19999376", "id2": "386316", "code1": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "code2": "    private static File copyFileTo(File file, File directory) throws IOException {\n        File newFile = new File(directory, file.getName());\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(file);\n            fos = new FileOutputStream(newFile);\n            byte buff[] = new byte[1024];\n            int val;\n            while ((val = fis.read(buff)) > 0) fos.write(buff, 0, val);\n        } finally {\n            if (fis != null) fis.close();\n            if (fos != null) fos.close();\n        }\n        return newFile;\n    }\n", "label": 1, "substitutes": {"zipfile": ["zipFile", "zFile", "Zipdir", "zfile", "clipfile", "zentry", "zipfiles", "clipfiles", "zipdir", "gzdir", "Zipfiles", " zipfiles", "zipentry", "Zipfile", "clipFile", "Zipstream", "clipstream", "gzFile", "Zipentry", "gzentry", " zipstream", " zipFile", "zdir", "ZipFile", "gzfile", "zipstream"], "entry": ["next", "source", "folder", "route", "reader", "draft", "id", "export", "input", "link", "queue", "si", "line", "connection", "feed", "xml", "plugin", "ry", "audio", "lock", "in", "object", "cell", "ries", "base", "data", "directory", "zip", "system", "her", "archive", "server", "address", "info", "inner", "element", "module", "name", "dir", "it", "e", "country", "nt", "container", "log", "cel", "parser", "api", "enter", "comment", "se", "session", "path", "image", "cache", "install", "file", "record", "uri", "error", "or", "parse", "Entry", "service", "sea", "add", "ie"], "outputDir": ["inputFolder", " outputDIR", "outFile", " outputdir", "writeDIR", "inputdir", "inputDIR", "writeFolder", "outDir", "outDirectory", "exitDIR", "outputFolder", "exitDir", "outDIR", "outputDirectory", "outputDIR", "writeDir", "writeDirectory", "outFolder", "targetFolder", "exitdir", " outputDirectory", "targetFile", "inputDirectory", "targetDirectory", "outputdir", "targetDir", "inputDir", "exitDirectory", "inputFile"], "outputFile": [" outputfile", "inputfile", "inputFolder", "outFile", "inputPath", " outputPath", "outLine", "inputLine", "OutputPath", "outDir", "outDirectory", "outputLine", "outputFolder", "inputJar", "outputDirectory", " outputFolder", "responseFile", "OutputDir", "outputJar", " outputLine", " outputDirectory", "OutputFile", "responsefile", "inputDirectory", "outStream", "responseFolder", "responseDir", " outputJar", "inputDir", "outputPath", "OutputJar", "inputFile", "outputfile"], "inputStream": [" inputReader", "outputSteam", " inputChannel", "inputSteam", "InputStream", " inputView", " inputSteam", " inputFile", "inputReader", "InputView", "inputView", "outputReader", "outputChannel", "inputChannel", "InputFile", "InputChannel", "outputView", "InputSteam", "InputReader", "inputFile"], "outputStream": ["outputSteam", "inputSteam", "OutputSteam", "execStream", " outputChannel", "OutputStream", "execFile", "inputStreamer", "outputChannel", "inputChannel", " outputSteam", "OutputFile", "OutputStreamer", "execStreamer", "OutputChannel", "inputFile", "outputStreamer", "execSteam"]}}
{"id1": "14187481", "id2": "854475", "code1": "    protected void yesAction() {\n        try {\n            String result = getSurveyURL() + \"&buildtime=\" + Version.getBuildTimeString();\n            LOG.log(result);\n            if (!maySubmitSurvey()) {\n                return;\n            }\n            BufferedReader br = null;\n            try {\n                URL url = new URL(result);\n                InputStream urls = url.openStream();\n                InputStreamReader is = new InputStreamReader(urls);\n                br = new BufferedReader(is);\n                String line;\n                StringBuilder sb = new StringBuilder();\n                while ((line = br.readLine()) != null) {\n                    sb.append(line);\n                    sb.append(System.getProperty(\"line.separator\"));\n                }\n                LOG.log(sb.toString());\n            } catch (IOException e) {\n                LOG.log(\"Could not open URL using Java\", e);\n                try {\n                    PlatformFactory.ONLY.openURL(new URL(result));\n                    DrJava.getConfig().setSetting(OptionConstants.LAST_DRJAVA_SURVEY_RESULT, result);\n                } catch (IOException e2) {\n                    LOG.log(\"Could not open URL using web browser\", e2);\n                }\n            } finally {\n                try {\n                    if (br != null) br.close();\n                } catch (IOException e) {\n                }\n            }\n        } finally {\n            noAction();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"result": ["source", "page", "successful", "su", "value", "user", "success", "Result", "complete", "username", "function", "message", "grade", "format", "request", "description", "ver", "number", "data", "version", "re", "response", "r", "resource", "prefix", "ret", "match", "feature", "info", "server", "name", "method", "query", "results", "report", "json", "runner", "text", "comment", "status", "string", "answer", "uri", "html", "error", "err", "search", "URL", "date", "current", "valid", "test", "res"], "br": ["obi", "ber", "div", "brush", "str", "reader", "gr", "cb", "bh", "browser", "rel", "plug", "arr", "be", "jp", "Br", "b", "lr", "fr", "ver", "BR", "bi", "r", "bs", "rib", "ris", "serv", "ocr", "ur", "bb", "ob", "bridge", "sr", "hr", "dr", "bar", "ch", "tr", "abs", "buf", "cr", "orb", "sp", "ab", "obj", "ori", "i", "mr", "err", "prev", "fb", "bro", "img", "res", "rb", "jar", "coll", "sl", "bl"], "url": ["source", "page", "ball", "browser", "feed", "plug", "download", "l", "http", "b", "base", "f", "stream", "zip", "resource", "server", "address", "ur", "bb", "bel", "sl", "ls", "string", "image", "rl", "html", "uri", "file", "ssl", "or", "URL", "Url", "blog", "web", "jar", "ll"], "urls": ["slabs", "downloadses", "URLses", "URLings", "urllines", "loglines", "logs", "URLlines", "sllines", "logings", "URLis", "slis", "downloads", "urlabs", "URLs", "downloadis", "urlses", "logabs", "slings", "slses", "urlis", "downloadlines", "URLabs", "urlings", "sls"], "is": ["nis", "isa", "io", "rss", "ais", "isl", "in", "b", "as", "was", "are", "iss", "bi", "r", "os", "bs", "ris", "ai", "ir", "isi", "res", "ui", "iris", "IS", "mis", "ri", "isc", "ios", "ori", "its", "i", "err", "or", "ar", "Is", "bis", "iso", "s", "ip"], "line": ["next", "page", "sel", "reader", "id", "split", "nl", "link", "lf", "lines", "l", "letter", "out", "b", "end", "LINE", "cell", "Line", "row", "f", "model", "part", "data", "inline", "style", "zip", "info", "word", "sync", "name", "liner", "ge", "e", "log", "cl", "text", "comment", "job", "lc", "li", "key", "le", "se", "string", "frame", "rule", "pass", "file", "parse", "code", "i", "lin", "str", "ip", "sl", "entry"], "sb": ["cb", "sa", "bf", "si", "bh", "mb", "buffer", "lines", "sg", "usb", "bg", "pb", "src", "b", "sf", "bc", "login", "bm", "bd", "abb", "bs", "rob", "obb", "erb", "sup", "bj", "bb", "SB", " SB", "ob", "sv", "zb", "ls", "gb", "xb", "eb", "orb", "ib", "bsp", "ab", "db", "bt", "wb", "fb", "sq", "nb", "amb", "lb", "s", "rb", "bp", "bl"]}}
{"id1": "15416858", "id2": "854475", "code1": "    private void download(File archive, File timestamp, URL url, IProgressMonitor monitor) throws IOException {\n        monitor.subTask(\"download \" + url.toString());\n        InputStream in = null;\n        FileOutputStream out = null;\n        URLConnection conn = null;\n        try {\n            conn = url.openConnection();\n            Writer writer = null;\n            try {\n                Date date = new Date(conn.getLastModified());\n                writer = new FileWriter(timestamp);\n                writer.write(this.FORMAT.format(date));\n            } catch (IOException e) {\n                timestamp.delete();\n            } finally {\n                IOUtils.closeQuietly(writer);\n            }\n            in = conn.getInputStream();\n            out = new FileOutputStream(archive);\n            IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"archive": ["source", "folder", "queue", "upload", "download", "buffer", "io", "audio", "http", "object", "directory", "arch", "zip", "resource", "server", "address", "info", "archives", "tar", "report", "slice", "media", "path", "image", "index", "library", "install", "file", "uri", "record", "array", "database", "metadata", "store", "jar", "entry"], "timestamp": ["Timification", "imestamp", "metestamp", "timeeline", "simestamp", "timeestamp", "Timest", "nullest", "timest", "simposition", "imest", "timdate", "Timestamp", "timposition", "imeline", "metest", "impoint", "simeline", "Timpoint", "Timdate", "Timposition", "metification", "timification", "timepoint", "simdate", "timedate", "timeposition", "timeline", "timpoint", "nullification", "Timeline", "timeest", "nullestamp"], "url": ["source", "host", "page", "id", "queue", "link", "connection", "download", "buffer", "ll", "username", "l", "http", "object", "client", "base", "loader", "stream", "zip", "resource", "email", "server", "address", "twitter", "org", "filename", "ob", "log", "api", "job", "location", "string", "path", "image", "socket", "uri", "file", "ssl", "or", "builder", "URL", "service", "hub", "Url", "blog", "str", "sl"], "monitor": ["program", "processor", "mon", "task", "cm", "buffer", "watch", "thread", "http", "controller", "driver", "mx", "state", "worker", "summary", "system", "master", "handler", "server", "resource", "config", "module", "sync", "mp", "dm", "report", "runner", "stat", "m", "timeout", "job", "time", "pm", "path", "pool", "graph", "meter", "lock", "or", "builder", "manager", "timer", "Monitor", "test", "port"], "in": ["source", "read", "reader", "id", "input", "inc", "din", "win", "connection", "download", "min", "io", "nin", "this", "login", "as", "data", "In", "pin", "again", "inas", "r", "resource", "info", "inner", "isin", "oin", "init", "ins", "log", "gin", "ini", "a", "kin", "cin", "socket", "file", "record", "i", "IN", "inside", "like", "or", "inn", "rin", "is", "lin", "bin", "copy"], "out": ["source", "page", "parent", "reader", "inc", "write", "line", "user", "office", "player", "co", "outer", "io", "output", "w", "client", "this", "OUT", "Out", "again", "outs", "server", "external", "inner", "editor", "off", "exec", "serv", "sync", "name", "o", "other", "password", "writ", "temp", "image", "cache", "file", "error", "err", "outside", "bin", "copy", "null", "ext"], "conn": ["host", "dc", "sql", "si", "connection", "cm", "open", "cf", "http", "con", "client", "Conn", "connected", "login", "loc", "channel", "worker", "rn", "cp", "n", "enc", "ctx", "server", "serv", "ai", "config", "dn", "inner", "adj", "pc", "cn", "exec", "sync", "conf", "init", "ci", "act", "log", "fn", "cs", "api", "Connect", "coll", "ch", "cli", "apt", "ann", "connect", "c", "socket", "db", "rt", "g", "cc", "Connection", "ct", "nc", "ad", "p"], "writer": ["reader", "later", "wrapper", "write", "connection", "buffer", "director", "player", "ee", "ws", "outer", "widget", "w", "this", "object", "ler", "wa", "driver", "winner", "walker", "worker", "writers", "r", "master", "riter", "handler", "editor", "usher", "creator", "server", "inner", "her", "er", "sync", "wt", "e", "written", "Writer", "writ", "temp", "pointer", "rw", "lock", "war", "builder", "writing", "null", "wr", "journal", "type"], "date": ["default", "write", "d", "connection", "year", "open", "dd", "now", "sign", "message", "updated", "format", "Date", "number", "data", "worker", "style", "dn", "update", "tag", "dt", "body", "zone", "e", "log", "today", "time", "key", "day", "change", "j", "file", "record", "modified", "g", "created", "start", "dates", "design", "value", "dat"]}}
{"id1": "7170603", "id2": "12116028", "code1": "    private static void generateSQLUpgradeFile(String milestoneDefFileName, String sqlDirectoryName, String fromMilestone, String destMilestone, String destFileName) throws Exception {\n        File milestoneDefFile = new File(milestoneDefFileName);\n        if (!milestoneDefFile.exists()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : does not exists\");\n        }\n        if (!milestoneDefFile.isFile()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : not a file\");\n        }\n        if (!milestoneDefFile.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + milestoneDefFileName + \"] : not readable\");\n        }\n        File sqlDirectory = new File(sqlDirectoryName);\n        if (!sqlDirectory.exists()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : does not exists\");\n        }\n        if (!sqlDirectory.isDirectory()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : not a directory\");\n        }\n        if (!sqlDirectory.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read [\" + sqlDirectoryName + \"] : not readable\");\n        }\n        File destFile = new File(destFileName);\n        if (destFile.exists()) {\n            throw new IllegalArgumentException(\"Cannot write to [\" + destFileName + \"] : already exists\");\n        }\n        destFile.createNewFile();\n        SqlUpgradeXmlParser parser = SqlUpgradeXmlParser.newParser();\n        FileInputStream milestoneDefFIS = null;\n        try {\n            milestoneDefFIS = new FileInputStream(milestoneDefFile);\n            parser.parse(milestoneDefFIS);\n        } catch (XMLParseException e) {\n            printXmlError(e, milestoneDefFileName);\n        } finally {\n            try {\n                if (milestoneDefFIS != null) milestoneDefFIS.close();\n            } catch (Exception e) {\n                _logger.warn(\"Exception caught when closing inputstream \", e);\n            }\n        }\n        int fromMilestoneIdx = parser.getMilestoneIndex(fromMilestone);\n        int toMilestoneIdx = parser.getMilestoneIndex(destMilestone);\n        if (fromMilestoneIdx < 0) {\n            throw new IllegalArgumentException(\"Cannot upgrade from milestone [\" + fromMilestone + \"] : does not exist . (Exisiting milestones \" + parser.listMilestones() + \")\");\n        }\n        if (toMilestoneIdx < 0) {\n            throw new IllegalArgumentException(\"Cannot upgrade to milestone [\" + destMilestone + \"] : does not exist . (Exisiting milestones \" + parser.listMilestones() + \")\");\n        }\n        if (fromMilestoneIdx == toMilestoneIdx) {\n            throw new IllegalArgumentException(\"Cannot upgrade to the same milestone\");\n        }\n        List<String> files = parser.getFilesForMilestones(fromMilestoneIdx, toMilestoneIdx);\n        List<String> views = parser.getViewsForMilestones(fromMilestoneIdx, toMilestoneIdx);\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(destFile);\n            for (Iterator<String> it = files.iterator(); it.hasNext(); ) {\n                appendFileToOutputStream(fos, sqlDirectory, it.next());\n            }\n            for (Iterator<String> it = views.iterator(); it.hasNext(); ) {\n                appendFileToOutputStream(fos, sqlDirectory, it.next());\n            }\n        } catch (Exception e) {\n            fos.close();\n            destFile.delete();\n            throw e;\n        } finally {\n            try {\n                if (fos != null) fos.close();\n            } catch (Exception e) {\n                _logger.warn(\"Exception caught when closing outputstream \", e);\n            }\n        }\n        System.out.println(\"An SQL update file has been generated to \" + destFileName + \".\");\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        File inputFile = new File(args[0]);\n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));\n        StringBuffer stringBuffer = new StringBuffer();\n        String readed;\n        while ((readed = reader.readLine()) != null) stringBuffer.append(readed + \"\\r\\n\");\n        readed = stringBuffer.toString();\n        reader.close();\n        File outputFile = new File(args[0] + \".output\");\n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));\n        readed = readed.replaceAll(\"\\\\t+\", \"#\");\n        readed = readed.replaceAll(\"\\\\s*#\\\\s*\", \"#\");\n        readed = readed.replaceAll(\"Latitude,.*\", \"\");\n        readed = readed.replaceAll(\"Flag of\", \"\");\n        readed = readed.replaceAll(\"^\\\\s+$\", \"\");\n        writer.write(readed);\n        writer.close();\n    }\n", "label": 1, "substitutes": {"milestoneDefFileName": ["milestoneDefFILESource", "milestoneDefSourceFilePart", "milestoneInfFILEPart", "milestoneDeffileName", "milestoneDefFILEUrl", "milestoneDeclFileFile", "milestonedefSourceFileName", "milestonedeffileSource", "milestoneDefinitionFilePath", "milestonedefFileDesc", "milestoneDefLineUrl", "milestoneDefFileFile", "milestoneDefPlaceUrl", "milestoneDefPlacePath", "milestoneDefDirectoryPart", "milestoneDefFilePath", "milestoneDeffileUrl", "milestoneDeclfilePart", "milestoneDefFilename", "milestoneDeffileShare", "milestoneDefDirectoryIn", "milestoneDeclfileName", "milestonedefSourceFileDir", "milestoneDefinitionLineName", "milestoneDefinitionLinePath", "milestonedeffileUrl", "milestoneDefFilePart", "milestoneDeffileSource", "milestonedeffileDesc", "milestoneDefFileShare", "milestoneDefinitionFileSize", "milestoneDefClassFile", "milestoneInfFileString", "milestoneDefSourceFileLine", "milestonedefFilePart", "milestoneDefStreamname", "milestoneDefStreamString", "milestoneDefinitionLineSize", "milestonedefSourceFileUrl", "milestoneDefFILEIn", "milestoneDefSourceFileInfo", "milestoneInfFILEString", "milestoneDefDirectoryLine", "milestoneDefFILEString", "milestoneDefSourceFileIn", "milestoneDefinitionFileUrl", "milestoneDefFILEDesc", "milestoneDefClassname", "milestoneDefLineName", "milestoneDefFileDir", "milestoneDefDirectoryName", "milestoneInfFILEName", "milestoneDefClassName", "milestoneDefFileSource", "milestoneInfFileShare", "milestoneDeffileDir", "milestoneInfFileName", "milestoneDefSourceFileUrl", "milestoneDefSourceFileDir", "milestoneInfFilePart", "milestoneDefSourceFileName", "milestoneDefClassUrl", "milestonedefFileDir", "milestonedefSourceFilePart", "milestoneDefFileInfo", "milestoneDeffileFile", "milestoneDefFileString", "milestoneDefFILEPart", "milestoneDefStreamPart", "milestoneDefStreamName", "milestoneDefFileLine", "milestoneDeclfilename", "milestonedefFileUrl", "milestoneDefDirectoryDir", "milestoneDeclFilename", "milestoneDefinitionLineUrl", "milestoneDefFileUrl", "milestoneDeffileDesc", "milestonedefFileName", "milestoneDefFILELine", "milestonedefFileSource", "milestoneDeclFileName", "milestoneDefFileDesc", "milestoneDefClassPart", "milestoneDeffileString", "milestoneDefFileSize", "milestoneDefClassSize", "milestoneDefPlaceName", "milestoneDefPlaceSize", "milestoneDefDirectoryInfo", "milestoneDefStreamShare", "milestoneDefDirectoryUrl", "milestonedeffileName", "milestoneDeffilePart", "milestoneDefFILEShare", "milestoneDeclFilePart", "milestoneDefDirectorySource", "milestoneDefFILEInfo", "milestoneDeffilename", "milestoneDefFileIn", "milestoneDeclfileFile", "milestoneDefLineSize", "milestoneDefinitionFileName", "milestoneDefLinePath", "milestoneDefStreamFile", "milestoneDefFILEName", "milestoneDefClassPath", "milestoneInfFILEShare", "milestoneDefDirectoryDesc"], "sqlDirectoryName": ["solDirectoryKey", "sqlModuleKey", "sqlDirName", "SQLDirAddress", "databaseDirectoryFile", "sqldirectoryPath", "sqlModulename", "sqlDirectoryKey", "SQLDirPath", "sqlFilePath", "sqlFolderName", "solDirectoryPart", "sqlFileFile", "solDirName", "sqlFolderPath", "SQLDirName", "sqlDirAddress", "sqlLocationName", "sqlDirPart", "sqldirectorySize", "sqlDirectoryAddress", "sqlFileAddress", "sqlDocumentPath", "sqlDirKey", "sqlDocumentName", "sqlFolderUrl", "sqlLocationUrl", "sqlDirectorySize", "SQLFolderKey", "databaseDirectoryPath", "sqldirectoryAddress", "SQLDirectoryKey", "sqlFilePart", "sqlDirectoryPart", "SQLFolderName", "SQLDirectorySize", "solDirectoryPath", "sqlFileKey", "sqlDirPath", "sqlFolderPart", "sqlDirectoryPath", "SQLDirectoryPath", "SQLFolderUrl", "sqlFileSize", "solDirKey", "sqlFileName", "sqlFileUrl", "sqlLocationPath", "solDirectoryName", "sqlLocationKey", "sqlDirectoryname", "sqlDocumentFile", "sqlDirSize", "SQLDirectoryName", "SQLFoldername", "SQLFolderPath", "sqlDirectoryUrl", "SQLDirectoryAddress", "sqlModuleName", "SQLDirSize", "databaseDirectoryName", "SQLDirectoryname", "sqlFoldername", "sqlDirectoryFile", "sqlFolderKey", "solDirPart", "SQLDirectoryUrl", "solDirPath", "sqldirectoryName"], "fromMilestone": ["withMilathon", "withLegaxy", "fromGalathon", "fromMilathon", "fromGalaxy", "withLegestone", "withMilaxy", "fromLegaxy", "fromSilaxy", "withMilework", "withLegathon", "fromSilathon", "fromLegathon", "fromGalestone", "fromLegestone", "withLegework", "fromGalework", "fromLegework", "fromSilework", "withMilestone", "fromSilestone", "fromMilaxy", "fromMilework"], "destMilestone": ["DestMilename", "DestMilestones", "destDigenge", "destDigename", "destMilename", "destMilenge", "destMillenge", "DestMilestone", "destMillestone", "destDigestone", "destDigestones", "destMillestones", "destMilestones", "destMillename", "DestMilenge"], "destFileName": ["destPageLine", "sourceFileLine", "DestDirectoryPath", "deleteFileAlias", "destFileLine", "destSourceFilePath", "destFileOption", "destfilePart", "sourceDirectoryname", "sourceFileName", "DestDirectoryPart", "destStreamName", "DestDirectoryName", "sourceDirectoryLocation", "destPagename", "destFilePath", "DestFilePath", "DestFilePart", "destDirectoryPath", "destDirectoryname", "destFilePart", "deleteFilenameOption", "destFilenameLine", "DestFileName", "destSourceFileSize", "deleteFileOption", "destStreamOption", "destFILEAlias", "destPageName", "destFileSize", "destDirectoryLine", "destStreamAlias", "destFILEName", "destDirectoryPart", "destFilenameAlias", "destFilenamename", "destFilenameOption", "sourceDirectoryName", "DestFileSize", "sourceFilename", "destFilenameLocation", "sourceDirectoryLine", "destFileLocation", "destSourceFilePart", "destFILEOption", "destFileAlias", "sourceFileLocation", "destDirectoryLocation", "destPageLocation", "destDirectoryName", "destDirectorySize", "destSourceFileName", "deleteFileName", "deleteFilenameName", "destFilenameName", "destfilePath", "DestDirectorySize", "destFilename", "destfileSize", "destfileName", "deleteFilenameAlias"], "milestoneDefFile": ["milestoneDefFolder", "milelineDEFfile", "milestoneDefPlace", "milestoneDefinitionFile", "milestoneDefinitionfile", "milestonedeffile", "milestonesDefinitionfile", "milestoneDefinitionFolder", "milestonesDefFile", "milestoneConfLine", "milestoneDiffDirectory", "milestoneDiffStream", "milelineDEFFile", "milestonDefDirectory", "milestoneConfFiles", "milestoneConfSourceFile", "milestoneDEFFiles", "milelineDefSourceFile", "milestonDefFolder", "milestoneConfPlace", "milestonDefFile", "milestoneDefDirectory", "milestonDefinitionfile", "milelineDefFile", "milestoneRefDirectory", "milestonesDefStream", "milwallDefFiles", "milestonedefSourceFile", "milwallDefLine", "milestoneDEFStream", "milestonDefinitionFolder", "milestoneConfigFile", "milestoneDEFSourceFile", "milestoneDefSourceFile", "milestoneDEFfile", "milestonDefinitionFile", "milestoneDiffFolder", "milestoneConfigFiles", "milwallDefinitionFile", "milestoneRefPlace", "milestoneDefStream", "milelineDEFFiles", "milestonesDefinitionFile", "milestonesDeffile", "milestoneConffile", "milestonesConfFile", "milestoneDiffFiles", "milestoneDefFiles", "milestoneConfigDirectory", "milestonedefFiles", "milestoneConfFile", "milestoneDiffFile", "milwallDefinitionfile", "milestoneDefinitionDirectory", "milelineDefFiles", "milestonesDefinitionFiles", "milwallDefinitionLine", "milestoneDEFFile", "milestoneDefLine", "milestoneConfDirectory", "milestoneRefFiles", "milestonesDefinitionStream", "milelineDEFSourceFile", "milestoneDefinitionLine", "milestonedefLine", "milestonesDefFiles", "milestoneRefFile", "milestonesDefDirectory", "milestoneDefinitionStream", "milestonDeffile", "milestonesConfPlace", "milwallDeffile", "milestonesConfDirectory", "milwallDefinitionFiles", "milestonDefinitionDirectory", "milestoneDifffile", "milestonesDefPlace", "milestoneConfigPlace", "milelineDeffile", "milestonedefFile", "milwallDefFile", "milestoneDefinitionFiles", "milestoneDeffile", "milestonesConfFiles"], "sqlDirectory": ["SQLDirector", "dsFolder", "qlDirector", "sqlCollection", "SQLDir", "sqCollection", "sqDirectory", "dbDir", "sqDirector", "dsLibrary", "dbFolder", "dsDirectory", "SQLDirectory", "sslDirectory", "sqlFile", "socialDir", "sqlFolder", "SQLFolder", " sqlFolder", "qlFolder", "sqFolder", " sqlCollection", "SQLLibrary", "qlDir", "sslFolder", "qlDirectory", "dbDirectory", "qlCollection", "qlLibrary", "socialFile", "sqlDirector", "sslLibrary", "socialFolder", "dsCollection", "dbFile", "SQLCollection", "sqlLibrary", "socialDirectory", " sqlLibrary", "sqlDir", "qlFile", "sslDir"], "destFile": ["DestFiles", "DestFile", "srcFolder", "destFiles", "targetPage", " destFilename", " destFiles", "DestPage", "destDirectory", "destfile", "DestFilename", " destfile", "Destfile", "srcDirectory", " destFolder", "transFilename", "targetFiles", "DestDirectory", " destPage", "DestFolder", "destDir", "srcDir", " destDirectory", "targetFile", "transFile", "srcFile", "targetDir", "transDirectory", " destDir", "destPage", "DestDir", "destFilename", "destFolder", "transfile"], "parser": ["lp", "parent", "aws", "reader", "general", "processor", "pe", "xml", "plugin", "pd", "l", "arser", "in", "b", "layer", "loader", "jack", "data", "worker", "auto", "system", "handler", "server", "writer", "er", "php", "per", "json", "instance", "se", "up", "document", "node", "sp", "parse", "builder", "manager", "s", "Parser", "fork", "p"], "milestoneDefFIS": ["milestoneDefBISS", "milestoneDefinitionVIs", "milestonedefLIs", "milestoneDEFLIR", "milestoneDefDISS", "milestoneDefDIS", "milestonedefFIS", "milestoneDEFFIs", "milestoneDefEFIS", "milestoneDefFISS", "milestoneDefHIT", "milestoneDEFLINS", "milestonedefLAS", "milestoneDefVIs", "milestoneDefinitionVIT", "milestoneDefFIT", "milestoneDefEISS", "milestoneDefFis", "milestoneDefLAS", "milestoneDefVIT", "milestoneDefLis", "milestoneDivFIs", "milestoneDefVISS", "milestoneDefPFIS", "milestoneDefBIs", "milestoneDefDAS", "milestoneDefLIR", "milestoneDefLISS", "milestoneDefEFINS", "milestoneDefEFIR", "milestoneDefFIR", "milestoneDefHISS", "milestonedefLISS", "milestoneDefBIR", "milestoneDefPFIs", "milestoneDefEIS", "milestoneDefFAS", "milestoneDeffIS", "milestonedefLIS", "milestoneDeffIs", "milestoneDefEIs", "milestoneDEFLIs", "milestoneDEFFIR", "milestoneDefinitionFIS", "milestoneDefinitionFISS", "milestoneDefinitionFIs", "milestoneDEFFINS", "milestoneDefHIs", "milestoneDefEFIs", "milestonedefFAS", "milestoneDefBINS", "milestoneDefLIS", "milestoneDefBIS", "milestonedefFISS", "milestoneDivfIs", "milestoneDivFIS", "milestoneDefinitionFIT", "milestoneDefPFISS", "milestoneDefHIS", "milestoneDefLIT", "milestoneDefinitionVis", "milestoneDivFis", "milestoneDefEAS", "milestoneDefDIT", "milestoneDefinitionVIS", "milestonedefFIs", "milestoneDivfis", "milestoneDEFFIS", "milestoneDefinitionFis", "milestoneDeffIT", "milestoneDefinitionVISS", "milestoneDeffis", "milestoneDefVIS", "milestoneDefBis", "milestoneDEFLIS", "milestoneDefDIs", "milestoneDivFIT", "milestoneDivfIS", "milestoneDivfIT", "milestoneDefLIs", "milestoneDefVis", "milestoneDefFINS", "milestoneDefLINS", "milestoneDefPFis", "milestoneDefFIs"]}}
{"id1": "17972560", "id2": "19999376", "code1": "    private void folderFileChooserActionPerformed(java.awt.event.ActionEvent evt) {\n        if (evt.getActionCommand().equals(JFileChooser.APPROVE_SELECTION)) {\n            File selectedFolder = folderFileChooser.getSelectedFile();\n            File collectionCopyFile;\n            String newDocumentName;\n            Document newDocument;\n            StringBuilder distinguisherReplacer = new StringBuilder();\n            int matchingFilenameDistinguisher;\n            String nextToken;\n            Term newTerm;\n            String userHome;\n            String fileSeparator;\n            int userOption;\n            ArrayList<File> folderTextFiles = new ArrayList<File>();\n            ArrayList<File> folderRejectedFiles = new ArrayList<File>();\n            HashSet<File> ignoredFiles = new HashSet<File>();\n            FileNameExtensionFilter textFileFilter = new FileNameExtensionFilter(\"Text Files\", \"txt\");\n            Scanner tokenizer = null;\n            FileChannel fileSource = null;\n            FileChannel collectionDestination = null;\n            HashMap<String, Integer> termHashMap = null;\n            Index collectionIndex = activeCollection.getIndex();\n            int documentTermMaxFrequency;\n            int currentTermFrequency;\n            for (File folderFile : selectedFolder.listFiles()) if (textFileFilter.accept(folderFile)) folderTextFiles.add(folderFile); else folderRejectedFiles.add(folderFile);\n            for (File selectedFile : folderTextFiles) {\n                newDocumentName = selectedFile.getName();\n                newDocument = new Document(newDocumentName);\n                if (activeCollection.containsDocument(newDocument)) {\n                    matchingFilenameDistinguisher = 1;\n                    newDocumentName = newDocumentName.concat(\"(\" + matchingFilenameDistinguisher + \")\");\n                    newDocument.setDocumentName(newDocumentName);\n                    while (activeCollection.containsDocument(newDocument)) {\n                        matchingFilenameDistinguisher++;\n                        newDocumentName = distinguisherReplacer.replace(newDocumentName.length() - 2, newDocumentName.length() - 1, new Integer(matchingFilenameDistinguisher).toString()).toString();\n                        newDocument.setDocumentName(newDocumentName);\n                    }\n                }\n                termHashMap = new HashMap<String, Integer>();\n                try {\n                    tokenizer = new Scanner(new BufferedReader(new FileReader(selectedFile)));\n                    tokenizer.useDelimiter(Pattern.compile(\"\\\\p{Space}|\\\\p{Punct}|\\\\p{Cntrl}\"));\n                    while (tokenizer.hasNext()) {\n                        nextToken = tokenizer.next().toLowerCase();\n                        if (!nextToken.isEmpty()) if (termHashMap.containsKey(nextToken)) termHashMap.put(nextToken, termHashMap.get(nextToken) + 1); else termHashMap.put(nextToken, 1);\n                    }\n                    documentTermMaxFrequency = 0;\n                    for (String term : termHashMap.keySet()) {\n                        newTerm = new Term(term);\n                        if (!collectionIndex.termExists(newTerm)) collectionIndex.addTerm(newTerm);\n                        currentTermFrequency = termHashMap.get(term);\n                        if (currentTermFrequency > documentTermMaxFrequency) documentTermMaxFrequency = currentTermFrequency;\n                        collectionIndex.addOccurence(newTerm, newDocument, currentTermFrequency);\n                    }\n                    newDocument.setTermMaxFrequency(documentTermMaxFrequency);\n                    activeCollection.addDocument(newDocument);\n                    userHome = System.getProperty(\"user.home\");\n                    fileSeparator = System.getProperty(\"file.separator\");\n                    collectionCopyFile = new File(userHome + fileSeparator + \"Infrared\" + fileSeparator + activeCollection.getDocumentCollectionName() + fileSeparator + newDocumentName);\n                    collectionCopyFile.createNewFile();\n                    fileSource = new FileInputStream(selectedFile).getChannel();\n                    collectionDestination = new FileOutputStream(collectionCopyFile).getChannel();\n                    collectionDestination.transferFrom(fileSource, 0, fileSource.size());\n                } catch (FileNotFoundException e) {\n                    System.err.println(e.getMessage() + \" This error should never occur! The file was just selected!\");\n                    return;\n                } catch (IOException e) {\n                    userOption = JOptionPane.showConfirmDialog(this, \"A file insertion has failed. If you want it to ignore this\" + \"file, press YES, else press NO to repeat the insertion\", \"FileInsertionFailure\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                    if (userOption == JOptionPane.NO_OPTION) {\n                        activeCollection.removeDocument(newDocument);\n                        for (String term : termHashMap.keySet()) {\n                            collectionIndex.removeAllOccurences(new Term(term), newDocument);\n                        }\n                        folderTextFiles.add(selectedFile);\n                    } else ignoredFiles.add(selectedFile);\n                } finally {\n                    try {\n                        if (tokenizer != null) tokenizer.close();\n                        if (fileSource != null) fileSource.close();\n                        if (collectionDestination != null) collectionDestination.close();\n                    } catch (IOException e) {\n                        System.err.println(e.getMessage());\n                    }\n                }\n            }\n            if (ignoredFiles.size() > 0) {\n                IgnoredFilesDialog ignoredFilesDialog = new IgnoredFilesDialog(ignoredFiles, this);\n                ignoredFilesDialog.setVisible(true);\n            }\n            processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));\n        } else if (evt.getActionCommand().equalsIgnoreCase(JFileChooser.CANCEL_SELECTION)) processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"evt": [" evte", "evts", "ekte", "evmt", "ekt", " Evts", "evT", " Evtz", "evte", " Evte", " Evt", " evts", " evtz", "emt", "evtz", " evT", "ekT", "emte", "ekmt", " evmt", " awte", "emmt", " awtz", " awt", "emT", " awts"], "selectedFolder": ["currentArea", "lectedFolder", " selectedDir", "lectedArea", " selectedArea", "selectedContainer", " selectedDirectory", "lectedContainer", "currentDirectory", "currentFolder", "currentFile", "currentContainer", "lectedDirectory", " selectedContainer", "selectedDir", "lectedDir", "currentDir", "lectedFile", "selectedArea", "selectedDirectory"], "collectionCopyFile": ["collectionActivefile", "collectionEditedSourceFile", "collectionEditedFile", " collectionCopyfile", " collectionCopySourceFile", "collectionActiveFile", "collectionActiveSourceFile", "collectionCopyfile", "collectionEditedfile", "collectionCopySourceFile"], "newDocumentName": ["newdocumentUrl", "newFileLine", "freshDocumentLength", "newDocumentDefinition", "newDocAlias", "newFeaturePath", "newProductname", " newDocumentInfo", "newMediaName", "oldDocumentName", "newFileDefinition", "newQuerySync", " newDocumentNames", "NEWDocumentAlias", "newFileUrl", "newDocumentNames", " newDirectoryDefinition", "newContextName", " newDocumentUrl", "newProductAlias", "newFileNames", "newDocUrl", "newDirectoryName", " newDocumentLine", "olddocumentname", "NEWDocAlias", "newDocumentLine", "initialDocumentInfo", "newProductName", "newFileName", "newDocumentSync", " newDocumentAlias", "olddocumentAlias", "newConnectionname", "newQueryInfo", "newDocumentAlias", "newdocumentname", "newdocumentPath", "newdocumentInfo", "freshApplicationname", "freshDocumentName", " newDocumentPath", " newDirectoryInfo", "newConnectionLength", "newDocname", "newDirectoryNames", "newFeatureName", "newFeatureUrl", "newDocSync", "newDocumentPath", "oldDocumentAlias", "newFileAlias", "newdocumentLine", "newApplicationLength", " newDocumentDefinition", "NEWDocumentSync", "NEWDocName", "newDirectoryInfo", "freshApplicationLength", "initialMediaName", " newDirectoryUrl", "newDocumentUrl", "newApplicationName", "NEWDocumentName", "newdocumentAlias", " newDirectoryLine", "newContextname", "newFilePath", "newContextLength", "initialMediaInfo", "newQueryAlias", "newdocumentNames", "newdocumentTime", "NEWDocSync", "newDocumentLength", " newDirectoryName", "newDocumentname", "newdocumentSync", " newDirectoryAlias", "newDirectoryUrl", "newQueryTime", "newQueryName", "newMediaInfo", "NEWDocumentTime", " newDirectoryPath", "oldDocumentname", "newDirectoryAlias", "newdocumentName", "freshApplicationName", "initialDocumentName", "newDocName", "newApplicationname", "newDirectoryLine", "newDirectoryPath", "newDocDefinition", "NEWDocTime", "newFileInfo", "olddocumentName", "newConnectionName", "freshDocumentname", "newDocTime", "newDocumentTime", "newDocPath", "newDirectoryDefinition", "newDocumentInfo", " newDirectoryNames"], "newDocument": ["viewdocument", "nextNumber", "differentdocument", "differentProduct", "olddocument", "oldDirectory", "nextNode", "nextDoc", "newProduct", "currentDocument", "freshDirectory", " newContent", "newContent", "nextProduct", "differentContent", "freshProduct", "differentDocument", "oldProduct", " newDoc", "freshDocument", "oldDocument", "newNode", "currentDoc", " newDocuments", " newProduct", "newNumber", "newSession", "differentDocuments", "NewFile", "NewDoc", "freshDoc", "nextDocument", "Newdocument", "NewDocument", "nextContent", "oldDoc", "newDocuments", "NewNode", "currentFile", "currentdocument", "viewDoc", "newFile", "differentSession", "viewDocument", " newdocument", "nextFile", " newNumber", "freshNumber", "oldSession", "newdocument", "freshSession", "newDoc", "differentDirectory", "nextdocument", " newFile", "nextDocuments", "newDirectory", " newNode", "viewDocuments", "oldDocuments", "NewDocuments"], "distinguisherReplacer": ["distinguisherPrefacer", "distinguisherPlacers", "distinguishersPlacer", "distinguishReplacer", "distinguishReplacement", "distinguisherPrefacement", "distinguisherReplacers", "distinguishreplacement", "distinguishRepliner", "distinguishReplacers", "distinguisherJoaser", "distinguisherJoacer", "distinguisherPlaser", "distinguishreplacer", "distinguishersReplaser", "distinguisherPlacer", "distinguisherPlformer", "distinguisherreplacer", "distinguisherrepliner", "distinguisherJoformer", "distinguishersReplformer", "distinguisherPrefiner", "distinguishersReplacement", "distinguisherreplacement", "distinguishreplacers", "distinguisherPlacement", "distinguishersPlaser", "distinguisherPliner", "distinguisherPrefformer", "distinguisherReplaser", "distinguishersReplacer", "distinguisherreplacers", "distinguisherReplformer", "distinguisherPrefaser", "distinguishersPlformer", "distinguisherReplacement", "distinguisherJoacement", "distinguisherPrefacers", "distinguishersPlacement", "distinguisherRepliner", "distinguishrepliner"], "matchingFilenameDistinguisher": ["matchingFilenameDistinctisher", "matchingFilenameDistinguishers", "matchingFilenameDistributer", "matchingFilenameRestinctisher", "matchingFilenameDistanguishes", "matchingFilenameDistinctiner", "matchingFilenameDistinctioninger", "matchingFilenameContinguiner", "matchingFilenameRestinguishedcher", "matchingFilenameChinctionisher", "matchingFilenameChinguinger", "matchingFilenameRestinguishedishing", "matchingFilenameDistinguishedisher", "matchingFilenameChinctionishes", "matchingFilenameDistinguer", "matchingFilenameContinguishers", "matchingFilenameDistortioniner", "matchingFilenameDistinguish", "matchingFilenameDistortionishers", "matchingFilenameDistinquinger", "matchingFilenameDistinguished", "matchingFilenameContortionishers", "matchingFilenameDistinctcher", "matchingFilenameDistanguisher", "matchingFilenameRestinctishers", "matchingFilenameDistinctioncher", "matchingFilenameChinguished", "matchingFilenameContinguisher", "matchingFilenameDistricishers", "matchingFilenameDistributish", "matchingFilenameDistortionish", "matchingFilenameDistinquisher", "matchingFilenameDistriccher", "matchingFilenameRestinguish", "matchingFilenameDistributishing", "matchingFilenameDistinctishers", "matchingFilenameRestinguisher", "matchingFilenameDistricishing", "matchingFilenameDistingucher", "matchingFilenameDistributcher", "matchingFilenameDistinctionishes", "matchingFilenameDistinguishedishing", "matchingFilenameDistinctionished", "matchingFilenameChinguishes", "matchingFilenameRestingucher", "matchingFilenameContortionisher", "matchingFilenameDistinguishedishers", "matchingFilenameDistinctionisher", "matchingFilenameDistinctish", "matchingFilenameDistinguishedcher", "matchingFilenameDistinctionishers", "matchingFilenameRestinguishers", "matchingFilenameDistributishers", "matchingFilenameRestinguishedish", "matchingFilenameRestinguishing", "matchingFilenameDistinguinger", "matchingFilenameRestincter", "matchingFilenameDistinguishediller", "matchingFilenameDistinguishing", "matchingFilenameChinctioninger", "matchingFilenameDistanguished", "matchingFilenameRestinctish", "matchingFilenameDistinctioniner", "matchingFilenameDistinquished", "matchingFilenameDistinguiner", "matchingFilenameChinguisher", "matchingFilenameRestinguiller", "matchingFilenameRestinguishedisher", "matchingFilenameDistricisher", "matchingFilenameDistortioniller", "matchingFilenameDistinquishes", "matchingFilenameDistortioncher", "matchingFilenameRestinguer", "matchingFilenameContingucher", "matchingFilenameRestinguishediller", "matchingFilenameDistinguishedish", "matchingFilenameDistributisher", "matchingFilenameDistinguiller", "matchingFilenameDistinctioniller", "matchingFilenameDistinguishes", "matchingFilenameContortioniner", "matchingFilenameDistinctionish", "matchingFilenameRestinguishedishers", "matchingFilenameDistinguisheder", "matchingFilenameContortioncher", "matchingFilenameDistanguinger", "matchingFilenameDistincter", "matchingFilenameDistortionisher", "matchingFilenameChinctionished"], "nextToken": ["NextTerm", "newWord", " nextTerm", "NextWord", "NextTokens", "nextWord", "nextTokens", "newToken", "newTokens", " nextWord", " nextTokens", "nextTerm", "NextToken"], "newTerm": [" nextText", "newterm", " newWord", " nextTerm", " newText", " nextterm", "nextWord", " nextWord", "nextterm", "nextText", "newText", "nextTerm", " newterm", "newWord"], "userHome": [" userLocation", "humanHome", "UserHome", "Userhome", " userhome", "humanLocation", "userLocation", "UserLocation", "userhome", "humanhome"], "fileSeparator": ["fileDelatation", "fileDelatate", "fileDelatator", "fileSeparate", "fileSepparator", "fileSeparateator", "fileSeparateation", "fileSepparation", "fileDelarate", "fileSeparation", "fileSepparater", "fileDelatater", "fileDelarater", "fileSeparateater", "fileSeparater", "fileSepparate", "fileDelarator", "fileSeparateate", "fileSepatator", "fileDelaration", "fileSepatater", "fileSepatate", "fileSepatation"], "userOption": [" userOptions", "userEnd", "userOpt", "useOptions", "useOpt", "fileOption", " userEnd", " userOpt", "fileEnd", "fileOpt", "useOption", "fileOptions", "useEnd", "userOptions"], "folderTextFiles": ["folderInputSources", "folderEmptyParents", " folderTextSources", "folderReadFile", "folderTEXTFiles", " folderTextBooks", "folderTextBooks", "folderReadFiles", " folderInputBooks", " folderTextParents", "folderTextPages", "folderEmptyFiles", "folderTEXTPages", "FolderTextPages", "foldertextFiles", "folderInputPages", "folderTEXTBooks", " folderInputFiles", "folderInputItems", "folderReadPages", "folderTextParents", " folderInputItems", "FolderReadFile", " folderInputPages", "folderTEXTFile", "foldertextParents", "foldertextItems", "FolderTextFile", " folderTextfiles", " folderTextItems", "FolderReadFiles", " folderInputfiles", "folderTextSources", "folderInputFiles", " folderInputSources", "folderInputParents", " folderInputParents", "FolderTextFiles", "foldertextBooks", "folderEmptySources", "folderInputBooks", "foldertextSources", "folderTEXTItems", "folderInputfiles", " folderTextPages", "folderTextItems", "folderEmptyfiles", "FolderReadPages", "foldertextPages", "foldertextfiles", "folderTextfiles", "folderTextFile"], "folderRejectedFiles": ["folderPrejectedPages", "folderRejectedItems", "folderReceivedFile", "folderPrejectionFiles", "folderPreceivedItems", "folderRecludedFiles", "folderRejectionFiles", "folderReceivedItems", "folderReruptedFile", "folderPreceivedFile", "folderPrejectedFile", "folderReruptedItems", "folderPrejectionItems", "folderRejectionDocuments", "folderRecludedFile", "folderReceivedFiles", "folderReruptedDocuments", "folderReruptedFiles", "folderRejectionPages", "folderPreceivedPages", "folderPrejectionFile", "folderPrejectionDocuments", "folderPrejectedDocuments", "folderRecludedItems", "folderRejectedDocuments", "folderReruptedPages", "folderReceivedPages", "folderRejectedPages", "folderRejectionItems", "folderRecludedDocuments", "folderRejectionFile", "folderPrejectedItems", "folderPreceivedFiles", "folderRejectedFile", "folderPrejectedFiles"], "ignoredFiles": ["ignoveredParents", "colorableFolder", "ignoveredFiles", "ignouredParents", "ignorableFolder", "coloredFiles", "ignouredFiles", "colorableParents", "ignoredFolder", "coloredParents", "coloredFS", "ignoveredFS", "colorableFiles", "ignorableFS", "ignorableFiles", "ignoveredFolder", "ignorableParents", "ignouredFS", "ignouredFolder", "ignoredParents", "colorableFS", "coloredFolder", "ignoredFS"], "textFileFilter": ["textLineFilter", "classfileParser", "classFileHandler", "textFileParser", "classfileFilter", "textMessageFilter", "classFileFilter", "textFilesFilter", "classFileParser", "classfileManager", "textFilesHandler", "textMessageHandler", "textStringReader", "textLineManager", "TextFilesHandler", "textFileReader", "TextFilesReader", "textFilesExt", "TextFileReader", "textStringHandler", "textFileHandler", "classFileManager", "textFileExt", "TextFileFilter", "TextFileExt", "textfileHandler", "textLineHandler", "TextFilesExt", "textFilesManager", "TextFilesFilter", "TextFileHandler", "textLineParser", "textfileParser", "textStringFilter", "classfileHandler", "textFileManager", "textMessageExt", "textFilesReader", "textFilesParser", "textMessageReader", "textfileFilter", "textStringExt", "textfileManager"], "tokenizer": ["initializer", " tokenize", " tokenization", "tokenization", "Tokenized", "Tokenize", "tokenized", "Tokenizer", " tokenized", "initialized", "tokenize", "Tokenization", "initialize", "initialization"], "fileSource": ["FileResource", "collectionService", "FileSources", "selectionSource", "selectionResource", "FileService", "fileResource", "selectionService", "collectionSource", "collectionResource", "FileSource", "fileService", "collectionSources", "selectionSources", "fileSources"], "collectionDestination": ["collectionOrdribution", "collectionDestinator", "archiveDestribution", "collectionDestinate", "archiveOrdribution", "collectionOrdinator", "collectionHomeinator", "archiveDestinator", "archiveOrdinator", "collectionOrdinate", "collectionOrdination", "collectiondestinate", "collectiondestination", "collectionHomeination", "collectionDestribution", "archiveOrdinate", "archiveDestinate", "archiveOrdination", "collectiondestinator", "collectionHomeinate", "collectionHomeribution", "archiveDestination", "collectiondestribution"], "termHashMap": ["termHandMap", " termHandArray", "termChSet", "termHashSet", "termHashList", "TermMatMap", "termCacheSet", "termHashArray", "TermMatSet", "termChArray", "termHMap", "termMatList", "termHList", "termHandList", " termHashSet", "TermHashList", " termHandSet", "TermMatList", "TermMatArray", "termShSet", "termCacheMap", "TermHashSet", "TermHashArray", "termShMap", "termCacheList", "termMatSet", "termCacheArray", "termHSet", " termHandList", "termHandArray", " termHashList", " termHandMap", "termMatMap", "termChMap", "termChList", " termHashArray", "termShArray", "termMatArray", "termHandSet", "TermHashMap", "termShList", "termHArray"], "collectionIndex": ["collIndex", "containerIndex", " collectionId", "collectionAddress", "collId", "containerindex", "containerAddress", " collectionindex", "collindex", "collectionindex", "collAddress", " collectionAddress", "collectionId", "containerId"], "documentTermMaxFrequency": ["documentTermLimitFraction", "documentTermLimitFrequent", "documentTermLimitRepidelity", "documentTermMaxFrequent", "documentTermMaxWidelity", "documentTermMaxFraction", "documentTermLimitReprequency", "documentTermMaxWrequency", "documentTermMaxfraction", "documentTermLimitReprequent", "documentTermMaxfidelity", "documentTermLimitRepraction", "documentTermMaxfrequent", "documentTermMaxfrequency", "documentTermMaxRepidelity", "documentTermMaxReprequency", "documentTermMaxReprequent", "documentTermMaxRepraction", "documentTermMaxFidelity", "documentTermMaxWraction", "documentTermMaxWrequent", "documentTermLimitFrequency", "documentTermLimitFidelity"], "currentTermFrequency": ["currentWordFreshold", "currentTermPrequently", "currentWordRefrance", "currentTermPrance", "currentTermFrance", "currentTermRefrequently", "currentTermPreshold", "currentWordRefrequently", "currentTermPrequency", "currentTermRefreshold", "currentWordFrance", "currentTermRefrance", "currentWordRefreshold", "currentWordRefrequency", "currentTermBFrequency", "currentTermRefrequency", "currentTermBFrequently", "currentWordFrequently", "currentTermBFrance", "currentTermBFreshold", "currentTermFreshold", "currentWordFrequency", "currentTermFrequently"], "folderFile": ["draftChild", "folderImage", " folderFolder", "FolderFile", "draftF", "directoryFolder", "draftFile", "containerFiles", "archiveFolder", "archiveLine", "folderFolder", "projectFolder", "folderLine", "containerfile", "projectChild", "Folderfile", "containerImage", "flatfile", "folderF", "archiveFile", "directoryfile", "archiveFiles", " folderFiles", "folderChild", "directoryLine", "flatFile", "draftFolder", "projectF", "archiveChild", "FolderFiles", "FolderImage", "archivefile", "directoryFile", "folderfile", "flatFolder", "archiveF", "projectFile", "directoryLocal", " folderImage", "folderLocal", " folderLine", " folderLocal", "directoryFiles", " folderfile", "containerFile", "flatLocal", "folderFiles"], "selectedFile": ["selectionPage", "copyFile", "copyFiles", " selectedDocument", "currentDocument", "copyFolder", " selectedFiles", " selectedPage", "copyDocument", "selectionFolder", "currentFolder", "currentFile", "selectionFiles", "currentPage", "selectedDocument", "selectionDocument", "selectedPage", "selectionFile", "selectedFiles"]}}
{"id1": "15723802", "id2": "2252572", "code1": "    void createAgentProgram(PrintStream ps, String agentName, String agentID) throws IOException, ConfigException {\n        Agent agent = service.getAgent(agentName);\n        File instanceDir = getInstanceDir();\n        double agent_timeout_seconds = engine.getTimeout();\n        String ii = \"\\\"\";\n        String agentScript = \"agent-\" + agentName + \".py\";\n        String serviceScript = \"service.py\";\n        Set<String> taskNames = agent.getTasks().keySet();\n        File scriptDir = getService().getScriptDir();\n        final boolean embedScripts = true;\n        {\n            ps.println(\"#!/bin/sh\");\n            ps.println(\"umask 0077\");\n        }\n        for (String taskName : taskNames) {\n            Task task = getService().getTask(taskName);\n            String script = task.getScriptContent();\n            if (embedScripts) {\n                ps.println();\n                ps.println(\"cat > \" + task.getFile() + \" << \" + ii + \"EOF_\" + task.getFile() + ii);\n                ps.println(script);\n                ps.println(\"EOF_\" + task.getFile());\n            } else {\n                File taskScriptFile = new File(instanceDir, task.getFile());\n                PrintStream xs = new PrintStream(taskScriptFile);\n                xs.print(script);\n                xs.close();\n            }\n        }\n        {\n            PrintStream ss = null;\n            if (embedScripts) {\n                ps.println();\n                ps.println(\"cat > \" + serviceScript + \" << \" + ii + \"EOF_\" + serviceScript + ii);\n                ss = ps;\n            } else {\n                File serviceScriptFile = new File(instanceDir, serviceScript);\n                ss = new PrintStream(serviceScriptFile);\n            }\n            service.createServiceScript(ss);\n            if (embedScripts) ps.println(\"EOF_\" + serviceScript); else ss.close();\n        }\n        {\n            URL url = new URL(engine.getAgentContextURL() + \"/\" + engine.getAgentURLPath());\n            log.debug(\"url for agent = \" + url.toExternalForm());\n            PrintStream as = null;\n            if (embedScripts) {\n                ps.println();\n                ps.println(\"cat > \" + agentScript + \" << \" + ii + \"EOF_\" + agentScript + ii);\n                as = ps;\n            } else {\n                File agentScriptFile = new File(instanceDir, agentScript);\n                as = new PrintStream(agentScriptFile);\n            }\n            String tab[] = { \"\", \"    \", \"        \", \"            \", \"                \", \"                    \" };\n            int i = 0;\n            as.println(tab[i] + \"from wrapper import ZSIWrapper\");\n            as.println(tab[i] + \"from service import Service\");\n            as.println(tab[i] + \"import threading\");\n            as.println(tab[i] + \"from sys import exit\");\n            as.println();\n            as.println(tab[i] + \"URL=\" + ii + url.toString() + ii);\n            as.println(tab[i] + \"agentID=\" + ii + agentID + ii);\n            as.println(tab[i] + \"instanceID=\" + instanceID);\n            as.println(tab[i] + \"instanceKey=\" + ii + key + ii);\n            as.println(tab[i] + \"timeout=\" + ii + agent_timeout_seconds + ii);\n            as.println(tab[i] + \"stop_flag=0\");\n            as.println(tab[i] + \"kill_flag=0\");\n            as.println();\n            as.println(tab[i] + \"# Need extra port for each thread, \" + \"ZSIWrapper (actually ZSI) not thread save\");\n            as.println(tab[i] + \"port0=ZSIWrapper(URL, agentID, instanceID, instanceKey, timeout)\");\n            as.println(tab[i] + \"port0.setAgentStatus(\" + Status.RUNNING.ordinal() + \")\");\n            as.println();\n            as.println(tab[i] + \"def create_namespace(service) :\");\n            as.println(tab[i] + \"    \" + ii + \"create a namespace for injection \" + \"into a task script and returns it.\" + ii);\n            as.println(tab[i] + \"# first get most (not all) variables\");\n            as.print(tab[i] + \"    arglist = [ \");\n            int counter = 0;\n            for (VarAttributes va : attributesMap.values()) {\n                counter++;\n                String varname = va.getName();\n                if (Constants.VAR_STDOUT.equals(varname)) continue;\n                VarTypeEnum vartype = va.getType();\n                switch(vartype) {\n                    case DOUBLE:\n                    case STRING:\n                    case LONG:\n                    case BOOLEAN:\n                    case CHOICE:\n                        as.print(tab[i] + \"    '\" + varname + \"'\");\n                        if (counter != attributesMap.size()) as.println(\",\\\\\");\n                        break;\n                    case FILES:\n                        break;\n                    default:\n                        throw new RuntimeException(\"unkown data type in switch\");\n                }\n            }\n            as.println(\"]\");\n            as.println(tab[i] + \"    vars=port0.getManyVars(arglist)\");\n            as.println(tab[i] + \"    namesp = vars \");\n            as.println(tab[i] + \"    namesp[ 'service' ] = service \");\n            as.println(tab[i] + \"    return namesp\");\n            as.println();\n            for (String taskName : taskNames) {\n                Task task = getService().getTask(taskName);\n                boolean background = task.isBackground();\n                as.println(tab[i] + \"def task_\" + taskName + \"():\");\n                {\n                    i++;\n                    as.println(tab[i] + \"try :\");\n                    if (background) {\n                        as.println(tab[i] + \"    # as ZSIWrapper is not task save,\" + \" create a new one\");\n                        as.println(tab[i] + \"    port_task=ZSIWrapper(URL, agentID, \" + \"instanceID, instanceKey, timeout)\");\n                        as.println(tab[i] + \"    service = Service(port_task)\");\n                    } else {\n                        as.println(tab[i] + \"    # this is foreground, \" + \"use port0 from current task\");\n                        as.println(tab[i] + \"    service = Service(port0)\");\n                    }\n                    as.println(tab[i] + \"    globals = create_namespace(service)\");\n                    as.println(tab[i] + \"    locals = { }\");\n                    as.println(tab[i] + \"    execfile('\" + task.getFile() + \"', globals, locals )\");\n                    as.println(tab[i] + \"except :\");\n                    as.println(tab[i] + \"    port0.setTaskStatus('\" + taskName + \"', \" + Status.FAILED.ordinal() + \" )\");\n                    as.println(tab[i] + \"else :\");\n                    as.println(tab[i] + \"    if kill_flag :\");\n                    as.println(tab[i] + \"        task_exit_status = \" + Status.FAILED.ordinal());\n                    as.println(tab[i] + \"    elif stop_flag :\");\n                    as.println(tab[i] + \"        task_exit_status = \" + Status.TERMINATED.ordinal());\n                    as.println(tab[i] + \"    else :\");\n                    as.println(tab[i] + \"        task_exit_status = \" + Status.FINISHED.ordinal());\n                    as.println(tab[i] + \"    port0.setTaskStatus('\" + taskName + \"', task_exit_status )\");\n                    as.println();\n                    i--;\n                }\n            }\n            as.println(tab[i] + \"try:\");\n            i++;\n            as.println(tab[i] + \"tasklist = []\");\n            as.println(tab[i] + \"action=None\");\n            as.println(tab[i] + \"while action != '\" + Agent.STOP + \"' and action != '\" + Agent.KILL + \"' and action != '\" + Agent.FINISH + \"' :\");\n            {\n                i++;\n                as.println(tab[i] + \"# print 'ACTION=', action\");\n                as.println(tab[i] + \"action = port0.getAction()\");\n                as.println(tab[i] + \"\");\n                as.println(tab[i] + \"# cleanup tasklist (only to save memory)\");\n                as.println(tab[i] + \"# In two cycles, don't change list during iter.\");\n                as.println(tab[i] + \"to_be_removed = []\");\n                as.println(tab[i] + \"for tr2 in tasklist:\");\n                as.println(tab[i] + \"    if (not tr2.isAlive()):\");\n                as.println(tab[i] + \"        to_be_removed.append(tr2)\");\n                as.println(tab[i] + \"for tr3 in to_be_removed:\");\n                as.println(tab[i] + \"    # print 'old task removed: ',tr3.getName()\");\n                as.println(tab[i] + \"    tasklist.remove(tr3)\");\n                as.println(tab[i] + \"\");\n                as.println(tab[i] + \"if action == None :\");\n                as.println(tab[i] + \"    # print 'processing None'\");\n                as.println(tab[i] + \"    None\");\n                as.println(tab[i] + \"if action == '\" + Agent.FINISH + \"' :\");\n                as.println(tab[i] + \"    # print 'processing FINISH'\");\n                as.println(tab[i] + \"    None\");\n                as.println(tab[i] + \"elif action == '\" + Agent.STOP + \"' :\");\n                as.println(tab[i] + \"    stop_flag=1\");\n                as.println(tab[i] + \"    # print 'processing STOP'\");\n                String onStop = agent.onStop;\n                if (onStop != null) {\n                    String function = \"task_\" + onStop;\n                    as.println(tab[i] + \"    \" + function + \"()\");\n                }\n                as.println(tab[i] + \"\");\n                as.println(tab[i] + \"elif action == '\" + Agent.KILL + \"' :\");\n                as.println(tab[i] + \"    kill_flag=1\");\n                as.println(tab[i] + \"    # print 'processing KILL'\");\n                String onKill = agent.onKill;\n                if (onKill != null) {\n                    String function = \"task_\" + onKill;\n                    as.println(tab[i] + \"    \" + function + \"()\");\n                }\n                as.println(tab[i] + \"    # This would be the place \" + \"to kill external programs\");\n                as.println(tab[i] + \"    port0.setAgentStatus(\" + Status.FAILED.ordinal() + \")\");\n                as.println(tab[i] + \"    # exit without waiting for bg threads\");\n                as.println(tab[i] + \"    exit(13)\");\n                as.println(tab[i] + \"\");\n                for (String taskName : taskNames) {\n                    Task task = getService().getTask(taskName);\n                    boolean background = task.isBackground();\n                    as.println(tab[i] + \"elif action == '\" + Agent.TASK + taskName + \"':\");\n                    String function = \"task_\" + taskName;\n                    if (background) {\n                        as.println(tab[i] + \"    # create, register and start task\");\n                        as.println(tab[i] + \"    t = threading.Thread(target=\" + function + \", name='\" + function + \"')\");\n                        as.println(tab[i] + \"    tasklist.append(t)\");\n                        as.println(tab[i] + \"    t.start()\");\n                    } else {\n                        as.println(tab[i] + \"    \" + function + \"()\");\n                    }\n                }\n                as.println(tab[i] + \"else :\");\n                as.println(tab[i] + \"    print 'undefined case in agent script iov0j23fds, \" + \"action=', action\");\n                i--;\n            }\n            as.println();\n            as.println(tab[i] + \"# wait for running background tasks\");\n            as.println(tab[i] + \"# print 'remaining threads (inclides demonic ones!):'\" + \", threading.activeCount()\");\n            as.println(tab[i] + \"# for tr in threading.enumerate():\");\n            as.println(tab[i] + \"#    print 'remaining thread: ',\" + \" tr.getName()\");\n            as.println(tab[i] + \"for tr2 in tasklist:\");\n            as.println(tab[i] + \"    # print 'joining with ',tr2.getName()\");\n            as.println(tab[i] + \"    tr2.join()\");\n            i--;\n            as.println(tab[i] + \"# Set agent status\");\n            as.println(tab[i] + \"except :\");\n            as.println(tab[i] + \"    port0.setAgentStatus(\" + Status.FAILED.ordinal() + \")\");\n            as.println(tab[i] + \"else :\");\n            as.println(tab[i] + \"    if kill_flag :\");\n            as.println(tab[i] + \"        agent_exit_status = \" + Status.FAILED.ordinal());\n            as.println(tab[i] + \"    elif stop_flag :\");\n            as.println(tab[i] + \"        agent_exit_status = \" + Status.TERMINATED.ordinal());\n            as.println(tab[i] + \"    else :\");\n            as.println(tab[i] + \"        agent_exit_status = \" + Status.FINISHED.ordinal());\n            as.println(tab[i] + \"    port0.setAgentStatus( agent_exit_status )\");\n            if (embedScripts) ps.println(\"EOF_\" + agentScript); else as.close();\n        }\n        for (String agentFileName : agent.getFilesSet()) {\n            ps.println();\n            File agentRelFile = new File(agentFileName);\n            File directory = agentRelFile.getParentFile();\n            if (directory != null) {\n                ps.println(\"mkdir -p \" + directory.getPath());\n            }\n            ps.println(\"cat > \" + agentFileName + \" << \" + ii + \"EOF_\" + agentFileName + ii);\n            File file = new File(scriptDir, agentFileName);\n            byte bytes[] = FileUtils.readFileToByteArray(file);\n            ps.write(bytes);\n            ps.println();\n            ps.println(\"EOF_\" + agentFileName);\n        }\n        if (embedScripts) {\n            ps.println(\"SKIP=`awk '/^__ARCHIVE_FOLLOWS__/ { print NR + 1; exit 0; }' $0`\");\n            ps.println(\"tail -n +$SKIP $0 | gzip -dc | tar x \");\n            ps.println(\"python -u \" + agentScript);\n            ps.println(\"exit 0\");\n            ps.println(\"__ARCHIVE_FOLLOWS__\");\n            java.io.InputStream istream = this.getClass().getClassLoader().getResourceAsStream(\"sc/fgrid/agent.tar.gz\");\n            IOUtils.copy(istream, ps);\n        } else {\n            String pypath = engine.getAgentPythonPath();\n            ps.println(\"export PYTHONPATH=\" + ii + pypath + ii);\n            ps.println(\"python -u \" + agentScript);\n            ps.println(\"exit 0\");\n        }\n    }\n", "code2": "    public static void main(String argv[]) {\n        String cp = System.getProperty(\"java.class.path\");\n        String sep = System.getProperty(\"file.separator\");\n        String dirpath = cp.substring(0, cp.lastIndexOf(sep));\n        String jarpath = dirpath + \"/WiiRemoteJ.jar\";\n        if (!new File(jarpath).exists()) {\n            try {\n                System.out.println(\"getting WiiRemoteJ file from remote source...\");\n                URL wiiRemLoc = new URL(\"http://www.world-of-cha0s.hostrocket.com/WiiRemoteJ/WiiRemoteJ%20v1.5.zip.gz\");\n                GZIPInputStream input = new GZIPInputStream(wiiRemLoc.openStream());\n                String temploc = copyInputStreamToTmpFile(input, \".zip\");\n                ZipInputStream zipIn = new ZipInputStream(new FileInputStream(temploc));\n                ZipEntry i = null;\n                while ((i = zipIn.getNextEntry()) != null) {\n                    if (i.getName().endsWith(\"WiiRemoteJ.jar\")) {\n                        File outjar = new File(jarpath);\n                        BufferedOutputStream fs = new BufferedOutputStream(new FileOutputStream(outjar));\n                        int bufferSize = 8192;\n                        byte[] buffer = new byte[bufferSize];\n                        int readSize = 0;\n                        while ((readSize = zipIn.read(buffer, 0, bufferSize)) != -1) {\n                            fs.write(buffer, 0, readSize);\n                        }\n                        fs.close();\n                    }\n                }\n                System.out.println(\"unpacked into classpath.\");\n            } catch (MalformedURLException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        Boogiepants.main(argv);\n    }\n", "label": 1, "substitutes": {"ps": ["ils", "lines", "pipe", "ns", "pc", "vs", "eps", "log", "cs", "PS", "post", "ls", "pse", "pm", "pp", "files", "ts", "pas", "pass", "py", "ons", "pd", "css", "ep", "po", "pex", "os", "print", "posts", "ins", "Ps", "sp", "ras", "pers", "pi", "res", "pl", "parent", "als", "proc", "points", "pe", "lets", "fs", "http", "params", "gs", "ups", "cp", "qs", "ports", "pid", "per", "pr", "ping", "pro", "ops", "ds", "process", "s", "null", "p", "ks", "pull", "pes", "ws", "out", "pg", "ms", "ppa", "pa", "plugins", "tp", "pps", "amps", "ips", "its", "details", "pos", "proxy"], "agentName": ["serviceId", "agentNAME", "agencyName", "interfaceType", " agentId", "interfaceNAME", "serviceName", "AgentName", "interfaceId", "AgentId", "agencyId", "AgentID", "serviceID", "interfaceID", " agentType", " agentNAME", "agentType", "serviceNAME", "agentId", "AgentType", "interfaceName", "agencyID"], "agentID": [" agentURI", " agentId", "serviceURI", "serviceId", "serviceName", "AgentName", "serviceID", "AgentURI", "AgentId", "agentId", "AgentID", "agentURI"], "agent": ["active", "operator", "ant", "link", "connection", "admin", "plugin", "gent", "engine", "man", "ct", "client", "app", "model", "base", "agents", "data", "handler", "server", "config", "activity", "exec", "machine", "monitor", "action", "station", "ace", "Agent", "act", "agency", "session", "media", "image", "connect", "sp", "command", "service", "account", "bot", "proxy", "ad", "ie"], "instanceDir": ["instanceLoc", "exampleVol", "anceDirectory", "imageFile", "anceFolder", "uploadDIR", "exampleDir", "uploadDir", "anceDur", "instanceVol", "storageDIR", "testDir", "anceDir", "uploadLoc", "testName", "imageFolder", "imageDirectory", "instanceDIR", "anceLoc", "instanceDirectory", "instanceFile", " instanceFile", "anceFile", "instanceName", "instanceFolder", "imageDir", "storageDir", "exampleDIR", "anceVol", "anceName", "testVol", "testDIR", " instanceDirectory", "uploadDur", "instanceDur", "anceDIR", "storageDur", "storageLoc", " instanceFolder", "exampleName"], "agent_timeout_seconds": ["agent_cache_seconds", "agent_timeout_second", "agent_timeout_duration", "agent_cache_second", "agent_cache_duration", "agent_cache_sec", "agent_timeout_sec"], "ii": ["ei", "ice", "si", "qi", "abi", "uni", "CI", "ind", "hi", "yi", "inf", "model", "version", "di", "tif", "zi", "zip", "prefix", "ni", "ji", "ai", "info", "gi", "address", "ti", "gui", "init", "dir", "ui", "ci", "ix", "ani", "api", "ini", "cli", "timeout", "li", "xi", "iri", "mini", "index", "slice", "image", "cin", "uri", "iii", "cci", "service", "secret", "vi", "II", "img", "fi", "agi", "ig", "chi", "qa", "sci", "ie"], "agentScript": ["serviceCode", " serviceCode", " serviceFile", "agentCode", "ServiceScript", "ServiceCode", "ServiceFile", "serviceFile", "agentFile"], "serviceScript": ["ServiceConfig", "serviceText", "servicescript", "spaceCode", "featurescript", "agentCode", "featureScript", "ServiceFile", "serviceFile", "serverCode", "sourceSocket", "skillConfig", "serviceCode", "siteCode", "agentText", " servicescript", "serverScript", "sourceFile", "serviceSocket", "ServiceCode", "skillFile", "spaceFile", " serviceSocket", "skillSocket", "ServiceSocket", "siteScript", " serviceCode", " serviceFile", " serviceText", "ServiceScript", "spacescript", "serverFile", "serverText", "featureFile", " serviceConfig", "serviceConfig", "sourcescript", "skillScript", "featureSocket", "siteFile", "Servicescript", "spaceScript", "sourceScript", "agentFile"], "taskNames": ["askNames", "taskFiles", "TaskFiles", "askNumbers", "askTypes", "TaskNumbers", "threadNumbers", "taskMaps", "TaskTypes", "taskNumbers", "askFiles", "threadNames", " taskNumbers", "threadTypes", "threadMaps", "TaskNames", " taskFiles", "taskTypes", "TaskMaps", "askMaps"], "scriptDir": ["criptDb", "serviceDirectory", "criptPath", "scriptDirectory", " scriptDb", "serviceDb", "criptDir", " scriptPath", "scriptPath", "servicePath", " scriptDirectory", "serviceDir", "scriptDb", "criptDirectory"], "taskName": ["taskKey", "askNames", "askName", "deviceName", " taskKey", "fileName", "deviceKey", "devicename", "fileKey", "askname", " taskLine", "fileLine", "taskLine", "askKey", " taskname", "TaskLine", "TaskKey", "TaskNames", "deviceNames", "TaskName", "fileNames", "taskname"], "task": ["Task", "route", "contract", "input", "link", "network", "complete", "plugin", "game", "message", "thread", "out", "request", "object", "client", "pack", "worker", "remote", "work", "slave", "resource", "child", "config", "role", "address", "master", "server", "module", "activity", "tag", "name", "action", "sync", "event", "skill", "target", "device", "password", "instance", "job", "session", "key", "image", "ask", "error", "command", "problem", "service", "type", "project", "test", "unit"], "script": ["source", "play", "input", "cript", "output", "css", "model", "Script", "javascript", "data", "style", "zip", "resource", "sc", "config", "template", "address", "exec", "js", "tag", "sync", "module", "query", "scope", "pattern", "patch", "esc", "log", "password", "text", "pic", "content", "timeout", "key", "variable", "slice", "string", "scripts", "image", "code", "command", "lua", "service", "proxy", "ct", "test", "p"], "embedScripts": ["morphScripts", "attachScriptions", "embedScriptes", "embedcriptures", "videoScriptes", "videocriptes", "embedScriptments", "embedcriptes", "embedScripted", " embedcriptures", "embedScriptings", "attachScripts", "embedSecondgs", " embedScripted", "embedScriptures", "embedProgrames", "embedcriptions", "embedScriptd", "embedcriptments", "embedStreamed", "embedConfigments", "videoScripto", "embedcriptgs", "videocriptings", "embedStructments", " embedcripts", "morphStreams", "embedConfigs", "videoScripts", "embedScriptions", "morphStreames", "embedStreamd", "morphScripted", "embedConfiges", "embedProgramo", "videocripts", "embedSecondches", "videoScriptgs", "embedScriptches", "embedcriptches", "videoScriptings", "attachStructes", "embedscriptgs", "embedscripted", "embedStructs", "embedcripto", "embedConfigions", "attachStructments", "embedSecondes", "embedStructions", "embedScripto", "embedscripts", "embedscriptches", "embedcriptings", "morphScriptes", "morphScriptd", "embedStreames", "embedPrograms", "embedscriptings", "videocriptches", "morphStreamed", "videocripto", "embedStreams", " embedScriptures", "videocriptgs", "embedScriptgs", "embedProgramings", "embedcriptd", "embedscriptd", "embedscriptes", "embedscriptures", "morphStreamd", "embedcripts", "attachStructions", "embedStructed", "attachStructs", "embedSeconds", "embedStructures", " embedcripted", "attachScriptes", " embedcriptes", "videoScriptches", " embedScriptes", "embedscripto", "embedcripted", "attachScriptments", "embedStructes"], "taskScriptFile": ["TaskStyleFile", "taskSignGlobal", "taskEscPath", "TaskStylefile", "TaskStyleGlobal", "courseStructPath", "taskSyncFile", "taskSyncBody", "taskSyncfile", "taskEscFile", "taskScriptPath", "taskEscBody", "taskStructfile", "taskStreamGlobal", "TaskScriptfile", "TaskScriptFile", "taskSignFile", "taskStyleGlobal", "courseScriptFile", "taskScriptBody", "taskStyleFile", "taskScriptfile", "courseStructBody", "taskStylefile", "taskStreamLine", "taskSignLine", "taskEscfile", "TaskScriptGlobal", "taskStructPath", "courseScriptfile", "taskScriptGlobal", "taskScriptLine", "taskStructBody", "TaskScriptLine", "taskSignfile", "taskStreamFile", "courseStructfile", "taskStyleLine", "taskSyncPath", "taskStructFile", "courseStructFile", "courseScriptBody", "taskStreamfile", "TaskStyleLine", "courseScriptPath"], "xs": ["px", "hs", "aws", " xp", "rx", "events", "pes", "ils", "xd", "ws", "rss", "wx", "fs", "gs", "css", "Tx", "ns", "fe", "codes", "xes", "ctx", "xc", "outs", "qs", "gets", "js", "xx", "eps", "x", "vs", "ins", "icks", "pps", "rs", "cs", "iffs", "ls", "apps", "xp", "ses", "ds", "views"], "ss": ["su", "fts", "ks", "test", "sb", "si", "ws", "rss", "cas", "fs", "sw", "pg", "css", "sf", "ns", "ros", "ms", "iss", "ess", "bs", "stats", "sc", "ass", "serv", "uss", "os", "WS", "qs", "ics", "eps", "vs", "ssh", "oss", "xx", "js", "s", "pps", "cs", "rs", "sv", "ls", "pse", "SS", "sp", "ssl", "hess", "\u00df", "service", "us", "ses", "ds", "services", "ng", "ts", "ys", "sl", "pass"], "serviceScriptFile": ["serviceScriptBook", "serviceTextF", "serviceJSONFile", "bankscriptUrl", "serviceSignBook", "serviceSignFile", "securitySignBook", "servicescriptStream", "bankScriptFile", "bankScriptUrl", "securityScriptFile", "serviceFormBook", "bankScriptF", "servicescriptFile", "serviceJSONLine", "serviceTextStream", "serviceCodeFile", "bankScriptStream", "serviceFormfile", "serviceFormLine", "serviceScriptUrl", "bankscriptStream", "securityScriptfile", "securityScriptLine", "serviceCodeStream", "serviceSignLine", "servicescriptF", "serviceScriptLine", "serviceScriptStream", "serviceCodeF", "serviceScriptF", "bankscriptFile", "serviceTextFile", "serviceTextUrl", "securityScriptBook", "securitySignfile", "serviceScriptfile", "serviceCodeUrl", "serviceJSONfile", "securitySignLine", "servicescriptUrl", "serviceSignfile", "serviceJSONBook", "securitySignFile", "serviceFormFile", "bankscriptF"], "url": ["source", "host", "page", "id", "link", "browser", "connection", "feed", "xml", "l", "http", "bc", "base", "f", "https", "data", "ver", "ref", "stream", "channel", "response", "resource", "server", "call", "config", "address", "update", "name", "action", "gl", "api", "text", "location", "string", "path", "image", "uri", "ssl", "db", "URL", "service", "Url", "www", "blog", "proxy", "web", "coll", "sl"], "as": ["aws", " ts", "acs", "http", "out", "pack", "was", "to", "As", "bs", "outs", "ass", " to", "vs", "parser", " rs", "a", "asa", "pos", " os", "ras", "is", " es", " us", " is", "www", "pas"]}}
{"id1": "11329784", "id2": "18384626", "code1": "    @PostConstruct\n    public void init() {\n        logger.info(\"+++++ TRACAuditChecklistWizardMB: init() start ++++++++\");\n        try {\n            tracSectionAll = new ArrayList<TRACCriteriaCheckListItem>();\n            List<TRACCriteriaCheckListItem> tracSectionA = new ArrayList<TRACCriteriaCheckListItem>();\n            List<TRACCriteriaCheckListItem> tracSectionB = new ArrayList<TRACCriteriaCheckListItem>();\n            List<TRACCriteriaCheckListItem> tracSectionC = new ArrayList<TRACCriteriaCheckListItem>();\n            URL url = TRACAuditChecklistManagedBean.class.getResource(tracCriteriaPropertiesFileName);\n            tracCriteriaCheckList = new LinkedProperties();\n            tracCriteriaCheckList.load(url.openStream());\n            Set<String> tmpKeys = tracCriteriaCheckList.stringPropertyNames();\n            List<String> sortWrkList = new ArrayList<String>();\n            sortWrkList.addAll(tmpKeys);\n            sortList(sortWrkList);\n            for (String key : sortWrkList) {\n                String aspectCode = key.substring(aspectCodeOffsetValue);\n                logger.info(\"aspectCode=\" + aspectCode);\n                if (aspectCode.startsWith(\"A\")) {\n                    if (aspectCode.equals(\"A\")) {\n                        sectionAcaption = tracCriteriaCheckList.getProperty(key);\n                    } else {\n                        if (aspectCode.length() == 4) {\n                            tracSectionAll.add(new TRACCriteriaCheckListItem(aspectCode, tracCriteriaCheckList.getProperty(key), \"\", \"\", \"\"));\n                        }\n                    }\n                } else if (aspectCode.startsWith(\"B\")) {\n                    if (aspectCode.equals(\"B\")) {\n                        sectionBcaption = tracCriteriaCheckList.getProperty(key);\n                    } else {\n                        if (aspectCode.length() == 4) {\n                            tracSectionAll.add(new TRACCriteriaCheckListItem(aspectCode, tracCriteriaCheckList.getProperty(key), \"\", \"\", \"\"));\n                        }\n                    }\n                } else if (aspectCode.startsWith(\"C\")) {\n                    if (aspectCode.equals(\"C\")) {\n                        sectionCcaption = tracCriteriaCheckList.getProperty(key);\n                    } else {\n                        if (aspectCode.length() == 4) {\n                            tracSectionAll.add(new TRACCriteriaCheckListItem(aspectCode, tracCriteriaCheckList.getProperty(key), \"\", \"\", \"\"));\n                        }\n                    }\n                } else {\n                    logger.warning(\"offset value is wrong: 16th character must be A or B or C\");\n                }\n            }\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.WARNING, \"specified properties file was not found\", ex);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"IO error occurred\", ex);\n        } finally {\n        }\n        logger.info(\"+++++ TRACAuditChecklistWizardMB: init() end   ++++++++\");\n    }\n", "code2": "            protected Object getNewObject() throws IOException {\n                URLConnection conn = HTTPMessageDeliveryImpl.this.url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                conn.setUseCaches(false);\n                conn.setRequestProperty(\"Content-Type\", \"text/xml\");\n                return conn;\n            }\n", "label": 0, "substitutes": {"tracSectionAll": ["tracoRegionAs", "tracGroupALL", "trackSectionA", "trACsectionAll", "tracRegionAll", "tracConfigALL", "trACsectionAL", "trACSectionAL", "tracoRegionAll", "tracRegionALL", "tracSectionFull", "tracZoneList", "tracoSectionAs", "trACSectionALL", "tracChannelEach", "trACsectionALL", "tracSectionList", "tracZoneALL", "trackPartAll", "tracGroupAll", "tracConfigAL", "tracSectionAs", "tracsectionList", "tracPartAll", "trackPartA", "tracPartA", "tracsectionALL", "tracoRegionALL", "trackSectionALL", "tracoSectionAll", "tracGroupA", "tracoSectionALL", "trACSectionAll", "tracChannelAs", "tracSectionALL", "tracConfigList", "tracChannelALL", "tracoSectionEach", "trackPartALL", "trackSectionAll", "trackSectionFull", "trackPartFull", "tracPartFull", "tracZoneAL", "tracGroupFull", "tracZoneAll", "tracConfigAll", "tracsectionAL", "tracSectionAL", "trACsectionList", "tracoRegionEach", "tracRegionAs", "trACSectionList", "tracPartALL", "tracRegionEach", "tracChannelAll", "tracSectionEach", "tracsectionAll"], "tracSectionA": ["tracsectionA", "tracCourseAPI", "trACSectionAPI", "trACSectionA", "tracsectionB", "tracSectionAPI", "tracsectionAPI", "tracCourseB", "trACSectionAll", "trACSectionB", "tracCourseAll", "tracsectionAll", "tracCourseA"], "tracSectionB": ["tracsectionA", "tracGroupP", "trACsectionA", "tracDirectoryP", "tracsectionBs", "trACSectionA", "tracSectionP", "tracsectionB", "trACsectionP", "tracGroupB", "tracSectionBs", "trACSectionBs", "tracGroupBs", "tracsectionP", "tracDirectoryA", "trACSectionP", "tracGroupA", "trACsectionBs", "tracDirectoryBs", "tracDirectoryB", "trACSectionB", "trACsectionB"], "tracSectionC": ["trACSectionC", "tracPartE", "tracSectionD", "tracsectionB", "tracsectionC", "tracsectionD", "tracAccessD", "trACsectionE", "trACsectionD", "tracsectionE", "tracPartD", "trACSectionE", "trACSectionD", "tracAccessE", "trACsectionC", "tracAccessC", "trACSectionB", "tracAccessB", "tracPartB", "tracPartC", "tracSectionE", "trACsectionB"], "url": ["source", "page", "user", "connection", "open", "buffer", "xml", "l", "http", "b", "state", "f", "loader", "base", "data", "channel", "stream", "class", "r", "resource", "org", "server", "config", " URL", "element", "name", "gl", "api", "location", "window", "string", "path", "file", "uri", "ssl", "URL", "service", "Url", "www", "web", "str", "sl", "entry"], "tracCriteriaCheckList": ["tracCriteriaServiceL", "tr\n", "tracCriteriaConfiglist", "tracCriteriaServiceEx", "tracCriteriaServiceList", "tracCriterionCheckEx", " tr\n", "tracCriteriaServiceData", "tracCriteriaFilelist", "tracCriteriacheckPool", "tracCriteriaConfigPool", "tracCriteriaChecklist", "Tr\n", "tracCriteriaServicePool", "tracCriteriaCleanData", "tracCriteraServiceData", "tracCriteriaReviewL", "tracCriteraServiceList", "tracCriteriaServiceLIST", "tracCriteriaCheckData", "tracCriteriaConfigL", "tracCriteriaConfigLIST", "tracCriteriaCheckLIST", "tracCriterionCheckLIST", "tracCriterionServiceMap", "tracCriteraChecklist", "tracCriteriaCheckEx", "tracCriterionWorklist", "tracCriterionCheckMap", "tracCriteriaCheckPool", "tracCriteriaFileL", "tracCriteriaReviewMap", "tracCriteraCheckData", "tracCriterionServiceLIST", "tracCriterionWorkList", "tracCriteriaServiceMap", "tracCriteriaConfigList", "tracCriterionCheckL", "tracCriteriaReviewEx", "tracCriteriaWorkGroup", "tracCriterionChecklist", "tracCriteraCheckList", "tracCriterionCheckGroup", "tracCriteriaCheckMap", "tracCriteriaCleanList", "tracCriteriaServicelist", "tracCriterionServiceL", "tracCriterionServiceList", "tracCriteraServiceL", "tracCriterionCheckList", "tracCriterionWorkL", "tracCriteriaFileList", "tracCriteriacheckLIST", "tracCriteriaWorklist", "tracCriteriaWorkLIST", "tracCriterionWorkGroup", "tracCriteriaCleanlist", "tracCriteriaWorkL", "tracCriteriacheckL", "tracCriterionServiceEx", "tracCriteriaCheckGroup", "tracCriterionWorkLIST", "tracCriteriaCleanL", "tracCriteraServicelist", "tracCriteriaWorkList", "tracCriteriacheckList", "tracCriteriaReviewList", "tracCriteriaFileGroup", "tracCriteraCheckL", "tracCriterionCheckPool", "tracCriteriaServiceGroup", "tracCriterionServicePool", "tracCriteriaCheckL", "TR\n"], "tmpKeys": ["mpKey", "cmpNames", "mpKeys", "tempKey", "tmpNames", "tempTokens", " tmpkeys", "vtKey", "tempNames", "mpNames", "cmpKeys", "tmpKey", "vtTokens", "tmpTokens", " tmpTokens", "tempKeys", "mpkeys", "vtNames", " tmpKey", " tmpNames", "vtKeys", "tmpkeys", "cmpkeys", "cmpKey"], "sortWrkList": ["sortWkList", "sortWrckL", "sortWrKEx", "sortSprkSet", "sortWrKList", "sortWrckList", "sortSprkString", "sortWrksList", "sortWrKL", "sortSprkList", "sortSprkChain", "sortWrkL", "sortWrkQueue", "sortSprksList", "sortWrklist", "sortWrksL", "sortWrokString", "sortWrkerL", "sortWrksSet", "sortWrkString", "sortWrksString", "sortWrKlist", "sortWrkEx", "sortWrksEx", "sortWkQueue", "sortWKList", "sortWrokQueue", "sortWrkerList", "sortWrkSet", "sortWrokL", "sortWrkslist", "sortWraklist", "sortSprksSet", "sortWrckEx", "sortSprkslist", "sortWkL", "sortWrkerSet", "sortWrckSet", "sortWrckString", "sortWrkerCollection", "sortWrokList", "sortWrkCollection", "sortSprksEx", "sortSprklist", "sortSprkEx", "sortWrksChain", "sortWrckCollection", "sortSprkCollection", "sortSprksCollection", "sortWrksCollection", "sortWKL", "sortWrakChain", "sortWrakL", "sortSprksChain", "sortWrKQueue", "sortWkString", "sortWKString", "sortWrkChain", "sortSprksString", "sortWKQueue", "sortWrKString", "sortSprkL", "sortWrakList", "sortWrksQueue", "sortWrKChain", "sortSprksL"], "key": ["ame", "default", "sign", "ry", "val", "ray", "mac", "Key", "roy", "r", "name", "temp", "list", "type", "id", " Key", "cell", "part", "row", "phrase", "pair", "ring", "a", "index", "point", "search", "value", "source", "page", "parent", "my", "link", "pe", "f", "base", "version", "server", "KEY", "section", "x", "element", "full", "string", "path", "j", " entry", "date", "order", "p", "go", "connection", "cy", "right", "keys", "k", "y", "data", "match", "here", "ace", "json", "rule", "change", "seed", "lock", "code", "current", "item", "ce", "field", "any", "entry"], "aspectCode": ["aspirText", "waspectedName", "assspectKey", " aspectText", "asspectionType", "aspectioncode", "aspirZone", " aspectsCode", "aspectionString", "aspectionType", "aspirKey", "aspectsName", "aspectCondition", "aspectsCode", "aspectName", "asspectId", "Aspectcode", "waspectText", "aspectZone", "rasspectName", "aspectingCode", "assepectedName", "aspecName", "aspirCode", "asspectCondition", "assspectCode", "aspectsId", "asspectString", "Aspectioncode", "aspectingId", "rasspectCode", "asstrumentCode", "aspectsType", "aspectsNumber", "aspectId", "raspectId", " aspectName", "aspectionNumber", "waspectComplete", "aspectsText", "asspectioncode", "aspectionName", " aspectsName", "asspectionKey", "aspectString", "aspectedComplete", "aspectType", "rasspectType", "rasspectId", "asspectionCondition", "aspectedText", "assepectName", " aspectsZone", "aspectKey", " aspectZone", "assepectedZone", "aspectingText", "aspectCount", "raspectCode", "aspircode", "asspectNumber", "asspectName", "asspectZone", "aspectedKey", "assspectCount", "aspectionZone", "asspectionNumber", "aspectingName", "waspectName", "aspirName", "aspecCode", "aspectedCode", "asstrumentZone", "assspectName", "AspectionCode", "waspectedText", "asspectcode", "aspectingCondition", " aspectsText", "assepectcode", "aspectsZone", "aspectedZone", "asspectCount", "waspectCode", "AspectCode", "aspecKey", "assepectZone", "aspectionCondition", "aspectComplete", "aspirComplete", "aspectingType", "aspectsComplete", "asspectType", "aspectedcode", "aspectionKey", "asspectCode", "aspectNumber", "aspectedString", "aspectcode", "aspectedName", "raspectType", "waspectedComplete", "asspectionName", "aspirCount", "aspectsCondition", "aspecCount", "aspeccode", "assepectCode", "aspecZone", "assepectedCode", "aspectsKey", "asstrumentText", "waspectedCode", "aspectText", "aspectionCode", "raspectName", "asspectionText", "aspectionText", "asspectText", "asspectionCode", "asceptionCode", "assepectedcode", "asceptioncode", "asspectKey", "asspectionString"], "sectionAcaption": ["sectionACaution", "sectionAtaachment", "sectionAccaachment", "sectionAccaption", "sectionAcaution", "sectionACaption", "sectionAccaution", "sectionAtaoption", "sectionACaachment", "sectionAcaachment", "sectionAcaoption", "sectionAtaution", "sectionAccaoption", "sectionAtaption", "sectionACaoption"], "sectionBcaption": ["sectionBCAlement", "sectionBtalement", "sectionBcaution", "sectionBCalement", "sectionBCaution", "sectionBtaption", "sectionBtaution", "sectionBcalement", "sectionBCAption", "sectionBCaption", "sectionBCAution"]}}
{"id1": "20784778", "id2": "16190704", "code1": "    private boolean checkTypeChange(Class clazz, File wsdlFile) {\n        if (!clazz.isPrimitive()) {\n            ClassLoader cl = clazz.getClassLoader();\n            if (cl instanceof AntClassLoader) {\n                if (clazz.isArray()) return checkTypeChange(getArrayType(clazz), wsdlFile);\n                String path = clazz.getName().replace('.', File.separatorChar) + \".class\";\n                File file = new File(builddir, path);\n                long lastMod = Long.MAX_VALUE;\n                if (!file.exists()) {\n                    URL url = cl.getResource(path);\n                    if (url == null) throw new BuildException(\"Can't get URL for webservice class '\" + clazz.getName() + \"' from jar file.\"); else {\n                        try {\n                            JarURLConnection con = (JarURLConnection) url.openConnection();\n                            lastMod = con.getJarEntry().getTime();\n                        } catch (IOException x) {\n                            throw new BuildException(\"Can't get modification time for webservice class '\" + clazz.getName() + \"' from jar file.\");\n                        }\n                    }\n                } else {\n                    lastMod = file.lastModified();\n                }\n                if (wsdlFile.lastModified() < lastMod) return true;\n                if (clazz.isInterface()) {\n                    Class[] itfs = clazz.getInterfaces();\n                    for (int i = 0; i < itfs.length; i++) {\n                        boolean changed = checkTypeChange(itfs[i], wsdlFile);\n                        if (changed) return true;\n                    }\n                } else {\n                    Class sup = clazz.getSuperclass();\n                    boolean changed = checkTypeChange(sup, wsdlFile);\n                    if (changed) return true;\n                }\n            }\n        }\n        return false;\n    }\n", "code2": "    public static String exchangeForSessionToken(String protocol, String domain, String onetimeUseToken, PrivateKey key) throws IOException, GeneralSecurityException, AuthenticationException {\n        String sessionUrl = getSessionTokenUrl(protocol, domain);\n        URL url = new URL(sessionUrl);\n        HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();\n        String header = formAuthorizationHeader(onetimeUseToken, key, url, \"GET\");\n        httpConn.setRequestProperty(\"Authorization\", header);\n        if (httpConn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new AuthenticationException(httpConn.getResponseCode() + \": \" + httpConn.getResponseMessage());\n        }\n        String body = CharStreams.toString(new InputStreamReader(httpConn.getInputStream(), Charsets.ISO_8859_1));\n        Map<String, String> parsedTokens = StringUtil.string2Map(body, \"\\n\", \"=\", true);\n        parsedTokens = StringUtil.lowercaseKeys(parsedTokens);\n        return parsedTokens.get(\"token\");\n    }\n", "label": 0, "substitutes": {"clazz": [" claz", "plclass", "clabel", "clclass", " club", "closer", "plaz", "classace", "spllass", "plabel", " closer", "pllass", " cllass", "classe", "classlass", "slclass", "blazz", "sllass", "plazz", "plClass", "CLoser", "clClass", "blclass", "slace", "Clazz", "sploser", " classe", "plub", "slazz", "claz", "blasse", "Closer", "slub", "CLlass", "blClass", "Clace", "club", "Cllass", " cluster", " clclass", "CLclass", "splabel", "classclass", "CLazz", "Clclass", "bluster", "CLClass", "CLuster", "Cluster", "splazz", "classazz", "bllass", "slaz", "pluster", "sluster", "plasse", " clabel", "clace", "cluster", "cllass", "ploser", "Classe"], "wsdlFile": ["wslfile", "openslFile", "wslbFile", "wsdcFile", "wordsdalFile", "wordsdalFILE", "wordsdalFiles", "wsslParser", "opensdlClass", "wordsdlFILE", "wsslFilename", "wsdrofile", "wsdroFilename", "wslFile", "wsslFILE", "opensdlFiles", "wsdlSourceFile", "wsdlClass", "wsllfile", "wsdcFiles", "wordsdlFiles", "wsdcfile", "wdlfile", "wsdalFile", "openslClass", "openslFiles", "wsllFilename", "wsdlfile", "opensdlFile", "wsslFile", "wsdlFILE", "opensdlfile", "wslbFilename", "wsllClass", "wsdlFilename", "wsdroSourceFile", "wsllFiles", "wsdalfile", "wllSourceFile", "wsdlParser", "wslClass", "wdlSourceFile", "wsllFile", "wllFiles", "wslbfile", "wsslfile", "wsdcFILE", "wsdalFILE", "wordsdalfile", "wordsdlFile", "openslfile", "wdlParser", "wslParser", "wslFilename", "wdlFiles", "wsslClass", "wdlFile", "wllfile", "wsllParser", "wllFile", "wsdroFile", "wdlFilename", "wsdlFiles", "wllFilename", "wsslFiles", "wslbFiles", "wslSourceFile", "wslFiles", "wsllSourceFile", "wordsdlfile", "wsdalFiles"], "cl": ["sel", "hl", "la", "lang", "uc", "hell", "lim", "CL", "l", "ul", "scl", "bc", "lr", "Cl", "loader", "L", "loc", "ctrl", "class", "sc", "kl", "mc", "el", "exec", "Class", "acl", "cle", "cel", "log", "wl", "sl", "cli", "lc", "ls", "fl", "com", "il", "cr", "ocl", "lock", "c", "ml", "comb", "ol", "cloud", "clone", "lass", "cc", "pl", "coll", "ll", "bl"], "path": ["host", "folder", "route", "id", "format", "PATH", "Path", "base", "loader", "p", "data", "prop", "loc", "class", "zip", "resource", "prefix", "config", "ath", "alias", "name", "filename", "method", "dir", "pattern", "patch", "step", "log", "text", "content", "key", "slice", "string", "point", "image", "pointer", "uri", "context", "value", "entry", "location", "type"], "file": ["get", "page", "ball", "folder", "ile", "line", "pe", "place", "connection", "feed", "lf", "function", "File", "l", "http", "fp", "b", "object", "model", "f", "loader", "base", "layer", "loc", "class", "zip", "resource", "server", "el", "filename", "body", "dir", "log", "job", "le", "rule", "il", "image", "rl", "cache", "db", "uri", "files", "local", "FILE", "jar", "use", "entry"], "lastMod": [" lastMOD", "lastMOD", "latestmod", "LastMin", "firstSem", "lastTime", "nextmod", "maxMOD", "lastmod", "firstMOD", "firstmod", "maxMod", "lastReg", "firstTime", "lastSem", "nextMin", " lastTime", "firstMod", " lastSem", "latestMod", " lastmod", "maxReg", "Lastmod", "maxSem", "firstReg", "nextMOD", "nextMod", " lastReg", "maxTime", " lastMin", "latestMOD", "lastMin", "maxmod", "LastMOD", "LastMod"], "url": ["source", "link", "connection", "xml", "download", "ll", "conn", "l", "ul", "http", "src", "client", "b", "lr", "f", "loader", "base", "loc", "class", "resource", "server", "address", "ur", "event", "gl", "bb", "ob", "log", "fl", "location", "li", "string", "image", "il", "rl", "impl", "socket", "uri", "ssl", "URL", "Url", "www", "blog", "web", "jar", "coll", "sl", "entry"], "con": ["en", "connection", "cm", "uc", "cf", "conn", "in", "client", "Conn", "const", "gen", "cover", "class", "enc", "resource", "ctx", "config", "can", "cn", "conf", "x", "bean", "cons", "ci", "rc", "CON", "container", "syn", "ocon", "ex", "ann", "com", "rec", "cr", "connect", "c", "reg", "ran", "un", "conv", "cc", "Connection", "ca", "coll", "Con"], "itfs": ["itf", "itsfs", "utf", "Itns", "Itfb", "pitvs", "Itcs", "itsfaces", "Itfaces", "itsns", " itf", "itns", "pitf", "atfts", "pitfaces", " itns", "utfs", "itfb", " itcs", "itvs", "itsvs", "utfts", "itscs", "itcs", "atf", "itfaces", "atfb", "itsf", "atfs", "Itf", "itfts", "Itfts", "Itvs", "pitfs", "Itfs", "utfb"], "i": ["id", "si", "d", "multi", "abi", "qi", "uli", "iu", "hi", "io", "phi", "k", "yi", "y", "in", "b", "f", "di", "bi", "I", "ti", "oi", "ai", "gi", "info", "ji", "off", "x", "ix", "ui", "u", "ci", "o", "e", "t", "m", "li", "v", "xi", "ri", "index", "wei", "j", "uri", "ii", "g", "q", "pi", "start", "fi", "z", "ip", "p", "type"], "changed": ["added", "edited", "updated", "diff", "bug", "formed", "connected", "used", "loaded", "broken", "set", "won", "changes", "wrong", "different", "update", "started", "known", "changing", "disabled", "failed", "found", "checked", "comment", "anged", "variable", "history", "confirmed", "change", "error", "problem", "Changed", "required", "modified", "valid", "created", "initialized", "current", "balanced", "fixed", "locked", "called", "ended", "handled", "made"], "sup": ["shift", "lp", "cop", "div", "su", "suff", "pe", "uc", "rup", "cmp", "ss", "jp", "azz", " Sup", "ship", "sf", "def", "cpp", "class", "uss", "sc", "ub", "sub", "desc", "vp", "inst", "upp", "uf", "SU", "up", "usa", "ii", "SUP", "np", "Sup", "pp", "sq", "lass", "uper", "uff", "img", "cup", "small", "imp"]}}
{"id1": "5638421", "id2": "17728719", "code1": "    private void copy(File in, File out) {\n        log.info(\"Copying yam file from: \" + in.getName() + \" to: \" + out.getName());\n        try {\n            FileChannel ic = new FileInputStream(in).getChannel();\n            FileChannel oc = new FileOutputStream(out).getChannel();\n            ic.transferTo(0, ic.size(), oc);\n            ic.close();\n            oc.close();\n        } catch (IOException ioe) {\n            fail(\"Failed testing while copying modified file: \" + ioe.getMessage());\n        }\n    }\n", "code2": "    private void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"in": ["source", "reader", "id", "input", "inc", "din", "arin", "plugin", "min", "io", "src", "l", "this", "part", "login", "f", "base", "In", "pin", "again", "n", "work", "isin", "inner", "exec", "x", "sync", "init", "it", "ins", "m", "ex", "image", "lock", "c", "file", "i", "IN", "inside", "inn", "rin", "at", "bin", "s"], "out": ["source", "parent", "plain", "inc", "user", "io", "output", "b", "this", "object", "part", "base", "f", "to", "OUT", "Out", "again", "outs", "n", "call", "ac", "writer", "off", "exec", "x", "word", "name", "init", "o", "target", "dot", "ex", "v", "up", "point", "obj", "c", "file", "i", "at", "working", "copy", "null", "p"], "ic": ["mic", "ik", "inc", "cu", "voc", "vc", "icc", "ico", "fc", "ick", "IC", "aic", "ec", "nic", "enc", "xc", "irc", "ac", "ai", "lic", "mc", "pc", "ics", "exec", "x", "ix", "acl", "ci", "rc", "pic", "icer", "lc", "ex", "iac", "c", "i", "cci", "cc", "cit", "ici", "ig", "ct"], "oc": ["mic", "dc", "anc", "uc", "cf", "voc", "co", "vc", "ico", "io", "output", "aco", "fc", "OC", "alloc", "bc", "toc", "loc", "ec", "aic", "nic", "enc", "org", "sc", "xc", "irc", "oca", "ac", "ai", "lic", "exec", "pc", "iv", "ci", "o", "rc", "ace", "arc", "roc", "c", "oci", "cc", "soc", "ct"]}}
{"id1": "370982", "id2": "153462", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static File copyFileTo(File file, File directory) throws IOException {\n        File newFile = new File(directory, file.getName());\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(file);\n            fos = new FileOutputStream(newFile);\n            byte buff[] = new byte[1024];\n            int val;\n            while ((val = fis.read(buff)) > 0) fos.write(buff, 0, val);\n        } finally {\n            if (fis != null) fis.close();\n            if (fos != null) fos.close();\n        }\n        return newFile;\n    }\n", "label": 1, "substitutes": {"inFile": ["inputfile", "inPlace", "InFiles", "oldfile", "inputFiles", "incPlace", " inPath", "outFilename", "outfile", "inFilename", "outPlace", "outPath", "oldFiles", "inputFilename", "infile", "InFile", "oldFilename", "incfile", "oldFile", "outFiles", "inPath", "incFile", "inFiles", " inFiles", "incFiles", "InPlace", " infile", "inputFile", "Infile", "InPath"], "outFile": [" outTable", "zipFile", " outPlace", "inputFolder", "outTable", "zipString", "newfile", " outString", "newPlace", "OutFile", " outfile", "outputFILE", "outputFilename", "outDir", "zipFilename", "outputFile", "outputFolder", "outFILE", "outFilename", "outputString", " outFolder", " outDir", "outfile", "newDir", "inputPlace", "outPlace", "OutPlace", "Outfile", " outFilename", "outFolder", "OutDir", "newFile", "inputTable", " outFILE", "outString", "inputFile", "outputPlace", "outputTable", "zipFILE"], "iis": [" iIS", " iiss", "Iisc", " iIs", "iniais", "ciis", "iois", "iiIS", "ioIs", "IIs", "iIS", "iniIS", "iiIs", "iid", "iisc", "ioiss", " iais", "Iiss", "ciid", "iiss", "iniIs", "iils", "ciais", "Iis", " iils", "iiils", " iid", "ioisc", "iniis", "iniisc", "iiis", "iniiss", "iniid", "iIs", "ciiss", "iniils", "iais"], "dcmParser": ["dcpJar", " dpmarser", "dcpReader", "dcmLoader", "pdymJar", "dpmarser", "dpmLoader", "dcyJar", "pdcmparser", "dcyReader", "Dcmarser", " dpmPlugin", "dsemPlugin", "dmcarser", "dcmparser", "dsemStreamer", "dcrarser", "dpmStreamer", "dcrParser", "dmoduleParser", "dymReader", "dcrparser", "dsemParser", " dcmStreamer", "dtermStreamer", "dpmparser", "dtermParser", "ddcReader", "dcmBuilder", "dmmWriter", "dymparser", "dmmParser", " dcmPlugin", "dmoduleBuilder", "dcmWriter", "ddcParser", " dpmJar", "dmcParser", "dmodulePlugin", "dpmJar", "pdcmReader", "dpmParser", " dcmReader", " dpmLoader", "DcmReader", "dcyParser", "ddcLoader", "dymParser", "dcyarser", " dpmReader", "pdymparser", "pdymReader", "dpmPlugin", " dcmJar", " dcmPar", "DcmJar", "dtermPlugin", "dcpParser", "dcpparser", " dpmPar", " dcmLoader", "pdcmParser", "dpmPar", " dpmBuilder", "dmcJar", "dmoduleReader", " dpmStreamer", "dpmBuilder", " dcmBuilder", " dcmarser", "dymJar", "dcmStreamer", "dmmReader", "dcrWriter", "dcmPlugin", "dmcPar", "dcmJar", "ddcPlugin", " dpmParser", "Dcmparser", "DcmParser", "dsemReader", "dcmarser", "dcmPar", "dcrPar", "DcmWriter", "pdymParser", "dmmarser", "dcmReader", "dtermReader", "dcrReader", "dpmReader", "pdcmJar", "dcrJar"], "ds": ["ys", "ks", "dc", "ipes", "Ds", "des", "d", "points", "dd", "ils", "ld", "ss", "ws", "gd", "src", "pd", "conn", "cdn", "gs", "client", "ns", "ads", "fd", "ros", "Db", "asi", "data", "iss", "di", "os", "bs", "DS", "tx", "drivers", "sys", "js", "vs", "eps", "sync", "dt", "xs", "plugins", "ins", "dds", "da", "rs", "cs", "Ts", "amps", "dr", "ls", "df", "Os", "ays", "session", "docs", "utils", "db", "details", "parts", "services", "is", "tes", "ts", "nas", "ps", "s", "dat", "uds"], "pdReader": ["wdRead", "pcParser", "dsreader", "pbParser", "pcLoader", "pdreader", "pbReader", "xdreader", "xdWriter", "hdreader", "pdRead", "pcReader", "dsRead", "pdLoader", "hdRead", "pidParser", "pbLoader", "hdWriter", "wdReader", "pdParser", "pidScan", "pcScan", "dsLoader", "pbScan", "pcRead", "pcWriter", "wdLoader", "hdReader", "pidReader", "wdWriter", "pidLoader", "xdReader", "dsWriter", "dsReader", "pdScan", "xdRead"], "out": ["default", "later", "d", "net", "with", "result", "down", "now", "doc", "model", "over", "Out", "call", "writer", "sys", "sync", "name", "dot", "log", "flush", "cli", "temp", "image", "list", "obj", "file", "ssl", "err", "array", "img", "group", "store", "line", "pass", "co", "outer", "io", "conn", "lib", "object", "gen", "to", "OUT", "auto", "class", "child", "exp", "ex", "key", "point", "pool", "cache", "at", "copy", "ext", "page", "parent", "url", "user", "write", "inc", "term", "in", "client", "login", "base", "oder", "sum", "external", "exec", "word", "full", "o", "builder", "manager", "order", "s", "null", "connection", "output", "w", "as", "data", "again", "outs", "inner", "flow", "password", "session", "up", "lock", "db", "code", "device"], "dcmEncParam": ["dcmElParameter", "dcmDecParam", "dpmDecParam", "dcmEngType", "dcmDecParameter", "dcmEnVar", "dcmDecPar", "dcmElVar", "dcmEncType", "dcmElType", "dcmencParam", "dpmEncParam", "dcmEnPar", "dcmEncSm", "dcmEngParam", "dcmEnParam", "dcmElParam", "dcmAccParameter", "dcmDecSm", "dpmEncSm", "dcmencParameter", "dpmDecParameter", "dcmEngVar", "dcmAccParam", "dcmencSm", "dpmEncParameter", "dcmAccSm", "dpmDecSm", "dcmEnParameter", "dcmEncPar", "dcmEncVar", "dcmEncParameter", "dcmEnType", "dcmEngParameter"], "pdWriter": ["hdOutput", "pdContent", "pxContent", "PDOutput", "pxReader", "PDReader", "PDWriter", "PDContent", "pxWriter", "tdReader", "ddWR", "dsWrite", "hdWriter", "pxOutput", "ddWrite", "ddOutput", "hdWrite", "pdOutput", "pdWrite", "hdWR", "pdWR", "tdWriter", "dsOutput", "tdContent", "dsWriter", "tdOutput", "ddWriter", "dsWR"]}}
{"id1": "12289756", "id2": "14120602", "code1": "    public String loadURL(URL url) {\n        String retVal = \"\";\n        try {\n            InputStream inputStream = url.openStream();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            String line = bufferedReader.readLine();\n            retVal += line + \"\\n\";\n            while (line != null) {\n                System.out.println(line);\n                line = bufferedReader.readLine();\n                if (line != null) retVal += line + \"\\n\";\n            }\n            bufferedReader.close();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        } catch (IOException e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        } catch (Exception e) {\n            e.printStackTrace();\n            retVal = e.getMessage();\n        }\n        return retVal;\n    }\n", "code2": "    public void startElement(String uri, String tag, String qName, org.xml.sax.Attributes attributes) throws SAXException {\n        wabclient.Attributes prop = new wabclient.Attributes(attributes);\n        try {\n            if (tag.equals(\"app\")) {\n                if (prop == null) {\n                    System.err.println(\"app without properties\");\n                    return;\n                }\n                String appname = prop.getValue(\"name\", \"\");\n                String lookandfeel = prop.getValue(\"lookandfeel\", \"\");\n                global.setAppName(appname);\n                if (lookandfeel.length() > 0) {\n                    if (lookandfeel.equalsIgnoreCase(\"Windows\")) lookandfeel = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\"; else if (lookandfeel.equalsIgnoreCase(\"Motif\")) lookandfeel = \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\"; else if (lookandfeel.equalsIgnoreCase(\"Mac\")) lookandfeel = \"com.sun.java.swing.plaf.mac.MacLookAndFeel\";\n                    UIManager.setLookAndFeel(lookandfeel);\n                }\n            } else if (tag.equals(\"script\")) {\n                WABClient c = (WABClient) global;\n                c.beginScript();\n                String url = prop.getValue(\"src\");\n                if (url.length() > 0) {\n                    try {\n                        BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                        String buffer;\n                        while (true) {\n                            buffer = r.readLine();\n                            if (buffer == null) break;\n                            c.script += buffer + \"\\n\";\n                        }\n                        r.close();\n                        c.endScript();\n                    } catch (IOException ioe) {\n                        System.err.println(\"[IOError] \" + ioe.getMessage());\n                        System.exit(0);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n        }\n    }\n", "label": 1, "substitutes": {"url": ["source", "host", "page", "user", "connection", "buffer", "xml", "l", "http", "object", "request", "b", "lr", "base", "loader", "f", "r", "resource", "server", "address", "el", "ur", "e", "sl", "job", "string", "path", "image", "rule", "file", "uri", "ssl", "err", "URL", "service", "Url", "www", "proxy", "str", "location"], "inputStream": ["outputStream", "inBuffer", " inputstream", "InputBuffer", "inputstream", "InputStream", "accessStream", "accessStreamer", "inWriter", "inputStreamer", "inputReader", " inputWriter", "outputstream", "outputReader", "Inputstream", "inStream", "InputStreamer", " inputBuffer", "instream", "inputWriter", "InputWriter", "accessstream", "inputBuffer", "InputReader", "accessReader", "outputStreamer"], "bufferedReader": ["bufflatedLine", "buffinedLine", "bufferredWriter", "buffaredStream", "BufferedRunner", "bufferingRunner", "bufferedRunner", "buffaredreader", "BuffedWriter", "muteredWriter", "mutmentedreader", "buffiedWriter", "buffiedreader", "bufferedWriter", "buffedWriter", "muteredReader", "buffmentedreader", "buffedLine", "buffiedReader", "BufferedReader", "BuffledWriter", "buffaredWriter", "buffiedLine", "bufferedStream", "buffinedWriter", "bufferedLine", "mutmentedReader", "muteredStream", "BuffedRunner", "mutmentedStream", "bufferedreader", "mutmentedWriter", "bufferingReader", "BufferedWriter", "BufferedLine", "bufflatedReader", "bufferingWriter", "bufflatedWriter", "buffledStream", " bufferingStream", " bufferingWriter", " bufferedLine", "buffmentedStream", "buffaredReader", "buffedReader", "buffedStream", " bufferedStream", "BuffedReader", "buffmentedReader", "bufflatedreader", "BuffedStream", "bufferredReader", "muteredreader", "buffledreader", "bufferingStream", "buffledWriter", "BuffledReader", " bufferingReader", "Bufferedreader", "buffmentedWriter", "buffedRunner", "BuffledLine", "buffinedStream", "Buffledreader", "bufferredRunner", "bufferingLine", "bufferredStream", "buffledReader", "buffledLine", "buffinedReader", "BufferedStream", " bufferingLine", " bufferedWriter"], "line": ["lines", "l", "definition", "val", "Line", "model", "number", "style", "zip", "email", "strip", "sync", "cl", "log", "sl", "le", "file", "err", "ip", "pass", "continue", "lf", "one", "object", "cell", "row", "inline", "liner", "job", "lin", "str", "page", "none", "link", "write", "pe", "user", "LINE", "column", "base", "no", "raw", "el", "section", "element", "word", "e", "text", "comment", "string", "error", "i", " Line", "entry", "next", "message", "letter", "out", "char", "layer", "data", "response", "non", "content", "lc", "frame", "code", "character", "block", "item", "shell", "unit"], "retVal": ["ftEl", "rtValue", "RetVAL", "replyValue", "altval", "returnValue", "retValid", "replyBu", "returnval", "RETBu", "RETArg", "replyval", "retVAL", "ftVal", "rtBu", "rtValid", "refBu", "refVAL", "replyVal", "RetValue", "altValue", "refVal", "rtVal", "altVal", "retEl", " retval", "RetValid", "retval", "returnVal", " retValue", "retBu", "RetBu", "rtArg", "altBu", "RETVal", " retBu", "retValue", "rtval", "rtEl", "ftValid", "Retval", "replyValid", "rtVAL", "RetVal", "refValue", "retArg", "returnBu", " retArg", " retEl", " retValid", "ftval"]}}
{"id1": "18338913", "id2": "6296285", "code1": "    public static String encodeMD5(String param) throws Exception {\n        MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        digest.update(param.getBytes());\n        byte[] hash = digest.digest();\n        char buf[] = new char[hash.length * 2];\n        for (int i = 0, x = 0; i < hash.length; i++) {\n            buf[x++] = HEX_CHARS[(hash[i] >>> 4) & 0xf];\n            buf[x++] = HEX_CHARS[hash[i] & 0xf];\n        }\n        return String.valueOf(buf);\n    }\n", "code2": "    public static final String digest(String credentials, String algorithm, String encoding) {\n        try {\n            MessageDigest md = (MessageDigest) MessageDigest.getInstance(algorithm).clone();\n            if (encoding == null) {\n                md.update(credentials.getBytes());\n            } else {\n                md.update(credentials.getBytes(encoding));\n            }\n            return (convert(md.digest()));\n        } catch (Exception ex) {\n            tools.util.LogMgr.err(\"Crypto.digest \" + ex.toString());\n            return credentials;\n        }\n    }\n", "label": 1, "substitutes": {"param": ["source", "input", "num", "buffer", "Param", "message", "am", "params", "object", "char", "request", "part", "base", "Parameter", "data", "arm", "ref", "resource", "config", "info", "address", "par", "gram", "name", "password", "text", "instance", "m", "aram", "temp", "string", "image", "meter", "obj", "ram", "array", "crypt", "str", "amp", "p"], "digest": ["Diger", "mdester", "digester", "digests", "mdse", "DigEST", "genest", "mdest", "Digeter", "hedester", " digse", "diger", "hedest", "digse", "digeter", " digge", "generest", " digeter", "genests", "digEST", "dester", "der", "dest", "Digester", "genester", "genested", "generested", "hedEST", "Digested", " digEST", "dested", "generests", "digge", "generester", "Digge", " digester", "mdeter", "Digse", "hedge", "digested", " diger", " digested", "Digests", "Digest"], "hash": ["host", "ash", "h", "id", "url", "memory", "bh", "handle", "ha", "build", "ashes", "b", "char", "row", "base", "data", "hex", "version", "sum", "her", "sh", "box", "match", "dash", "sha", "tag", "kh", "hed", "body", "batch", "log", "length", "wave", "rh", "v", "key", "carry", "index", "string", "count", "image", "cache", "html", "code", "check", "search", "map", "array", "header", "block", "Hash", "total", "hist", "bin", "gh", "dig", "filter", "square"], "buf": ["utf", "cb", "tmp", "queue", "bh", "uc", "buffer", "buff", "cf", "br", "Buffer", "output", "src", "cas", "home", "b", "aux", "bc", "val", "char", "base", "loc", "cv", "data", "blocks", "ctx", "box", "pad", "cur", "func", "batch", "brace", "bb", "text", "seq", "uf", "cap", "bag", "v", "temp", "abs", "carry", "pool", "cache", "ab", " buffer", "vec", "comb", "map", "fb", "array", "header", "block", "wb", "conv", "ff", "rb", "fab"], "i": ["next", "page", "h", "id", "si", "qi", "hi", "io", "k", "l", "y", "in", "b", "f", "data", "di", "bi", "r", "zi", "I", "ti", "ji", "ai", "oi", "gi", "info", "ix", "it", "ui", "u", "o", "ci", "e", "length", "t", "ini", "m", "li", "v", "xi", "index", "ri", "j", "c", "uri", "ii", "code", "pi", "is", "start", "z", "p", "ie"], "x": ["px", "xf", "h", "rx", "yx", "rex", "ux", "wx", "xt", "y", "xe", "w", "sw", "xy", "f", "hex", "xc", "ctx", "xes", "tx", "X", "xa", "sex", "xx", "xs", "ix", "ax", "ex", "xxx", "xi", "v", "index", "xb", "xxxx", "dx", "width", "xp", "ww", "lex", "z", "fx"]}}
{"id1": "11129960", "id2": "19846242", "code1": "    public static String getGoGl(final String urlPath, String key) {\n        log.debug(\"getGoGl url \" + urlPath);\n        log.debug(\"getGoGl key \" + key);\n        String shortUrl = null;\n        URL simpleURL = null;\n        HttpsURLConnection url = null;\n        BufferedInputStream bStream = null;\n        StringBuffer resultString = new StringBuffer(\"\");\n        String inputString = \"{\\\"longUrl\\\":\\\"\" + urlPath + \"\\\"}\";\n        log.debug(\"getGoGl inputString \" + inputString);\n        try {\n            simpleURL = new URL(\"https://www.googleapis.com/urlshortener/v1/url?key=\" + key);\n            url = (HttpsURLConnection) simpleURL.openConnection();\n            url.setDoOutput(true);\n            url.setRequestProperty(\"content-type\", \"application/json\");\n            PrintWriter pw = new PrintWriter(url.getOutputStream());\n            pw.print(inputString);\n            pw.close();\n        } catch (Exception ex) {\n            log.error(ex);\n            shortUrl = urlPath;\n        }\n        try {\n            bStream = new BufferedInputStream(url.getInputStream());\n            int i;\n            while ((i = bStream.read()) >= 0) {\n                resultString.append((char) i);\n            }\n        } catch (Exception ex) {\n            SocialUtils.log.error(ex);\n            shortUrl = urlPath;\n        }\n        return shortUrl;\n    }\n", "code2": "    public I18N(JApplet applet) {\n        if (prop != null) return;\n        String lang = \"en\";\n        try {\n            Properties userProperties = new Properties();\n            if (applet != null) {\n                URL url = new URL(applet.getCodeBase() + \"logicsim.cfg\");\n                userProperties.load(url.openStream());\n            } else {\n                userProperties.load(new FileInputStream(\"logicsim.cfg\"));\n            }\n            if (userProperties.containsKey(\"language\")) lang = userProperties.getProperty(\"language\");\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        prop = new Properties();\n        try {\n            if (applet != null) {\n                URL url = new URL(applet.getCodeBase() + \"languages/\" + lang + \".txt\");\n                prop.load(url.openStream());\n            } else {\n                prop.load(new FileInputStream(\"languages/\" + lang + \".txt\"));\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            try {\n                if (applet != null) {\n                    URL url = new URL(applet.getCodeBase() + \"languages/en.txt\");\n                    prop.load(url.openStream());\n                } else {\n                    prop.load(new FileInputStream(\"languages/en.txt\"));\n                }\n            } catch (Exception ex2) {\n                JOptionPane.showMessageDialog(null, \"Language file languages/en.txt not found.\\nPlease run the program from its directory.\");\n                System.exit(5);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"urlPath": [" urlContext", "blogInfo", "UrlString", "resourceFull", "urlUrl", "URLCry", "uriPoint", "urlPart", " urlPATH", " urlUrl", "Urlpath", " urlString", "workInfo", "shortCry", "emailUrl", "urlPATH", "urlpath", "shortpath", "UrlContext", " urlInfo", "URLPoint", "uriLocation", " urlPoint", "uriPath", " urlpath", "resourceContext", "workPath", "blogPATH", "urlLocation", "URLPart", "URLInfo", "shortPart", "emailpath", "resourceUrl", "URLpath", "shortPath", "workPATH", " urlLocation", "URLLocation", "urlInfo", "urlCry", " urlCry", "URLPath", " urlFull", "urlString", "emailPath", "blogPath", "UrlPath", "urlFull", "resourcePath", "emailFull", "urlPoint", "uriInfo", "resourcepath", " urlPart", "resourceString", "urlContext"], "key": ["page", "parent", "value", "id", "hash", "link", "my", "token", "year", "right", "keys", "k", "ry", "sign", "y", "license", "part", "mode", "base", "row", "by", "phrase", "Key", "mac", "enc", "resource", "ie", "KEY", "where", "name", "query", "ace", "json", "password", "text", "ey", "time", "index", "string", "path", "list", "cert", "cache", "lock", "ssl", "error", "code", "date", "secret", "service", "lease", "is", "kw", "order", "which", "kid", "reason", "str", "ip", "type"], "shortUrl": ["rightLine", "privateLink", "privateURL", "longPage", "actUrl", "actPage", "nextPath", "rightURL", "longURL", " shortLine", "longLink", "rightLink", "ShortUrl", " shortURL", " shortLink", "rawURL", " shortPage", "longUr", "nextURL", "ShortPath", "actURL", "shortEmail", "shortLink", "longUrl", "nextUr", "longPath", "shortURL", "ShortLine", "shortPath", "actEmail", "rawUr", "nextUrl", "shortLine", "rawUrl", "ShortLink", "rawPath", "ShortURL", "privateUrl", "privatePath", " shortEmail", "shortUr", "rightUrl", "shortPage", "longEmail"], "simpleURL": ["easyBB", " simpleFile", "prettyUrl", "SimpleURL", "simpleUrl", "SimpleURI", "simpleHTTP", "SimpleBB", "prettyGR", "prettyURL", "easyHTTP", "SimpleHTTP", " simpleSSL", "simpleURI", "simpleBB", "SimpleSSL", "basicURI", "SimpleUrl", "simpleFile", "basicURL", "easyURL", " simpleBB", "prettyHTTP", " simpleUrl", "simpleSSL", "simpleGR", "easyUrl", "SimpleGR", "basicFile", " simpleURI", "easySSL", "easyGR", "SimpleFile", "basicUrl"], "url": ["rel", " impl", "now", "l", "channel", "resource", "call", "address", "sync", "bb", "log", "cl", "image", "impl", "file", "ssl", "web", "ll", "location", "id", "feed", "xml", "build", "ul", "object", "b", "ver", "update", "ob", "atom", "job", "html", "URL", "Url", "www", "str", "source", "page", "user", "link", "browser", " server", " curl", "http", " library", "client", "base", "f", "https", "git", "loc", " factory", "org", "server", "el", " config", "string", "path", "date", " internet", " http", "use", "host", "connection", "pull", "out", "lr", "layer", "config", " timeout", "api", "bel", "fl", "li", "socket", "uri", "proxy", "blog", "both", " protocol", "coll", "sl"], "bStream": ["brThread", "lStream", "fbstream", "iStream", " bThread", "lWriter", "bbStream", "lbWriter", "iString", "lSteam", "iPath", "bstream", " bStack", "pPath", "pStream", "fbWriter", " bMode", "bbThread", "bbStack", "brSteam", "bbSteam", "bMode", "bPath", " bSteam", "iMode", "bSteam", "lbSteam", "bThread", "lbstream", "bString", "brStack", "fbStream", "bStack", "brStream", " bString", "lstream", "fbSteam", "pMode", "lbStream", "bWriter", " bPath", "pString"], "resultString": ["returnString", "outputStream", " resultLine", " resultArray", "resultsString", "answerString", "resultLine", "returnArray", "answerLine", "ResultStr", "returnStream", "outputBuffer", "resultsStream", " resultStr", "resultsArray", "resultBuffer", "outputString", "answerStr", "resultStr", "resultArray", "ResultLine", "ResultString", "resultsBuffer", "resultStream", "ResultArray", "outputArray", "answerArray", "returnBuffer"], "inputString": ["resultData", "inputPath", "outputStream", "InputStr", " inputArray", "requestStream", "submitString", "requeststring", "InputStream", "InputPath", " inputPath", "outputString", " inputstring", " inputData", " inputStr", "submitPath", "resultStr", "inputData", "resultstring", "outputData", "inputArray", "resultArray", "submitstring", "requestString", "inputstring", " inputStream", "resultStream", "Inputstring", "InputString", "outputArray", "inputStr", "requestArray", "submitStream", "inputStream", "InputArray"], "pw": ["psW", " pwb", "pswa", " pwr", "Pwa", "pwr", "ptw", " pW", "pwb", "lpW", "apwa", "lpwr", "apW", "fw", "pW", "PW", "pwa", "frw", "Prw", "prw", "Pw", "fW", "Pwb", "lpw", "apwb", "apw", "fwa", " ptw", "psw", "Ptw", "psrw", "Pwr", " pwa", "lptw"], "i": ["id", "d", "si", "qi", "multi", "phi", "io", "k", "limit", "l", "b", "f", "di", "n", "zi", "bi", "I", "mu", "oi", "ji", "ai", "info", "r", "gi", "x", "ui", "ci", "u", "e", "length", "t", "ini", "a", "m", "li", "v", "xi", "index", "ri", "count", "j", "c", "ii", "pi", "is", "chi", "z", "line", "ip", "p", "ie"]}}
{"id1": "17847880", "id2": "12764800", "code1": "    public static boolean saveToTempFile(Context context, String filePath, DirType dirType, String tempSavePath, boolean secrete) {\n        FileOutputStream fos = null;\n        InputStream in = null;\n        byte[] buffer = new byte[1024];\n        int readLength = 0;\n        boolean result = false;\n        try {\n            try {\n                File f = new File(context.getFilesDir().getAbsolutePath() + File.separator + tempSavePath);\n                if (f.exists()) {\n                    context.deleteFile(tempSavePath);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            fos = context.openFileOutput(tempSavePath, Context.MODE_WORLD_READABLE);\n            logger.error(\"tempfile:\" + tempSavePath);\n            if (dirType == DirType.assets) {\n                AssetManager assetManager = context.getAssets();\n                in = assetManager.open(filePath);\n            } else if (dirType == DirType.file && Constant.getUpdateDataPath() != null) {\n                in = new FileInputStream(Constant.getUpdateDataPath() + File.separator + filePath);\n            } else if (dirType == DirType.sd && Constant.getSdPath() != null) {\n                in = new FileInputStream(Constant.getSdPath() + File.separator + filePath);\n            } else if (dirType == DirType.extSd && Constant.getExtSdPath() != null) {\n                in = new FileInputStream(Constant.getExtSdPath() + File.separator + filePath);\n            }\n            if (in == null) {\n                return false;\n            }\n            readLength = in.read(buffer);\n            if (readLength >= ZipToFile.encrypLength && secrete) {\n                byte[] encrypByte = new byte[ZipToFile.encrypLength];\n                System.arraycopy(buffer, 0, encrypByte, 0, ZipToFile.encrypLength);\n                byte[] temp = CryptionControl.getInstance().decryptECB(encrypByte, ZipToFile.rootKey);\n                System.arraycopy(temp, 0, buffer, 0, ZipToFile.encrypLength);\n            }\n            while (readLength > 0) {\n                fos.write(buffer, 0, readLength);\n                fos.flush();\n                readLength = in.read(buffer);\n            }\n            result = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (fos != null) {\n                try {\n                    fos.flush();\n                    fos.close();\n                } catch (Exception e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public static void extractZipFile(String filename) {\n        try {\n            byte[] buf = new byte[1024];\n            ZipInputStream zipinputstream = null;\n            ZipEntry zipentry;\n            zipinputstream = new ZipInputStream(new FileInputStream(filename));\n            zipentry = zipinputstream.getNextEntry();\n            while (zipentry != null) {\n                String entryName = zipentry.getName();\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(entryName);\n                String directory = newFile.getParent();\n                if (directory == null) {\n                    if (newFile.isDirectory()) break;\n                }\n                fileoutputstream = new FileOutputStream(entryName);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n                zipentry = zipinputstream.getNextEntry();\n            }\n            zipinputstream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"context": ["options", "source", "folder", "parent", "foundation", "reader", "translation", "input", "queue", "connection", "cf", "settings", "function", "view", "cas", "request", "client", "driver", "bc", "environment", "base", "application", "loader", "version", "stream", "storage", "system", "ctx", "resource", "contact", "config", "tx", "component", "event", "rc", "container", "tc", "kernel", "instance", "text", "path", "document", "cache", "c", "command", "support", "Context", "manager", "service", "database", "current", "ce", "self", "cms", "project", "stack", "concept"], "filePath": ["fileStream", "inputPath", "inputId", "linepath", "basePath", "FilePath", " fileStream", "modelBody", "FILEBody", " fileName", "filepath", " fileType", "singleLocation", "fileType", "saveLocation", " filepath", "lineLoc", "FileId", "fileCh", "fileName", "FILEType", "FileType", " fileLoc", "FILELoc", "singleStream", "singlePath", "modelpath", "savePath", "modelCh", "fileLoc", "fileBody", "basepath", "fileId", "baseBody", "saveStream", "linePath", "resourceName", " fileLocation", "resourceType", "FileName", "FILEpath", "FILEPath", "FILECh", "Filepath", "lineType", "savepath", "FileStream", "resourcePath", "fileLocation", "inputpath", "resourcepath", "modelPath", "baseCh", "singlepath", "inputStream", " fileId"], "dirType": ["fileStyle", "entryTypes", "entryType", "directoryTypes", "dirtype", "libTyp", " dirBase", "directoryTyp", "DIRPath", "directorytype", "directorType", "fileBase", "fileType", "directortype", "dirTitle", "DirTitle", "libType", "fileTyp", "directorTitle", "directoryStyle", "libtype", "DirType", "directionTyp", "DIRStyle", "dirTypes", " dirTypes", "dirTyp", " dirTyp", "dirPath", "Dirtype", "entryTyp", "directoryPath", " dirStyle", "DirPath", "directoryTYPE", "directionType", "DirTyp", "directorTyp", "dirBase", "dirTYPE", "DIRType", " dirTYPE", "fileTYPE", "libTitle", "DirStyle", "DIRtype", "fileTypes", "directionStyle", "entryTYPE", "directionBase", "directoryType", "dirStyle"], "tempSavePath": ["TempFileDir", "tempStorePart", "TempSaveDir", "tempSetDir", "tempSetpath", "tempSetPath", "fakeStoreType", "tempSaveLocation", "currentsavePoint", "TempSaveLocation", "tempFilePath", "tempStoreHome", "tempsaveCase", "currentsaveCase", " tempSetDir", "TempSavePoint", "tempFileFile", "fakeSavePath", "currentSaveFile", "TempFilePath", "tempSaveType", "tempStoreType", "TempSaveUrl", "tempSaveHome", "currentSavePath", "tempSaveCase", "tempCopyPoint", "tempFileCase", "fakeSaveHome", "tempApplyCase", "tempImportUrl", "tempApplyPoint", "currentsaveFile", "tempWriteLocation", "tempCopyLocation", "tempClosePath", "tempApplyFile", "tempSaveName", "tempsaveFile", "tempCloseHome", "tempWritePath", "tempFileLocation", "tempFileDir", "TempFilePoint", "tempCreatepath", "tempWritePoint", "tempStorePath", "fakeSavePart", "tempImportType", "tempCopyUrl", "tempCopyPath", "tempSaveFile", "fakeStorePart", "tempSaveUrl", "TempFileLocation", "tempSavePoint", "tempCloseType", "tempFilePoint", " tempSaveDir", "tempApplyPath", "tempFileUrl", "tempsavePath", " tempSetpath", "tempImportPath", " tempSetPath", " tempSetName", "TempFileUrl", "tempsavePoint", "tempImportPoint", " tempSaveName", "tempSavePart", "tempSavepath", " tempSavepath", "tempImportHome", "tempCreateName", "tempClosePart", "tempCreatePath", "currentsavePath", "tempImportpath", "tempImportName", "tempSetName", "fakeSaveType", "tempWriteDir", "fakeStoreHome", "tempImportDir", "TempSavePath", "currentSavePoint", "tempImportLocation", "fakeStorePath", "tempImportPart", "tempCreateDir", "tempSaveDir", "currentSaveCase"], "secrete": ["sicrete", "secstract", "discrete", "siccrete", "secourage", "SECcrete", "SECurate", "discourage", "sicstract", "SECstract", "seccrete", "disccrete", "sicourage", "securitystract", "sicuous", "secidental", "SECidental", "securityrete", "discurate", "secuous", "sicidental", "securate", "sicurate", "SECourage", "securityuous", "SECuous", "SECrete", "securityidental"], "fos": ["sfos", "Fops", "infOS", " fops", " fOS", "Fos", "fops", "infos", "fios", "sfis", " fis", " fios", " faos", "Faos", "Fis", "FOS", "fOS", "faos", "sfios", "fis", "infios", "Fios", "sfops", "infaos"], "in": ["source", "get", "read", "reader", "url", "input", "inc", "din", "binary", "token", "connection", "with", "min", "io", "nin", "conn", "con", "out", "this", "b", "diff", "part", "login", "as", "data", "In", "pin", "again", "include", "into", "re", "thin", "resource", "serv", "config", "isin", "exec", "init", "ins", "vin", "cl", "gin", "ini", "m", "cli", "session", "cin", "image", "impl", "socket", "ssl", "file", "i", "IN", "err", "or", "inn", "ar", "lin", "bin", "ac"], "buffer": ["source", "read", "reader", "url", "queue", "memory", "binary", "input", "reference", "buff", "iter", "Buffer", "message", "output", "limit", "audio", "request", "b", "bc", "base", "data", "table", "phrase", "bytes", "response", "available", "resource", "server", "address", "writer", "info", "uffer", "transfer", "batch", "length", "flush", "text", "wave", "initial", "buf", "offset", "slice", "document", "seed", "cache", "header", "block", "texture", "position", "bin", "stack", "copy"], "readLength": ["writeDuration", "loadlength", "writePath", "loadWidth", "readLen", "ReadDuration", "Readlength", " readDuration", "readWidth", "ReadLength", "writeLength", " readWidth", "loadLength", "loadLen", "readDuration", "writeWidth", "ReadPath", "readlength", " readLen", " readPath", "readPath", "writelength", " readlength", "writeLen"], "f": ["af", "folder", "h", "rf", "feed", "cf", "function", "io", "fo", "l", "fc", "fs", "w", "fp", "b", "sf", "fd", "fr", "fe", "n", "fac", "handler", "info", "conf", "aff", "e", "fn", "F", "m", "df", "v", "j", "c", "file", "i", "raf", "g", "fm", "fed", "s", "fa", "p", "fx"], "assetManager": ["assAssetManager", "assAssetmanager", "AssetsManagement", "assetteDirector", "AssetsManager", "AssetMan", "assetMan", "AssetsDirector", "asseticMan", "assetManagement", "assetteManager", "assAssetDirector", "asseticDirector", "assAssetManagement", "assetteManagement", "assettemanager", "Assetmanager", "AssetDirector", "AssetManager", "assetsmanager", "assetsDirector", "AssetManagement", "assetmanager", "assetsMan", "Assetsmanager", "assetsManager", "assetsManagement", "AssetsMan", "assetDirector", "assAssetMan", "asseticManager", "asseticmanager"], "encrypByte": ["encrybChar", "encryfByte", "encriperChar", "encrybByte", "encripBit", "encrypeBit", "encryfBytes", "encrypeByte", "encrifBit", "encrifBytes", "encrifByte", "encrypeChar", "encrypeWord", "enccypByte", "enccyperByte", "encriperBit", "encryfBit", "encripChar", "enccypBytes", "enccyperChar", "enccypChar", "encripBytes", "encrifWord", "encriperByte", "encrypaByte", "enccypWord", "encryperChar", "encryperBytes", "encrypChar", "encrypeBytes", "encrybWord", "encrypBit", "encrypaBit", "encripByte", "encripWord", "encryperBit", "encrypBytes", "encrybBit", "encriperWord", "encrypWord", "encryperByte", "encryperWord", "encryfChar", "enccyperBytes", "encrypaWord", "encryfWord", "enccyperWord", "encrypaChar"], "temp": ["get", "div", "tmp", "export", "txt", "safe", "porary", "iter", "extra", "flat", "pre", "fake", "stable", "pack", "ctrl", "hex", "tem", "storage", "clean", "enc", "wrap", "Temp", "init", "full", "cel", "tc", "api", "partial", "ex", "lc", "col", "cache", "emp", "local", "wait", "unsigned", "current", "img", "empty", "test", "mini"], "result": ["successful", "default", "success", "Result", "complete", "expected", "output", "out", "include", "data", "response", "r", "match", "resource", "ret", "full", "results", "rc", "found", "content", "status", "lock", "load", "accept", "res", "exit"]}}
{"id1": "10460548", "id2": "22674018", "code1": "    public void parse() {\n        InputSource urlInputStream = null;\n        SAXParserFactory spf = null;\n        SAXParser sp = null;\n        HttpURLConnection conn = null;\n        try {\n            URL url = new URL(this.urlString);\n            _setProxy();\n            conn = (HttpURLConnection) url.openConnection();\n            urlInputStream = new InputSource(StreamUtils.inputStreamToReader(conn.getInputStream()));\n            spf = SAXParserFactory.newInstance();\n            if (spf != null) {\n                sp = spf.newSAXParser();\n                sp.parse(urlInputStream, this);\n            }\n        } catch (Exception e) {\n            if (conn != null) {\n                if (conn.getHeaderField(\"X-RateLimit-Limit\") != null) {\n                    String rateLimit = conn.getHeaderField(\"X-RateLimit-Limit\");\n                    String rateRemaining = conn.getHeaderField(\"X-RateLimit-Remaining\");\n                    long rateReset = Long.valueOf(conn.getHeaderField(\"X-RateLimit-Reset\")) * 1000;\n                    LOG.warn(\"Possible rate limits?  LIMIT:\" + rateLimit + \"  REMAINING:\" + rateRemaining + \"  RESET:\" + new Date(rateReset));\n                }\n            }\n            e.printStackTrace();\n            LOG.warn(\"error parsing rss feed\", e);\n        } finally {\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = Log4jImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 0, "substitutes": {"urlInputStream": ["urlInstream", "httpInputStream", "urlInSteam", "urlInStream", "urlSourceString", "urlInputSteam", "URLInstream", "urlImportSource", "urlOutputSteam", " urlInputReader", "urlImportString", "urlImportReader", "urlInputReader", "URLInputInterface", "httpOutputReader", "URLInputStream", " urlUpstream", "urlImportStream", "urlReadSource", "urlOutputstream", "urlContentSource", "httpInputReader", "urlReadReader", "urlOutputInterface", "urlUpstream", "urlOutputReader", "URLInputstream", "urlOutputStream", "urlSubInterface", "urlInputString", "urlOutputSource", " urlUpStream", "urlSubStream", " urlUpReader", "urlSourceReader", "urlOutputString", "urlUpReader", "URLInInterface", "urlSourceSource", "urlSourceStream", "URLInStream", "URLInputSteam", "urlReadstream", "urlUpStream", "urlReadStream", "urlInputInterface", "urlInputstream", " urlUpSource", "urlInInterface", "httpOutputStream", " urlInputSource", "httpOutputSource", "httpInputString", "urlContentstream", "httpOutputString", "urlSubSteam", "urlUpSource", "urlContentReader", "urlContentStream", "URLInSteam", " urlInputstream", "httpInputSource", "urlInputSource", "urlSubstream"], "spf": ["Spfx", "psF", "pF", "psf", " spfi", "pf", "psfx", "srfi", "spF", "ypfi", "srf", "spff", "prF", "SPfx", "ypfs", "prfs", "spfx", "ypf", "srfs", "ypfac", " spff", "spfs", "SpF", " spfx", "pfs", " spF", "psfs", "SPfs", "spfi", "Spfs", "prff", "SPF", "Spf", "prf", "SPf", "pff", " spfac", " spfs", "spfac", "srfac"], "sp": ["lp", "py", "pe", "si", "space", "spl", "jp", "sw", "pg", "sf", "f", "isp", "p", "sc", "sh", "serv", "par", "wp", "pc", "sch", "Sp", "sup", "tp", "hp", "mp", "gp", "spec", "ph", "parser", "sl", "pr", "span", "esp", "se", "pt", "pm", "sk", "SP", "parse", "ssl", "pp", "asp", "ps", "pl", "so", "bp"], "conn": ["host", "dc", "cb", "connection", "cm", "auth", "open", "uc", "cf", "core", "co", "ct", "con", "client", "Conn", "loc", "po", "ec", "cp", "rn", "n", "oa", "enc", "ctx", "org", "server", "pub", "ai", "dn", "mc", "adj", "pc", "cn", "conf", "exec", "sync", "oss", "ci", "rc", "nt", "act", "log", "gn", "api", "stat", "ch", "cli", "lc", "ann", "session", "sec", "col", "cr", "connect", "cert", "c", "ssl", "socket", "db", "err", "resp", "fail", "error", "reg", "conv", "cc", "Connection", "ca", "nc", "coll"], "url": ["host", "page", "feed", "connection", "uc", "ll", "l", "http", "b", "lr", "fr", "base", "loc", "zip", "resource", "org", "server", "ur", "gl", "bb", "ob", "log", "cl", "fl", "ls", "path", "rl", "impl", "ssl", "uri", "fb", "URL", "Url", "www", "blog", "proxy", "web", "sl"], "rateLimit": ["RateLimited", "ratingLim", "RateLim", "ratingLock", "RateLock", " ratePool", "rateLim", "ratePool", " rateLim", "rateLock", "ratingLimited", "RateLimit", " rateLock", "RatePool", "rateLimited", "ratingLimit", " rateLimited", "ratingPool"], "rateRemaining": [" rateRemining", " rateResained", " rateRemained", " rateResining", "rateReminding", "ratereminding", " rateResaining", " rateReminding", "rateremaining", "rateResining", "rateMining", "rateMain", "rateResaining", "rateMaining", "rateMained", "rateremain", "rateRemained", " rateResain", "rateResinding", "rateremained", " rateResinding", "rateResain", "rateRemain", "rateResained", " rateRemain", "rateremining", "rateRemining"], "rateReset": ["rateRepume", "ratePresume", "rateRewait", "rateExerved", " rateExait", "rateRewet", "rateExet", "ratePresend", "rateResize", "rateResend", "ratePresize", " rateResume", "ratePreset", " rateExerved", "rateExait", "rateRemet", "rateRemend", "rateResume", " rateExend", " rateReserved", "rateReperved", " rateResend", "rateRepait", "rateExize", "rateRewerved", " rateResait", "rateExume", " rateExize", "rateReserved", "rateResait", "rateExend", "rateRepet", " rateExet", "rateRemize", " rateResize", "rateRemume", "rateRewume", " rateExume"]}}
{"id1": "19631892", "id2": "16301512", "code1": "    public static void copyFiles(File src, File dest) throws IOException {\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            for (String f : src.list()) {\n                String df = dest.getPath() + File.separator + f;\n                String sf = src.getPath() + File.separator + f;\n                copyFiles(new File(sf), new File(df));\n            }\n        } else {\n            FileInputStream fin = new FileInputStream(src);\n            FileOutputStream fout = new FileOutputStream(dest);\n            int c;\n            while ((c = fin.read()) >= 0) fout.write(c);\n            fin.close();\n            fout.close();\n        }\n    }\n", "code2": "    public static void copy(File src, File dst) throws IOException {\n        FileChannel inChannel;\n        FileChannel outChannel;\n        inChannel = new FileInputStream(src).getChannel();\n        outChannel = new FileOutputStream(dst).getChannel();\n        outChannel.transferFrom(inChannel, 0, inChannel.size());\n        inChannel.close();\n        outChannel.close();\n    }\n", "label": 1, "substitutes": {"src": ["source", "resources", "sel", "RC", "sb", "tmp", "url", "input", "req", "txt", "upload", "sit", "origin", "http", "in", "inf", "b", "Source", "st", "supp", "loc", "ruby", "stream", "storage", "resource", "sc", "rob", "archive", "config", "ources", "sub", "cur", "sup", "filename", "init", "ins", "rc", "inst", "spec", "sr", "ource", "sin", "SOURCE", "slice", "scripts", "thumbnails", "obj", "secure", "ssl", "seed", "support", "files", "sq", "dist", "start", "img", "project", "s", "rb", "rest", "sl"], "dest": ["source", "folder", "parent", "route", "die", "dc", "tmp", "export", "trans", "later", "d", "txt", "upload", "dep", "result", "flat", "wd", "cdn", "out", "both", "home", "st", " destination", "delete", "loc", "thin", " Dest", "du", "sup", "desc", "transfer", "dir", "target", "de", "cont", "transform", "Dest", "temp", "done", "orig", "file", "comb", "wb", "front", "dist", "destroy", "project", "store", "rest"], "f": ["xf", "h", "rf", "d", "feed", "cf", "l", "fs", "fp", "b", "fd", "fr", "tf", "fe", "ref", "n", "x", "fun", "name", "e", "fn", "t", "F", "m", "fold", "v", "string", "file", "i", "fen", "field", "s", "fa", "p", "fx"], "df": ["dl", "dq", "xf", "isf", "dc", "rf", "cd", "bf", "d", "lf", "dd", "cf", "fore", "fs", "out", "fp", "elf", "fd", "fr", "tf", "def", "fe", "di", "dn", "der", "du", "dir", "dm", "deb", "uf", "dr", "dim", "file", "db", "raf", "dist", "ds", "ff", "sd", "fa", "DF", "fx"], "sf": ["dl", "xf", "isf", "su", "sb", "rf", "suff", "bf", "si", "ulp", "feed", "lf", "cf", "ss", "fs", "fp", "inf", "fd", "elf", "tf", "fe", "tif", "sh", "sup", "vp", "fn", "SF", "sv", "sp", "file", "db", "fb", "sq", "dist", "ds", "fm", "ff", "sd", "s", "sl", "fx"], "fin": ["su", "die", "rf", "cb", "trans", "Fin", "fine", "conn", "fs", "fp", "in", "fd", "fr", "pin", "thin", "fat", "off", "init", "rc", "per", "FIN", "non", "fn", "spec", "rb", "ini", "nir", "kin", "done", "close", "fit", "before", "ori", "prev", "raf", "fb", "inn", "fen", "rin", "fi", "lin", "inv", "fa"], "fout": ["FOut", "fsync", "fOUT", "fdsync", "ufOUT", " fagain", "fOut", "fenoff", " fOut", "ffOUT", "fdOut", "ffoff", "ffout", "ufout", " foff", "fdinit", "Fsync", "Finit", " finit", "fileoff", "fileout", " fsync", " fwrite", "fenout", "fagain", "filenet", " fOUT", " fnet", "ufwrite", "fenagain", "fennet", "foff", "fdout", "fileagain", "ufoff", "fwrite", "finit", "Fout", "ffwrite", "fnet"], "c": ["dec", "dc", "cb", "cd", "d", "uc", "cy", "cu", "cf", "k", "fc", "l", "char", "bc", "p", "ec", "oc", "n", "r", "enc", "xc", "ac", "pc", "x", "exec", "ci", "rc", "e", "u", "o", "esc", "cl", "arc", "t", "ch", "m", "lc", "abc", "col", "cr", "pointer", "i", "character", "ce", "cc", "ct", "nc", "ic", "C"]}}
{"id1": "17815062", "id2": "3286240", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"text": ["source", "contract", "value", "test", "input", "url", "TEXT", "txt", "token", "buffer", " TEXT", "message", "format", "letter", "object", "this", "in", "Text", "number", "data", "hex", "bytes", "class", "editor", "config", "template", "name", "pattern", "password", "length", "content", "key", "string", "path", "image", "font", "code", "context", "struct", "secret", " Text", "str", "ext"], "md": ["hash", "cd", "bf", "d", "mb", "dig", "dd", "ld", "hd", "message", "mm", "ma", "pd", " MD", "gd", "wd", "am", "pg", "cmd", "ms", "mode", "bm", "data", "mac", "mo", "bd", "di", "match", "mand", "mag", "meta", "mc", "sha", "method", "mp", "bb", "dm", "mod", "dh", "MD", "mt", "m", "df", "own", "od", "pm", "mg", "code", "manager", "valid", "Cmd", "metadata", "amd", "nm", "me", "ad", "pkg"], "md5hash": ["MD5sum", "md4sum", "MD5hash", " md2sum", "mdblockHash", "md5sum", "md4ash", "md4hash", "MD2hash", "md5hex", "md2sum", "md2hash", " md5sh", " md2hex", "mddownHash", " md5hex", "md3Hash", " md2hash", "MD2Hash", "md3hash", "MD5ash", " md2sh", " md5url", "md2ash", "md5url", " md5sum", "md4sh", "md2Hash", "MD5Hash", "mdblockurl", "mddownhash", "md3sum", "mddownsum", "MD2ash", "md0hex", "mdblockhex", " md2Hash", "md2url", "mddownsh", "md5ash", "md0url", " md5Hash", "md5sh", "md2sh", " md2url", "md0hash", "md3ash", "md2hex", "mdblockhash", "md5Hash", "md4Hash", "MD2sum", "md0Hash"]}}
{"id1": "789253", "id2": "10195648", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        int readBytes;\n        while ((readBytes = fis.read(b)) > 0) fos.write(b, 0, readBytes);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    public static void main(String[] args) {\n        if (args.length != 3) {\n            System.out.println(\"Usage: HexStrToBin enc/dec <infileName> <outfilename>\");\n            System.exit(1);\n        }\n        try {\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            InputStream in = new FileInputStream(args[1]);\n            int len = 0;\n            byte buf[] = new byte[1024];\n            while ((len = in.read(buf)) > 0) os.write(buf, 0, len);\n            in.close();\n            os.close();\n            byte[] data = null;\n            if (args[0].equals(\"dec\")) data = decode(os.toString()); else {\n                String strData = encode(os.toByteArray());\n                data = strData.getBytes();\n            }\n            FileOutputStream fos = new FileOutputStream(args[2]);\n            fos.write(data);\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"src": ["source", "sel", "RC", "sb", "id", "url", "txt", "upload", "sit", "loc", "href", "ruby", "stream", "remote", "resource", "sc", "archive", "config", "sub", "cur", "sup", "filename", "name", "desc", "sync", "rc", "inst", "rs", "text", "ource", "gb", "sin", "string", "path", "image", "seed", "secure", "uri", "code", "ssl", "file", "files", "dist", "img", "project", "s", "rb"], "dest": ["source", "folder", "die", "tmp", "later", "default", "d", "txt", "build", "buff", "dev", "output", "flat", "wd", "home", "end", " destination", "const", "delete", "loc", "prop", "tern", "du", " Dest", "desc", "dir", "target", "feat", "text", "Dest", "temp", "orig", "file", "them", "comb", "replace", "wb", "opt", "dist", "img", "destroy", "bin", "test", "dat"], "ifp": ["Ifpr", "itf", "lfps", "dfb", "dfp", "ibcp", "Ifb", "Ifcp", "Ifop", "ifps", "iwpr", "lfcp", "Ifpe", "iwp", "dfcp", "ibp", "ifP", "itpr", "ibpe", "Ifp", "IfP", "Ifps", "ifb", "iwf", "ifpe", "ifcp", "ifpr", "dfpe", "ofcp", "ibb", "lfp", "ofps", "ifop", "Iff", "iwP", "itP", "lfop", "iff", "itp", "ofop"], "ofp": [" ofapi", "Ofpi", "OFc", "odP", "OFp", "Ofp", "otherps", "otherP", " ofc", "ofpi", "ippp", "othersp", "ippsp", "ofsp", "OFapi", "ippps", "odps", " ofpi", "odp", "ippP", "odsp", "Ofc", "OFpi", "ofc", "ofps", "otherp", "Ofapi", "ofP", "ofapi"], "fis": ["ifiss", "cfits", "ifois", "fois", " fops", "Fiss", "ifais", "fiss", "fais", "afais", "fops", "afos", "afis", "afops", " fois", "Fis", "cfos", " fits", "fits", "Fois", "cfops", "ifis", "ifos", " fais", "cfis", "ifops", " fiss", "ifits", "Fais"], "fos": ["Foes", "bas", " fros", "los", " foses", "ifas", " foes", "ifOS", " fOS", "bros", "fros", "Fos", "bos", "boses", "Fis", "loes", " fas", "fOS", "lis", "foses", "ifis", "ifos", "ifoes", "ifros", "Foses", "lOS", "bis", "foes", "fas", "boes"], "b": ["sb", "h", "binary", "mb", "d", "bf", "buffer", "buff", "br", "l", "w", "f", "base", "p", "bd", "bytes", "bi", "bs", "r", "n", "e", "bb", "ob", "a", "bound", "bar", "v", "gb", "ba", "xb", "B", "emb", "ab", "c", "db", "i", "wb", "fb", "nb", "bis", "boot", "lb", "bin", "rb", "ib", "bl"], "readBytes": ["writeBytes", " readbytes", "writeBs", "Readbytes", " readParts", "loadParts", "readParts", "loadBytes", "loadbytes", " readByte", "ReadBytes", "readbytes", "writeParts", "readBs", "readByte", "readingBytes", "ReadByte", "ReadParts", "loadBs", "readingByte", "readingBs", "loadByte", "writeByte", "writebytes", "readingbytes"]}}
{"id1": "16030263", "id2": "17511631", "code1": "    public static String md5(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            return ForumUtil.bufferToHex(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    private static void extract(final ZipFile zf, final ZipEntry zipEntry, final String desDir, final int... startDirLevel) throws IOException {\n        File desf = new File(desDir);\n        if (!desf.exists()) {\n            desf.mkdirs();\n        }\n        int start = 1;\n        if (null != startDirLevel && startDirLevel.length > 0) {\n            start = startDirLevel[0];\n            if (start < 1) {\n                start = 1;\n            }\n        }\n        String startDir = \"\";\n        String zeName = zipEntry.getName();\n        String folder = zeName;\n        boolean isDir = zipEntry.isDirectory();\n        if (null != folder) {\n            String[] folders = folder.split(\"\\\\/\");\n            if (null != folders && folders.length > 0) {\n                int len = folders.length;\n                if (start == 1) {\n                    startDir = zeName;\n                } else {\n                    if (start > len) {\n                    } else {\n                        for (int i = start - 1; i < len; i++) {\n                            startDir += \"/\" + folders[i];\n                        }\n                        if (null != startDir) {\n                            startDir = startDir.substring(1);\n                        }\n                    }\n                }\n            }\n        }\n        startDir = StringUtils.trim(startDir);\n        if (StringUtils.isNotEmpty(startDir)) {\n            StringBuilder desFileName = new StringBuilder(desDir);\n            if (!desDir.endsWith(\"/\") && !startDir.startsWith(\"/\")) {\n                desFileName.append(\"/\");\n            }\n            desFileName.append(startDir);\n            File destFile = new File(desFileName.toString());\n            if (isDir) {\n                if (!destFile.exists()) {\n                    destFile.mkdirs();\n                }\n            } else {\n                File parentDir = new File(destFile.getParentFile().getPath());\n                if (!parentDir.exists()) {\n                    parentDir.mkdirs();\n                }\n                InputStream is = zf.getInputStream(zipEntry);\n                OutputStream os = new FileOutputStream(destFile);\n                IOUtils.copy(is, os);\n                if (null != is) {\n                    is.close();\n                }\n                if (null != os) {\n                    os.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"text": ["source", "contract", "input", "TEXT", "txt", "connection", "buffer", "message", "output", "format", "letter", "out", "object", "this", "in", "Text", "data", "hex", "bytes", "class", "editor", "config", "template", "name", "method", "pattern", "target", "password", "content", "key", "string", "path", "image", "obj", "font", "code", "struct", "secret", "str", "ext"], "md": ["um", "hash", "cd", "bf", "d", "mb", "dd", "material", "hd", "message", "ma", "mm", "pd", " MD", "gd", "wd", "sm", "pg", "cmd", "ms", "f", "po", "mo", "mac", "bd", "di", "bm", "mand", "editor", "mag", "meta", "mc", "kg", "mp", "dm", "mod", "rm", "MD", "mt", "m", "od", "pm", "mg", "mad", "metadata", "amd", "nm", "dig", "ad"]}}
{"id1": "44949", "id2": "2897046", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public boolean execute_check() {\n        FTPClient ftp = new FTPClient();\n        File filename = null;\n        FileChannel channel;\n        InputStream is;\n        OutputStream os;\n        int reply;\n        if (super.verbose > 0) verbose = true;\n        ftp.setDefaultPort(port);\n        ftp.setDefaultTimeout(timeout);\n        if (verbose) {\n            System.out.println(\"Using FTP Server: \" + hostname);\n            System.out.println(\"Using FTP Port: \" + port);\n            System.out.println(\"Using Timeout of: \" + timeout);\n        }\n        if (passive) {\n            ftp.enterLocalPassiveMode();\n            if (verbose) System.out.println(\"Using Passive Mode\");\n        }\n        try {\n            filename = new File(file);\n            channel = new RandomAccessFile(filename, \"rw\").getChannel();\n            if (verbose) System.out.println(\"Attempting FTP Connection to \" + hostname);\n            ftp.connect(hostname);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                if (verbose) System.out.println(\"FTP Connection to \" + hostname + \" failed\");\n                check_state = common_h.STATE_CRITICAL;\n                check_message = ftp.getReplyString();\n                filename.delete();\n                ftp.disconnect();\n                return true;\n            }\n            if (username != null && password != null) {\n                if (verbose) System.out.println(\"Attempting to log in into FTP Server \" + hostname);\n                if (!ftp.login(username, password)) {\n                    if (verbose) System.out.println(\"Unable to log in to FTP Server \" + hostname);\n                    check_state = common_h.STATE_CRITICAL;\n                    check_message = ftp.getReplyString();\n                    ftp.disconnect();\n                    filename.delete();\n                    return true;\n                }\n            }\n            if (verbose) System.out.println(\"Attempting to change to required directory\");\n            if (!ftp.changeWorkingDirectory(directory)) {\n                if (verbose) System.out.println(\"Required directory cannot be found!\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            if (verbose) System.out.println(\"Attempting to retrieve specified file!\");\n            is = ftp.retrieveFileStream(file);\n            if (is == null) {\n                if (verbose) System.out.println(\"Unable to locate required file.\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            os = Channels.newOutputStream(channel);\n            byte[] buf = new byte[4096];\n            if (verbose) System.out.println(\"Beginning File transfer...\");\n            for (int len = -1; (len = is.read(buf)) != -1; ) os.write(buf, 0, len);\n            if (verbose) {\n                System.out.println(\"...transfer complete.\");\n                System.out.println(\"Attempting to finalise Command\");\n            }\n            if (!ftp.completePendingCommand()) {\n                if (verbose) System.out.println(\"Unable to finalise command\");\n                check_state = common_h.STATE_WARNING;\n                check_message = ftp.getReplyString();\n                ftp.disconnect();\n                filename.delete();\n                return true;\n            }\n            if (verbose) System.out.println(\"Check Completed.\");\n            check_state = common_h.STATE_OK;\n            check_message = ftp.getReplyString();\n            is.close();\n            os.close();\n            channel.close();\n            filename.delete();\n        } catch (IOException e) {\n            check_state = common_h.STATE_CRITICAL;\n            check_message = e.getMessage();\n            if (filename != null) filename.delete();\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (Exception e) {\n                }\n            }\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"inFile": ["inputfile", "inPlace", "InFiles", "oldfile", "inputFiles", "incPlace", " inPath", "outFilename", "outfile", "inFilename", "outPlace", "outPath", "oldFiles", "inputFilename", "infile", "InFile", "oldFilename", "incfile", "oldFile", "outFiles", "inPath", "incFile", "inFiles", " inFiles", "incFiles", "InPlace", " infile", "inputFile", "Infile", "InPath"], "outFile": [" outTable", "zipFile", " outPlace", "inputFolder", "outTable", "zipString", "newfile", " outString", "newPlace", "OutFile", " outfile", "outputFILE", "outputFilename", "outDir", "zipFilename", "outputFile", "outputFolder", "outFILE", "outFilename", "outputString", " outFolder", " outDir", "outfile", "newDir", "inputPlace", "outPlace", "OutPlace", "Outfile", " outFilename", "outFolder", "OutDir", "newFile", "inputTable", " outFILE", "outString", "inputFile", "outputPlace", "outputTable", "zipFILE"], "iis": [" iIS", " iiss", "Iisc", " iIs", "iniais", "ciis", "iois", "iiIS", "ioIs", "IIs", "iIS", "iniIS", "iiIs", "iid", "iisc", "ioiss", " iais", "Iiss", "ciid", "iiss", "iniIs", "iils", "ciais", "Iis", " iils", "iiils", " iid", "ioisc", "iniis", "iniisc", "iiis", "iniiss", "iniid", "iIs", "ciiss", "iniils", "iais"], "dcmParser": ["dcpJar", " dpmarser", "dcpReader", "dcmLoader", "pdymJar", "dpmarser", "dpmLoader", "dcyJar", "pdcmparser", "dcyReader", "Dcmarser", " dpmPlugin", "dsemPlugin", "dmcarser", "dcmparser", "dsemStreamer", "dcrarser", "dpmStreamer", "dcrParser", "dmoduleParser", "dymReader", "dcrparser", "dsemParser", " dcmStreamer", "dtermStreamer", "dpmparser", "dtermParser", "ddcReader", "dcmBuilder", "dmmWriter", "dymparser", "dmmParser", " dcmPlugin", "dmoduleBuilder", "dcmWriter", "ddcParser", " dpmJar", "dmcParser", "dmodulePlugin", "dpmJar", "pdcmReader", "dpmParser", " dcmReader", " dpmLoader", "DcmReader", "dcyParser", "ddcLoader", "dymParser", "dcyarser", " dpmReader", "pdymparser", "pdymReader", "dpmPlugin", " dcmJar", " dcmPar", "DcmJar", "dtermPlugin", "dcpParser", "dcpparser", " dpmPar", " dcmLoader", "pdcmParser", "dpmPar", " dpmBuilder", "dmcJar", "dmoduleReader", " dpmStreamer", "dpmBuilder", " dcmBuilder", " dcmarser", "dymJar", "dcmStreamer", "dmmReader", "dcrWriter", "dcmPlugin", "dmcPar", "dcmJar", "ddcPlugin", " dpmParser", "Dcmparser", "DcmParser", "dsemReader", "dcmarser", "dcmPar", "dcrPar", "DcmWriter", "pdymParser", "dmmarser", "dcmReader", "dtermReader", "dcrReader", "dpmReader", "pdcmJar", "dcrJar"], "ds": ["ys", "ks", "dc", "ipes", "Ds", "des", "d", "points", "dd", "ils", "ld", "ss", "ws", "gd", "src", "pd", "conn", "cdn", "gs", "client", "ns", "ads", "fd", "ros", "Db", "asi", "data", "iss", "di", "os", "bs", "DS", "tx", "drivers", "sys", "js", "vs", "eps", "sync", "dt", "xs", "plugins", "ins", "dds", "da", "rs", "cs", "Ts", "amps", "dr", "ls", "df", "Os", "ays", "session", "docs", "utils", "db", "details", "parts", "services", "is", "tes", "ts", "nas", "ps", "s", "dat", "uds"], "pdReader": ["wdRead", "pcParser", "dsreader", "pbParser", "pcLoader", "pdreader", "pbReader", "xdreader", "xdWriter", "hdreader", "pdRead", "pcReader", "dsRead", "pdLoader", "hdRead", "pidParser", "pbLoader", "hdWriter", "wdReader", "pdParser", "pidScan", "pcScan", "dsLoader", "pbScan", "pcRead", "pcWriter", "wdLoader", "hdReader", "pidReader", "wdWriter", "pidLoader", "xdReader", "dsWriter", "dsReader", "pdScan", "xdRead"], "out": ["default", "later", "d", "net", "with", "result", "down", "now", "doc", "model", "over", "Out", "call", "writer", "sys", "sync", "name", "dot", "log", "flush", "cli", "temp", "image", "list", "obj", "file", "ssl", "err", "array", "img", "group", "store", "line", "pass", "co", "outer", "io", "conn", "lib", "object", "gen", "to", "OUT", "auto", "class", "child", "exp", "ex", "key", "point", "pool", "cache", "at", "copy", "ext", "page", "parent", "url", "user", "write", "inc", "term", "in", "client", "login", "base", "oder", "sum", "external", "exec", "word", "full", "o", "builder", "manager", "order", "s", "null", "connection", "output", "w", "as", "data", "again", "outs", "inner", "flow", "password", "session", "up", "lock", "db", "code", "device"], "dcmEncParam": ["dcmElParameter", "dcmDecParam", "dpmDecParam", "dcmEngType", "dcmDecParameter", "dcmEnVar", "dcmDecPar", "dcmElVar", "dcmEncType", "dcmElType", "dcmencParam", "dpmEncParam", "dcmEnPar", "dcmEncSm", "dcmEngParam", "dcmEnParam", "dcmElParam", "dcmAccParameter", "dcmDecSm", "dpmEncSm", "dcmencParameter", "dpmDecParameter", "dcmEngVar", "dcmAccParam", "dcmencSm", "dpmEncParameter", "dcmAccSm", "dpmDecSm", "dcmEnParameter", "dcmEncPar", "dcmEncVar", "dcmEncParameter", "dcmEnType", "dcmEngParameter"], "pdWriter": ["hdOutput", "pdContent", "pxContent", "PDOutput", "pxReader", "PDReader", "PDWriter", "PDContent", "pxWriter", "tdReader", "ddWR", "dsWrite", "hdWriter", "pxOutput", "ddWrite", "ddOutput", "hdWrite", "pdOutput", "pdWrite", "hdWR", "pdWR", "tdWriter", "dsOutput", "tdContent", "dsWriter", "tdOutput", "ddWriter", "dsWR"]}}
{"id1": "7044128", "id2": "1737313", "code1": "    public static String setErrorServer(String newServer) {\n        String old = errorServerURL;\n        try {\n            URL url = new URL(newServer);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setInstanceFollowRedirects(false);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder page = new StringBuilder();\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                page.append(line);\n            }\n            rd.close();\n            if (!page.toString().equals(\"maRla\")) throw new ConfigurationException(\"URL given for error server is invalid\", ConfigType.ErrorServer);\n        } catch (UnknownHostException ex) {\n            System.out.println(\"Accepting setting for error sever, unable to check\");\n        } catch (MalformedURLException ex) {\n            throw new ConfigurationException(\"URL given for error server ('\" + newServer + \"') appears invalid\", ConfigType.ErrorServer, ex);\n        } catch (IOException ex) {\n            throw new ConfigurationException(\"URL given for error server could not be reached\", ConfigType.ErrorServer, ex);\n        }\n        errorServerURL = newServer;\n        return old;\n    }\n", "code2": "    public void sendPOIGpxNonePOIs() {\n        this.myloc = new Position(45.56, 5.9);\n        this.left = myloc.getY() - 0.025;\n        this.right = myloc.getY() + 0.025;\n        this.top = myloc.getX() + 0.03;\n        this.bottom = myloc.getX() - 0.03;\n        assertEquals(\"left test\", left, (5.9 - 0.025));\n        assertEquals(\"right test\", right, (5.9 + 0.025));\n        assertEquals(\"top test\", top, (45.56 - 0.025));\n        assertEquals(\"bottom test\", left, (45.56 + 0.025));\n        this.poisCheck.add(\"None\");\n        try {\n            if (this.poisCheck.get(0).compareTo(\"None\") == 0) {\n                model.setPointsOfInterest(new Items());\n            } else {\n                this.url = new URL(\"http://www.informationfreeway.org/api/0.6/node[\" + poisCheck.get(0) + \"=*][bbox=\" + left + \",\" + bottom + \",\" + right + \",\" + top + \"]\");\n                assertEquals(\"url informationfreeway.org test\", url, \"http://www.informationfreeway.org/api/0.6/node[amenity=*]\" + \"[bbox=\" + left + \",\" + bottom + \",\" + right + \",\" + top + \"]\");\n                SAXParser pars = null;\n                ParsePoiGpx gpxHandler = new ParsePoiGpx(poisCheck, this.model.getContext());\n                pars = SAXParserFactory.newInstance().newSAXParser();\n                pars.getXMLReader().setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                pars.parse(url.openStream(), gpxHandler);\n                this.pois = gpxHandler.getPOIResultsItems();\n                assertFalse(\"there is some pois\", !this.pois.equals(0));\n                assertTrue(\"there is some pois\", this.pois.equals(0));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            assertFalse(!e.getCause().equals(null));\n        }\n    }\n", "label": 0, "substitutes": {"newServer": ["oldURL", "cleanServer", "oldUrl", " newMaster", "cleanUrl", " newURL", "longURL", "NEWSite", "oldSite", "NewURL", "cleanAddress", "newAddress", "oldserver", "NEWURL", "Newserver", "newserver", "longUrl", " newserver", "cleanserver", " newSite", "NEWServer", "NEWMaster", "oldMaster", "oldServer", "longServer", "NewUrl", "newUrl", "NEWUrl", "NewServer", "newMaster", "newSite", "NEWserver", "oldAddress", " newAddress", "newURL", " newUrl"], "old": ["get", "sel", "id", "none", "default", "last", "ld", "build", "expected", "ore", "now", "l", "original", "pre", "older", "end", "diff", "base", "clean", "bad", "update", "name", "full", "post", "lc", "back", "orig", "replace", "prev", "or", "OLD", "current", " Old", "ignore", "addr", "test", "Old"], "url": ["host", "nl", "connection", "rel", "ld", "ll", "l", "http", "bc", "lr", "fr", "loc", "r", "org", "resource", "server", "config", "el", "ur", "gl", "log", "cl", "bel", "fl", "ls", "path", "rl", "impl", "ssl", "db", "uri", "fb", "URL", "Url", "www", "web", "pl", "sl"], "conn": ["Config", "cb", "ln", "connection", "open", "auth", "cm", "co", "http", "con", "client", "cdn", "fd", "Conn", "fr", "loc", "rn", "cp", "n", "oa", "ctx", "org", "server", "serv", "ai", "cn", "pc", "conf", "exec", "ci", "rc", "nt", "cl", "ch", "cli", "cr", "connect", "c", "ssl", "rt", "db", "conv", "cc", "Connection", "ca", "nc", "rb", "ad", "Con"], "rd": ["wr", "reader", "ru", "rf", "ra", "rx", "dd", "ld", "xd", "ro", "rss", "pd", "ird", "fd", "fr", "red", "rn", "bd", "r", "rob", "rg", "rc", "erd", "rm", "rs", "rod", "rh", "dr", "adr", "hr", "art", "rl", "rw", "rt", "rid", "raf", "rr", "dra", "rb", "RD"], "page": ["host", "route", "site", "pe", "net", "office", "feed", "buffer", "xml", "result", "pl", "wiki", "view", "http", "article", "out", "pg", "age", "root", "row", "base", "channel", "po", "data", "response", "r", "server", "address", "word", "name", "body", "paper", "ge", "per", "pages", "log", "api", "content", "v", "pm", "string", "Page", "sp", "html", "record", "db", "code", "pp", "aa", "www", "blog", "web", "copy", "ip", "p"], "line": ["source", "sel", "link", "write", "pe", "feed", "lf", "lines", "message", "l", "letter", "one", "out", "end", "LINE", "cell", "column", "Line", "row", "f", "part", "base", "data", "inline", "response", "strip", "word", "sync", "name", "ge", "e", "log", "cl", "text", "comment", "content", "lc", "col", "string", "frame", "pass", "file", "error", "code", "parse", "header", "lin", "str", "ip", "sl", "entry"], "errorServerURL": ["errorSiteUrl", " errorClientURI", "errorClientSSL", "errorServerUrl", "ErrorClientSSL", "ErrorServerUrl", "errorServiceUrl", " errorClientID", " errorClientUrl", "errorClientID", "errorSiteID", " errorServerURI", "ErrorClientURI", "errorServerURI", "errorserverUrl", "errorServerID", "ErrorClientUrl", "errorServerSSL", " errorClientURL", "errorSiteURI", "errorServiceID", "ErrorServerSSL", " errorServerUrl", "errorClientUrl", "errorServiceSSL", "errorserverURI", "errorserverSSL", "ErrorServerURI", "ErrorClientURL", " errorServerID", "errorClientURL", "errorServiceURL", "errorClientURI", "errorServiceURI", "ErrorServerURL", "errorSiteURL", "errorserverURL"]}}
{"id1": "19752873", "id2": "168607", "code1": "    public void reqservmodif(HttpServletRequest req, HttpServletResponse resp, SessionCommand command) {\n        setHeader(resp);\n        try {\n            logger.debug(\"SeMo: Requesting server modification for session \" + command.getSession());\n            File tempFile = new File(getSyncWorkDirectory(req), command.getSession() + \".smodif\");\n            OutputStream fos = new FileOutputStream(tempFile);\n            syncServer.getServerModifications(command.getSession(), fos);\n            InputStream fis = new FileInputStream(tempFile);\n            resp.setContentLength(fis.available());\n            while (fis.available() > 0) {\n                resp.getOutputStream().write(fis.read());\n            }\n            resp.getOutputStream().flush();\n            resp.flushBuffer();\n        } catch (IOException ioe) {\n            logger.error(ioe.getMessage());\n        } catch (ImogSerializationException ex) {\n            logger.error(ex.getMessage());\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"req": ["respond", "rf", "gr", "proc", "input", "require", "rep", "conn", "request", "client", "cmd", "app", "fr", "f", "data", "progress", "worker", "ref", "r", "response", "ctx", "comp", "config", "Request", "info", "comm", "exec", "cur", "query", "requ", "report", "ch", "temp", "rec", "reg", "err", "required", "q", "ctr", "dom", "res"], "resp": ["rem", "page", "respond", "msg", "rest", "rel", "rep", "reply", "cmp", "result", "rss", "conn", "view", "request", "client", "cmd", "model", "fr", "part", "exc", "ref", "re", "response", "r", "resource", "ctx", "repl", "serv", "server", "ret", "comm", "exec", "conf", "body", "bb", "report", "exp", "api", "rh", "job", "temp", "session", "rec", "Response", "esp", "content", "respons", "cache", "html", "obj", "rev", "sp", "err", "Resp", "res", "coll", "p"], "command": ["operation", "input", "msg", "queue", "Command", "connection", "admin", "game", "message", "view", "controller", "request", "client", "cmd", "jo", "model", "mode", "directory", "prom", "response", "system", "slave", "handler", "server", "child", "config", "comm", "module", "exec", "action", "method", "component", "query", "event", "pattern", "password", "once", "cli", "session", "history", "document", "obj", "service", "process", "md", "which", "form", "dom", "project", "location"], "tempFile": ["tempLine", "tempFiles", "tempPath", " tempfile", " tempPath", "TempFile", "TempPath", "poraryLine", " tempDir", "myDir", "tempF", "tempfile", "poraryfile", "TempFiles", "tmpfile", "tmpFile", "currentFile", "Tempfile", " tempLine", "tempDir", "tmpLine", "myfile", "poraryFile", "currentDir", "tmpF", "poraryF", "tmpFiles", "currentfile", "myFile", "tmpPath", " tempFiles", " tempF"], "fos": ["Foes", "Fops", "infOS", " foes", "flos", " fops", " fOS", "Fos", "flis", "fops", "infos", "fios", "floes", " fios", "flios", "Fis", "FOS", "fOS", "infis", "Fios", "foes", "infops"], "fis": ["fii", "cfits", "bires", "affis", " fisc", " fires", "flos", "Fos", "ifais", "Fiss", "fiss", "fais", "gis", "flis", "affais", "bos", "affii", "fios", "flires", " fii", "visc", "biss", " fios", "affios", "Fis", "cfos", "gios", " fits", "fisc", "vais", "fits", "vis", "ifis", "ifos", "ifisc", "Fits", "gii", " fais", "vos", "fires", "cfis", "bis", "gais", " fiss", "fliss", "cfiss"]}}
{"id1": "5233678", "id2": "12728035", "code1": "    public static boolean postData(URL url, String parameters) {\n        HttpURLConnection hpcon = null;\n        try {\n            hpcon = (HttpURLConnection) url.openConnection();\n            hpcon.setRequestMethod(\"POST\");\n            hpcon.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(parameters.getBytes().length));\n            hpcon.setUseCaches(false);\n            hpcon.setDoInput(true);\n            hpcon.setDoOutput(true);\n            DataOutputStream printout = new DataOutputStream(hpcon.getOutputStream());\n            printout.writeBytes(parameters);\n            printout.flush();\n            printout.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(hpcon.getInputStream()));\n            String input;\n            boolean success = false;\n            while ((input = in.readLine()) != null) {\n                if (input.contains(\"OK\")) success = true;\n            }\n            return success;\n        } catch (Exception e) {\n            try {\n                if (hpcon != null) hpcon.disconnect();\n            } catch (Exception e2) {\n            }\n            return false;\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["host", "page", "user", "feed", "connection", "plug", "buffer", "pull", "ll", "l", "http", "lr", "loc", "base", "https", "twitter", "resource", "server", "org", "address", "ur", "gl", "facebook", "ls", "location", "string", "path", "image", "uri", "ssl", "file", "URL", "service", "hub", "Url", "www", "proxy", "web", "sl"], "parameters": ["paramsers", "paramparams", "metparams", "parParameters", "meteters", "parameter", "paramsels", "metels", "premels", "meters", "paramentials", "paramsets", "premeters", "paramseters", "pathParameters", "paramsparams", "paramers", "paramels", "promparams", "paramseter", "premeter", "paramsentials", "paramets", "metentials", "prometers", "paramsParameters", "pathets", "pareters", "meteter", "patheters", "paramParameters", "promentials", "pareter", "prometer", "premers", "parets", "patheter"], "hpcon": ["cppfc", "cppconn", "hlcon", "cpppen", "hpact", "hpran", "phyran", "gpcn", "gpocon", "phyconn", "hpconv", "hpfc", "hlcons", "hlpen", "htcons", "npconn", "htcon", "hconn", "phppen", "npconv", "hapcons", "phpconn", "htpen", "phpfc", "hpc", "npcon", "jpco", "htCon", "gpconn", "hapcon", "hapconn", "htact", "cppcon", "htocon", "hcons", "phpcon", " hpconnect", "htcn", "htran", "gpact", "cppconv", "hlconn", "hpocon", "hpcn", "gpconnect", "hpacon", "hppen", "jpcon", "jpc", "cppcom", "wpcon", " hpre", "jpconn", "npfc", "hpco", "gpcon", "phycon", "hlfun", "gpc", "hpre", "gpco", "htc", "phpre", "cppacon", "hpCon", "wpcom", "hapocon", "phalconn", "htco", "wpacon", "hpen", " hpconn", "htconv", "gpCon", " hpact", "hpcons", "htacon", "hpfun", "htconn", "jpocon", "htre", "jpCon", "cppfun", "gpran", "hpconn", "hpcom", "htfun", "jpconnect", "wpconn", "htfc", " hpfc", "phalcons", "phyCon", "phalcon", "gppen", "hpconnect", "htconnect", "phpcn", "hcon", "htcom", "phalocon"], "printout": ["printgin", "printex", "writepath", "readin", " printin", "printin", "buildin", "printline", "readex", "putin", "writegin", " printOut", "buildout", "buildOut", "writeout", "writein", "putout", " printgin", "printpath", "putex", "writeOut", "readout", " printline", " printpath", "putline", "readline", "buildpath", " printex", "readOut", "printOut", "readgin"], "in": ["source", "reader", "h", "inc", "din", "min", "nin", "conn", "l", "con", "out", "b", "this", "diff", "client", "part", "login", "f", "data", "In", "pin", "stream", "again", "r", "re", "isin", "inner", "ins", "e", "container", "ini", "kin", "rec", "c", "i", "IN", "inn", "lin", "bin", "s", "line"], "input": ["source", "read", "reader", "id", "inc", "feed", "xml", "pull", "buffer", "result", "output", "format", "out", "request", "inf", "model", "data", "include", "stream", "resource", "sum", "work", "raw", "enc", "inner", "element", "sub", "name", "Input", "null", "rc", "ink", "act", "password", "text", "comment", "enter", "string", "path", "image", "help", "load", "error", "i", "search", "valid", "form", "accept", "str", "qa", "entry", "ip", "type"], "success": ["successful", "continue", "roll", "default", "warning", "first", "launch", "successfully", "submit", " succeed", "complete", "result", "right", "review", "message", "Success", "flash", "winner", "progress", "future", "response", "match", "primary", "full", "results", "ok", "length", "failed", "initial", "danger", "text", "content", "status", "done", "load", "error", "fail", "valid", "ccess", "process", "follow", "ceed", "accept", "good", "value", " successful", "pass"]}}
{"id1": "14974844", "id2": "8006559", "code1": "    public boolean backupFile(File oldFile, File newFile) {\n        boolean isBkupFileOK = false;\n        FileChannel sourceChannel = null;\n        FileChannel targetChannel = null;\n        try {\n            sourceChannel = new FileInputStream(oldFile).getChannel();\n            targetChannel = new FileOutputStream(newFile).getChannel();\n            targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IO exception occurred while copying file\", e);\n        } finally {\n            if ((newFile != null) && (newFile.exists()) && (newFile.length() > 0)) {\n                isBkupFileOK = true;\n            }\n            try {\n                if (sourceChannel != null) {\n                    sourceChannel.close();\n                }\n                if (targetChannel != null) {\n                    targetChannel.close();\n                }\n            } catch (IOException e) {\n                logger.log(Level.INFO, \"closing channels failed\");\n            }\n        }\n        return isBkupFileOK;\n    }\n", "code2": "    private final void findSubclasses(URL location, String packageName, Class superClass, Set setOfClasses) {\n        synchronized (results) {\n            String fqcn = searchClass.getName();\n            List knownLocations = new ArrayList();\n            knownLocations.add(location);\n            for (int loc = 0; loc < knownLocations.size(); loc++) {\n                URL url = (URL) knownLocations.get(loc);\n                File directory = new File(url.getFile());\n                if (directory.exists()) {\n                    File[] files = directory.listFiles(CLASSES_ONLY);\n                    for (int i = 0; i < files.length; i++) {\n                        String filename = files[i].getName();\n                        String classname = filename.substring(0, filename.length() - 6);\n                        try {\n                            if (!fqcn.equals(packageName + \".\" + classname)) {\n                                Class c = callClassForName(packageName + \".\" + classname);\n                                manageClass(setOfClasses, superClass, c, url);\n                            }\n                        } catch (Throwable t) {\n                            errors.add(t);\n                        }\n                    }\n                } else {\n                    try {\n                        JarURLConnection conn = (JarURLConnection) url.openConnection();\n                        JarFile jarFile = conn.getJarFile();\n                        Enumeration e = jarFile.entries();\n                        while (e.hasMoreElements()) {\n                            JarEntry entry = (JarEntry) e.nextElement();\n                            String entryname = entry.getName();\n                            if (!entry.isDirectory() && entryname.endsWith(\".class\")) {\n                                String classname = entryname.substring(0, entryname.length() - 6);\n                                if (classname.startsWith(\"/\")) classname = classname.substring(1);\n                                classname = classname.replace('/', '.');\n                                try {\n                                    if (!fqcn.equals(classname)) {\n                                        Class c = callClassForName(classname);\n                                        manageClass(setOfClasses, superClass, c, url);\n                                    }\n                                } catch (Throwable t) {\n                                    errors.add(t);\n                                }\n                            }\n                        }\n                    } catch (IOException ioex) {\n                        errors.add(ioex);\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"oldFile": [" oldfile", "Oldfile", "OldSourceFile", "olderSourceFile", "oldDirectory", "oldFolder", " oldDirectory", "oldSourceFile", "olderFolder", "oldfile", "olderFile", "olderDirectory", " oldFolder", "oldDir", "olderfile", "OldDirectory", "OldDir", " oldSourceFile", " oldDir", "OldFile", "olderDir", "OldFolder"], "newFile": ["newSourceFile", " newDir", "newPage", "remoteFile", "newfile", "NewDir", "NewPath", "remoteFiles", "NewSourceFile", "NewFilename", "updatePage", "oldDir", "remoteDir", "updatefile", "newPath", "NewFile", "newFiles", "nowfile", "newDir", " newFilename", "nowFile", "targetSourceFile", "targetfile", " newPage", "oldFiles", "oldFilename", "updateDir", "remoteFilename", " newSourceFile", "targetFile", "NewPage", " newFiles", " newfile", "oldPath", "nowSourceFile", "targetDir", "updateFile", "Newfile", " newPath", "NewFiles", "newFilename", "nowFilename"], "sourceChannel": ["sourceConnection", " sourceStream", "targetStream", "proxyChannel", " sourceChan", "resourcechannel", "resourceClient", "sourceChan", "targetBuffer", "Sourcechannel", "resourceChannel", " sourceConnection", " sourceClient", "proxyConnection", "SourceBuffer", "targetClient", " sourceHandler", " sourceBuffer", "proxychannel", "targetHandler", "sourceBuffer", "inputChannel", "targetChan", "targetConnection", "inputchannel", "targetchannel", "inputChan", "SourceConnection", "sourceClient", "SourceChan", "resourceChan", "inputHandler", "sourcechannel", "sourceHandler", "proxyChan", "proxyStream", "SourceChannel", " sourcechannel", "sourceStream"], "targetChannel": ["sourceConnection", "argetPage", "targetStream", " targetStream", "TargetFile", "targetPage", "argetConnection", "TargetManager", "masterChan", "sourceChan", "argetChan", " targetChan", "masterConnection", "masterChannel", "argetchannel", " targetPage", "masterStream", "sourceFile", "Targetchannel", "TargetConnection", "TargetChan", "targetChan", "targetConnection", "targetchannel", "targetManager", "argetManager", "argetChannel", " targetFile", "targetFile", "targetScope", " targetScope", "TargetStream", "argetScope", "sourcePage", "sourcechannel", " targetManager", "TargetChannel", " targetConnection", " targetchannel", "sourceScope"], "isBkupFileOK": ["isBkupfileO", "isBkupFilesSync", "isBkupfileOk", "isBkupFileok", "isBkupefileO", "isBkupDirectoryO", "isBkupFilesOk", "isBkupfileOK", "isBkupTimeO", "isBkupeFileO", "isBkupTimeok", "isBkupFilesOK", "isBkupefileSync", "isBkupFileOk", "isBkupfileok", "isBkupeFileok", "isBkupefileOk", "isBkupStreamOk", "isBkupefileok", "isBkupfileSync", "isBkupefileOK", "isBkupStreamSync", "isBkupTimeOk", "isBkupStreamok", "isBkupStreamOK", "isBkupTimeOK", "isBkupeFileOK", "isBkupFilesok", "isBkupeFileOk", "isBkupeFileSync", "isBkupFileSync", "isBkupFileO", "isBkupDirectoryOk", "isBkupDirectoryOK", "isBkupDirectoryok"]}}
{"id1": "15306466", "id2": "11129960", "code1": "    public static Document tidyHTML(URL url) throws XMLHelperException {\n        try {\n            URLConnection inConnection = url.openConnection();\n            if (inConnection.getContentType().startsWith(\"text/xml\") || inConnection.getContentType().startsWith(\"text/xhtml\")) {\n                return parseXMLFromURL(url);\n            } else if (inConnection.getContentType().startsWith(\"text/html\")) {\n                InputStream is = inConnection.getInputStream();\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                int totalBytes = 0;\n                byte[] buffer = new byte[65536];\n                while (true) {\n                    int bytesRead = is.read(buffer, 0, buffer.length);\n                    if (bytesRead < 0) break;\n                    for (int i = 0; i < bytesRead; i++) {\n                        byte b = buffer[i];\n                        if (b < 32 && b != 10 && b != 13 && b != 9) b = 32;\n                        buffer[i] = b;\n                    }\n                    out.write(buffer, 0, bytesRead);\n                    totalBytes += bytesRead;\n                }\n                is.close();\n                out.close();\n                String outContent = out.toString();\n                InputStream in = new ByteArrayInputStream(out.toByteArray());\n                Tidy tidy = new Tidy();\n                tidy.setShowWarnings(false);\n                tidy.setXmlOut(true);\n                tidy.setXmlPi(false);\n                tidy.setDocType(\"omit\");\n                tidy.setXHTML(false);\n                tidy.setRawOut(true);\n                tidy.setNumEntities(true);\n                tidy.setQuiet(true);\n                tidy.setFixComments(true);\n                tidy.setIndentContent(true);\n                tidy.setCharEncoding(org.w3c.tidy.Configuration.ASCII);\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                org.w3c.dom.Document tNode = (org.w3c.dom.Document) tidy.parseDOM(in, baos);\n                String result = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + baos.toString();\n                int startIndex = 0;\n                int endIndex = 0;\n                if ((startIndex = result.indexOf(\"<!DOCTYPE\")) >= 0) {\n                    endIndex = result.indexOf(\">\", startIndex);\n                    result = result.substring(0, startIndex) + result.substring(endIndex + 1, result.length());\n                }\n                while ((startIndex = result.indexOf(\"<script\")) >= 0) {\n                    endIndex = result.indexOf(\"</script>\");\n                    result = result.substring(0, startIndex) + result.substring(endIndex + 9, result.length());\n                }\n                in.close();\n                baos.close();\n                return parseXMLFromString(result);\n            } else {\n                throw new XMLHelperException(\"Unable to tidy content type: \" + inConnection.getContentType());\n            }\n        } catch (IOException ioe) {\n            throw new XMLHelperException(\"Unable to perform input/output\", ioe);\n        }\n    }\n", "code2": "    public static String getGoGl(final String urlPath, String key) {\n        log.debug(\"getGoGl url \" + urlPath);\n        log.debug(\"getGoGl key \" + key);\n        String shortUrl = null;\n        URL simpleURL = null;\n        HttpsURLConnection url = null;\n        BufferedInputStream bStream = null;\n        StringBuffer resultString = new StringBuffer(\"\");\n        String inputString = \"{\\\"longUrl\\\":\\\"\" + urlPath + \"\\\"}\";\n        log.debug(\"getGoGl inputString \" + inputString);\n        try {\n            simpleURL = new URL(\"https://www.googleapis.com/urlshortener/v1/url?key=\" + key);\n            url = (HttpsURLConnection) simpleURL.openConnection();\n            url.setDoOutput(true);\n            url.setRequestProperty(\"content-type\", \"application/json\");\n            PrintWriter pw = new PrintWriter(url.getOutputStream());\n            pw.print(inputString);\n            pw.close();\n        } catch (Exception ex) {\n            log.error(ex);\n            shortUrl = urlPath;\n        }\n        try {\n            bStream = new BufferedInputStream(url.getInputStream());\n            int i;\n            while ((i = bStream.read()) >= 0) {\n                resultString.append((char) i);\n            }\n        } catch (Exception ex) {\n            SocialUtils.log.error(ex);\n            shortUrl = urlPath;\n        }\n        return shortUrl;\n    }\n", "label": 0, "substitutes": {"url": ["source", "host", "page", "input", "link", "connection", "feed", "xml", "download", "pull", "conn", "l", "http", "bug", "loc", "loader", "base", "data", "stream", "remote", "resource", "server", "address", "config", "ur", "text", "sl", "string", "path", "image", "il", "html", "uri", "file", "context", "ssl", "URL", "service", "Url", "str", "location"], "inConnection": [" inConnector", "inControl", "INConnector", "incConnect", "InSession", " inconnection", "Inconnection", "outConnector", "insConnect", "InConnection", "INconnection", "incConnector", "InConnector", "insConnector", " inControl", "inconnection", "bControl", "incConnection", "insConn", "inSession", "bConnection", " inSession", "bconnection", "inConnect", "outconnection", "INConnection", "bConnect", "InConn", "INConn", "insconnection", "insConnection", "insControl", "INConnect", "incconnection", " inConn", "outConnection", "insSession", " inConnect", "InConnect", "inConnector", "inConn", "outConnect"], "is": ["get", "id", "si", "ic", "isa", "ws", "io", "ais", "isl", "app", "as", "was", "iss", "are", "os", "ris", "serv", "ai", "info", "inner", "ir", "isi", "init", "it", "ui", "ci", "ins", "ob", "iris", "IS", "api", "ini", "abs", "close", "ri", "isc", "ios", "impl", "ori", "uri", "im", "or", "us", "bis", "Is", "ar", "iso", "ip", "ib", "ie"], "out": ["source", "page", "parent", "size", "input", "inc", "extra", "co", "io", "output", "outer", "conn", "object", "this", "client", "base", "table", "to", "data", "version", "OUT", "Out", "again", "outs", "sum", "resource", "prefix", "writer", "info", "exec", "name", "o", "exp", "timeout", "temp", "up", "image", "pool", "obj", "cache", "file", "error", "err", "lock", "array", "at", "bin", "copy", "null", "ext"], "totalBytes": ["TotalPages", "maxbytes", "otalbytes", " totalCharacters", "Totalbytes", " totalParts", "totalParts", "maxParts", "totalPages", "otalBytes", "otalCharacters", " totalPages", " totalbytes", "maxPages", "TotalBytes", "TotalParts", "totalbytes", "maxBytes", "totalCharacters", "otalPages", "TotalCharacters"], "buffer": ["source", "page", "read", "size", "reader", "queue", "memory", "binary", "reference", "buff", "iter", "Buffer", "message", "limit", "base", "layer", "number", "data", "phrase", "bytes", "server", "address", "pad", "uffer", "sequence", "padding", "transfer", "null", "batch", "bb", "length", "flush", "wave", "bar", "buf", "timeout", "offset", "variable", "slice", "FFER", "border", "seed", "cache", "fb", "array", "header", "position", "bin", "stack", "copy", "pause"], "bytesRead": ["keysCount", "bytesWork", " bytesGet", "errorsWrite", "BytesWrite", "BytesPass", "usersWork", "byteWrite", "bytesread", "keysReader", " bytesWrite", "keysWrite", "bytesReader", " bytesCount", "secondsRead", "BytesWritten", "BytesLoad", "secondsLoad", "bytePass", "errorsread", "BytesReader", "bytesGet", "secondsWrite", " bytesKill", "stringsGet", "bytesWritten", "keysRead", "flowsLoad", "flowsRead", " bytesLoad", "bytesKill", "secondsGet", "byteRead", "stringsRead", "byteWritten", "flowsKill", "flowsWrite", "errorsWork", "bytesLoad", " bytesWritten", "usersread", "stringsWrite", "BytesCount", "usersRead", "secondsWork", "secondsread", "bytesWrite", "bytesCount", " bytesReader", "stringsLoad", "bytesPass", "errorsRead", "usersWrite", "BytesKill", "BytesRead", " bytesPass"], "i": ["id", "h", "si", "d", "multi", "abi", "qi", "br", "hi", "k", "io", "l", "y", "f", "di", "bi", "n", "r", "I", "oi", "ji", "ai", "info", "gi", "x", "init", "it", "ui", "ci", "u", "e", "o", "ix", "t", "ini", "m", "abs", "li", "v", "xi", "index", "ri", "B", "ib", "j", "c", "uri", "ii", "g", "pi", "fi", "mi", "line", "ip", "p", "ie"], "b": ["bp", "sb", "cb", "split", "binary", "d", "bf", "mb", "be", "k", "pb", "l", "y", "bc", "f", "base", "bd", "n", "r", "bytes", "bi", "bs", "abb", "x", "batch", "e", "bb", "ob", "u", "length", "bit", "bar", "a", "abs", "v", "ba", "gb", "buf", "B", "ib", "eb", "emb", "c", "ab", " B", "code", "db", "fb", "wb", "aa", "nb", "lb", "bin", "rb", "p", "bl"], "outContent": ["outHeader", "OutHeader", "OutContent", "outBuffer", "outputHeader", "outputContent", " outString", "outputString", "outString", " outBuffer", "OutBuffer", "OutString", " outHeader", "outputBuffer"], "in": ["source", "reader", "id", "input", "inc", "din", "xml", "min", "nin", "con", "login", "f", "data", "In", "pin", "again", "n", "r", "resource", "serv", "ac", "isin", "inner", "x", "ins", "gin", "ini", "sin", "rec", "cin", "image", "IN", "inn", "lin", "bin", "ic"], "tidy": [" tiny", "lidy", "atedy", "Tinner", "atidi", "Tandy", "ptinky", "thisairy", "thisedy", "tempaser", "butidi", "stime", " tiki", "bime", " tink", "pinky", "ytidy", "topidi", "hink", "pinker", "ytidi", "atinker", "ttidy", " tinky", "landy", " tickle", "retidy", "stick", "atiki", "transidy", "lidi", "nidy", "priage", "Taser", " triter", "ttidi", "ninker", "tink", "lickle", "driage", "tise", "tick", " tinker", "ptandy", " taser", "tempickle", "tiki", "Tedy", "tandy", "atinky", "Tidi", "nedy", "topidy", "bick", "Tiny", "transandy", "ninky", "tempidy", "retiny", "transidi", "bidy", "dise", "didy", "ctickle", "dinky", "stise", "stairy", "tedy", "linky", "ptidy", "retidi", "triter", "dime", "ctidy", "Tickle", "atkee", "butidy", "bise", "ptickle", "transinky", "taser", "time", "tidi", "tempidi", "tickle", "atandy", " tkee", "triage", "ytriter", "Tinker", "atriter", "pidy", "tairy", "butriage", "atickle", "hidy", "ctinky", "hriage", "dink", "ttandy", " triage", "butkee", "dick", "Triage", "atinner", " tandy", "ctandy", "stedy", "Tinky", "thisidi", "stidi", "thisidy", " tinner", "stidy", "hinky", "topairy", "Tidy", "ytiki", "atriage", "tinner", "tinky", "topedy", "atidy", "tkee", "tinker", "tiny", " tidi", "ttinky"], "baos": [" baOS", "BAis", " baoes", "abao", "abaos", "hao", "abaoes", "baoes", "haoss", "haOS", "bao", "BAOS", "BAoss", "abais", "BAos", "haos", "BAoes", "BAo", " baoss", "baoss", "bais", " bais", "baOS", " bao"], "tNode": ["tTree", "stContent", "stTree", "TContent", "TTree", "TDocument", "stNode", " tContent", " tDocument", "tDocument", "TNode", "tContent", " tTree", "stDocument"], "result": ["page", "DOM", "Result", "output", "message", " results", "description", " markup", "data", "style", "response", "r", "info", " Result", " response", " res", "Output", "results", "s", "report", "json", "comment", "replace", " ret", "dom", "res"]}}

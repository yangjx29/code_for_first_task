int main () {
    int count;
    count = (330 - 330);
    int EEO4ldJK6y [256] = {(369 - 369)};
    struct   book {
        int no;
        char as [10];
    }
    bk;
    int dyw2ZSIqF6GU, j, n;
    struct   book *books = (struct   book *) malloc (sizeof (struct   book) * n);
    free (books);
    scanf ("%d", &n);
    {
        dyw2ZSIqF6GU = 152 - 152;
        while (n > dyw2ZSIqF6GU) {
            scanf ("%d %s", &bk.no, bk.as);
            books[dyw2ZSIqF6GU] = bk;
            dyw2ZSIqF6GU = dyw2ZSIqF6GU + 1;
        };
    }
    for (dyw2ZSIqF6GU = (250 - 250); dyw2ZSIqF6GU < n; dyw2ZSIqF6GU = dyw2ZSIqF6GU + 1) {
        bk = books[dyw2ZSIqF6GU];
        {
            j = 707 - 707;
            {
                int x = 0;
                if (!(x * (x - 1) % 2 == 0)) {
                    return 0;
                }
            }
            while (bk.as[j]) {
                EEO4ldJK6y[bk.as[j]]++;
                {
                    int x = 0, y;
                    if (!(x * (x - 1) % 2 == 0)) {
                        float n = 0.0;
                        if (n > 10)
                            return;
                        else
                            n = 0;
                    }
                }
                j = j + 1;
            };
        };
    }
    for (int max = 1000;
    (811 - 811) < max; max = max - 1) {
        for (char c = 'A';
        'Z' >= c; c = c + 1) {
            if (!(max != EEO4ldJK6y[c])) {
                printf ("%c\n%d\n", c, max);
                {
                    dyw2ZSIqF6GU = 0;
                    while (dyw2ZSIqF6GU < n) {
                        bk = books[dyw2ZSIqF6GU];
                        {
                            j = 0;
                            while (bk.as[j]) {
                                if (bk.as[j] == c) {
                                    printf ("%d\n", bk.no);
                                    break;
                                }
                                j = j + 1;
                            };
                        }
                        dyw2ZSIqF6GU++;
                    };
                }
                count = count + 1;
            };
        }
        if (count == (596 - 595)) {
            free (books);
            return 0;
        };
    }
    return -1;
}

